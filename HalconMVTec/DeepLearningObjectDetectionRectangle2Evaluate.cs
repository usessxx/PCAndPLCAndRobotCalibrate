using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using HalconDotNet;
using System.Windows.Forms;
using System.Threading;

namespace HalconMVTec
{
    public class DeepLearningObjectDetectionRectangle2Evaluate
    {
        // Local control variables 
        HTuple hv_PreprocessResultDirectoryPath = new HTuple();//存储预处理结果-sample文件夹 及 hdict文件的上一级文件夹路径(包含文件夹名)
        HTuple hv_PreprocessResultFileName = new HTuple();//预处理结果文件名(以".hdict"为后缀,例如:dl_preprocess_dataset.hdict)
        //HTuple hv_PreprocessResultParameterFileName = new HTuple();//预处理结果-参数的文件名(以".hdict"为后缀,例如:dl_preprocess_param.hdict)
        HTuple hv_BestModelBaseName = new HTuple();//已训练好的Best模型文件的存放路径(包含文件名,不需要后缀)(例如:best_dl_model_classification.hdl;best_dl_model_classification_info.hdict)

        HTuple hv_BatchSize = new HTuple();//评估批次大小
        HTuple hv_EvaluationMeasures = new HTuple();
        HTuple hv_IoUThresholds = new HTuple();
        HTuple hv_DisplayIoUThreshold = new HTuple();
        HTuple hv_AreaNames = new HTuple();
        HTuple hv_AreaMin = new HTuple();
        HTuple hv_AreaMax = new HTuple();
        HTuple hv_MaxNumDetections = new HTuple();
        HTuple hv_GenParam = new HTuple();
        HTuple hv_DLSampleIndices = new HTuple();
        HTuple hv_DLSampleIndicesShuffled = new HTuple();
        HTuple hv_DLSampleBatch = new HTuple();
        HTuple hv_DLResultBatch = new HTuple();
        HTuple hv_AreaRanges = new HTuple();
        HTuple hv_EvaluationResultDetection = new HTuple();
        HTuple hv_EvalParams = new HTuple();
        HTuple hv_DisplayParam = new HTuple();
        HTuple hv_EvalIoUThresholds = new HTuple();

        HTuple hv_UseGPU = new HTuple();
        HTuple hv_CudaLoaded = new HTuple();
        HTuple hv_CuDNNLoaded = new HTuple();
        HTuple hv_CuBlasLoaded = new HTuple();
        HTuple hv_DLModelHandle = new HTuple();
        HTuple hv_DLDataset = new HTuple();
        HTuple hv_GenParamEval = new HTuple();
        HTuple hv_EvaluationResult = new HTuple();
        HTuple hv_WindowHandleDict = new HTuple();
        HTuple hv_GenParamEvalDisplay = new HTuple();
        HTuple hv_SelectedHeatmapGTClassName = new HTuple();
        HTuple hv_SelectedHeatmapInfClassName = new HTuple();
        HTuple hv_EvaluatedSamples = new HTuple();
        HTuple hv_ImageIDs = new HTuple();
        HTuple hv_ImageLabelIDs = new HTuple();
        HTuple hv_Predictions = new HTuple();
        HTuple hv_ClassNames = new HTuple();
        HTuple hv_ClassIDs = new HTuple();
        HTuple hv_PredictedClassID = new HTuple();
        HTuple hv_GroundTruthClassID = new HTuple();
        HTuple hv_GTIndices = new HTuple();
        HTuple hv_PredictionIndices = new HTuple();
        HTuple hv_ImageIDsSelected = new HTuple();
        HTuple hv_HeatmapMethod = new HTuple();
        HTuple hv_TargetClassID = new HTuple();
        HTuple hv_HeatmapParam = new HTuple();
        HTuple hv_FeatureSize = new HTuple();
        HTuple hv_SamplingSize = new HTuple();
        HTuple hv_DLSamples = new HTuple();
        HTuple hv_Index = new HTuple();
        HTuple hv_DLSampleIndex = new HTuple();
        HTuple hv_DLSample = new HTuple();
        HTuple hv_DLResult = new HTuple();

        public bool displayNextFlag = false;

        #region DeepLearningObjectDetectionRectangle2Evaluate(构造函数里对评估参数初始化)
        //构造函数里对评估参数初始化
        public DeepLearningObjectDetectionRectangle2Evaluate()
        {
            //MODIFY
            //ADD FOR DISPLAY
            //非常重要!如果没有以下4行代码,则开启的两个窗口不显示内容,且这两个窗口是死机的状态!!!
            HOperatorSet.SetSystem("width", 512);
            HOperatorSet.SetSystem("height", 512);
            if (HalconAPI.isWindows)
                HOperatorSet.SetSystem("use_window_thread", "true");
        }
        #endregion


        #region EvaluateAction(评估开始)
        public void EvaluateAction(string preprocessResultDirectoryPath, string preprocessResultFileName, string bestModelBaseName, int batchSize)
        {
            try
            {

                dev_update_off();

                hv_PreprocessResultDirectoryPath = preprocessResultDirectoryPath;
                hv_PreprocessResultFileName = preprocessResultFileName;
                hv_BestModelBaseName = bestModelBaseName;

                //The evaluation can be performed on GPU or CPU.
                //See the respective system requirements in the Installation Guide.
                hv_UseGPU.Dispose();
                hv_UseGPU = 1;

                //Check availability of GPU mode.
                if ((int)(hv_UseGPU) != 0)
                {
                    hv_CudaLoaded.Dispose();
                    HOperatorSet.GetSystem("cuda_loaded", out hv_CudaLoaded);
                    hv_CuDNNLoaded.Dispose();
                    HOperatorSet.GetSystem("cudnn_loaded", out hv_CuDNNLoaded);
                    hv_CuBlasLoaded.Dispose();
                    HOperatorSet.GetSystem("cublas_loaded", out hv_CuBlasLoaded);
                    if ((int)((new HTuple((new HTuple((new HTuple(hv_CudaLoaded.TupleEqual("true"))).TupleAnd(
                        new HTuple(hv_CuDNNLoaded.TupleEqual("true"))))).TupleAnd(new HTuple(hv_CuBlasLoaded.TupleEqual(
                        "true"))))).TupleNot()) != 0)
                    {
                        hv_UseGPU.Dispose();
                        hv_UseGPU = 0;
                    }
                }

                try
                {
                    //Check if all necessary files exist.
                    check_data_availability(hv_PreprocessResultDirectoryPath, hv_PreprocessResultDirectoryPath + "\\" + hv_PreprocessResultFileName, hv_BestModelBaseName + ".hdl", 1);             
                }
                catch (Exception ex)
                {
                    MessageBox.Show("数据文件检查错误!" + "\r" + ex.ToString());
                    return;
                }


                //Specify measures of interest
                hv_EvaluationMeasures.Dispose();
                hv_EvaluationMeasures = "all";
                //
                //Specify considered IoU thresholds.
                hv_IoUThresholds.Dispose();
                hv_IoUThresholds = new HTuple();
                //
                //Display detailed results for the following IoU threshold.
                hv_DisplayIoUThreshold.Dispose();
                hv_DisplayIoUThreshold = 0.7;
                //
                //评估的时候的批次大小最好和训练一致
                hv_BatchSize.Dispose();
                hv_BatchSize = batchSize;
                //
                //Specify evaluation subsets for objects of a certain size.
                hv_AreaNames.Dispose();
                hv_AreaNames = new HTuple();
                hv_AreaMin.Dispose();
                hv_AreaMin = new HTuple();
                hv_AreaMax.Dispose();
                hv_AreaMax = new HTuple();
                //
                //Specify the maximum number of detections considered for each measure.
                hv_MaxNumDetections.Dispose();
                hv_MaxNumDetections = new HTuple();

                //Read the retrained model.
                hv_DLModelHandle.Dispose();
                HOperatorSet.ReadDlModel(hv_BestModelBaseName, out hv_DLModelHandle);
                //
                //Initialize the model.
                if ((int)(hv_UseGPU.TupleNot()) != 0)
                {
                    HOperatorSet.SetDlModelParam(hv_DLModelHandle, "runtime", "cpu");
                }
                HOperatorSet.SetDlModelParam(hv_DLModelHandle, "batch_size", hv_BatchSize);
                HOperatorSet.SetDlModelParam(hv_DLModelHandle, "runtime_init", "immediately");
                //
                //Initialize the model.
                if ((int)(hv_UseGPU.TupleNot()) != 0)
                {
                    HOperatorSet.SetDlModelParam(hv_DLModelHandle, "runtime", "cpu");
                }
                //Set batch size of the model to 1 temporarily.
                HOperatorSet.SetDlModelParam(hv_DLModelHandle, "batch_size", 1);
                HOperatorSet.SetDlModelParam(hv_DLModelHandle, "runtime_init", "immediately");

                //Read the preprocessed DLDataset file.
                hv_DLDataset.Dispose();
                HOperatorSet.ReadDict(hv_PreprocessResultDirectoryPath + "\\" + hv_PreprocessResultFileName, new HTuple(), new HTuple(), out hv_DLDataset);



                //
                //****************************************************************
                //**   Set optimized parameters for inference                  ***
                //****************************************************************
                //
                //To reduce the number of false positives, set lower values for
                //'max_overlap' (default = 0.5) and 'max_overlap_class_agnostic'
                //(default = 1.0) and a higher confidence threshold (default = 0.5).
                HOperatorSet.SetDlModelParam(hv_DLModelHandle, "max_overlap_class_agnostic", 0.7);       
                HOperatorSet.SetDlModelParam(hv_DLModelHandle, "max_overlap", 0.2);
                HOperatorSet.SetDlModelParam(hv_DLModelHandle, "min_confidence", 0.6);
                //
                //****************************************************************
                //**   First impression via visual inspection of results       ***
                //****************************************************************
                //
                //Create parameter dictionaries for visualization.
                hv_WindowHandleDict.Dispose();
                HOperatorSet.CreateDict(out hv_WindowHandleDict);
                hv_GenParam.Dispose();
                HOperatorSet.CreateDict(out hv_GenParam);
                HOperatorSet.SetDictTuple(hv_GenParam, "bbox_display_confidence", 0);
                //
                //Select test images randomly.
                hv_DLSamples.Dispose();
                HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLSamples);
                hv_DLSampleIndices.Dispose();
                find_dl_samples(hv_DLSamples, "split", "test", "or", out hv_DLSampleIndices);
                hv_DLSampleIndicesShuffled.Dispose();
                tuple_shuffle(hv_DLSampleIndices, out hv_DLSampleIndicesShuffled);
                //
                //Apply the model and display results.
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_DLSampleIndicesShuffled.TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DLSampleBatch.Dispose();
                        read_dl_samples(hv_DLDataset, hv_DLSampleIndicesShuffled.TupleSelect(hv_Index),
                            out hv_DLSampleBatch);
                    }
                    hv_DLResultBatch.Dispose();
                    HOperatorSet.ApplyDlModel(hv_DLModelHandle, hv_DLSampleBatch, new HTuple(),
                        out hv_DLResultBatch);
                    dev_display_dl_data(hv_DLSampleBatch, hv_DLResultBatch, hv_DLDataset, "bbox_both",
                        hv_GenParam, hv_WindowHandleDict);
                    if (HDevWindowStack.IsOpen())
                    {
                        //MODIFY
                        displayNextFlag = false;
                        while (!displayNextFlag)
                        {
                            Thread.Sleep(100);
                        }
                        displayNextFlag = false;
                        //HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", "window", "bottom", "right", "black", new HTuple(), new HTuple());
                            
                    }
                }
                //
                dev_close_window_dict(hv_WindowHandleDict);
                HOperatorSet.SetDlModelParam(hv_DLModelHandle, "batch_size", hv_BatchSize);
                //
                //****************************************************************
                //**   Evaluate object detection model on evaluation data      ***
                //****************************************************************
                //
                //Set generic evaluation parameters.
                hv_GenParamEval.Dispose();
                HOperatorSet.CreateDict(out hv_GenParamEval);
                //Set the measures of interest.
                HOperatorSet.SetDictTuple(hv_GenParamEval, "measures", hv_EvaluationMeasures);
                //Set maximum number of detections considered for each measure.
                if ((int)(new HTuple(hv_MaxNumDetections.TupleLength())) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_GenParamEval, "max_num_detections", hv_MaxNumDetections);
                }
                //Set the evaluation area subsets.
                if ((int)(new HTuple(hv_AreaNames.TupleLength())) != 0)
                {
                    if ((int)((new HTuple((new HTuple(hv_AreaNames.TupleLength())).TupleNotEqual(
                        new HTuple(hv_AreaMin.TupleLength())))).TupleOr(new HTuple((new HTuple(hv_AreaNames.TupleLength()
                        )).TupleNotEqual(new HTuple(hv_AreaMax.TupleLength()))))) != 0)
                    {
                        throw new HalconException(new HTuple("AreaNames, AreaMin, and AreaMax must have the same size."));
                    }
                    hv_AreaRanges.Dispose();
                    HOperatorSet.CreateDict(out hv_AreaRanges);
                    HOperatorSet.SetDictTuple(hv_AreaRanges, "name", hv_AreaNames);
                    HOperatorSet.SetDictTuple(hv_AreaRanges, "min", hv_AreaMin);
                    HOperatorSet.SetDictTuple(hv_AreaRanges, "max", hv_AreaMax);
                    HOperatorSet.SetDictTuple(hv_GenParamEval, "area_ranges", hv_AreaRanges);
                }
                //Set IoU thresholds.
                if ((int)(new HTuple(hv_IoUThresholds.TupleLength())) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_GenParamEval, "iou_threshold", hv_IoUThresholds);
                }
                //Enable detailed evaluation.
                HOperatorSet.SetDictTuple(hv_GenParamEval, "detailed_evaluation", 1);
                //Show progress of evaluation.
                HOperatorSet.SetDictTuple(hv_GenParamEval, "show_progress", 1);
                //
                //Evaluate the finetuned model on the 'test' split of the dataset.
                hv_EvaluationResultDetection.Dispose(); hv_EvalParams.Dispose();
                evaluate_dl_model(hv_DLDataset, hv_DLModelHandle, "split", "test", hv_GenParamEval,
                    out hv_EvaluationResultDetection, out hv_EvalParams);
                //
                //Display results of the detailed evaluation.
                hv_DisplayParam.Dispose();
                HOperatorSet.CreateDict(out hv_DisplayParam);
                //Set the IoU of interest. The default is the first 'iou_threshold' of EvalParams.
                if ((int)(new HTuple((new HTuple(hv_DisplayIoUThreshold.TupleLength())).TupleEqual(
                    1))) != 0)
                {
                    hv_EvalIoUThresholds.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "iou_threshold", out hv_EvalIoUThresholds);
                    if ((int)(new HTuple(((hv_EvalIoUThresholds.TupleFind(hv_DisplayIoUThreshold))).TupleNotEqual(
                        -1))) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_DisplayParam, "iou_threshold", hv_DisplayIoUThreshold);
                    }
                    else
                    {
                        throw new HalconException("No evaluation result for specified IoU threshold.");
                    }
                }
                //Display detailed precision and recall
                HOperatorSet.SetDictTuple(hv_DisplayParam, "display_mode", (new HTuple("pie_charts_precision")).TupleConcat("pie_charts_recall"));
                HOperatorSet.CreateDict(out hv_WindowHandleDict);
                dev_display_detection_detailed_evaluation(hv_EvaluationResultDetection, hv_EvalParams, hv_DisplayParam, hv_WindowHandleDict);
                    
                if (HDevWindowStack.IsOpen())
                {
                    //MODIFY
                    displayNextFlag = false;
                    while (!displayNextFlag)
                    {
                        Thread.Sleep(100);
                    }
                    displayNextFlag = false;
                    //HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", "window", "top", "right", "black", new HTuple(), new HTuple());                   
                }
                dev_close_window_dict(hv_WindowHandleDict);
                //Display confusion matrix.
                HOperatorSet.SetDictTuple(hv_DisplayParam, "display_mode", "absolute_confusion_matrix");
                dev_display_detection_detailed_evaluation(hv_EvaluationResultDetection, hv_EvalParams, hv_DisplayParam, hv_WindowHandleDict);
                    
                if (HDevWindowStack.IsOpen())
                {
                    //MODIFY
                    displayNextFlag = false;
                    while (!displayNextFlag)
                    {
                        Thread.Sleep(100);
                    }
                    displayNextFlag = false;
                    //HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", "window", "bottom", "right", "black", new HTuple(), new HTuple());                
                }
                dev_close_window_dict(hv_WindowHandleDict);

            }
            catch (HalconException HDevExpDefaultException)
            {
                hv_EvaluationMeasures.Dispose();
                hv_IoUThresholds.Dispose();
                hv_DisplayIoUThreshold.Dispose();
                hv_BatchSize.Dispose();
                hv_AreaNames.Dispose();
                hv_AreaMin.Dispose();
                hv_AreaMax.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_UseGPU.Dispose();
                hv_CudaLoaded.Dispose();
                hv_CuDNNLoaded.Dispose();
                hv_CuBlasLoaded.Dispose();
                hv_DLModelHandle.Dispose();
                hv_DLDataset.Dispose();
                hv_WindowHandleDict.Dispose();
                hv_GenParam.Dispose();
                hv_DLSamples.Dispose();
                hv_DLSampleIndices.Dispose();
                hv_DLSampleIndicesShuffled.Dispose();
                hv_Index.Dispose();
                hv_DLSampleBatch.Dispose();
                hv_DLResultBatch.Dispose();
                hv_GenParamEval.Dispose();
                hv_AreaRanges.Dispose();
                hv_EvaluationResultDetection.Dispose();
                hv_EvalParams.Dispose();
                hv_DisplayParam.Dispose();
                hv_EvalIoUThresholds.Dispose();

                throw HDevExpDefaultException;
            }

            hv_EvaluationMeasures.Dispose();
            hv_IoUThresholds.Dispose();
            hv_DisplayIoUThreshold.Dispose();
            hv_BatchSize.Dispose();
            hv_AreaNames.Dispose();
            hv_AreaMin.Dispose();
            hv_AreaMax.Dispose();
            hv_MaxNumDetections.Dispose();
            hv_UseGPU.Dispose();
            hv_CudaLoaded.Dispose();
            hv_CuDNNLoaded.Dispose();
            hv_CuBlasLoaded.Dispose();
            hv_DLModelHandle.Dispose();
            hv_DLDataset.Dispose();
            hv_WindowHandleDict.Dispose();
            hv_GenParam.Dispose();
            hv_DLSamples.Dispose();
            hv_DLSampleIndices.Dispose();
            hv_DLSampleIndicesShuffled.Dispose();
            hv_Index.Dispose();
            hv_DLSampleBatch.Dispose();
            hv_DLResultBatch.Dispose();
            hv_GenParamEval.Dispose();
            hv_AreaRanges.Dispose();
            hv_EvaluationResultDetection.Dispose();
            hv_EvalParams.Dispose();
            hv_DisplayParam.Dispose();
            hv_EvalIoUThresholds.Dispose();
        }
        #endregion





















        // Procedures 
        // External procedures 
        public void add_colormap_to_image(HObject ho_GrayValueImage, HObject ho_Image,
            out HObject ho_ColoredImage, HTuple hv_HeatmapColorScheme)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_RGBValueImage, ho_Channels, ho_ChannelsScaled;
            HObject ho_Channel = null, ho_ChannelScaled = null, ho_ChannelScaledByte = null;
            HObject ho_ImageByte, ho_ImageByteR = null, ho_ImageByteG = null;
            HObject ho_ImageByteB = null;

            // Local copy input parameter variables 
            HObject ho_GrayValueImage_COPY_INP_TMP;
            ho_GrayValueImage_COPY_INP_TMP = new HObject(ho_GrayValueImage);



            // Local control variables 

            HTuple hv_Type = new HTuple(), hv_NumChannels = new HTuple();
            HTuple hv_ChannelIndex = new HTuple(), hv_ChannelMin = new HTuple();
            HTuple hv_ChannelMax = new HTuple(), hv__ = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ColoredImage);
            HOperatorSet.GenEmptyObj(out ho_RGBValueImage);
            HOperatorSet.GenEmptyObj(out ho_Channels);
            HOperatorSet.GenEmptyObj(out ho_ChannelsScaled);
            HOperatorSet.GenEmptyObj(out ho_Channel);
            HOperatorSet.GenEmptyObj(out ho_ChannelScaled);
            HOperatorSet.GenEmptyObj(out ho_ChannelScaledByte);
            HOperatorSet.GenEmptyObj(out ho_ImageByte);
            HOperatorSet.GenEmptyObj(out ho_ImageByteR);
            HOperatorSet.GenEmptyObj(out ho_ImageByteG);
            HOperatorSet.GenEmptyObj(out ho_ImageByteB);
            try
            {
                //
                //This procedure adds a gray-value image to a RGB image with a chosen colormap.
                //
                hv_Type.Dispose();
                HOperatorSet.GetImageType(ho_GrayValueImage_COPY_INP_TMP, out hv_Type);
                //The image LUT needs a byte image. Rescale real images.
                if ((int)(new HTuple(hv_Type.TupleEqual("real"))) != 0)
                {
                    {
                        HObject ExpTmpOutVar_0;
                        scale_image_range(ho_GrayValueImage_COPY_INP_TMP, out ExpTmpOutVar_0, 0,
                            1);
                        ho_GrayValueImage_COPY_INP_TMP.Dispose();
                        ho_GrayValueImage_COPY_INP_TMP = ExpTmpOutVar_0;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConvertImageType(ho_GrayValueImage_COPY_INP_TMP, out ExpTmpOutVar_0,
                            "byte");
                        ho_GrayValueImage_COPY_INP_TMP.Dispose();
                        ho_GrayValueImage_COPY_INP_TMP = ExpTmpOutVar_0;
                    }
                }
                else if ((int)(new HTuple(hv_Type.TupleNotEqual("byte"))) != 0)
                {
                    throw new HalconException(new HTuple("For this transformation, a byte or real image is needed!"));
                }
                //
                //Apply the chosen color scheme on the gray value.
                ho_RGBValueImage.Dispose();
                apply_colorscheme_on_gray_value_image(ho_GrayValueImage_COPY_INP_TMP, out ho_RGBValueImage,
                    hv_HeatmapColorScheme);
                //
                //Convert input image to byte image for visualization.
                ho_Channels.Dispose();
                HOperatorSet.ImageToChannels(ho_Image, out ho_Channels);
                hv_NumChannels.Dispose();
                HOperatorSet.CountChannels(ho_Image, out hv_NumChannels);
                ho_ChannelsScaled.Dispose();
                HOperatorSet.GenEmptyObj(out ho_ChannelsScaled);
                HTuple end_val19 = hv_NumChannels;
                HTuple step_val19 = 1;
                for (hv_ChannelIndex = 1; hv_ChannelIndex.Continue(end_val19, step_val19); hv_ChannelIndex = hv_ChannelIndex.TupleAdd(step_val19))
                {
                    ho_Channel.Dispose();
                    HOperatorSet.SelectObj(ho_Channels, out ho_Channel, hv_ChannelIndex);
                    hv_ChannelMin.Dispose(); hv_ChannelMax.Dispose(); hv__.Dispose();
                    HOperatorSet.MinMaxGray(ho_Channel, ho_Channel, 0, out hv_ChannelMin, out hv_ChannelMax,
                        out hv__);
                    ho_ChannelScaled.Dispose();
                    scale_image_range(ho_Channel, out ho_ChannelScaled, hv_ChannelMin, hv_ChannelMax);
                    ho_ChannelScaledByte.Dispose();
                    HOperatorSet.ConvertImageType(ho_ChannelScaled, out ho_ChannelScaledByte,
                        "byte");
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_ChannelsScaled, ho_ChannelScaledByte, out ExpTmpOutVar_0
                            );
                        ho_ChannelsScaled.Dispose();
                        ho_ChannelsScaled = ExpTmpOutVar_0;
                    }
                }
                ho_ImageByte.Dispose();
                HOperatorSet.ChannelsToImage(ho_ChannelsScaled, out ho_ImageByte);
                //
                //Note that ImageByte needs to have the same number of channels as
                //RGBValueImage to display colormap image correctly.
                hv_NumChannels.Dispose();
                HOperatorSet.CountChannels(ho_ImageByte, out hv_NumChannels);
                if ((int)(new HTuple(hv_NumChannels.TupleNotEqual(3))) != 0)
                {
                    //Just take the first channel and use this to generate
                    //an image with 3 channels for visualization.
                    ho_ImageByteR.Dispose();
                    HOperatorSet.AccessChannel(ho_ImageByte, out ho_ImageByteR, 1);
                    ho_ImageByteG.Dispose();
                    HOperatorSet.CopyImage(ho_ImageByteR, out ho_ImageByteG);
                    ho_ImageByteB.Dispose();
                    HOperatorSet.CopyImage(ho_ImageByteR, out ho_ImageByteB);
                    ho_ImageByte.Dispose();
                    HOperatorSet.Compose3(ho_ImageByteR, ho_ImageByteG, ho_ImageByteB, out ho_ImageByte
                        );
                }
                //
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.AddImage(ho_ImageByte, ho_RGBValueImage, out ExpTmpOutVar_0, 0.5,
                        0);
                    ho_RGBValueImage.Dispose();
                    ho_RGBValueImage = ExpTmpOutVar_0;
                }
                ho_ColoredImage.Dispose();
                ho_ColoredImage = new HObject(ho_RGBValueImage);
                //
                ho_GrayValueImage_COPY_INP_TMP.Dispose();
                ho_RGBValueImage.Dispose();
                ho_Channels.Dispose();
                ho_ChannelsScaled.Dispose();
                ho_Channel.Dispose();
                ho_ChannelScaled.Dispose();
                ho_ChannelScaledByte.Dispose();
                ho_ImageByte.Dispose();
                ho_ImageByteR.Dispose();
                ho_ImageByteG.Dispose();
                ho_ImageByteB.Dispose();

                hv_Type.Dispose();
                hv_NumChannels.Dispose();
                hv_ChannelIndex.Dispose();
                hv_ChannelMin.Dispose();
                hv_ChannelMax.Dispose();
                hv__.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_GrayValueImage_COPY_INP_TMP.Dispose();
                ho_RGBValueImage.Dispose();
                ho_Channels.Dispose();
                ho_ChannelsScaled.Dispose();
                ho_Channel.Dispose();
                ho_ChannelScaled.Dispose();
                ho_ChannelScaledByte.Dispose();
                ho_ImageByte.Dispose();
                ho_ImageByteR.Dispose();
                ho_ImageByteG.Dispose();
                ho_ImageByteB.Dispose();

                hv_Type.Dispose();
                hv_NumChannels.Dispose();
                hv_ChannelIndex.Dispose();
                hv_ChannelMin.Dispose();
                hv_ChannelMax.Dispose();
                hv__.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Short Description: Create a lookup table and convert a grey scale image. 
        public void apply_colorscheme_on_gray_value_image(HObject ho_InputImage, out HObject ho_ResultImage,
            HTuple hv_Schema)
        {




            // Local iconic variables 

            HObject ho_ImageR, ho_ImageG, ho_ImageB;

            // Local control variables 

            HTuple hv_X = new HTuple(), hv_Low = new HTuple();
            HTuple hv_High = new HTuple(), hv_OffR = new HTuple();
            HTuple hv_OffG = new HTuple(), hv_OffB = new HTuple();
            HTuple hv_A1 = new HTuple(), hv_A0 = new HTuple(), hv_R = new HTuple();
            HTuple hv_G = new HTuple(), hv_B = new HTuple(), hv_A0R = new HTuple();
            HTuple hv_A0G = new HTuple(), hv_A0B = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ResultImage);
            HOperatorSet.GenEmptyObj(out ho_ImageR);
            HOperatorSet.GenEmptyObj(out ho_ImageG);
            HOperatorSet.GenEmptyObj(out ho_ImageB);
            try
            {
                //
                //This procedure generates an RGB ResultImage for a grey-value InputImage.
                //In order to do so, create a color distribution as look up table
                //according to the Schema.
                //
                hv_X.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_X = HTuple.TupleGenSequence(
                        0, 255, 1);
                }
                hv_Low.Dispose();
                HOperatorSet.TupleGenConst(256, 0, out hv_Low);
                hv_High.Dispose();
                HOperatorSet.TupleGenConst(256, 255, out hv_High);
                //
                if ((int)(new HTuple(hv_Schema.TupleEqual("jet"))) != 0)
                {
                    //Scheme Jet: from blue to red
                    hv_OffR.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_OffR = 3.0 * 64.0;
                    }
                    hv_OffG.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_OffG = 2.0 * 64.0;
                    }
                    hv_OffB.Dispose();
                    hv_OffB = 64.0;
                    hv_A1.Dispose();
                    hv_A1 = -4.0;
                    hv_A0.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_A0 = 255.0 + 128.0;
                    }
                    hv_R.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_R = ((((((((hv_X - hv_OffR)).TupleAbs()
                            ) * hv_A1) + hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
                    }
                    hv_G.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_G = ((((((((hv_X - hv_OffG)).TupleAbs()
                            ) * hv_A1) + hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
                    }
                    hv_B.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_B = ((((((((hv_X - hv_OffB)).TupleAbs()
                            ) * hv_A1) + hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
                    }
                    //
                }
                else if ((int)(new HTuple(hv_Schema.TupleEqual("inverse_jet"))) != 0)
                {
                    //Scheme InvJet: from red to blue.
                    hv_OffR.Dispose();
                    hv_OffR = 64;
                    hv_OffG.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_OffG = 2 * 64;
                    }
                    hv_OffB.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_OffB = 3 * 64;
                    }
                    hv_A1.Dispose();
                    hv_A1 = -4.0;
                    hv_A0.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_A0 = 255.0 + 128.0;
                    }
                    hv_R.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_R = ((((((((hv_X - hv_OffR)).TupleAbs()
                            ) * hv_A1) + hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
                    }
                    hv_G.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_G = ((((((((hv_X - hv_OffG)).TupleAbs()
                            ) * hv_A1) + hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
                    }
                    hv_B.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_B = ((((((((hv_X - hv_OffB)).TupleAbs()
                            ) * hv_A1) + hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
                    }
                    //
                }
                else if ((int)(new HTuple(hv_Schema.TupleEqual("hot"))) != 0)
                {
                    //Scheme Hot.
                    hv_A1.Dispose();
                    hv_A1 = 3.0;
                    hv_A0R.Dispose();
                    hv_A0R = 0.0;
                    hv_A0G.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_A0G = ((1.0 / 3.0) * hv_A1) * 255.0;
                    }
                    hv_A0B.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_A0B = ((2.0 / 3.0) * hv_A1) * 255.0;
                    }
                    hv_R.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_R = (((((hv_X * hv_A1) - hv_A0R)).TupleMax2(
                            hv_Low))).TupleMin2(hv_High);
                    }
                    hv_G.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_G = (((((hv_X * hv_A1) - hv_A0G)).TupleMax2(
                            hv_Low))).TupleMin2(hv_High);
                    }
                    hv_B.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_B = (((((hv_X * hv_A1) - hv_A0B)).TupleMax2(
                            hv_Low))).TupleMin2(hv_High);
                    }
                    //
                }
                else if ((int)(new HTuple(hv_Schema.TupleEqual("inverse_hot"))) != 0)
                {
                    //Scheme Inverse Hot.
                    hv_A1.Dispose();
                    hv_A1 = -3.0;
                    hv_A0R.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_A0R = hv_A1 * 255.0;
                    }
                    hv_A0G.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_A0G = ((2.0 / 3.0) * hv_A1) * 255.0;
                    }
                    hv_A0B.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_A0B = ((1.0 / 3.0) * hv_A1) * 255.0;
                    }
                    hv_R.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_R = (((((hv_X * hv_A1) - hv_A0R)).TupleMax2(
                            hv_Low))).TupleMin2(hv_High);
                    }
                    hv_G.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_G = (((((hv_X * hv_A1) - hv_A0G)).TupleMax2(
                            hv_Low))).TupleMin2(hv_High);
                    }
                    hv_B.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_B = (((((hv_X * hv_A1) - hv_A0B)).TupleMax2(
                            hv_Low))).TupleMin2(hv_High);
                    }
                    //
                }
                else
                {
                    //
                    throw new HalconException(("Unknown color schema: " + hv_Schema) + ".");
                    //
                }
                //
                ho_ImageR.Dispose();
                HOperatorSet.LutTrans(ho_InputImage, out ho_ImageR, hv_R);
                ho_ImageG.Dispose();
                HOperatorSet.LutTrans(ho_InputImage, out ho_ImageG, hv_G);
                ho_ImageB.Dispose();
                HOperatorSet.LutTrans(ho_InputImage, out ho_ImageB, hv_B);
                ho_ResultImage.Dispose();
                HOperatorSet.Compose3(ho_ImageR, ho_ImageG, ho_ImageB, out ho_ResultImage);
                //
                ho_ImageR.Dispose();
                ho_ImageG.Dispose();
                ho_ImageB.Dispose();

                hv_X.Dispose();
                hv_Low.Dispose();
                hv_High.Dispose();
                hv_OffR.Dispose();
                hv_OffG.Dispose();
                hv_OffB.Dispose();
                hv_A1.Dispose();
                hv_A0.Dispose();
                hv_R.Dispose();
                hv_G.Dispose();
                hv_B.Dispose();
                hv_A0R.Dispose();
                hv_A0G.Dispose();
                hv_A0B.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_ImageR.Dispose();
                ho_ImageG.Dispose();
                ho_ImageB.Dispose();

                hv_X.Dispose();
                hv_Low.Dispose();
                hv_High.Dispose();
                hv_OffR.Dispose();
                hv_OffG.Dispose();
                hv_OffB.Dispose();
                hv_A1.Dispose();
                hv_A0.Dispose();
                hv_R.Dispose();
                hv_G.Dispose();
                hv_B.Dispose();
                hv_A0R.Dispose();
                hv_A0G.Dispose();
                hv_A0B.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        public void area_iou(HTuple hv_Sample, HTuple hv_Result, HTuple hv_InstanceType,
            HTuple hv_ResultSortIndices, out HTuple hv_SampleArea, out HTuple hv_ResultArea,
            out HTuple hv_IoU)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_GtRow1 = new HTuple(), hv_GtCol1 = new HTuple();
            HTuple hv_GtRow2 = new HTuple(), hv_GtCol2 = new HTuple();
            HTuple hv_ResRow1 = new HTuple(), hv_ResCol1 = new HTuple();
            HTuple hv_ResRow2 = new HTuple(), hv_ResCol2 = new HTuple();
            HTuple hv_GtIdx = new HTuple(), hv_Height = new HTuple();
            HTuple hv_Width = new HTuple(), hv_ValidIdxs = new HTuple();
            HTuple hv_Intersection = new HTuple(), hv_Union = new HTuple();
            HTuple hv_GtRow = new HTuple(), hv_GtCol = new HTuple();
            HTuple hv_GtLength1 = new HTuple(), hv_GtLength2 = new HTuple();
            HTuple hv_GtPhi = new HTuple(), hv_ResRow = new HTuple();
            HTuple hv_ResCol = new HTuple(), hv_ResLength1 = new HTuple();
            HTuple hv_ResLength2 = new HTuple(), hv_ResPhi = new HTuple();
            // Initialize local and output iconic variables 
            hv_SampleArea = new HTuple();
            hv_ResultArea = new HTuple();
            hv_IoU = new HTuple();
            try
            {
                //
                //Compute the intersection over union (IoU) between
                //the ground truth and the inferred bounding box of the object instances.
                //The bounding box type is determined over the InstanceType.
                //
                if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
                {
                    //Get bounding box coordinates.
                    hv_GtRow1.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_row1", out hv_GtRow1);
                    hv_GtCol1.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_col1", out hv_GtCol1);
                    hv_GtRow2.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_row2", out hv_GtRow2);
                    hv_GtCol2.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_col2", out hv_GtCol2);
                    hv_ResRow1.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_row1", out hv_ResRow1);
                    hv_ResCol1.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_col1", out hv_ResCol1);
                    hv_ResRow2.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_row2", out hv_ResRow2);
                    hv_ResCol2.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_col2", out hv_ResCol2);
                    //
                    //Sort the results.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResRow1 = hv_ResRow1.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResRow1.Dispose();
                            hv_ResRow1 = ExpTmpLocalVar_ResRow1;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResCol1 = hv_ResCol1.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResCol1.Dispose();
                            hv_ResCol1 = ExpTmpLocalVar_ResCol1;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResRow2 = hv_ResRow2.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResRow2.Dispose();
                            hv_ResRow2 = ExpTmpLocalVar_ResRow2;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResCol2 = hv_ResCol2.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResCol2.Dispose();
                            hv_ResCol2 = ExpTmpLocalVar_ResCol2;
                        }
                    }
                    //
                    //Compute areas.
                    hv_SampleArea.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SampleArea = (hv_GtRow2 - hv_GtRow1) * (hv_GtCol2 - hv_GtCol1);
                    }
                    hv_ResultArea.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ResultArea = (hv_ResRow2 - hv_ResRow1) * (hv_ResCol2 - hv_ResCol1);
                    }
                    //
                    //Compute IoUs.
                    hv_IoU.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_IoU = HTuple.TupleGenConst(
                            (new HTuple(hv_GtRow1.TupleLength())) * (new HTuple(hv_ResRow1.TupleLength()
                            )), 0);
                    }
                    if ((int)(new HTuple((new HTuple(hv_IoU.TupleLength())).TupleGreater(0))) != 0)
                    {
                        for (hv_GtIdx = 0; (int)hv_GtIdx <= (int)((new HTuple(hv_GtRow1.TupleLength()
                            )) - 1); hv_GtIdx = (int)hv_GtIdx + 1)
                        {
                            hv_Height.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Height = (((hv_GtRow2.TupleSelect(
                                    hv_GtIdx))).TupleMin2(hv_ResRow2)) - (((hv_GtRow1.TupleSelect(hv_GtIdx))).TupleMax2(
                                    hv_ResRow1));
                            }
                            hv_Width.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Width = (((hv_GtCol2.TupleSelect(
                                    hv_GtIdx))).TupleMin2(hv_ResCol2)) - (((hv_GtCol1.TupleSelect(hv_GtIdx))).TupleMax2(
                                    hv_ResCol1));
                            }
                            hv_ValidIdxs.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ValidIdxs = (new HTuple(((hv_Height.TupleGreaterElem(
                                    0))).TupleAnd(hv_Width.TupleGreaterElem(0)))).TupleFind(1);
                            }
                            if ((int)(new HTuple(hv_ValidIdxs.TupleGreater(-1))) != 0)
                            {
                                hv_Intersection.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Intersection = (hv_Height.TupleSelect(
                                        hv_ValidIdxs)) * (hv_Width.TupleSelect(hv_ValidIdxs));
                                }
                                hv_Union.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Union = ((hv_SampleArea.TupleSelect(
                                        hv_GtIdx)) + (hv_ResultArea.TupleSelect(hv_ValidIdxs))) - hv_Intersection;
                                }
                                if (hv_IoU == null)
                                    hv_IoU = new HTuple();
                                hv_IoU[(hv_GtIdx * (new HTuple(hv_ResRow1.TupleLength()))) + hv_ValidIdxs] = (hv_Intersection.TupleReal()
                                    ) / hv_Union;
                            }
                        }
                    }
                }
                else if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
                {
                    //Get bounding box coordinates.
                    hv_GtRow.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_row", out hv_GtRow);
                    hv_GtCol.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_col", out hv_GtCol);
                    hv_GtLength1.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_length1", out hv_GtLength1);
                    hv_GtLength2.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_length2", out hv_GtLength2);
                    hv_GtPhi.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_phi", out hv_GtPhi);
                    hv_ResRow.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_row", out hv_ResRow);
                    hv_ResCol.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_col", out hv_ResCol);
                    hv_ResLength1.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_length1", out hv_ResLength1);
                    hv_ResLength2.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_length2", out hv_ResLength2);
                    hv_ResPhi.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_phi", out hv_ResPhi);
                    //
                    //Sort results.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResRow = hv_ResRow.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResRow.Dispose();
                            hv_ResRow = ExpTmpLocalVar_ResRow;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResCol = hv_ResCol.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResCol.Dispose();
                            hv_ResCol = ExpTmpLocalVar_ResCol;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResLength1 = hv_ResLength1.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResLength1.Dispose();
                            hv_ResLength1 = ExpTmpLocalVar_ResLength1;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResLength2 = hv_ResLength2.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResLength2.Dispose();
                            hv_ResLength2 = ExpTmpLocalVar_ResLength2;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResPhi = hv_ResPhi.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResPhi.Dispose();
                            hv_ResPhi = ExpTmpLocalVar_ResPhi;
                        }
                    }
                    //
                    //Compute Areas.
                    hv_SampleArea.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SampleArea = (4.0 * hv_GtLength1) * hv_GtLength2;
                    }
                    hv_ResultArea.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ResultArea = (4.0 * hv_ResLength1) * hv_ResLength2;
                    }
                    //
                    //Compute IoUs.
                    hv_IoU.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_IoU = HTuple.TupleGenConst(
                            (new HTuple(hv_GtRow.TupleLength())) * (new HTuple(hv_ResRow.TupleLength()
                            )), 0);
                    }
                    if ((int)(new HTuple((new HTuple(hv_IoU.TupleLength())).TupleGreater(0))) != 0)
                    {
                        for (hv_GtIdx = 0; (int)hv_GtIdx <= (int)((new HTuple(hv_GtRow.TupleLength()
                            )) - 1); hv_GtIdx = (int)hv_GtIdx + 1)
                        {
                            hv_ValidIdxs.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ValidIdxs = (new HTuple(((((hv_SampleArea.TupleSelect(
                                    hv_GtIdx))).TupleGreaterElem(0))).TupleAnd(hv_ResultArea.TupleGreaterElem(
                                    0)))).TupleFind(1);
                            }
                            if ((int)(new HTuple(hv_ValidIdxs.TupleGreater(-1))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Intersection.Dispose();
                                    HOperatorSet.AreaIntersectionRectangle2(hv_GtRow.TupleSelect(hv_GtIdx),
                                        hv_GtCol.TupleSelect(hv_GtIdx), hv_GtPhi.TupleSelect(hv_GtIdx),
                                        hv_GtLength1.TupleSelect(hv_GtIdx), hv_GtLength2.TupleSelect(hv_GtIdx),
                                        hv_ResRow.TupleSelect(hv_ValidIdxs), hv_ResCol.TupleSelect(hv_ValidIdxs),
                                        hv_ResPhi.TupleSelect(hv_ValidIdxs), hv_ResLength1.TupleSelect(
                                        hv_ValidIdxs), hv_ResLength2.TupleSelect(hv_ValidIdxs), out hv_Intersection);
                                }
                                hv_Union.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Union = ((hv_SampleArea.TupleSelect(
                                        hv_GtIdx)) + (hv_ResultArea.TupleSelect(hv_ValidIdxs))) - hv_Intersection;
                                }
                                if (hv_IoU == null)
                                    hv_IoU = new HTuple();
                                hv_IoU[(hv_GtIdx * (new HTuple(hv_ResRow.TupleLength()))) + hv_ValidIdxs] = (hv_Intersection.TupleReal()
                                    ) / hv_Union;
                            }
                        }
                    }
                }
                else
                {
                    throw new HalconException(("Instance type '" + hv_InstanceType) + "' is not supported");
                }

                hv_GtRow1.Dispose();
                hv_GtCol1.Dispose();
                hv_GtRow2.Dispose();
                hv_GtCol2.Dispose();
                hv_ResRow1.Dispose();
                hv_ResCol1.Dispose();
                hv_ResRow2.Dispose();
                hv_ResCol2.Dispose();
                hv_GtIdx.Dispose();
                hv_Height.Dispose();
                hv_Width.Dispose();
                hv_ValidIdxs.Dispose();
                hv_Intersection.Dispose();
                hv_Union.Dispose();
                hv_GtRow.Dispose();
                hv_GtCol.Dispose();
                hv_GtLength1.Dispose();
                hv_GtLength2.Dispose();
                hv_GtPhi.Dispose();
                hv_ResRow.Dispose();
                hv_ResCol.Dispose();
                hv_ResLength1.Dispose();
                hv_ResLength2.Dispose();
                hv_ResPhi.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_GtRow1.Dispose();
                hv_GtCol1.Dispose();
                hv_GtRow2.Dispose();
                hv_GtCol2.Dispose();
                hv_ResRow1.Dispose();
                hv_ResCol1.Dispose();
                hv_ResRow2.Dispose();
                hv_ResCol2.Dispose();
                hv_GtIdx.Dispose();
                hv_Height.Dispose();
                hv_Width.Dispose();
                hv_ValidIdxs.Dispose();
                hv_Intersection.Dispose();
                hv_Union.Dispose();
                hv_GtRow.Dispose();
                hv_GtCol.Dispose();
                hv_GtLength1.Dispose();
                hv_GtLength2.Dispose();
                hv_GtPhi.Dispose();
                hv_ResRow.Dispose();
                hv_ResCol.Dispose();
                hv_ResLength1.Dispose();
                hv_ResLength2.Dispose();
                hv_ResPhi.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Calculate evaluation measures based on the values of RunningMeasures and the settings in EvalParams. 
        public void calculate_evaluation_measures(HTuple hv_RunningMeasures, HTuple hv_EvalParams,
            out HTuple hv_EvaluationResult)
        {



            // Local control variables 

            HTuple hv_EvaluationType = new HTuple();
            // Initialize local and output iconic variables 
            hv_EvaluationResult = new HTuple();
            try
            {
                //
                //This procedure calculates the final measures depending on the evaluation type.
                //
                hv_EvaluationType.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "evaluation_type", out hv_EvaluationType);
                if ((int)(new HTuple(hv_EvaluationType.TupleEqual("anomaly_detection"))) != 0)
                {
                    hv_EvaluationResult.Dispose();
                    calculate_image_anomaly_measures(hv_RunningMeasures, hv_EvalParams, out hv_EvaluationResult);
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("classification"))) != 0)
                {
                    hv_EvaluationResult.Dispose();
                    calculate_image_classification_measures(hv_RunningMeasures, hv_EvalParams,
                        out hv_EvaluationResult);
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("detection"))) != 0)
                {
                    hv_EvaluationResult.Dispose();
                    calculate_instance_measures(hv_RunningMeasures, hv_EvalParams, out hv_EvaluationResult);
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("segmentation"))) != 0)
                {
                    hv_EvaluationResult.Dispose();
                    calculate_pixel_measures(hv_RunningMeasures, hv_EvalParams, out hv_EvaluationResult);
                }
                //

                hv_EvaluationType.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_EvaluationType.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection
        // Short Description: Calculate anomaly detection measures based on RunningMeasures. 
        public void calculate_image_anomaly_measures(HTuple hv_RunningMeasures, HTuple hv_EvalParams,
            out HTuple hv_EvaluationResult)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_MinScaling = new HTuple(), hv_MaxScaling = new HTuple();
            HTuple hv_ImageIDs = new HTuple(), hv_AnomalyLabelIDs = new HTuple();
            HTuple hv_AnomalyScores = new HTuple(), hv_AnomalyScoreHistogram = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_MinScorePlot = new HTuple();
            HTuple hv_MaxScorePlot = new HTuple(), hv_NumBins = new HTuple();
            HTuple hv_OKIndices = new HTuple(), hv_ImageLevelScoresOK = new HTuple();
            HTuple hv_HistoOK = new HTuple(), hv_BinSize = new HTuple();
            HTuple hv_HistoCumulOK = new HTuple(), hv_NOKIndices = new HTuple();
            HTuple hv_ImageLevelScoresNOK = new HTuple(), hv_HistoNOK = new HTuple();
            HTuple hv_HistoCumulNOK = new HTuple(), hv_AnomalyScoreBins = new HTuple();
            HTuple hv_ScoreHistogram = new HTuple();
            // Initialize local and output iconic variables 
            hv_EvaluationResult = new HTuple();
            try
            {
                //
                //This procedure calculates the final summarizing image anomaly detection measures based on the running measures.
                //
                //Set some parameters.
                hv_MinScaling.Dispose();
                hv_MinScaling = 0.7;
                hv_MaxScaling.Dispose();
                hv_MaxScaling = 1.3;
                //Get and check values in RunningMeasures.
                //
                //Get image ids.
                hv_ImageIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "image_ids", out hv_ImageIDs);
                //Get anomaly ids.
                hv_AnomalyLabelIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "anomaly_label_ids", out hv_AnomalyLabelIDs);
                //Get image scores.
                hv_AnomalyScores.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "anomaly_scores", out hv_AnomalyScores);
                //Get anomaly score thresholds from EvalParams.
                try
                {
                    hv_AnomalyScoreHistogram.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "anomaly_score_histogram", out hv_AnomalyScoreHistogram);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    hv_MinScorePlot.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MinScorePlot = hv_MinScaling * (hv_AnomalyScores.TupleMin()
                            );
                    }
                    hv_MaxScorePlot.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxScorePlot = hv_MaxScaling * (hv_AnomalyScores.TupleMax()
                            );
                    }
                    hv_NumBins.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumBins = new HTuple(hv_AnomalyScores.TupleLength()
                            );
                    }
                }
                //
                //No minimum value given.
                try
                {
                    hv_MinScorePlot.Dispose();
                    HOperatorSet.GetDictTuple(hv_AnomalyScoreHistogram, "min", out hv_MinScorePlot);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    hv_MinScorePlot.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MinScorePlot = ((hv_MinScaling * (hv_AnomalyScores.TupleMin()
                            ))).TupleReal();
                    }
                }
                //
                //No maximum value given.
                try
                {
                    hv_MaxScorePlot.Dispose();
                    HOperatorSet.GetDictTuple(hv_AnomalyScoreHistogram, "max", out hv_MaxScorePlot);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    hv_MaxScorePlot.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxScorePlot = ((hv_MaxScaling * (hv_AnomalyScores.TupleMax()
                            ))).TupleReal();
                    }
                }
                //
                //No number of bins given.
                try
                {
                    hv_NumBins.Dispose();
                    HOperatorSet.GetDictTuple(hv_AnomalyScoreHistogram, "num_bins", out hv_NumBins);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    hv_NumBins.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumBins = new HTuple(hv_AnomalyScores.TupleLength()
                            );
                    }
                }
                //
                //Estimate thresholds for histogram calculation by using min/max of the anomaly scores.
                if ((int)((new HTuple(hv_MinScorePlot.TupleEqual(-1))).TupleOr(new HTuple((new HTuple(hv_MinScorePlot.TupleLength()
                    )).TupleEqual(0)))) != 0)
                {
                    hv_MinScorePlot.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MinScorePlot = hv_MinScaling * (hv_AnomalyScores.TupleMin()
                            );
                    }
                }
                else if ((int)(new HTuple(hv_MinScorePlot.TupleLess(0))) != 0)
                {
                    throw new HalconException("Invalid value for minimum histogram value. Must be >= 0.");
                }
                //
                if ((int)((new HTuple(hv_MaxScorePlot.TupleEqual(-1))).TupleOr(new HTuple((new HTuple(hv_MaxScorePlot.TupleLength()
                    )).TupleEqual(0)))) != 0)
                {
                    hv_MaxScorePlot.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxScorePlot = (new HTuple(1.0)).TupleMin2(
                            hv_MaxScaling * (hv_AnomalyScores.TupleMax()));
                    }
                }
                else if ((int)(new HTuple(hv_MaxScorePlot.TupleLessEqual(0))) != 0)
                {
                    throw new HalconException("Invalid value for maximum histogram value. Must be > 0.");
                }
                //
                if ((int)((new HTuple(hv_NumBins.TupleEqual(-1))).TupleOr(new HTuple((new HTuple(hv_NumBins.TupleLength()
                    )).TupleEqual(0)))) != 0)
                {
                    hv_NumBins.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumBins = new HTuple(hv_AnomalyScores.TupleLength()
                            );
                    }
                }
                else if ((int)(new HTuple(hv_NumBins.TupleEqual(0))) != 0)
                {
                    throw new HalconException("Invalid number of bins. Must at least be 1.");
                }
                //
                //Assign scores with the right labels.
                hv_OKIndices.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_OKIndices = hv_AnomalyLabelIDs.TupleFind(
                        0);
                }
                hv_ImageLevelScoresOK.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ImageLevelScoresOK = hv_AnomalyScores.TupleSelect(
                        hv_OKIndices);
                }
                //
                //Calculate histograms.
                hv_HistoOK.Dispose(); hv_BinSize.Dispose();
                HOperatorSet.TupleHistoRange(hv_ImageLevelScoresOK, hv_MinScorePlot, hv_MaxScorePlot,
                    hv_NumBins, out hv_HistoOK, out hv_BinSize);
                //
                //Calculate cumulative histogram
                hv_HistoCumulOK.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HistoCumulOK = 1.0 - (((hv_HistoOK / ((((new HTuple(1.0)).TupleMax2(
                        hv_HistoOK.TupleSum()))).TupleReal()))).TupleCumul());
                }
                //
                hv_NOKIndices.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NOKIndices = hv_AnomalyLabelIDs.TupleFind(
                        1);
                }
                if ((int)(new HTuple(hv_NOKIndices.TupleNotEqual(-1))) != 0)
                {
                    hv_ImageLevelScoresNOK.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageLevelScoresNOK = hv_AnomalyScores.TupleSelect(
                            hv_NOKIndices);
                    }
                    hv_HistoNOK.Dispose(); hv_BinSize.Dispose();
                    HOperatorSet.TupleHistoRange(hv_ImageLevelScoresNOK, hv_MinScorePlot, hv_MaxScorePlot,
                        hv_NumBins, out hv_HistoNOK, out hv_BinSize);
                    hv_HistoCumulNOK.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_HistoCumulNOK = ((hv_HistoNOK / ((((new HTuple(1.0)).TupleMax2(
                            hv_HistoNOK.TupleSum()))).TupleReal()))).TupleCumul();
                    }
                }
                else
                {
                    hv_HistoCumulNOK.Dispose();
                    hv_HistoCumulNOK = new HTuple();
                }
                //
                //Calculate left sided bins.
                hv_AnomalyScoreBins.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_AnomalyScoreBins = HTuple.TupleGenSequence(
                        hv_MinScorePlot, hv_MinScorePlot + (((hv_NumBins - 1) + 1e-4) * hv_BinSize), hv_BinSize);
                }
                //
                //Create dictionary for the score histogram.
                hv_ScoreHistogram.Dispose();
                HOperatorSet.CreateDict(out hv_ScoreHistogram);
                HOperatorSet.SetDictTuple(hv_ScoreHistogram, "ok", hv_HistoCumulOK);
                HOperatorSet.SetDictTuple(hv_ScoreHistogram, "nok", hv_HistoCumulNOK);
                //
                //Set the score histogram in the results dictionary.
                hv_EvaluationResult.Dispose();
                HOperatorSet.CreateDict(out hv_EvaluationResult);
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "anomaly_score_histogram", hv_ScoreHistogram);
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "anomaly_score_bins", hv_AnomalyScoreBins);
                //

                hv_MinScaling.Dispose();
                hv_MaxScaling.Dispose();
                hv_ImageIDs.Dispose();
                hv_AnomalyLabelIDs.Dispose();
                hv_AnomalyScores.Dispose();
                hv_AnomalyScoreHistogram.Dispose();
                hv_Exception.Dispose();
                hv_MinScorePlot.Dispose();
                hv_MaxScorePlot.Dispose();
                hv_NumBins.Dispose();
                hv_OKIndices.Dispose();
                hv_ImageLevelScoresOK.Dispose();
                hv_HistoOK.Dispose();
                hv_BinSize.Dispose();
                hv_HistoCumulOK.Dispose();
                hv_NOKIndices.Dispose();
                hv_ImageLevelScoresNOK.Dispose();
                hv_HistoNOK.Dispose();
                hv_HistoCumulNOK.Dispose();
                hv_AnomalyScoreBins.Dispose();
                hv_ScoreHistogram.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_MinScaling.Dispose();
                hv_MaxScaling.Dispose();
                hv_ImageIDs.Dispose();
                hv_AnomalyLabelIDs.Dispose();
                hv_AnomalyScores.Dispose();
                hv_AnomalyScoreHistogram.Dispose();
                hv_Exception.Dispose();
                hv_MinScorePlot.Dispose();
                hv_MaxScorePlot.Dispose();
                hv_NumBins.Dispose();
                hv_OKIndices.Dispose();
                hv_ImageLevelScoresOK.Dispose();
                hv_HistoOK.Dispose();
                hv_BinSize.Dispose();
                hv_HistoCumulOK.Dispose();
                hv_NOKIndices.Dispose();
                hv_ImageLevelScoresNOK.Dispose();
                hv_HistoNOK.Dispose();
                hv_HistoCumulNOK.Dispose();
                hv_AnomalyScoreBins.Dispose();
                hv_ScoreHistogram.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Calculate image classification measures based on RunningMeasures. 
        public void calculate_image_classification_measures(HTuple hv_RunningMeasures,
            HTuple hv_EvalParams, out HTuple hv_EvaluationResult)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_TopKErrorKs = new HTuple(), hv_CalcPrecision = new HTuple();
            HTuple hv_CalcRecall = new HTuple(), hv_CalcFScore = new HTuple();
            HTuple hv_CalcAbsoluteConfusionMatrix = new HTuple(), hv_CalcRelativeConfusionMatrix = new HTuple();
            HTuple hv_Measures = new HTuple(), hv_RegExpTopKError = new HTuple();
            HTuple hv_M = new HTuple(), hv_ComputeTopKError = new HTuple();
            HTuple hv_K = new HTuple(), hv_ClassIDs = new HTuple();
            HTuple hv_KeyExists = new HTuple(), hv_ClassesToEvaluate = new HTuple();
            HTuple hv_ClassIDsToEvaluate = new HTuple(), hv_ClassNames = new HTuple();
            HTuple hv_Index = new HTuple(), hv_Position = new HTuple();
            HTuple hv_ImageIDs = new HTuple(), hv_ImageLabelIDs = new HTuple();
            HTuple hv_Predictions = new HTuple(), hv_TopKPredictions = new HTuple();
            HTuple hv_EvalIndex = new HTuple(), hv_CurrentEvalClass = new HTuple();
            HTuple hv_IndexClass = new HTuple(), hv_EvaluatedSamples = new HTuple();
            HTuple hv_ConfusionMatrix = new HTuple(), hv_RelativeConfusionMatrix = new HTuple();
            HTuple hv_EvalClassID = new HTuple(), hv_KIndex = new HTuple();
            HTuple hv_Indices = new HTuple(), hv_TopKError = new HTuple();
            HTuple hv_NumClasses = new HTuple(), hv_ClassPrecisions = new HTuple();
            HTuple hv_MatrixRowSumID = new HTuple(), hv_TruePositive = new HTuple();
            HTuple hv_SumPredictedClass = new HTuple(), hv_ClassPrecision = new HTuple();
            HTuple hv_Precision = new HTuple(), hv_ClassRecalls = new HTuple();
            HTuple hv_MatrixColumnSumID = new HTuple(), hv_SumLabel = new HTuple();
            HTuple hv_ClassRecall = new HTuple(), hv_Recall = new HTuple();
            HTuple hv_ClassFScores = new HTuple(), hv_SumPrecisionRecall = new HTuple();
            HTuple hv_PositiveIndices = new HTuple(), hv_FScore = new HTuple();
            HTuple hv_KeyName = new HTuple();
            // Initialize local and output iconic variables 
            hv_EvaluationResult = new HTuple();
            try
            {
                //
                //This procedure calculates the final summarizing image classification measures based on the running measures.
                //
                //Set default values.
                hv_TopKErrorKs.Dispose();
                hv_TopKErrorKs = new HTuple();
                hv_CalcPrecision.Dispose();
                hv_CalcPrecision = 0;
                hv_CalcRecall.Dispose();
                hv_CalcRecall = 0;
                hv_CalcFScore.Dispose();
                hv_CalcFScore = 0;
                hv_CalcAbsoluteConfusionMatrix.Dispose();
                hv_CalcAbsoluteConfusionMatrix = 0;
                hv_CalcRelativeConfusionMatrix.Dispose();
                hv_CalcRelativeConfusionMatrix = 0;
                //
                //Check which measures are to be calculated.
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                hv_RegExpTopKError.Dispose();
                hv_RegExpTopKError = "top([0-9]+)_error";
                for (hv_M = 0; (int)hv_M <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_M = (int)hv_M + 1)
                {
                    hv_ComputeTopKError.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ComputeTopKError = ((hv_Measures.TupleSelect(
                            hv_M))).TupleRegexpTest("top([0-9]+)_error");
                    }
                    if ((int)(hv_ComputeTopKError) != 0)
                    {
                        hv_K.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_K = ((((hv_Measures.TupleSelect(
                                hv_M))).TupleRegexpMatch(hv_RegExpTopKError))).TupleNumber();
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_TopKErrorKs = ((hv_TopKErrorKs.TupleConcat(
                                    hv_K))).TupleSort();
                                hv_TopKErrorKs.Dispose();
                                hv_TopKErrorKs = ExpTmpLocalVar_TopKErrorKs;
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "precision"))) != 0)
                    {
                        hv_CalcPrecision.Dispose();
                        hv_CalcPrecision = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "recall"))) != 0)
                    {
                        hv_CalcRecall.Dispose();
                        hv_CalcRecall = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "f_score"))) != 0)
                    {
                        hv_CalcFScore.Dispose();
                        hv_CalcFScore = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "absolute_confusion_matrix"))) != 0)
                    {
                        hv_CalcAbsoluteConfusionMatrix.Dispose();
                        hv_CalcAbsoluteConfusionMatrix = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "relative_confusion_matrix"))) != 0)
                    {
                        hv_CalcRelativeConfusionMatrix.Dispose();
                        hv_CalcRelativeConfusionMatrix = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "all"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_TopKErrorKs = ((hv_TopKErrorKs.TupleConcat(
                                    1))).TupleSort();
                                hv_TopKErrorKs.Dispose();
                                hv_TopKErrorKs = ExpTmpLocalVar_TopKErrorKs;
                            }
                        }
                        hv_CalcPrecision.Dispose();
                        hv_CalcPrecision = 1;
                        hv_CalcRecall.Dispose();
                        hv_CalcRecall = 1;
                        hv_CalcFScore.Dispose();
                        hv_CalcFScore = 1;
                        hv_CalcAbsoluteConfusionMatrix.Dispose();
                        hv_CalcAbsoluteConfusionMatrix = 1;
                        hv_CalcRelativeConfusionMatrix.Dispose();
                        hv_CalcRelativeConfusionMatrix = 1;
                    }
                    else
                    {
                        throw new HalconException("Unknown image classification measure: " + (hv_Measures.TupleSelect(
                            hv_M)));
                    }
                }
                //
                //Initialize output dictionary and get necessary evaluation parameters.
                hv_EvaluationResult.Dispose();
                HOperatorSet.CreateDict(out hv_EvaluationResult);
                hv_ClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                hv_KeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "class_names_to_evaluate",
                    out hv_KeyExists);
                if ((int)(hv_KeyExists) != 0)
                {
                    hv_ClassesToEvaluate.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "class_names_to_evaluate", out hv_ClassesToEvaluate);
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate = new HTuple();
                    hv_ClassNames.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "class_names", out hv_ClassNames);
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_ClassesToEvaluate.TupleLength()
                        )) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        hv_Position.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Position = (((((new HTuple("global")).TupleConcat(
                                hv_ClassNames))).TupleEqualElem(hv_ClassesToEvaluate.TupleSelect(hv_Index)))).TupleFind(
                                1);
                        }
                        if ((int)((new HTuple(hv_Position.TupleEqual(-1))).TupleOr(new HTuple(hv_Position.TupleEqual(
                            new HTuple())))) != 0)
                        {
                            throw new HalconException("Invalid entry in  'class_names_to_evaluate': " + ((((new HTuple("global")).TupleConcat(
                                hv_ClassesToEvaluate))).TupleSelect(hv_Index)));
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_ClassIDsToEvaluate = hv_ClassIDsToEvaluate.TupleConcat(
                                    (((new HTuple("global")).TupleConcat(hv_ClassIDs))).TupleSelect(hv_Position));
                                hv_ClassIDsToEvaluate.Dispose();
                                hv_ClassIDsToEvaluate = ExpTmpLocalVar_ClassIDsToEvaluate;
                            }
                        }
                    }
                    HOperatorSet.SetDictTuple(hv_EvalParams, "class_ids_to_evaluate", hv_ClassIDsToEvaluate);
                }
                hv_ClassIDsToEvaluate.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids_to_evaluate", out hv_ClassIDsToEvaluate);
                //
                //Get and check values in RunningMeasures.
                hv_ImageIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "image_ids", out hv_ImageIDs);
                hv_ImageLabelIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "image_label_ids", out hv_ImageLabelIDs);
                hv_Predictions.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "top1_predictions", out hv_Predictions);
                hv_TopKPredictions.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "topk_predictions", out hv_TopKPredictions);
                //
                //Check if needed classes appear in image label IDs.
                //For the confusion matrices, all classes need to be represented.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_CalcAbsoluteConfusionMatrix = (new HTuple((new HTuple(hv_CalcPrecision.TupleOr(
                            hv_CalcRecall))).TupleOr(hv_CalcFScore))).TupleOr(hv_CalcAbsoluteConfusionMatrix);
                        hv_CalcAbsoluteConfusionMatrix.Dispose();
                        hv_CalcAbsoluteConfusionMatrix = ExpTmpLocalVar_CalcAbsoluteConfusionMatrix;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_CalcRelativeConfusionMatrix = (new HTuple((new HTuple(hv_CalcPrecision.TupleOr(
                            hv_CalcRecall))).TupleOr(hv_CalcFScore))).TupleOr(hv_CalcRelativeConfusionMatrix);
                        hv_CalcRelativeConfusionMatrix.Dispose();
                        hv_CalcRelativeConfusionMatrix = ExpTmpLocalVar_CalcRelativeConfusionMatrix;
                    }
                }
                if ((int)(hv_CalcAbsoluteConfusionMatrix.TupleOr(hv_CalcRelativeConfusionMatrix)) != 0)
                {
                    if ((int)(new HTuple(((((hv_ImageLabelIDs.TupleSort())).TupleUniq())).TupleNotEqual(
                        hv_ClassIDs.TupleSort()))) != 0)
                    {
                        throw new HalconException("Not all classes are represented in the ground truth labels. \nPlease check your data split.");
                    }
                }
                //For top-K errors, the evaluated classes need to be represented.
                if ((int)(new HTuple(hv_TopKErrorKs.TupleNotEqual(new HTuple()))) != 0)
                {
                    for (hv_EvalIndex = 0; (int)hv_EvalIndex <= (int)((new HTuple(hv_ClassIDsToEvaluate.TupleLength()
                        )) - 1); hv_EvalIndex = (int)hv_EvalIndex + 1)
                    {
                        hv_CurrentEvalClass.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentEvalClass = hv_ClassIDsToEvaluate.TupleSelect(
                                hv_EvalIndex);
                        }
                        if ((int)(new HTuple(hv_CurrentEvalClass.TupleNotEqual("global"))) != 0)
                        {
                            hv_IndexClass.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_IndexClass = hv_ImageLabelIDs.TupleFind(
                                    hv_CurrentEvalClass);
                            }
                            if ((int)((new HTuple(hv_IndexClass.TupleEqual(-1))).TupleOr(new HTuple(hv_IndexClass.TupleEqual(
                                new HTuple())))) != 0)
                            {
                                throw new HalconException(("The evaluated class ID " + hv_CurrentEvalClass) + " is not represented in the ground truth labels.");
                            }
                        }
                    }
                }
                //
                //Set image IDs, image label IDs, and top1-predictions to of evaluated samples EvaluationResult.
                hv_EvaluatedSamples.Dispose();
                HOperatorSet.CreateDict(out hv_EvaluatedSamples);
                HOperatorSet.SetDictTuple(hv_EvaluatedSamples, "image_ids", hv_ImageIDs);
                HOperatorSet.SetDictTuple(hv_EvaluatedSamples, "image_label_ids", hv_ImageLabelIDs);
                HOperatorSet.SetDictTuple(hv_EvaluatedSamples, "top1_predictions", hv_Predictions);
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "evaluated_samples", hv_EvaluatedSamples);
                //
                //Calculate absolute confusion matrix if needed and set it to EvaluationResult.
                if ((int)(hv_CalcAbsoluteConfusionMatrix) != 0)
                {
                    hv_ConfusionMatrix.Dispose();
                    gen_confusion_matrix(hv_ImageLabelIDs, hv_Predictions, "display_matrix",
                        "none", new HTuple(), out hv_ConfusionMatrix);
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "absolute_confusion_matrix",
                        hv_ConfusionMatrix);
                }
                //
                //Calculate relative confusion matrix.
                if ((int)(hv_CalcRelativeConfusionMatrix) != 0)
                {
                    hv_RelativeConfusionMatrix.Dispose();
                    gen_confusion_matrix(hv_ImageLabelIDs, hv_Predictions, (new HTuple("display_matrix")).TupleConcat(
                        "return_matrix"), (new HTuple("none")).TupleConcat("relative"), new HTuple(),
                        out hv_RelativeConfusionMatrix);
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "relative_confusion_matrix",
                        hv_RelativeConfusionMatrix);
                }
                //
                // Calcuate measures for every class to be evaluated.
                for (hv_EvalIndex = 0; (int)hv_EvalIndex <= (int)((new HTuple(hv_ClassIDsToEvaluate.TupleLength()
                    )) - 1); hv_EvalIndex = (int)hv_EvalIndex + 1)
                {
                    hv_CurrentEvalClass.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentEvalClass = hv_ClassIDsToEvaluate.TupleSelect(
                            hv_EvalIndex);
                    }
                    hv_EvalClassID.Dispose();
                    HOperatorSet.CreateDict(out hv_EvalClassID);
                    //
                    //Calculate top-K errors.
                    for (hv_KIndex = 0; (int)hv_KIndex <= (int)((new HTuple(hv_TopKErrorKs.TupleLength()
                        )) - 1); hv_KIndex = (int)hv_KIndex + 1)
                    {
                        hv_K.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_K = hv_TopKErrorKs.TupleSelect(
                                hv_KIndex);
                        }
                        if ((int)(new HTuple(hv_CurrentEvalClass.TupleEqual("global"))) != 0)
                        {
                            hv_Indices.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Indices = HTuple.TupleGenSequence(
                                    0, (new HTuple(hv_ImageLabelIDs.TupleLength())) - 1, 1);
                            }
                        }
                        else
                        {
                            hv_Indices.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Indices = hv_ImageLabelIDs.TupleFind(
                                    hv_CurrentEvalClass);
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TopKError.Dispose();
                            compute_top_k_error(hv_ImageLabelIDs.TupleSelect(hv_Indices), hv_TopKPredictions.TupleSelect(
                                hv_Indices), hv_K, out hv_TopKError);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_EvalClassID, ("top" + hv_K) + "_error", hv_TopKError);
                        }
                    }
                    //
                    if ((int)(new HTuple(hv_CurrentEvalClass.TupleEqual("global"))) != 0)
                    {
                        //Compute the mean of the measures for all classes.
                        hv_NumClasses.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_NumClasses = new HTuple(hv_ClassIDs.TupleLength()
                                );
                        }
                        hv_IndexClass.Dispose();
                        hv_IndexClass = new HTuple(hv_ClassIDs);
                    }
                    else
                    {
                        //Compute the measures for a certain class.
                        hv_NumClasses.Dispose();
                        hv_NumClasses = 1;
                        hv_IndexClass.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_IndexClass = hv_ClassIDs.TupleFind(
                                hv_CurrentEvalClass);
                        }
                    }
                    //
                    //Calculate prediction.
                    if ((int)(hv_CalcPrecision.TupleOr(hv_CalcFScore)) != 0)
                    {
                        hv_ClassPrecisions.Dispose();
                        hv_ClassPrecisions = new HTuple();
                        hv_MatrixRowSumID.Dispose();
                        HOperatorSet.SumMatrix(hv_ConfusionMatrix, "rows", out hv_MatrixRowSumID);
                        HTuple end_val138 = hv_NumClasses - 1;
                        HTuple step_val138 = 1;
                        for (hv_Index = 0; hv_Index.Continue(end_val138, step_val138); hv_Index = hv_Index.TupleAdd(step_val138))
                        {
                            //Compute the precision for every selected class.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TruePositive.Dispose();
                                HOperatorSet.GetValueMatrix(hv_ConfusionMatrix, hv_IndexClass.TupleSelect(
                                    hv_Index), hv_IndexClass.TupleSelect(hv_Index), out hv_TruePositive);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_SumPredictedClass.Dispose();
                                HOperatorSet.GetValueMatrix(hv_MatrixRowSumID, hv_IndexClass.TupleSelect(
                                    hv_Index), 0, out hv_SumPredictedClass);
                            }
                            if ((int)(new HTuple(hv_SumPredictedClass.TupleEqual(0))) != 0)
                            {
                                hv_ClassPrecision.Dispose();
                                hv_ClassPrecision = 0;
                            }
                            else
                            {
                                hv_ClassPrecision.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ClassPrecision = hv_TruePositive / hv_SumPredictedClass;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ClassPrecisions = hv_ClassPrecisions.TupleConcat(
                                        hv_ClassPrecision);
                                    hv_ClassPrecisions.Dispose();
                                    hv_ClassPrecisions = ExpTmpLocalVar_ClassPrecisions;
                                }
                            }
                        }
                        hv_Precision.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Precision = hv_ClassPrecisions.TupleMean()
                                ;
                        }
                        HOperatorSet.ClearMatrix(hv_MatrixRowSumID);
                        if ((int)(new HTuple(hv_NumClasses.TupleEqual(1))) != 0)
                        {
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "precision", hv_Precision);
                        }
                        else
                        {
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "mean_precision", hv_Precision);
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "precision_per_class", hv_ClassPrecisions);
                        }
                    }
                    //
                    //Calculate recall.
                    if ((int)(hv_CalcRecall.TupleOr(hv_CalcFScore)) != 0)
                    {
                        hv_ClassRecalls.Dispose();
                        hv_ClassRecalls = new HTuple();
                        hv_MatrixColumnSumID.Dispose();
                        HOperatorSet.SumMatrix(hv_ConfusionMatrix, "columns", out hv_MatrixColumnSumID);
                        HTuple end_val163 = hv_NumClasses - 1;
                        HTuple step_val163 = 1;
                        for (hv_Index = 0; hv_Index.Continue(end_val163, step_val163); hv_Index = hv_Index.TupleAdd(step_val163))
                        {
                            //Compute the recall for every class.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TruePositive.Dispose();
                                HOperatorSet.GetValueMatrix(hv_ConfusionMatrix, hv_IndexClass.TupleSelect(
                                    hv_Index), hv_IndexClass.TupleSelect(hv_Index), out hv_TruePositive);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_SumLabel.Dispose();
                                HOperatorSet.GetValueMatrix(hv_MatrixColumnSumID, 0, hv_IndexClass.TupleSelect(
                                    hv_Index), out hv_SumLabel);
                            }
                            hv_ClassRecall.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClassRecall = hv_TruePositive / hv_SumLabel;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ClassRecalls = hv_ClassRecalls.TupleConcat(
                                        hv_ClassRecall);
                                    hv_ClassRecalls.Dispose();
                                    hv_ClassRecalls = ExpTmpLocalVar_ClassRecalls;
                                }
                            }
                        }
                        hv_Recall.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Recall = hv_ClassRecalls.TupleMean()
                                ;
                        }
                        HOperatorSet.ClearMatrix(hv_MatrixColumnSumID);
                        if ((int)(new HTuple(hv_NumClasses.TupleEqual(1))) != 0)
                        {
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "recall", hv_Recall);
                        }
                        else
                        {
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "mean_recall", hv_Recall);
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "recall_per_class", hv_ClassRecalls);
                        }
                    }
                    //
                    //Calculate F-score.
                    if ((int)(hv_CalcFScore) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClassFScores.Dispose();
                            HOperatorSet.TupleGenConst(new HTuple(hv_ClassPrecisions.TupleLength()),
                                0.0, out hv_ClassFScores);
                        }
                        hv_SumPrecisionRecall.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_SumPrecisionRecall = hv_ClassPrecisions + hv_ClassRecalls;
                        }
                        hv_PositiveIndices.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_PositiveIndices = ((hv_SumPrecisionRecall.TupleNotEqualElem(
                                0.0))).TupleFind(1);
                        }
                        if ((int)((new HTuple(hv_PositiveIndices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_PositiveIndices.TupleNotEqual(
                            new HTuple())))) != 0)
                        {
                            if (hv_ClassFScores == null)
                                hv_ClassFScores = new HTuple();
                            hv_ClassFScores[hv_PositiveIndices] = ((2 * (hv_ClassPrecisions.TupleSelect(
                                hv_PositiveIndices))) * (hv_ClassRecalls.TupleSelect(hv_PositiveIndices))) / (hv_SumPrecisionRecall.TupleSelect(
                                hv_PositiveIndices));
                        }
                        hv_FScore.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FScore = hv_ClassFScores.TupleMean()
                                ;
                        }
                        if ((int)(new HTuple(hv_NumClasses.TupleEqual(1))) != 0)
                        {
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "f_score", hv_FScore);
                        }
                        else
                        {
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "mean_f_score", hv_FScore);
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "f_score_per_class", hv_ClassFScores);
                        }
                    }
                    //
                    //Set evaluation results for current class ID.
                    hv_KeyName.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_KeyName = hv_ClassIDsToEvaluate.TupleSelect(
                            hv_EvalIndex);
                    }
                    if ((int)(new HTuple(((hv_ClassIDsToEvaluate.TupleSelect(hv_EvalIndex))).TupleNotEqual(
                        "global"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_KeyName = "class_id_" + hv_KeyName;
                                hv_KeyName.Dispose();
                                hv_KeyName = ExpTmpLocalVar_KeyName;
                            }
                        }
                    }
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, hv_KeyName, hv_EvalClassID);
                }
                //

                hv_TopKErrorKs.Dispose();
                hv_CalcPrecision.Dispose();
                hv_CalcRecall.Dispose();
                hv_CalcFScore.Dispose();
                hv_CalcAbsoluteConfusionMatrix.Dispose();
                hv_CalcRelativeConfusionMatrix.Dispose();
                hv_Measures.Dispose();
                hv_RegExpTopKError.Dispose();
                hv_M.Dispose();
                hv_ComputeTopKError.Dispose();
                hv_K.Dispose();
                hv_ClassIDs.Dispose();
                hv_KeyExists.Dispose();
                hv_ClassesToEvaluate.Dispose();
                hv_ClassIDsToEvaluate.Dispose();
                hv_ClassNames.Dispose();
                hv_Index.Dispose();
                hv_Position.Dispose();
                hv_ImageIDs.Dispose();
                hv_ImageLabelIDs.Dispose();
                hv_Predictions.Dispose();
                hv_TopKPredictions.Dispose();
                hv_EvalIndex.Dispose();
                hv_CurrentEvalClass.Dispose();
                hv_IndexClass.Dispose();
                hv_EvaluatedSamples.Dispose();
                hv_ConfusionMatrix.Dispose();
                hv_RelativeConfusionMatrix.Dispose();
                hv_EvalClassID.Dispose();
                hv_KIndex.Dispose();
                hv_Indices.Dispose();
                hv_TopKError.Dispose();
                hv_NumClasses.Dispose();
                hv_ClassPrecisions.Dispose();
                hv_MatrixRowSumID.Dispose();
                hv_TruePositive.Dispose();
                hv_SumPredictedClass.Dispose();
                hv_ClassPrecision.Dispose();
                hv_Precision.Dispose();
                hv_ClassRecalls.Dispose();
                hv_MatrixColumnSumID.Dispose();
                hv_SumLabel.Dispose();
                hv_ClassRecall.Dispose();
                hv_Recall.Dispose();
                hv_ClassFScores.Dispose();
                hv_SumPrecisionRecall.Dispose();
                hv_PositiveIndices.Dispose();
                hv_FScore.Dispose();
                hv_KeyName.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_TopKErrorKs.Dispose();
                hv_CalcPrecision.Dispose();
                hv_CalcRecall.Dispose();
                hv_CalcFScore.Dispose();
                hv_CalcAbsoluteConfusionMatrix.Dispose();
                hv_CalcRelativeConfusionMatrix.Dispose();
                hv_Measures.Dispose();
                hv_RegExpTopKError.Dispose();
                hv_M.Dispose();
                hv_ComputeTopKError.Dispose();
                hv_K.Dispose();
                hv_ClassIDs.Dispose();
                hv_KeyExists.Dispose();
                hv_ClassesToEvaluate.Dispose();
                hv_ClassIDsToEvaluate.Dispose();
                hv_ClassNames.Dispose();
                hv_Index.Dispose();
                hv_Position.Dispose();
                hv_ImageIDs.Dispose();
                hv_ImageLabelIDs.Dispose();
                hv_Predictions.Dispose();
                hv_TopKPredictions.Dispose();
                hv_EvalIndex.Dispose();
                hv_CurrentEvalClass.Dispose();
                hv_IndexClass.Dispose();
                hv_EvaluatedSamples.Dispose();
                hv_ConfusionMatrix.Dispose();
                hv_RelativeConfusionMatrix.Dispose();
                hv_EvalClassID.Dispose();
                hv_KIndex.Dispose();
                hv_Indices.Dispose();
                hv_TopKError.Dispose();
                hv_NumClasses.Dispose();
                hv_ClassPrecisions.Dispose();
                hv_MatrixRowSumID.Dispose();
                hv_TruePositive.Dispose();
                hv_SumPredictedClass.Dispose();
                hv_ClassPrecision.Dispose();
                hv_Precision.Dispose();
                hv_ClassRecalls.Dispose();
                hv_MatrixColumnSumID.Dispose();
                hv_SumLabel.Dispose();
                hv_ClassRecall.Dispose();
                hv_Recall.Dispose();
                hv_ClassFScores.Dispose();
                hv_SumPrecisionRecall.Dispose();
                hv_PositiveIndices.Dispose();
                hv_FScore.Dispose();
                hv_KeyName.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Calculate instance measures based on RunningMeasures. 
        public void calculate_instance_measures(HTuple hv_RunningMeasures, HTuple hv_EvalParams,
            out HTuple hv_EvaluationResult)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_CalcClassAP = new HTuple(), hv_CalcMeanAP = new HTuple();
            HTuple hv_CalcSoAP = new HTuple(), hv_InstanceType = new HTuple();
            HTuple hv_Measures = new HTuple(), hv_M = new HTuple();
            HTuple hv_ClassIDs = new HTuple(), hv_NumClasses = new HTuple();
            HTuple hv_MaxNumDetections = new HTuple(), hv_AreaRanges = new HTuple();
            HTuple hv_IoUThresholds = new HTuple(), hv_DetailedEvaluation = new HTuple();
            HTuple hv_KeyExists = new HTuple(), hv_AreaNames = new HTuple();
            HTuple hv_MinAreas = new HTuple(), hv_MaxAreas = new HTuple();
            HTuple hv_RecThreshs = new HTuple(), hv_MDIdx = new HTuple();
            HTuple hv_MaxNum = new HTuple(), hv_MaxNumStr = new HTuple();
            HTuple hv_CurrentRunningMeasures = new HTuple(), hv_PerMaxNumEvaluationResult = new HTuple();
            HTuple hv_AreaIdx = new HTuple(), hv_MinArea = new HTuple();
            HTuple hv_MaxArea = new HTuple(), hv_AreaName = new HTuple();
            HTuple hv_AreaRunningMeasures = new HTuple(), hv_PerClassNumGt = new HTuple();
            HTuple hv_PerClassNumPred = new HTuple(), hv_PerClassConfidence = new HTuple();
            HTuple hv_PerClassNumGtIgnore = new HTuple(), hv_CurrentEvaluationResult = new HTuple();
            HTuple hv_ITIdx = new HTuple(), hv_PerIoUAP = new HTuple();
            HTuple hv_PerIoUSoAP = new HTuple(), hv_PerIoUDetailedEvaluation = new HTuple();
            HTuple hv_ClsIdx = new HTuple(), hv_PerClassDetailedEvaluation = new HTuple();
            HTuple hv_DetectionConfusionMatrix = new HTuple(), hv_PerIoUMeasure = new HTuple();
            HTuple hv_NumImgIDsWithFN = new HTuple(), hv_NumImgIDsWithFP = new HTuple();
            HTuple hv_ImgIDsWithFN = new HTuple(), hv_ImgIDsWithFP = new HTuple();
            HTuple hv_ClassMAPDict = new HTuple(), hv_ClassMSoAPDict = new HTuple();
            HTuple hv_ClassesWithGt = new HTuple(), hv_PerClassMAP = new HTuple();
            HTuple hv_PerIoUMAP = new HTuple(), hv_PerClassMSoAP = new HTuple();
            HTuple hv_PerIoUMSoAP = new HTuple(), hv_PerIoUNumClassesWithTP = new HTuple();
            HTuple hv_PerIoUTP = new HTuple(), hv_PerIoUFN = new HTuple();
            HTuple hv_PerIoUFP = new HTuple(), hv_PerIoUFPClass = new HTuple();
            HTuple hv_PerIoUFPBackground = new HTuple(), hv_PerIoUFPLocalization = new HTuple();
            HTuple hv_PerIoUFPDuplicate = new HTuple(), hv_PerIoUFPMultiple = new HTuple();
            HTuple hv_PerIoUSoAPClass = new HTuple(), hv_PerIoUSoAPLocalization = new HTuple();
            HTuple hv_PerIoUSoAPDuplicate = new HTuple(), hv_PerIoUSoAPMultiple = new HTuple();
            HTuple hv_PerIoUNumClassesWithFPClass = new HTuple(), hv_PerIoUNumClassesWithFPLocalization = new HTuple();
            HTuple hv_PerIoUNumClassesWithFPDuplicate = new HTuple();
            HTuple hv_PerIoUNumClassesWithFPMultiple = new HTuple();
            HTuple hv_ClassAPPerIoU = new HTuple(), hv_ClassSoAPPerIoU = new HTuple();
            HTuple hv_NumGt = new HTuple(), hv_NumGtIgnore = new HTuple();
            HTuple hv_NumPred = new HTuple(), hv_Confidences = new HTuple();
            HTuple hv_SortIdxs = new HTuple(), hv_CurrentClassMeasures = new HTuple();
            HTuple hv_IsTP = new HTuple(), hv_Ignore = new HTuple();
            HTuple hv_NoIgnoreIdxs = new HTuple(), hv_IsFP = new HTuple();
            HTuple hv_AccumulatedIsTP = new HTuple(), hv_AccumulatedIsFP = new HTuple();
            HTuple hv_Recall = new HTuple(), hv_Precision = new HTuple();
            HTuple hv_InterpolatedPrecision = new HTuple(), hv_PIdx = new HTuple();
            HTuple hv_PrecisionAtRecThreshs = new HTuple(), hv_RTIdx = new HTuple();
            HTuple hv_RecQuantile = new HTuple(), hv_AOD = new HTuple();
            HTuple hv_IdxsTP = new HTuple(), hv_IsFPClass = new HTuple();
            HTuple hv_IsFPBackground = new HTuple(), hv_IsFPLocalization = new HTuple();
            HTuple hv_IsFPDuplicate = new HTuple(), hv_IsFPMultiple = new HTuple();
            HTuple hv_NumTP = new HTuple(), hv_NumFP = new HTuple();
            HTuple hv_NumFN = new HTuple(), hv_NumFPClass = new HTuple();
            HTuple hv_NumFPBackground = new HTuple(), hv_NumFPLocalization = new HTuple();
            HTuple hv_NumFPDuplicate = new HTuple(), hv_NumFPMultiple = new HTuple();
            HTuple hv_IndicesWithClassConfusion = new HTuple(), hv_IsFPClassIdxs = new HTuple();
            HTuple hv_ClassIdxsConfused = new HTuple(), hv_Idx = new HTuple();
            HTuple hv_NumConfusedThisIdx = new HTuple(), hv_AODClass = new HTuple();
            HTuple hv_IdxsClass = new HTuple(), hv_ResSoAPClass = new HTuple();
            HTuple hv_AODLocalization = new HTuple(), hv_IdxsLocalization = new HTuple();
            HTuple hv_ResSoAPLocalization = new HTuple(), hv_AODDuplicate = new HTuple();
            HTuple hv_IdxsDuplicate = new HTuple(), hv_ResSoAPDuplicate = new HTuple();
            HTuple hv_AODMultiple = new HTuple(), hv_IdxsMultiple = new HTuple();
            HTuple hv_ResSoAPMultiple = new HTuple(), hv_MeanClassAP = new HTuple();
            HTuple hv_MeanClassSoAP = new HTuple(), hv_MAP = new HTuple();
            HTuple hv_MSoAP = new HTuple(), hv_IoUsWithTP = new HTuple();
            HTuple hv_MSoAPAll = new HTuple(), hv_NumSoAPAll = new HTuple();
            HTuple hv_IoUsWithFPClass = new HTuple(), hv_IoUsWithFPLocalization = new HTuple();
            HTuple hv_IoUsWithFPDuplicate = new HTuple(), hv_IoUsWithFPMultiple = new HTuple();
            // Initialize local and output iconic variables 
            hv_EvaluationResult = new HTuple();
            try
            {
                //
                //This procedure calculates the final summarizing instance measures based on the running measures.
                //
                //Set default values.
                hv_CalcClassAP.Dispose();
                hv_CalcClassAP = 0;
                hv_CalcMeanAP.Dispose();
                hv_CalcMeanAP = 0;
                hv_CalcSoAP.Dispose();
                hv_CalcSoAP = 0;
                //Check which measures are to be calculated.
                hv_InstanceType.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "instance_type", out hv_InstanceType);
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                for (hv_M = 0; (int)hv_M <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_M = (int)hv_M + 1)
                {
                    if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual("mean_ap"))) != 0)
                    {
                        hv_CalcMeanAP.Dispose();
                        hv_CalcMeanAP = 1;
                        //As we need to calculate the class APs anyway, we also write them out.
                        hv_CalcClassAP.Dispose();
                        hv_CalcClassAP = 1;
                    }
                    else if ((int)((new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "soap"))).TupleAnd(new HTuple(hv_InstanceType.TupleEqual("rectangle2")))) != 0)
                    {
                        hv_CalcSoAP.Dispose();
                        hv_CalcSoAP = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "all"))) != 0)
                    {
                        hv_CalcClassAP.Dispose();
                        hv_CalcClassAP = 1;
                        hv_CalcMeanAP.Dispose();
                        hv_CalcMeanAP = 1;
                        if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
                        {
                            hv_CalcSoAP.Dispose();
                            hv_CalcSoAP = 1;
                        }
                    }
                    else
                    {
                        throw new HalconException("Unknown Instance Measure: " + (hv_Measures.TupleSelect(
                            hv_M)));
                    }
                }
                //*
                //Dependencies of measures:
                //
                //Recall (per-class)       *                   --> AP per class --> mAP
                //Precision (per-class)  /
                //
                //*
                //Initialize output dictionary and get necessary evaluation parameters.
                hv_EvaluationResult.Dispose();
                HOperatorSet.CreateDict(out hv_EvaluationResult);
                hv_ClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                hv_NumClasses.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
                hv_MaxNumDetections.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "max_num_detections", out hv_MaxNumDetections);
                hv_AreaRanges.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "area_ranges", out hv_AreaRanges);
                hv_IoUThresholds.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "iou_threshold", out hv_IoUThresholds);
                //Check if a detailed evaluation should be done.
                hv_DetailedEvaluation.Dispose();
                hv_DetailedEvaluation = 0;
                hv_KeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "detailed_evaluation",
                    out hv_KeyExists);
                if ((int)(hv_KeyExists.TupleSelect(0)) != 0)
                {
                    hv_DetailedEvaluation.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "detailed_evaluation", out hv_DetailedEvaluation);
                }
                //
                //Get information about area ranges.
                hv_AreaNames.Dispose();
                HOperatorSet.GetDictTuple(hv_AreaRanges, "name", out hv_AreaNames);
                hv_MinAreas.Dispose();
                HOperatorSet.GetDictTuple(hv_AreaRanges, "min", out hv_MinAreas);
                hv_MaxAreas.Dispose();
                HOperatorSet.GetDictTuple(hv_AreaRanges, "max", out hv_MaxAreas);
                //
                //Equidistant thresholds used to approximate the area under the Precision-Recall curve.
                hv_RecThreshs.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RecThreshs = HTuple.TupleGenSequence(
                        0.0, 1.0, 0.01);
                }
                //Start with calculation.
                if ((int)(hv_CalcClassAP.TupleOr(hv_CalcMeanAP)) != 0)
                {
                    //Loop over maximal number of detections.
                    for (hv_MDIdx = 0; (int)hv_MDIdx <= (int)((new HTuple(hv_MaxNumDetections.TupleLength()
                        )) - 1); hv_MDIdx = (int)hv_MDIdx + 1)
                    {
                        //
                        //Get corresponding running measures.
                        hv_MaxNum.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MaxNum = hv_MaxNumDetections.TupleSelect(
                                hv_MDIdx);
                        }
                        hv_MaxNumStr.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MaxNumStr = "" + hv_MaxNum;
                        }
                        if ((int)(new HTuple(hv_MaxNum.TupleEqual(-1))) != 0)
                        {
                            hv_MaxNumStr.Dispose();
                            hv_MaxNumStr = "all";
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentRunningMeasures.Dispose();
                            HOperatorSet.GetDictTuple(hv_RunningMeasures, "max_num_detections_" + hv_MaxNumStr,
                                out hv_CurrentRunningMeasures);
                        }
                        //
                        //Initialize output dictionary.
                        hv_PerMaxNumEvaluationResult.Dispose();
                        HOperatorSet.CreateDict(out hv_PerMaxNumEvaluationResult);
                        //
                        //Loop over area ranges.
                        for (hv_AreaIdx = 0; (int)hv_AreaIdx <= (int)((new HTuple(hv_AreaNames.TupleLength()
                            )) - 1); hv_AreaIdx = (int)hv_AreaIdx + 1)
                        {
                            //Get area thresholds.
                            hv_MinArea.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_MinArea = hv_MinAreas.TupleSelect(
                                    hv_AreaIdx);
                            }
                            hv_MaxArea.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_MaxArea = hv_MaxAreas.TupleSelect(
                                    hv_AreaIdx);
                            }
                            hv_AreaName.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_AreaName = hv_AreaNames.TupleSelect(
                                    hv_AreaIdx);
                            }
                            //
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_AreaRunningMeasures.Dispose();
                                HOperatorSet.GetDictTuple(hv_CurrentRunningMeasures, "area_" + hv_AreaName,
                                    out hv_AreaRunningMeasures);
                            }
                            //
                            hv_PerClassNumGt.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_gt", out hv_PerClassNumGt);
                            hv_PerClassNumPred.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_pred", out hv_PerClassNumPred);
                            hv_PerClassConfidence.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "confidence", out hv_PerClassConfidence);
                            hv_PerClassNumGtIgnore.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_gt_ignore", out hv_PerClassNumGtIgnore);
                            //
                            //Initialize output dictionary.
                            hv_CurrentEvaluationResult.Dispose();
                            HOperatorSet.CreateDict(out hv_CurrentEvaluationResult);
                            for (hv_ITIdx = 0; (int)hv_ITIdx <= (int)((new HTuple(hv_IoUThresholds.TupleLength()
                                )) - 1); hv_ITIdx = (int)hv_ITIdx + 1)
                            {
                                hv_PerIoUAP.Dispose();
                                HOperatorSet.CreateDict(out hv_PerIoUAP);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "ap_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                        hv_ITIdx)))).TupleRegexpReplace("\\.", "")), hv_PerIoUAP);
                                }
                                if ((int)(hv_CalcSoAP) != 0)
                                {
                                    hv_PerIoUSoAP.Dispose();
                                    HOperatorSet.CreateDict(out hv_PerIoUSoAP);
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "soap_tp_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                            hv_ITIdx)))).TupleRegexpReplace("\\.", "")), hv_PerIoUSoAP);
                                    }
                                }
                                if ((int)(hv_DetailedEvaluation) != 0)
                                {
                                    //Initialize detailed measures.
                                    hv_PerIoUDetailedEvaluation.Dispose();
                                    HOperatorSet.CreateDict(out hv_PerIoUDetailedEvaluation);
                                    HTuple end_val97 = hv_NumClasses - 1;
                                    HTuple step_val97 = 1;
                                    for (hv_ClsIdx = 0; hv_ClsIdx.Continue(end_val97, step_val97); hv_ClsIdx = hv_ClsIdx.TupleAdd(step_val97))
                                    {
                                        hv_PerClassDetailedEvaluation.Dispose();
                                        HOperatorSet.CreateDict(out hv_PerClassDetailedEvaluation);
                                        //Initialize with zeros in case there is no ground truth for this class.
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_tp",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fn",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_class",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_background",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_duplicate",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_localization",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_multiple",
                                            0);
                                        if ((int)(hv_CalcSoAP) != 0)
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "soap_fp_class",
                                                -1);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "soap_fp_duplicate",
                                                -1);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "soap_fp_localization",
                                                -1);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "soap_fp_multiple",
                                                -1);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "class_" + (hv_ClassIDs.TupleSelect(
                                                hv_ClsIdx)), hv_PerClassDetailedEvaluation);
                                        }
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_DetectionConfusionMatrix.Dispose();
                                        HOperatorSet.CreateMatrix(hv_NumClasses + 1, hv_NumClasses + 4, 0, out hv_DetectionConfusionMatrix);
                                    }
                                    HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "detection_confusion_matrix",
                                        hv_DetectionConfusionMatrix);
                                    //
                                    //Get and set image IDs with false negatives and false positives.
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUMeasure.Dispose();
                                        HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                            hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUMeasure);
                                    }
                                    //Get image IDs with false negatives and false positives, respectively.
                                    hv_NumImgIDsWithFN.Dispose();
                                    HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_negatives",
                                        out hv_NumImgIDsWithFN);
                                    hv_NumImgIDsWithFP.Dispose();
                                    HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_positives",
                                        out hv_NumImgIDsWithFP);
                                    hv_ImgIDsWithFN.Dispose();
                                    HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_negatives",
                                        out hv_ImgIDsWithFN);
                                    hv_ImgIDsWithFP.Dispose();
                                    HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_positives",
                                        out hv_ImgIDsWithFP);
                                    //Set in current output.
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "image_ids_with_false_negatives",
                                            hv_ImgIDsWithFN.TupleSelectRange(0, hv_NumImgIDsWithFN - 1));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "image_ids_with_false_positives",
                                            hv_ImgIDsWithFP.TupleSelectRange(0, hv_NumImgIDsWithFP - 1));
                                    }
                                    //
                                    //Set output for this IoU.
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "detailed_evaluation_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                            hv_ITIdx)))).TupleRegexpReplace("\\.", "")), hv_PerIoUDetailedEvaluation);
                                    }
                                }
                            }
                            hv_ClassMAPDict.Dispose();
                            HOperatorSet.CreateDict(out hv_ClassMAPDict);
                            HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_iou_ap",
                                hv_ClassMAPDict);
                            if ((int)(hv_CalcSoAP) != 0)
                            {
                                hv_ClassMSoAPDict.Dispose();
                                HOperatorSet.CreateDict(out hv_ClassMSoAPDict);
                                HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_iou_soap_tp",
                                    hv_ClassMSoAPDict);
                            }
                            //
                            //Check which classes have ground truth annotations.
                            hv_ClassesWithGt.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClassesWithGt = ((((hv_PerClassNumGt - hv_PerClassNumGtIgnore)).TupleGreaterElem(
                                    0))).TupleFind(1);
                            }
                            if ((int)(new HTuple(hv_ClassesWithGt.TupleEqual(-1))) != 0)
                            {
                                hv_ClassesWithGt.Dispose();
                                hv_ClassesWithGt = new HTuple();
                            }
                            //
                            //Initialize PerClassMAP, i.e. mean average precision over IoU-thresholds per class.
                            hv_PerClassMAP.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_PerClassMAP = HTuple.TupleGenConst(
                                    hv_NumClasses, -1.0);
                            }
                            //
                            //Initialize PerIoUMAP, i.e. mean average precision over classes per IoU-threshold.
                            hv_PerIoUMAP.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_PerIoUMAP = HTuple.TupleGenConst(
                                    new HTuple(hv_IoUThresholds.TupleLength()), 0.0);
                            }
                            //
                            if ((int)(hv_CalcSoAP) != 0)
                            {
                                //Initialize PerClassMSoAP, i.e. mean SoAP over IoU-thresholds per class.
                                hv_PerClassMSoAP.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerClassMSoAP = HTuple.TupleGenConst(
                                        hv_NumClasses, -1.0);
                                }
                                //Initialize PerIoUMSoAP, i.e. mean SoAP over classes per IoU-threshold.
                                hv_PerIoUMSoAP.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUMSoAP = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0.0);
                                }
                                //Initialize PerIoUNumClassesWithTP to store the class-indices where true positives occured.
                                hv_PerIoUNumClassesWithTP.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUNumClassesWithTP = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                            }
                            //
                            if ((int)(hv_DetailedEvaluation) != 0)
                            {
                                //Initialize overall num_fn, num_tp, ...
                                hv_PerIoUTP.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUTP = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_PerIoUFN.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUFN = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_PerIoUFP.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUFP = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_PerIoUFPClass.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUFPClass = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_PerIoUFPBackground.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUFPBackground = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_PerIoUFPLocalization.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUFPLocalization = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_PerIoUFPDuplicate.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUFPDuplicate = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_PerIoUFPMultiple.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUFPMultiple = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                if ((int)(hv_CalcSoAP) != 0)
                                {
                                    hv_PerIoUSoAPClass.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUSoAPClass = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), -1);
                                    }
                                    hv_PerIoUSoAPLocalization.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUSoAPLocalization = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), -1);
                                    }
                                    hv_PerIoUSoAPDuplicate.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUSoAPDuplicate = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), -1);
                                    }
                                    hv_PerIoUSoAPMultiple.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUSoAPMultiple = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), -1);
                                    }
                                    hv_PerIoUNumClassesWithFPClass.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUNumClassesWithFPClass = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                    }
                                    hv_PerIoUNumClassesWithFPLocalization.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUNumClassesWithFPLocalization = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                    }
                                    hv_PerIoUNumClassesWithFPDuplicate.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUNumClassesWithFPDuplicate = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                    }
                                    hv_PerIoUNumClassesWithFPMultiple.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUNumClassesWithFPMultiple = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                    }
                                }
                            }
                            //Loop over all classes.
                            HTuple end_val184 = hv_NumClasses - 1;
                            HTuple step_val184 = 1;
                            for (hv_ClsIdx = 0; hv_ClsIdx.Continue(end_val184, step_val184); hv_ClsIdx = hv_ClsIdx.TupleAdd(step_val184))
                            {
                                //
                                //Initialize per-class AP per IoU-threshold (only for one class).
                                hv_ClassAPPerIoU.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ClassAPPerIoU = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), -1.0);
                                }
                                //
                                if ((int)(hv_CalcSoAP) != 0)
                                {
                                    hv_ClassSoAPPerIoU.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_ClassSoAPPerIoU = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), -1.0);
                                    }
                                }
                                //Get results for this class.
                                hv_NumGt.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_NumGt = hv_PerClassNumGt.TupleSelect(
                                        hv_ClsIdx);
                                }
                                hv_NumGtIgnore.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_NumGtIgnore = hv_PerClassNumGtIgnore.TupleSelect(
                                        hv_ClsIdx);
                                }
                                if ((int)(new HTuple(((hv_NumGt - hv_NumGtIgnore)).TupleGreater(0))) != 0)
                                {
                                    hv_NumPred.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_NumPred = hv_PerClassNumPred.TupleSelect(
                                            hv_ClsIdx);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Confidences.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerClassConfidence, "class_" + (hv_ClassIDs.TupleSelect(
                                            hv_ClsIdx)), out hv_Confidences);
                                    }
                                    //
                                    //Sort the confidences in descending order and
                                    //only take the first NumPred ones due to block allocation.
                                    hv_SortIdxs.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_SortIdxs = ((-(hv_Confidences.TupleSelectRange(
                                            0, hv_NumPred - 1)))).TupleSortIndex();
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_Confidences = hv_Confidences.TupleSelect(
                                                hv_SortIdxs);
                                            hv_Confidences.Dispose();
                                            hv_Confidences = ExpTmpLocalVar_Confidences;
                                        }
                                    }
                                }
                                //
                                //Loop over IoU thresholds.
                                for (hv_ITIdx = 0; (int)hv_ITIdx <= (int)((new HTuple(hv_IoUThresholds.TupleLength()
                                    )) - 1); hv_ITIdx = (int)hv_ITIdx + 1)
                                {
                                    //
                                    //Check if there are ground truth labels for this class.
                                    if ((int)(new HTuple(((hv_NumGt - hv_NumGtIgnore)).TupleGreater(0))) != 0)
                                    {
                                        //
                                        //Get results for this class and IoU-threshold.
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_PerIoUMeasure.Dispose();
                                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                                hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUMeasure);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_CurrentClassMeasures.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "class_" + (hv_ClassIDs.TupleSelect(
                                                hv_ClsIdx)), out hv_CurrentClassMeasures);
                                        }
                                        hv_IsTP.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_tp", out hv_IsTP);
                                        hv_Ignore.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "ignore", out hv_Ignore);
                                        //
                                        //Sort the arrays IsTP and Ignore according to the confidence values.
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_IsTP = hv_IsTP.TupleSelect(
                                                    hv_SortIdxs);
                                                hv_IsTP.Dispose();
                                                hv_IsTP = ExpTmpLocalVar_IsTP;
                                            }
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_Ignore = hv_Ignore.TupleSelect(
                                                    hv_SortIdxs);
                                                hv_Ignore.Dispose();
                                                hv_Ignore = ExpTmpLocalVar_Ignore;
                                            }
                                        }
                                        //
                                        //Sort out the ignored results.
                                        if ((int)(new HTuple((new HTuple(hv_IsTP.TupleLength())).TupleGreater(
                                            0))) != 0)
                                        {
                                            hv_NoIgnoreIdxs.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_NoIgnoreIdxs = hv_Ignore.TupleFind(
                                                    0);
                                            }
                                            if ((int)(new HTuple(hv_NoIgnoreIdxs.TupleNotEqual(-1))) != 0)
                                            {
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_IsTP = hv_IsTP.TupleSelect(
                                                            hv_NoIgnoreIdxs);
                                                        hv_IsTP.Dispose();
                                                        hv_IsTP = ExpTmpLocalVar_IsTP;
                                                    }
                                                }
                                                hv_IsFP.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_IsFP = hv_IsTP.TupleNot()
                                                        ;
                                                }
                                            }
                                            else
                                            {
                                                hv_IsTP.Dispose();
                                                hv_IsTP = new HTuple();
                                                hv_IsFP.Dispose();
                                                hv_IsFP = new HTuple();
                                            }
                                        }
                                        else
                                        {
                                            hv_IsFP.Dispose();
                                            hv_IsFP = new HTuple();
                                        }
                                        //
                                        //Accumulate IsTP and IsFP.
                                        hv_AccumulatedIsTP.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_AccumulatedIsTP = hv_IsTP.TupleCumul()
                                                ;
                                        }
                                        hv_AccumulatedIsFP.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_AccumulatedIsFP = hv_IsFP.TupleCumul()
                                                ;
                                        }
                                        //
                                        //Compute recall.
                                        //The recall is computed with respect to all ground truth instances,
                                        //independent of MaxNum.
                                        hv_Recall.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_Recall = (hv_AccumulatedIsTP.TupleReal()
                                                ) / (hv_NumGt - hv_NumGtIgnore);
                                        }
                                        //
                                        //Compute precision.
                                        hv_Precision.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_Precision = (hv_AccumulatedIsTP.TupleReal()
                                                ) / (hv_AccumulatedIsTP + hv_AccumulatedIsFP);
                                        }
                                        //
                                        //Smooth precision-curve.
                                        hv_InterpolatedPrecision.Dispose();
                                        hv_InterpolatedPrecision = new HTuple(hv_Precision);
                                        for (hv_PIdx = (new HTuple(hv_NumPred.TupleLength())) - 2; (int)hv_PIdx >= 0; hv_PIdx = (int)hv_PIdx + -1)
                                        {
                                            if (hv_InterpolatedPrecision == null)
                                                hv_InterpolatedPrecision = new HTuple();
                                            hv_InterpolatedPrecision[hv_PIdx] = ((hv_Precision.TupleSelect(
                                                hv_PIdx))).TupleMax2(hv_Precision.TupleSelect(hv_PIdx + 1));
                                        }
                                        //Compute approximated area under the Precision-Recall curve using Recall-Thresholds.
                                        hv_PrecisionAtRecThreshs.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_PrecisionAtRecThreshs = HTuple.TupleGenConst(
                                                new HTuple(hv_RecThreshs.TupleLength()), 0.0);
                                        }
                                        for (hv_RTIdx = 0; (int)hv_RTIdx <= (int)((new HTuple(hv_RecThreshs.TupleLength()
                                            )) - 1); hv_RTIdx = (int)hv_RTIdx + 1)
                                        {
                                            hv_RecQuantile.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_RecQuantile = ((hv_Recall.TupleGreaterEqualElem(
                                                    hv_RecThreshs.TupleSelect(hv_RTIdx)))).TupleFindFirst(1);
                                            }
                                            if ((int)(new HTuple(hv_RecQuantile.TupleGreater(-1))) != 0)
                                            {
                                                if (hv_PrecisionAtRecThreshs == null)
                                                    hv_PrecisionAtRecThreshs = new HTuple();
                                                hv_PrecisionAtRecThreshs[hv_RTIdx] = hv_InterpolatedPrecision.TupleSelect(
                                                    hv_RecQuantile);
                                            }
                                        }
                                        //
                                        //Calculate AP as mean of precision at equidistant recall values.
                                        if (hv_ClassAPPerIoU == null)
                                            hv_ClassAPPerIoU = new HTuple();
                                        hv_ClassAPPerIoU[hv_ITIdx] = hv_PrecisionAtRecThreshs.TupleMean()
                                            ;
                                        //
                                        //Accumulate AP over classes.
                                        if (hv_PerIoUMAP == null)
                                            hv_PerIoUMAP = new HTuple();
                                        hv_PerIoUMAP[hv_ITIdx] = (hv_PerIoUMAP.TupleSelect(hv_ITIdx)) + (hv_ClassAPPerIoU.TupleSelect(
                                            hv_ITIdx));
                                        //
                                        if ((int)(hv_CalcSoAP) != 0)
                                        {
                                            //Calculate SoAP out of the mean over absolute orientation differences.
                                            hv_AOD.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "abs_orientation_diff",
                                                out hv_AOD);
                                            hv_IdxsTP.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_IdxsTP = hv_IsTP.TupleFind(
                                                    1);
                                            }
                                            if ((int)((new HTuple((new HTuple(hv_IdxsTP.TupleLength())).TupleGreater(
                                                0))).TupleAnd(new HTuple(hv_IdxsTP.TupleNotEqual(-1)))) != 0)
                                            {
                                                if (hv_ClassSoAPPerIoU == null)
                                                    hv_ClassSoAPPerIoU = new HTuple();
                                                hv_ClassSoAPPerIoU[hv_ITIdx] = 1.0 - ((((hv_AOD.TupleSelect(hv_SortIdxs.TupleSelect(
                                                    hv_NoIgnoreIdxs.TupleSelect(hv_IdxsTP))))).TupleMean()) / ((new HTuple(180)).TupleRad()
                                                    ));
                                                //Accumulate SoAP over classes.
                                                if (hv_PerIoUMSoAP == null)
                                                    hv_PerIoUMSoAP = new HTuple();
                                                hv_PerIoUMSoAP[hv_ITIdx] = (hv_PerIoUMSoAP.TupleSelect(hv_ITIdx)) + (hv_ClassSoAPPerIoU.TupleSelect(
                                                    hv_ITIdx));
                                            }
                                            //Update PerIoUNumClassesWithTP.
                                            if ((int)(new HTuple((new HTuple(hv_AccumulatedIsTP.TupleLength()
                                                )).TupleGreater(0))) != 0)
                                            {
                                                if (hv_PerIoUNumClassesWithTP == null)
                                                    hv_PerIoUNumClassesWithTP = new HTuple();
                                                hv_PerIoUNumClassesWithTP[hv_ITIdx] = (hv_PerIoUNumClassesWithTP.TupleSelect(
                                                    hv_ITIdx)) + (((hv_AccumulatedIsTP.TupleSelect((new HTuple(hv_AccumulatedIsTP.TupleLength()
                                                    )) - 1))).TupleGreaterElem(0));
                                            }
                                        }
                                        //
                                        if ((int)(hv_DetailedEvaluation) != 0)
                                        {
                                            //Summarize detailed evaluation running measures, set matrix-values and update overall detailed measures.
                                            //
                                            //Get the necessary running measures.
                                            hv_IsFPClass.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_fp_class",
                                                out hv_IsFPClass);
                                            hv_IsFPBackground.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_fp_background",
                                                out hv_IsFPBackground);
                                            hv_IsFPLocalization.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_fp_localization",
                                                out hv_IsFPLocalization);
                                            hv_IsFPDuplicate.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_fp_duplicate",
                                                out hv_IsFPDuplicate);
                                            hv_IsFPMultiple.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_fp_multiple",
                                                out hv_IsFPMultiple);
                                            //
                                            //We use the values with maximal recall,
                                            //in case a higher precision is desired, increase 'min_confidence'.
                                            if ((int)(new HTuple((new HTuple(hv_AccumulatedIsTP.TupleLength()
                                                )).TupleGreater(0))) != 0)
                                            {
                                                hv_NumTP.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_NumTP = hv_AccumulatedIsTP.TupleSelect(
                                                        (new HTuple(hv_AccumulatedIsTP.TupleLength())) - 1);
                                                }
                                            }
                                            else
                                            {
                                                hv_NumTP.Dispose();
                                                hv_NumTP = 0;
                                            }
                                            if ((int)(new HTuple((new HTuple(hv_AccumulatedIsFP.TupleLength()
                                                )).TupleGreater(0))) != 0)
                                            {
                                                hv_NumFP.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_NumFP = hv_AccumulatedIsFP.TupleSelect(
                                                        (new HTuple(hv_AccumulatedIsFP.TupleLength())) - 1);
                                                }
                                            }
                                            else
                                            {
                                                hv_NumFP.Dispose();
                                                hv_NumFP = 0;
                                            }
                                            hv_NumFN.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_NumFN = (hv_NumGt - hv_NumGtIgnore) - hv_NumTP;
                                            }
                                            hv_NumFPClass.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_NumFPClass = ((((hv_IsFPClass.TupleSelect(
                                                    hv_SortIdxs))).TupleGreaterElem(-1))).TupleSum();
                                            }
                                            hv_NumFPBackground.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_NumFPBackground = ((((hv_IsFPBackground.TupleSelect(
                                                    hv_SortIdxs))).TupleGreaterElem(0))).TupleSum();
                                            }
                                            hv_NumFPLocalization.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_NumFPLocalization = ((((hv_IsFPLocalization.TupleSelect(
                                                    hv_SortIdxs))).TupleGreaterElem(0))).TupleSum();
                                            }
                                            hv_NumFPDuplicate.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_NumFPDuplicate = ((((hv_IsFPDuplicate.TupleSelect(
                                                    hv_SortIdxs))).TupleGreaterElem(0))).TupleSum();
                                            }
                                            hv_NumFPMultiple.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_NumFPMultiple = ((((hv_IsFPMultiple.TupleSelect(
                                                    hv_SortIdxs))).TupleGreaterElem(0))).TupleSum();
                                            }
                                            if ((int)(new HTuple((new HTuple(hv_SortIdxs.TupleLength())).TupleEqual(
                                                0))) != 0)
                                            {
                                                hv_NumFPClass.Dispose();
                                                hv_NumFPClass = 0;
                                                hv_NumFPBackground.Dispose();
                                                hv_NumFPBackground = 0;
                                                hv_NumFPLocalization.Dispose();
                                                hv_NumFPLocalization = 0;
                                                hv_NumFPDuplicate.Dispose();
                                                hv_NumFPDuplicate = 0;
                                                hv_NumFPMultiple.Dispose();
                                                hv_NumFPMultiple = 0;
                                            }
                                            //Consistency checks.
                                            if ((int)(new HTuple(((((((((((((((((hv_NumTP.TupleConcat(hv_NumFN))).TupleConcat(
                                                hv_NumFP))).TupleConcat(hv_NumFPClass))).TupleConcat(hv_NumFPBackground))).TupleConcat(
                                                hv_NumFPLocalization))).TupleConcat(hv_NumFPDuplicate))).TupleConcat(
                                                hv_NumFPMultiple))).TupleMin())).TupleLess(0))) != 0)
                                            {
                                                throw new HalconException("Fatal error while calculating instance measures.");
                                            }
                                            if ((int)(new HTuple(hv_NumFP.TupleNotEqual((((hv_NumFPClass + hv_NumFPBackground) + hv_NumFPLocalization) + hv_NumFPDuplicate) + hv_NumFPMultiple))) != 0)
                                            {
                                                throw new HalconException("Fatal error while calculating instance measures.");
                                            }
                                            //
                                            //Set per-class measures.
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_PerIoUDetailedEvaluation.Dispose();
                                                HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "detailed_evaluation_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                                    hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUDetailedEvaluation);
                                            }
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_PerClassDetailedEvaluation.Dispose();
                                                HOperatorSet.GetDictTuple(hv_PerIoUDetailedEvaluation, "class_" + (hv_ClassIDs.TupleSelect(
                                                    hv_ClsIdx)), out hv_PerClassDetailedEvaluation);
                                            }
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_tp",
                                                hv_NumTP);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fn",
                                                hv_NumFN);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp",
                                                hv_NumFP);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_class",
                                                hv_NumFPClass);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_background",
                                                hv_NumFPBackground);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_duplicate",
                                                hv_NumFPDuplicate);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_localization",
                                                hv_NumFPLocalization);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_multiple",
                                                hv_NumFPMultiple);
                                            //
                                            //Set detection confusion matrix values.
                                            hv_DetectionConfusionMatrix.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerIoUDetailedEvaluation, "detection_confusion_matrix",
                                                out hv_DetectionConfusionMatrix);
                                            HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx,
                                                hv_ClsIdx, hv_NumTP);
                                            HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_NumClasses,
                                                hv_ClsIdx, hv_NumFN);
                                            HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx,
                                                hv_NumClasses, hv_NumFPBackground);
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx,
                                                    hv_NumClasses + 1, hv_NumFPLocalization);
                                            }
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx,
                                                    hv_NumClasses + 2, hv_NumFPDuplicate);
                                            }
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx,
                                                    hv_NumClasses + 3, hv_NumFPMultiple);
                                            }
                                            //
                                            //Go over IsFPClass and set confusions in matrix.
                                            hv_IndicesWithClassConfusion.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_IndicesWithClassConfusion = ((((hv_IsFPClass.TupleSelect(
                                                    hv_SortIdxs))).TupleGreaterElem(-1))).TupleFind(1);
                                            }
                                            hv_IsFPClassIdxs.Dispose();
                                            hv_IsFPClassIdxs = new HTuple();
                                            if ((int)(new HTuple(hv_IndicesWithClassConfusion.TupleGreater(
                                                -1))) != 0)
                                            {
                                                hv_IsFPClassIdxs.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_IsFPClassIdxs = hv_IsFPClass.TupleSelect(
                                                        hv_SortIdxs.TupleSelect(hv_IndicesWithClassConfusion));
                                                }
                                            }
                                            hv_ClassIdxsConfused.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ClassIdxsConfused = ((hv_IsFPClassIdxs.TupleSort()
                                                    )).TupleUniq();
                                            }
                                            for (hv_Idx = 0; (int)hv_Idx <= (int)((new HTuple(hv_ClassIdxsConfused.TupleLength()
                                                )) - 1); hv_Idx = (int)hv_Idx + 1)
                                            {
                                                hv_NumConfusedThisIdx.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_NumConfusedThisIdx = ((((hv_IsFPClassIdxs.TupleFind(
                                                        hv_ClassIdxsConfused.TupleSelect(hv_Idx)))).TupleGreaterElem(
                                                        -1))).TupleSum();
                                                }
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx,
                                                        hv_ClassIdxsConfused.TupleSelect(hv_Idx), hv_NumConfusedThisIdx);
                                                }
                                            }
                                            //
                                            //Update overall measures.
                                            if (hv_PerIoUFN == null)
                                                hv_PerIoUFN = new HTuple();
                                            hv_PerIoUFN[hv_ITIdx] = (hv_PerIoUFN.TupleSelect(hv_ITIdx)) + hv_NumFN;
                                            if (hv_PerIoUTP == null)
                                                hv_PerIoUTP = new HTuple();
                                            hv_PerIoUTP[hv_ITIdx] = (hv_PerIoUTP.TupleSelect(hv_ITIdx)) + hv_NumTP;
                                            if (hv_PerIoUFP == null)
                                                hv_PerIoUFP = new HTuple();
                                            hv_PerIoUFP[hv_ITIdx] = (hv_PerIoUFP.TupleSelect(hv_ITIdx)) + hv_NumFP;
                                            if (hv_PerIoUFPClass == null)
                                                hv_PerIoUFPClass = new HTuple();
                                            hv_PerIoUFPClass[hv_ITIdx] = (hv_PerIoUFPClass.TupleSelect(hv_ITIdx)) + hv_NumFPClass;
                                            if (hv_PerIoUFPBackground == null)
                                                hv_PerIoUFPBackground = new HTuple();
                                            hv_PerIoUFPBackground[hv_ITIdx] = (hv_PerIoUFPBackground.TupleSelect(
                                                hv_ITIdx)) + hv_NumFPBackground;
                                            if (hv_PerIoUFPLocalization == null)
                                                hv_PerIoUFPLocalization = new HTuple();
                                            hv_PerIoUFPLocalization[hv_ITIdx] = (hv_PerIoUFPLocalization.TupleSelect(
                                                hv_ITIdx)) + hv_NumFPLocalization;
                                            if (hv_PerIoUFPDuplicate == null)
                                                hv_PerIoUFPDuplicate = new HTuple();
                                            hv_PerIoUFPDuplicate[hv_ITIdx] = (hv_PerIoUFPDuplicate.TupleSelect(
                                                hv_ITIdx)) + hv_NumFPDuplicate;
                                            if (hv_PerIoUFPMultiple == null)
                                                hv_PerIoUFPMultiple = new HTuple();
                                            hv_PerIoUFPMultiple[hv_ITIdx] = (hv_PerIoUFPMultiple.TupleSelect(
                                                hv_ITIdx)) + hv_NumFPMultiple;
                                            if ((int)(hv_CalcSoAP) != 0)
                                            {
                                                //Calculate and update absolute difference of orientation for class false positives.
                                                hv_AODClass.Dispose();
                                                HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "abs_orientation_diff_class",
                                                    out hv_AODClass);
                                                hv_IdxsClass.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_IdxsClass = ((hv_AODClass.TupleGreaterElem(
                                                        -1))).TupleFind(1);
                                                }
                                                if ((int)(new HTuple(hv_IdxsClass.TupleNotEqual(-1))) != 0)
                                                {
                                                    hv_ResSoAPClass.Dispose();
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        hv_ResSoAPClass = 1.0 - ((((hv_AODClass.TupleSelect(
                                                            hv_IdxsClass))).TupleMean()) / ((new HTuple(180)).TupleRad()
                                                            ));
                                                    }
                                                    HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation,
                                                        "soap_fp_class", hv_ResSoAPClass);
                                                    //Update mean over classes.
                                                    if (hv_PerIoUNumClassesWithFPClass == null)
                                                        hv_PerIoUNumClassesWithFPClass = new HTuple();
                                                    hv_PerIoUNumClassesWithFPClass[hv_ITIdx] = (hv_PerIoUNumClassesWithFPClass.TupleSelect(
                                                        hv_ITIdx)) + 1;
                                                    if ((int)(new HTuple(((hv_PerIoUSoAPClass.TupleSelect(hv_ITIdx))).TupleEqual(
                                                        -1))) != 0)
                                                    {
                                                        if (hv_PerIoUSoAPClass == null)
                                                            hv_PerIoUSoAPClass = new HTuple();
                                                        hv_PerIoUSoAPClass[hv_ITIdx] = hv_ResSoAPClass;
                                                    }
                                                    else
                                                    {
                                                        if (hv_PerIoUSoAPClass == null)
                                                            hv_PerIoUSoAPClass = new HTuple();
                                                        hv_PerIoUSoAPClass[hv_ITIdx] = (hv_PerIoUSoAPClass.TupleSelect(
                                                            hv_ITIdx)) + hv_ResSoAPClass;
                                                    }
                                                }
                                                //Calculate and update absolute difference of orientation for localization false positives.
                                                hv_AODLocalization.Dispose();
                                                HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "abs_orientation_diff_localization",
                                                    out hv_AODLocalization);
                                                hv_IdxsLocalization.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_IdxsLocalization = ((hv_AODLocalization.TupleGreaterElem(
                                                        -1))).TupleFind(1);
                                                }
                                                if ((int)(new HTuple(hv_IdxsLocalization.TupleNotEqual(-1))) != 0)
                                                {
                                                    hv_ResSoAPLocalization.Dispose();
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        hv_ResSoAPLocalization = 1.0 - ((((hv_AODLocalization.TupleSelect(
                                                            hv_IdxsLocalization))).TupleMean()) / ((new HTuple(180)).TupleRad()
                                                            ));
                                                    }
                                                    HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation,
                                                        "soap_fp_localization", hv_ResSoAPLocalization);
                                                    //Update mean over classes.
                                                    if (hv_PerIoUNumClassesWithFPLocalization == null)
                                                        hv_PerIoUNumClassesWithFPLocalization = new HTuple();
                                                    hv_PerIoUNumClassesWithFPLocalization[hv_ITIdx] = (hv_PerIoUNumClassesWithFPLocalization.TupleSelect(
                                                        hv_ITIdx)) + 1;
                                                    if ((int)(new HTuple(((hv_PerIoUSoAPLocalization.TupleSelect(
                                                        hv_ITIdx))).TupleEqual(-1))) != 0)
                                                    {
                                                        if (hv_PerIoUSoAPLocalization == null)
                                                            hv_PerIoUSoAPLocalization = new HTuple();
                                                        hv_PerIoUSoAPLocalization[hv_ITIdx] = hv_ResSoAPLocalization;
                                                    }
                                                    else
                                                    {
                                                        if (hv_PerIoUSoAPLocalization == null)
                                                            hv_PerIoUSoAPLocalization = new HTuple();
                                                        hv_PerIoUSoAPLocalization[hv_ITIdx] = (hv_PerIoUSoAPLocalization.TupleSelect(
                                                            hv_ITIdx)) + hv_ResSoAPLocalization;
                                                    }
                                                }
                                                //Calculate and update absolute difference of orientation for class false positives.
                                                hv_AODDuplicate.Dispose();
                                                HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "abs_orientation_diff_duplicate",
                                                    out hv_AODDuplicate);
                                                hv_IdxsDuplicate.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_IdxsDuplicate = ((hv_AODDuplicate.TupleGreaterElem(
                                                        -1))).TupleFind(1);
                                                }
                                                if ((int)(new HTuple(hv_IdxsDuplicate.TupleNotEqual(-1))) != 0)
                                                {
                                                    hv_ResSoAPDuplicate.Dispose();
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        hv_ResSoAPDuplicate = 1.0 - ((((hv_AODDuplicate.TupleSelect(
                                                            hv_IdxsDuplicate))).TupleMean()) / ((new HTuple(180)).TupleRad()
                                                            ));
                                                    }
                                                    HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation,
                                                        "soap_fp_duplicate", hv_ResSoAPDuplicate);
                                                    //Update mean over classes.
                                                    if (hv_PerIoUNumClassesWithFPDuplicate == null)
                                                        hv_PerIoUNumClassesWithFPDuplicate = new HTuple();
                                                    hv_PerIoUNumClassesWithFPDuplicate[hv_ITIdx] = (hv_PerIoUNumClassesWithFPDuplicate.TupleSelect(
                                                        hv_ITIdx)) + 1;
                                                    if ((int)(new HTuple(((hv_PerIoUSoAPDuplicate.TupleSelect(
                                                        hv_ITIdx))).TupleEqual(-1))) != 0)
                                                    {
                                                        if (hv_PerIoUSoAPDuplicate == null)
                                                            hv_PerIoUSoAPDuplicate = new HTuple();
                                                        hv_PerIoUSoAPDuplicate[hv_ITIdx] = hv_ResSoAPDuplicate;
                                                    }
                                                    else
                                                    {
                                                        if (hv_PerIoUSoAPDuplicate == null)
                                                            hv_PerIoUSoAPDuplicate = new HTuple();
                                                        hv_PerIoUSoAPDuplicate[hv_ITIdx] = (hv_PerIoUSoAPDuplicate.TupleSelect(
                                                            hv_ITIdx)) + hv_ResSoAPDuplicate;
                                                    }
                                                }
                                                //Calculate and update absolute difference of orientation for multiple false positives.
                                                hv_AODMultiple.Dispose();
                                                HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "abs_orientation_diff_multiple",
                                                    out hv_AODMultiple);
                                                hv_IdxsMultiple.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_IdxsMultiple = ((hv_AODMultiple.TupleGreaterElem(
                                                        -1))).TupleFind(1);
                                                }
                                                if ((int)(new HTuple(hv_IdxsMultiple.TupleNotEqual(-1))) != 0)
                                                {
                                                    hv_ResSoAPMultiple.Dispose();
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        hv_ResSoAPMultiple = 1.0 - ((((hv_AODMultiple.TupleSelect(
                                                            hv_IdxsMultiple))).TupleMean()) / ((new HTuple(180)).TupleRad()
                                                            ));
                                                    }
                                                    HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation,
                                                        "soap_fp_multiple", hv_ResSoAPMultiple);
                                                    //Update mean over classes.
                                                    if (hv_PerIoUNumClassesWithFPMultiple == null)
                                                        hv_PerIoUNumClassesWithFPMultiple = new HTuple();
                                                    hv_PerIoUNumClassesWithFPMultiple[hv_ITIdx] = (hv_PerIoUNumClassesWithFPMultiple.TupleSelect(
                                                        hv_ITIdx)) + 1;
                                                    if ((int)(new HTuple(((hv_PerIoUSoAPMultiple.TupleSelect(
                                                        hv_ITIdx))).TupleEqual(-1))) != 0)
                                                    {
                                                        if (hv_PerIoUSoAPMultiple == null)
                                                            hv_PerIoUSoAPMultiple = new HTuple();
                                                        hv_PerIoUSoAPMultiple[hv_ITIdx] = hv_ResSoAPMultiple;
                                                    }
                                                    else
                                                    {
                                                        if (hv_PerIoUSoAPMultiple == null)
                                                            hv_PerIoUSoAPMultiple = new HTuple();
                                                        hv_PerIoUSoAPMultiple[hv_ITIdx] = (hv_PerIoUSoAPMultiple.TupleSelect(
                                                            hv_ITIdx)) + hv_ResSoAPMultiple;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    //
                                    //Write to output.
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUAP.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "ap_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                            hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUAP);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUAP, "class_" + (hv_ClassIDs.TupleSelect(
                                            hv_ClsIdx)), hv_ClassAPPerIoU.TupleSelect(hv_ITIdx));
                                    }
                                    if ((int)(hv_CalcSoAP) != 0)
                                    {
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_PerIoUSoAP.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "soap_tp_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                                hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUSoAP);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUSoAP, "class_" + (hv_ClassIDs.TupleSelect(
                                                hv_ClsIdx)), hv_ClassSoAPPerIoU.TupleSelect(hv_ITIdx));
                                        }
                                    }
                                }
                                //
                                //Class mAP is the mean over IoU-thresholds.
                                if (hv_PerClassMAP == null)
                                    hv_PerClassMAP = new HTuple();
                                hv_PerClassMAP[hv_ClsIdx] = hv_ClassAPPerIoU.TupleMean();
                                hv_ClassMAPDict.Dispose();
                                HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "mean_iou_ap",
                                    out hv_ClassMAPDict);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_ClassMAPDict, "class_" + (hv_ClassIDs.TupleSelect(
                                        hv_ClsIdx)), hv_PerClassMAP.TupleSelect(hv_ClsIdx));
                                }
                                if ((int)(hv_CalcSoAP) != 0)
                                {
                                    //ClassMSoAP is the mean over IoU-thresholds.
                                    if (hv_PerClassMSoAP == null)
                                        hv_PerClassMSoAP = new HTuple();
                                    hv_PerClassMSoAP[hv_ClsIdx] = hv_ClassSoAPPerIoU.TupleMean();
                                    hv_ClassMSoAPDict.Dispose();
                                    HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "mean_iou_soap_tp",
                                        out hv_ClassMSoAPDict);
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_ClassMSoAPDict, "class_" + (hv_ClassIDs.TupleSelect(
                                            hv_ClsIdx)), hv_PerClassMSoAP.TupleSelect(hv_ClsIdx));
                                    }
                                }
                            }
                            //
                            //Calculate the mean AP and optionally mean SoAP (over classes) per IoU-threshold.
                            for (hv_ITIdx = 0; (int)hv_ITIdx <= (int)((new HTuple(hv_IoUThresholds.TupleLength()
                                )) - 1); hv_ITIdx = (int)hv_ITIdx + 1)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUAP.Dispose();
                                    HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "ap_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                        hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUAP);
                                }
                                //
                                //Consider only present classes.
                                hv_MeanClassAP.Dispose();
                                hv_MeanClassAP = -1.0;
                                if ((int)(new HTuple((new HTuple(hv_ClassesWithGt.TupleLength())).TupleGreater(
                                    0))) != 0)
                                {
                                    hv_MeanClassAP.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_MeanClassAP = (hv_PerIoUMAP.TupleSelect(
                                            hv_ITIdx)) / (new HTuple(hv_ClassesWithGt.TupleLength()));
                                    }
                                }
                                HOperatorSet.SetDictTuple(hv_PerIoUAP, "mean_class_ap", hv_MeanClassAP);
                                if ((int)(hv_CalcSoAP) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUSoAP.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "soap_tp_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                            hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUSoAP);
                                    }
                                    //
                                    //Consider only present classes.
                                    hv_MeanClassSoAP.Dispose();
                                    hv_MeanClassSoAP = -1.0;
                                    if ((int)(new HTuple(((hv_PerIoUNumClassesWithTP.TupleSelect(hv_ITIdx))).TupleGreater(
                                        0))) != 0)
                                    {
                                        hv_MeanClassSoAP.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_MeanClassSoAP = (hv_PerIoUMSoAP.TupleSelect(
                                                hv_ITIdx)) / (hv_PerIoUNumClassesWithTP.TupleSelect(hv_ITIdx));
                                        }
                                    }
                                    HOperatorSet.SetDictTuple(hv_PerIoUSoAP, "mean_class_soap_tp", hv_MeanClassSoAP);
                                }
                                //
                                if ((int)(hv_DetailedEvaluation) != 0)
                                {
                                    //Add overall measures for TP, FN, FP, ...
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUDetailedEvaluation.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "detailed_evaluation_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                            hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUDetailedEvaluation);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_tp",
                                            hv_PerIoUTP.TupleSelect(hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fn",
                                            hv_PerIoUFN.TupleSelect(hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp",
                                            hv_PerIoUFP.TupleSelect(hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_class",
                                            hv_PerIoUFPClass.TupleSelect(hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_background",
                                            hv_PerIoUFPBackground.TupleSelect(hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_duplicate",
                                            hv_PerIoUFPDuplicate.TupleSelect(hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_localization",
                                            hv_PerIoUFPLocalization.TupleSelect(hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_multiple",
                                            hv_PerIoUFPMultiple.TupleSelect(hv_ITIdx));
                                    }
                                    if ((int)(hv_CalcSoAP) != 0)
                                    {
                                        if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPClass.TupleSelect(
                                            hv_ITIdx))).TupleGreater(0))) != 0)
                                        {
                                            if (hv_PerIoUSoAPClass == null)
                                                hv_PerIoUSoAPClass = new HTuple();
                                            hv_PerIoUSoAPClass[hv_ITIdx] = (hv_PerIoUSoAPClass.TupleSelect(
                                                hv_ITIdx)) / (hv_PerIoUNumClassesWithFPClass.TupleSelect(hv_ITIdx));
                                        }
                                        if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPLocalization.TupleSelect(
                                            hv_ITIdx))).TupleGreater(0))) != 0)
                                        {
                                            if (hv_PerIoUSoAPLocalization == null)
                                                hv_PerIoUSoAPLocalization = new HTuple();
                                            hv_PerIoUSoAPLocalization[hv_ITIdx] = (hv_PerIoUSoAPLocalization.TupleSelect(
                                                hv_ITIdx)) / (hv_PerIoUNumClassesWithFPLocalization.TupleSelect(
                                                hv_ITIdx));
                                        }
                                        if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPDuplicate.TupleSelect(
                                            hv_ITIdx))).TupleGreater(0))) != 0)
                                        {
                                            if (hv_PerIoUSoAPDuplicate == null)
                                                hv_PerIoUSoAPDuplicate = new HTuple();
                                            hv_PerIoUSoAPDuplicate[hv_ITIdx] = (hv_PerIoUSoAPDuplicate.TupleSelect(
                                                hv_ITIdx)) / (hv_PerIoUNumClassesWithFPDuplicate.TupleSelect(
                                                hv_ITIdx));
                                        }
                                        if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPMultiple.TupleSelect(
                                            hv_ITIdx))).TupleGreater(0))) != 0)
                                        {
                                            if (hv_PerIoUSoAPMultiple == null)
                                                hv_PerIoUSoAPMultiple = new HTuple();
                                            hv_PerIoUSoAPMultiple[hv_ITIdx] = (hv_PerIoUSoAPMultiple.TupleSelect(
                                                hv_ITIdx)) / (hv_PerIoUNumClassesWithFPMultiple.TupleSelect(
                                                hv_ITIdx));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "soap_fp_class",
                                                hv_PerIoUSoAPClass.TupleSelect(hv_ITIdx));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "soap_fp_localization",
                                                hv_PerIoUSoAPLocalization.TupleSelect(hv_ITIdx));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "soap_fp_duplicate",
                                                hv_PerIoUSoAPDuplicate.TupleSelect(hv_ITIdx));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "soap_fp_multiple",
                                                hv_PerIoUSoAPMultiple.TupleSelect(hv_ITIdx));
                                        }
                                    }
                                }
                            }
                            //
                            //Calculate overall mean AP (over classes and IoU-thresholds).
                            //Also here only classes with ground truth annotations are taken into account.
                            hv_MAP.Dispose();
                            hv_MAP = -1.0;
                            if ((int)(new HTuple((new HTuple(hv_ClassesWithGt.TupleLength())).TupleGreater(
                                0))) != 0)
                            {
                                hv_MAP.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_MAP = (((hv_PerClassMAP.TupleSelect(
                                        hv_ClassesWithGt))).TupleSum()) / (new HTuple(hv_ClassesWithGt.TupleLength()
                                        ));
                                }
                            }
                            HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_ap", hv_MAP);
                            if ((int)(hv_CalcSoAP) != 0)
                            {
                                hv_MSoAP.Dispose();
                                hv_MSoAP = -1.0;
                                if ((int)(new HTuple(((hv_PerIoUNumClassesWithTP.TupleSum())).TupleGreater(
                                    0))) != 0)
                                {
                                    hv_IoUsWithTP.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_IoUsWithTP = ((hv_PerIoUNumClassesWithTP.TupleGreaterElem(
                                            0))).TupleFind(1);
                                    }
                                    hv_MSoAP.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_MSoAP = ((((hv_PerIoUMSoAP.TupleSelect(
                                            hv_IoUsWithTP)) / (hv_PerIoUNumClassesWithTP.TupleSelect(hv_IoUsWithTP)))).TupleSum()
                                            ) / (new HTuple(hv_IoUsWithTP.TupleLength()));
                                    }
                                }
                                HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_soap_tp",
                                    hv_MSoAP);
                                if ((int)(hv_DetailedEvaluation) != 0)
                                {
                                    hv_MSoAPAll.Dispose();
                                    hv_MSoAPAll = 0.0;
                                    hv_NumSoAPAll.Dispose();
                                    hv_NumSoAPAll = 0;
                                    if ((int)(new HTuple(((hv_PerIoUNumClassesWithTP.TupleSum())).TupleGreater(
                                        0))) != 0)
                                    {
                                        hv_IoUsWithTP.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_IoUsWithTP = ((hv_PerIoUNumClassesWithTP.TupleGreaterElem(
                                                0))).TupleFind(1);
                                        }
                                        hv_MSoAPAll.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_MSoAPAll = hv_MSoAP * (((hv_PerIoUNumClassesWithTP.TupleSelect(
                                                hv_IoUsWithTP))).TupleSum());
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_NumSoAPAll = hv_NumSoAPAll + (((hv_PerIoUNumClassesWithTP.TupleSelect(
                                                    hv_IoUsWithTP))).TupleSum());
                                                hv_NumSoAPAll.Dispose();
                                                hv_NumSoAPAll = ExpTmpLocalVar_NumSoAPAll;
                                            }
                                        }
                                    }
                                    if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPClass.TupleSum())).TupleGreater(
                                        0))) != 0)
                                    {
                                        hv_IoUsWithFPClass.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_IoUsWithFPClass = ((hv_PerIoUNumClassesWithFPClass.TupleGreaterElem(
                                                0))).TupleFind(1);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_MSoAPAll = hv_MSoAPAll + (((((hv_PerIoUSoAPClass.TupleSelect(
                                                    hv_IoUsWithFPClass))).TupleSum()) / (new HTuple(hv_IoUsWithFPClass.TupleLength()
                                                    ))) * (((hv_PerIoUNumClassesWithFPClass.TupleSelect(hv_IoUsWithFPClass))).TupleSum()
                                                    ));
                                                hv_MSoAPAll.Dispose();
                                                hv_MSoAPAll = ExpTmpLocalVar_MSoAPAll;
                                            }
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_NumSoAPAll = hv_NumSoAPAll + (((hv_PerIoUNumClassesWithFPClass.TupleSelect(
                                                    hv_IoUsWithFPClass))).TupleSum());
                                                hv_NumSoAPAll.Dispose();
                                                hv_NumSoAPAll = ExpTmpLocalVar_NumSoAPAll;
                                            }
                                        }
                                    }
                                    if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPLocalization.TupleSum()
                                        )).TupleGreater(0))) != 0)
                                    {
                                        hv_IoUsWithFPLocalization.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_IoUsWithFPLocalization = ((hv_PerIoUNumClassesWithFPLocalization.TupleGreaterElem(
                                                0))).TupleFind(1);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_MSoAPAll = hv_MSoAPAll + (((((hv_PerIoUSoAPLocalization.TupleSelect(
                                                    hv_IoUsWithFPLocalization))).TupleSum()) / (new HTuple(hv_IoUsWithFPLocalization.TupleLength()
                                                    ))) * (((hv_PerIoUNumClassesWithFPLocalization.TupleSelect(hv_IoUsWithFPLocalization))).TupleSum()
                                                    ));
                                                hv_MSoAPAll.Dispose();
                                                hv_MSoAPAll = ExpTmpLocalVar_MSoAPAll;
                                            }
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_NumSoAPAll = hv_NumSoAPAll + (((hv_PerIoUNumClassesWithFPLocalization.TupleSelect(
                                                    hv_IoUsWithFPLocalization))).TupleSum());
                                                hv_NumSoAPAll.Dispose();
                                                hv_NumSoAPAll = ExpTmpLocalVar_NumSoAPAll;
                                            }
                                        }
                                    }
                                    if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPDuplicate.TupleSum()
                                        )).TupleGreater(0))) != 0)
                                    {
                                        hv_IoUsWithFPDuplicate.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_IoUsWithFPDuplicate = ((hv_PerIoUNumClassesWithFPDuplicate.TupleGreaterElem(
                                                0))).TupleFind(1);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_MSoAPAll = hv_MSoAPAll + (((((hv_PerIoUSoAPDuplicate.TupleSelect(
                                                    hv_IoUsWithFPDuplicate))).TupleSum()) / (new HTuple(hv_IoUsWithFPDuplicate.TupleLength()
                                                    ))) * (((hv_PerIoUNumClassesWithFPDuplicate.TupleSelect(hv_IoUsWithFPDuplicate))).TupleSum()
                                                    ));
                                                hv_MSoAPAll.Dispose();
                                                hv_MSoAPAll = ExpTmpLocalVar_MSoAPAll;
                                            }
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_NumSoAPAll = hv_NumSoAPAll + (((hv_PerIoUNumClassesWithFPDuplicate.TupleSelect(
                                                    hv_IoUsWithFPDuplicate))).TupleSum());
                                                hv_NumSoAPAll.Dispose();
                                                hv_NumSoAPAll = ExpTmpLocalVar_NumSoAPAll;
                                            }
                                        }
                                    }
                                    if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPMultiple.TupleSum()
                                        )).TupleGreater(0))) != 0)
                                    {
                                        hv_IoUsWithFPMultiple.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_IoUsWithFPMultiple = ((hv_PerIoUNumClassesWithFPMultiple.TupleGreaterElem(
                                                0))).TupleFind(1);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_MSoAPAll = hv_MSoAPAll + (((((hv_PerIoUSoAPMultiple.TupleSelect(
                                                    hv_IoUsWithFPMultiple))).TupleSum()) / (new HTuple(hv_IoUsWithFPMultiple.TupleLength()
                                                    ))) * (((hv_PerIoUNumClassesWithFPMultiple.TupleSelect(hv_IoUsWithFPMultiple))).TupleSum()
                                                    ));
                                                hv_MSoAPAll.Dispose();
                                                hv_MSoAPAll = ExpTmpLocalVar_MSoAPAll;
                                            }
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_NumSoAPAll = hv_NumSoAPAll + (((hv_PerIoUNumClassesWithFPMultiple.TupleSelect(
                                                    hv_IoUsWithFPMultiple))).TupleSum());
                                                hv_NumSoAPAll.Dispose();
                                                hv_NumSoAPAll = ExpTmpLocalVar_NumSoAPAll;
                                            }
                                        }
                                    }
                                    if ((int)(new HTuple(hv_NumSoAPAll.TupleGreater(0))) != 0)
                                    {
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_soap_all",
                                                (hv_MSoAPAll.TupleReal()) / hv_NumSoAPAll);
                                        }
                                    }
                                    else
                                    {
                                        HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_soap_all",
                                            -1);
                                    }

                                }
                            }
                            //
                            //Add CurrentEvaluationResult to output.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_PerMaxNumEvaluationResult, "area_" + hv_AreaName,
                                    hv_CurrentEvaluationResult);
                            }
                        }
                        //Add PerMaxNumEvaluationResult to output.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_EvaluationResult, "max_num_detections_" + hv_MaxNumStr,
                                hv_PerMaxNumEvaluationResult);
                        }
                    }
                }
                //

                hv_CalcClassAP.Dispose();
                hv_CalcMeanAP.Dispose();
                hv_CalcSoAP.Dispose();
                hv_InstanceType.Dispose();
                hv_Measures.Dispose();
                hv_M.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClasses.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_IoUThresholds.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_KeyExists.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_RecThreshs.Dispose();
                hv_MDIdx.Dispose();
                hv_MaxNum.Dispose();
                hv_MaxNumStr.Dispose();
                hv_CurrentRunningMeasures.Dispose();
                hv_PerMaxNumEvaluationResult.Dispose();
                hv_AreaIdx.Dispose();
                hv_MinArea.Dispose();
                hv_MaxArea.Dispose();
                hv_AreaName.Dispose();
                hv_AreaRunningMeasures.Dispose();
                hv_PerClassNumGt.Dispose();
                hv_PerClassNumPred.Dispose();
                hv_PerClassConfidence.Dispose();
                hv_PerClassNumGtIgnore.Dispose();
                hv_CurrentEvaluationResult.Dispose();
                hv_ITIdx.Dispose();
                hv_PerIoUAP.Dispose();
                hv_PerIoUSoAP.Dispose();
                hv_PerIoUDetailedEvaluation.Dispose();
                hv_ClsIdx.Dispose();
                hv_PerClassDetailedEvaluation.Dispose();
                hv_DetectionConfusionMatrix.Dispose();
                hv_PerIoUMeasure.Dispose();
                hv_NumImgIDsWithFN.Dispose();
                hv_NumImgIDsWithFP.Dispose();
                hv_ImgIDsWithFN.Dispose();
                hv_ImgIDsWithFP.Dispose();
                hv_ClassMAPDict.Dispose();
                hv_ClassMSoAPDict.Dispose();
                hv_ClassesWithGt.Dispose();
                hv_PerClassMAP.Dispose();
                hv_PerIoUMAP.Dispose();
                hv_PerClassMSoAP.Dispose();
                hv_PerIoUMSoAP.Dispose();
                hv_PerIoUNumClassesWithTP.Dispose();
                hv_PerIoUTP.Dispose();
                hv_PerIoUFN.Dispose();
                hv_PerIoUFP.Dispose();
                hv_PerIoUFPClass.Dispose();
                hv_PerIoUFPBackground.Dispose();
                hv_PerIoUFPLocalization.Dispose();
                hv_PerIoUFPDuplicate.Dispose();
                hv_PerIoUFPMultiple.Dispose();
                hv_PerIoUSoAPClass.Dispose();
                hv_PerIoUSoAPLocalization.Dispose();
                hv_PerIoUSoAPDuplicate.Dispose();
                hv_PerIoUSoAPMultiple.Dispose();
                hv_PerIoUNumClassesWithFPClass.Dispose();
                hv_PerIoUNumClassesWithFPLocalization.Dispose();
                hv_PerIoUNumClassesWithFPDuplicate.Dispose();
                hv_PerIoUNumClassesWithFPMultiple.Dispose();
                hv_ClassAPPerIoU.Dispose();
                hv_ClassSoAPPerIoU.Dispose();
                hv_NumGt.Dispose();
                hv_NumGtIgnore.Dispose();
                hv_NumPred.Dispose();
                hv_Confidences.Dispose();
                hv_SortIdxs.Dispose();
                hv_CurrentClassMeasures.Dispose();
                hv_IsTP.Dispose();
                hv_Ignore.Dispose();
                hv_NoIgnoreIdxs.Dispose();
                hv_IsFP.Dispose();
                hv_AccumulatedIsTP.Dispose();
                hv_AccumulatedIsFP.Dispose();
                hv_Recall.Dispose();
                hv_Precision.Dispose();
                hv_InterpolatedPrecision.Dispose();
                hv_PIdx.Dispose();
                hv_PrecisionAtRecThreshs.Dispose();
                hv_RTIdx.Dispose();
                hv_RecQuantile.Dispose();
                hv_AOD.Dispose();
                hv_IdxsTP.Dispose();
                hv_IsFPClass.Dispose();
                hv_IsFPBackground.Dispose();
                hv_IsFPLocalization.Dispose();
                hv_IsFPDuplicate.Dispose();
                hv_IsFPMultiple.Dispose();
                hv_NumTP.Dispose();
                hv_NumFP.Dispose();
                hv_NumFN.Dispose();
                hv_NumFPClass.Dispose();
                hv_NumFPBackground.Dispose();
                hv_NumFPLocalization.Dispose();
                hv_NumFPDuplicate.Dispose();
                hv_NumFPMultiple.Dispose();
                hv_IndicesWithClassConfusion.Dispose();
                hv_IsFPClassIdxs.Dispose();
                hv_ClassIdxsConfused.Dispose();
                hv_Idx.Dispose();
                hv_NumConfusedThisIdx.Dispose();
                hv_AODClass.Dispose();
                hv_IdxsClass.Dispose();
                hv_ResSoAPClass.Dispose();
                hv_AODLocalization.Dispose();
                hv_IdxsLocalization.Dispose();
                hv_ResSoAPLocalization.Dispose();
                hv_AODDuplicate.Dispose();
                hv_IdxsDuplicate.Dispose();
                hv_ResSoAPDuplicate.Dispose();
                hv_AODMultiple.Dispose();
                hv_IdxsMultiple.Dispose();
                hv_ResSoAPMultiple.Dispose();
                hv_MeanClassAP.Dispose();
                hv_MeanClassSoAP.Dispose();
                hv_MAP.Dispose();
                hv_MSoAP.Dispose();
                hv_IoUsWithTP.Dispose();
                hv_MSoAPAll.Dispose();
                hv_NumSoAPAll.Dispose();
                hv_IoUsWithFPClass.Dispose();
                hv_IoUsWithFPLocalization.Dispose();
                hv_IoUsWithFPDuplicate.Dispose();
                hv_IoUsWithFPMultiple.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_CalcClassAP.Dispose();
                hv_CalcMeanAP.Dispose();
                hv_CalcSoAP.Dispose();
                hv_InstanceType.Dispose();
                hv_Measures.Dispose();
                hv_M.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClasses.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_IoUThresholds.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_KeyExists.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_RecThreshs.Dispose();
                hv_MDIdx.Dispose();
                hv_MaxNum.Dispose();
                hv_MaxNumStr.Dispose();
                hv_CurrentRunningMeasures.Dispose();
                hv_PerMaxNumEvaluationResult.Dispose();
                hv_AreaIdx.Dispose();
                hv_MinArea.Dispose();
                hv_MaxArea.Dispose();
                hv_AreaName.Dispose();
                hv_AreaRunningMeasures.Dispose();
                hv_PerClassNumGt.Dispose();
                hv_PerClassNumPred.Dispose();
                hv_PerClassConfidence.Dispose();
                hv_PerClassNumGtIgnore.Dispose();
                hv_CurrentEvaluationResult.Dispose();
                hv_ITIdx.Dispose();
                hv_PerIoUAP.Dispose();
                hv_PerIoUSoAP.Dispose();
                hv_PerIoUDetailedEvaluation.Dispose();
                hv_ClsIdx.Dispose();
                hv_PerClassDetailedEvaluation.Dispose();
                hv_DetectionConfusionMatrix.Dispose();
                hv_PerIoUMeasure.Dispose();
                hv_NumImgIDsWithFN.Dispose();
                hv_NumImgIDsWithFP.Dispose();
                hv_ImgIDsWithFN.Dispose();
                hv_ImgIDsWithFP.Dispose();
                hv_ClassMAPDict.Dispose();
                hv_ClassMSoAPDict.Dispose();
                hv_ClassesWithGt.Dispose();
                hv_PerClassMAP.Dispose();
                hv_PerIoUMAP.Dispose();
                hv_PerClassMSoAP.Dispose();
                hv_PerIoUMSoAP.Dispose();
                hv_PerIoUNumClassesWithTP.Dispose();
                hv_PerIoUTP.Dispose();
                hv_PerIoUFN.Dispose();
                hv_PerIoUFP.Dispose();
                hv_PerIoUFPClass.Dispose();
                hv_PerIoUFPBackground.Dispose();
                hv_PerIoUFPLocalization.Dispose();
                hv_PerIoUFPDuplicate.Dispose();
                hv_PerIoUFPMultiple.Dispose();
                hv_PerIoUSoAPClass.Dispose();
                hv_PerIoUSoAPLocalization.Dispose();
                hv_PerIoUSoAPDuplicate.Dispose();
                hv_PerIoUSoAPMultiple.Dispose();
                hv_PerIoUNumClassesWithFPClass.Dispose();
                hv_PerIoUNumClassesWithFPLocalization.Dispose();
                hv_PerIoUNumClassesWithFPDuplicate.Dispose();
                hv_PerIoUNumClassesWithFPMultiple.Dispose();
                hv_ClassAPPerIoU.Dispose();
                hv_ClassSoAPPerIoU.Dispose();
                hv_NumGt.Dispose();
                hv_NumGtIgnore.Dispose();
                hv_NumPred.Dispose();
                hv_Confidences.Dispose();
                hv_SortIdxs.Dispose();
                hv_CurrentClassMeasures.Dispose();
                hv_IsTP.Dispose();
                hv_Ignore.Dispose();
                hv_NoIgnoreIdxs.Dispose();
                hv_IsFP.Dispose();
                hv_AccumulatedIsTP.Dispose();
                hv_AccumulatedIsFP.Dispose();
                hv_Recall.Dispose();
                hv_Precision.Dispose();
                hv_InterpolatedPrecision.Dispose();
                hv_PIdx.Dispose();
                hv_PrecisionAtRecThreshs.Dispose();
                hv_RTIdx.Dispose();
                hv_RecQuantile.Dispose();
                hv_AOD.Dispose();
                hv_IdxsTP.Dispose();
                hv_IsFPClass.Dispose();
                hv_IsFPBackground.Dispose();
                hv_IsFPLocalization.Dispose();
                hv_IsFPDuplicate.Dispose();
                hv_IsFPMultiple.Dispose();
                hv_NumTP.Dispose();
                hv_NumFP.Dispose();
                hv_NumFN.Dispose();
                hv_NumFPClass.Dispose();
                hv_NumFPBackground.Dispose();
                hv_NumFPLocalization.Dispose();
                hv_NumFPDuplicate.Dispose();
                hv_NumFPMultiple.Dispose();
                hv_IndicesWithClassConfusion.Dispose();
                hv_IsFPClassIdxs.Dispose();
                hv_ClassIdxsConfused.Dispose();
                hv_Idx.Dispose();
                hv_NumConfusedThisIdx.Dispose();
                hv_AODClass.Dispose();
                hv_IdxsClass.Dispose();
                hv_ResSoAPClass.Dispose();
                hv_AODLocalization.Dispose();
                hv_IdxsLocalization.Dispose();
                hv_ResSoAPLocalization.Dispose();
                hv_AODDuplicate.Dispose();
                hv_IdxsDuplicate.Dispose();
                hv_ResSoAPDuplicate.Dispose();
                hv_AODMultiple.Dispose();
                hv_IdxsMultiple.Dispose();
                hv_ResSoAPMultiple.Dispose();
                hv_MeanClassAP.Dispose();
                hv_MeanClassSoAP.Dispose();
                hv_MAP.Dispose();
                hv_MSoAP.Dispose();
                hv_IoUsWithTP.Dispose();
                hv_MSoAPAll.Dispose();
                hv_NumSoAPAll.Dispose();
                hv_IoUsWithFPClass.Dispose();
                hv_IoUsWithFPLocalization.Dispose();
                hv_IoUsWithFPDuplicate.Dispose();
                hv_IoUsWithFPMultiple.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Calculate pixel measures based on RunningMeasures. 
        public void calculate_pixel_measures(HTuple hv_RunningMeasures, HTuple hv_EvalParams,
            out HTuple hv_EvaluationResult)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_CalcClassPixelAccuracy = new HTuple();
            HTuple hv_CalcPixelAccuracy = new HTuple(), hv_CalcPixelConfusionMatrix = new HTuple();
            HTuple hv_CalcMeanAccuracy = new HTuple(), hv_CalcMeanIou = new HTuple();
            HTuple hv_CalcClassIou = new HTuple(), hv_CalcFWIou = new HTuple();
            HTuple hv_Measures = new HTuple(), hv_M = new HTuple();
            HTuple hv_ConfMatrix = new HTuple(), hv_TPMat = new HTuple();
            HTuple hv_TP = new HTuple(), hv_SumRowMat = new HTuple();
            HTuple hv_RowSum = new HTuple(), hv_FP = new HTuple();
            HTuple hv_SumColMat = new HTuple(), hv_ColSum = new HTuple();
            HTuple hv_FN = new HTuple(), hv_IgnoreClassIDs = new HTuple();
            HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
            HTuple hv_FPIgnore = new HTuple(), hv_GT = new HTuple();
            HTuple hv_ClsIdxValid = new HTuple(), hv_ClassPixelAccuracy = new HTuple();
            HTuple hv_MeanAccuracy = new HTuple(), hv_PixelAccuracy = new HTuple();
            HTuple hv_ClassIoU = new HTuple(), hv_MeanIoU = new HTuple();
            HTuple hv_FWIoU = new HTuple(), hv_FwWeights = new HTuple();
            // Initialize local and output iconic variables 
            hv_EvaluationResult = new HTuple();
            try
            {
                //
                //This procedure calculates the pixel-wise measures based on the values in running measures.
                //
                //Set default values.
                hv_CalcClassPixelAccuracy.Dispose();
                hv_CalcClassPixelAccuracy = 0;
                hv_CalcPixelAccuracy.Dispose();
                hv_CalcPixelAccuracy = 0;
                hv_CalcPixelConfusionMatrix.Dispose();
                hv_CalcPixelConfusionMatrix = 0;
                hv_CalcMeanAccuracy.Dispose();
                hv_CalcMeanAccuracy = 0;
                hv_CalcMeanIou.Dispose();
                hv_CalcMeanIou = 0;
                hv_CalcClassIou.Dispose();
                hv_CalcClassIou = 0;
                hv_CalcFWIou.Dispose();
                hv_CalcFWIou = 0;
                //Check which measures are to be calculated.
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                hv_EvaluationResult.Dispose();
                HOperatorSet.CreateDict(out hv_EvaluationResult);
                for (hv_M = 0; (int)hv_M <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_M = (int)hv_M + 1)
                {
                    if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual("pixel_accuracy"))) != 0)
                    {
                        hv_CalcPixelAccuracy.Dispose();
                        hv_CalcPixelAccuracy = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "class_pixel_accuracy"))) != 0)
                    {
                        hv_CalcClassPixelAccuracy.Dispose();
                        hv_CalcClassPixelAccuracy = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "pixel_confusion_matrix"))) != 0)
                    {
                        hv_CalcPixelConfusionMatrix.Dispose();
                        hv_CalcPixelConfusionMatrix = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "mean_accuracy"))) != 0)
                    {
                        hv_CalcMeanAccuracy.Dispose();
                        hv_CalcMeanAccuracy = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "mean_iou"))) != 0)
                    {
                        hv_CalcMeanIou.Dispose();
                        hv_CalcMeanIou = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "class_iou"))) != 0)
                    {
                        hv_CalcClassIou.Dispose();
                        hv_CalcClassIou = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "frequency_weighted_iou"))) != 0)
                    {
                        hv_CalcFWIou.Dispose();
                        hv_CalcFWIou = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "all"))) != 0)
                    {
                        hv_CalcPixelAccuracy.Dispose();
                        hv_CalcPixelAccuracy = 1;
                        hv_CalcClassPixelAccuracy.Dispose();
                        hv_CalcClassPixelAccuracy = 1;
                        hv_CalcPixelConfusionMatrix.Dispose();
                        hv_CalcPixelConfusionMatrix = 1;
                        hv_CalcMeanAccuracy.Dispose();
                        hv_CalcMeanAccuracy = 1;
                        hv_CalcMeanIou.Dispose();
                        hv_CalcMeanIou = 1;
                        hv_CalcClassIou.Dispose();
                        hv_CalcClassIou = 1;
                        hv_CalcFWIou.Dispose();
                        hv_CalcFWIou = 1;
                    }
                    else
                    {
                        throw new HalconException("Unknown Segmentation Measure: " + (hv_Measures.TupleSelect(
                            hv_M)));
                    }
                }
                //
                //Depending on the running measure values (ConfusionMatrix or TP/FP/FN),
                //we first calculate TP/FP/FN from the ConfusionMatrix.
                if ((int)(hv_CalcPixelConfusionMatrix) != 0)
                {
                    //Get the running measures.
                    hv_ConfMatrix.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "pixel_confusion_matrix", out hv_ConfMatrix);
                    //Get the per-class true positives as the diagonal of the matrix.
                    hv_TPMat.Dispose();
                    HOperatorSet.GetDiagonalMatrix(hv_ConfMatrix, 0, out hv_TPMat);
                    hv_TP.Dispose();
                    HOperatorSet.GetFullMatrix(hv_TPMat, out hv_TP);
                    //For the confusion matrix, the row determines the predicted class-IDs,
                    //the column determines the ground truth class-IDs.
                    //Get the per-class false positives (FP) as the sum over the rows minus the diagonal (TP).
                    hv_SumRowMat.Dispose();
                    HOperatorSet.SumMatrix(hv_ConfMatrix, "rows", out hv_SumRowMat);
                    hv_RowSum.Dispose();
                    HOperatorSet.GetFullMatrix(hv_SumRowMat, out hv_RowSum);
                    hv_FP.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_FP = hv_RowSum - hv_TP;
                    }
                    //Get the per-class false negatives (FN) as the sum over the columns minus the diagonal (TP).
                    hv_SumColMat.Dispose();
                    HOperatorSet.SumMatrix(hv_ConfMatrix, "columns", out hv_SumColMat);
                    hv_ColSum.Dispose();
                    HOperatorSet.GetFullMatrix(hv_SumColMat, out hv_ColSum);
                    hv_FN.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_FN = hv_ColSum - hv_TP;
                    }
                    //We do not want to count the false positives (FP) in the ignore region.
                    //The false negatives (FN) are not affected, since the model does not predict the ignore class.
                    hv_IgnoreClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "ignore_class_ids", out hv_IgnoreClassIDs);
                    if ((int)(new HTuple((new HTuple(hv_IgnoreClassIDs.TupleLength())).TupleGreater(
                        0))) != 0)
                    {
                        //The ignore class corresponds to the last row/column in the confusion matrix.
                        hv_Rows.Dispose(); hv_Columns.Dispose();
                        HOperatorSet.GetSizeMatrix(hv_ConfMatrix, out hv_Rows, out hv_Columns);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FPIgnore.Dispose();
                            HOperatorSet.GetValueMatrix(hv_ConfMatrix, HTuple.TupleGenSequence(0, hv_Rows - 1, 1),
                                HTuple.TupleGenConst(hv_Rows, hv_Columns - 1), out hv_FPIgnore);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_FP = hv_FP - hv_FPIgnore;
                                hv_FP.Dispose();
                                hv_FP = ExpTmpLocalVar_FP;
                            }
                        }
                        //Remove last entries of TP, FP, FN (those related to the ignore class).
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_TP = hv_TP.TupleSelectRange(
                                    0, (new HTuple(hv_TP.TupleLength())) - 2);
                                hv_TP.Dispose();
                                hv_TP = ExpTmpLocalVar_TP;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_FP = hv_FP.TupleSelectRange(
                                    0, (new HTuple(hv_FP.TupleLength())) - 2);
                                hv_FP.Dispose();
                                hv_FP = ExpTmpLocalVar_FP;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_FN = hv_FN.TupleSelectRange(
                                    0, (new HTuple(hv_FN.TupleLength())) - 2);
                                hv_FN.Dispose();
                                hv_FN = ExpTmpLocalVar_FN;
                            }
                        }
                        //Remove last row/column from confusion matrix.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HTuple ExpTmpOutVar_0;
                            HOperatorSet.GetSubMatrix(hv_ConfMatrix, 0, 0, hv_Rows - 1, hv_Columns - 1,
                                out ExpTmpOutVar_0);
                            hv_ConfMatrix.Dispose();
                            hv_ConfMatrix = ExpTmpOutVar_0;
                        }
                    }
                    //Paste the confusion matrix to the output.
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "pixel_confusion_matrix",
                        hv_ConfMatrix);
                }
                else
                {
                    //Get the running measure values.
                    hv_TP.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "tp", out hv_TP);
                    hv_FP.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "fp", out hv_FP);
                    hv_FN.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "fn", out hv_FN);
                }
                //
                //It might be the case, that some of the classes are not present in the set of validation images.
                //--> Exclude these classes (they are indirectly present as they reduce the number of TP for other classes).
                hv_GT.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_GT = hv_TP + hv_FN;
                }
                hv_ClsIdxValid.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ClsIdxValid = ((hv_GT.TupleGreaterElem(
                        0))).TupleFind(1);
                }
                //
                //Mean Accuracy, Class Pixel Accuracy.
                //-> If one of 'mean_accuracy', 'class_pixel_accuracy' is specified, we give back both of them
                //   as they have to be calculated anyway (to the most part).
                if ((int)(hv_CalcClassPixelAccuracy.TupleOr(hv_CalcMeanAccuracy)) != 0)
                {
                    //Compute pixel accuracy per class (although we might only use it for the overall pixel accuracy).
                    hv_ClassPixelAccuracy.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassPixelAccuracy = HTuple.TupleGenConst(
                            new HTuple(hv_GT.TupleLength()), -1);
                    }
                    hv_MeanAccuracy.Dispose();
                    hv_MeanAccuracy = -1;
                    if ((int)(new HTuple(((hv_ClsIdxValid.TupleSelect(0))).TupleGreater(-1))) != 0)
                    {
                        if (hv_ClassPixelAccuracy == null)
                            hv_ClassPixelAccuracy = new HTuple();
                        hv_ClassPixelAccuracy[hv_ClsIdxValid] = (((hv_TP.TupleSelect(hv_ClsIdxValid))).TupleReal()
                            ) / (hv_GT.TupleSelect(hv_ClsIdxValid));
                        hv_MeanAccuracy.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MeanAccuracy = ((hv_ClassPixelAccuracy.TupleSelect(
                                hv_ClsIdxValid))).TupleMean();
                        }
                    }
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "class_pixel_accuracy", hv_ClassPixelAccuracy);
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "mean_accuracy", hv_MeanAccuracy);
                }
                //Pixel Accuracy
                if ((int)(hv_CalcPixelAccuracy) != 0)
                {
                    //Compute pixel accuracy as the total ratio of pixels that have been correctly predicted.
                    hv_PixelAccuracy.Dispose();
                    hv_PixelAccuracy = -1;
                    if ((int)(new HTuple(((hv_ClsIdxValid.TupleSelect(0))).TupleGreater(-1))) != 0)
                    {
                        hv_PixelAccuracy.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_PixelAccuracy = (((((hv_TP.TupleSelect(
                                hv_ClsIdxValid))).TupleSum())).TupleReal()) / (((hv_GT.TupleSelect(hv_ClsIdxValid))).TupleSum()
                                );
                        }
                    }
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "pixel_accuracy", hv_PixelAccuracy);
                }
                //Mean IoU, class IoU, frequency weighted IoU:
                //-> If the measures 'class_iou', 'mean_iou' or 'frequency_weighted_iou' is specified,
                //   we return all three of them as they have to be calculated anyway (to the most part).
                if ((int)((new HTuple(hv_CalcMeanIou.TupleOr(hv_CalcClassIou))).TupleOr(hv_CalcFWIou)) != 0)
                {
                    hv_ClassIoU.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassIoU = HTuple.TupleGenConst(
                            new HTuple(hv_GT.TupleLength()), -1);
                    }
                    hv_MeanIoU.Dispose();
                    hv_MeanIoU = -1;
                    hv_FWIoU.Dispose();
                    hv_FWIoU = -1;
                    if ((int)(new HTuple(((hv_ClsIdxValid.TupleSelect(0))).TupleGreater(-1))) != 0)
                    {
                        if (hv_ClassIoU == null)
                            hv_ClassIoU = new HTuple();
                        hv_ClassIoU[hv_ClsIdxValid] = (((hv_TP.TupleSelect(hv_ClsIdxValid))).TupleReal()
                            ) / ((hv_GT.TupleSelect(hv_ClsIdxValid)) + (hv_FP.TupleSelect(hv_ClsIdxValid)));
                        hv_MeanIoU.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MeanIoU = ((hv_ClassIoU.TupleSelect(
                                hv_ClsIdxValid))).TupleMean();
                        }
                        hv_FwWeights.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FwWeights = (hv_GT.TupleReal()
                                ) / (hv_GT.TupleSum());
                        }
                        hv_FWIoU.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FWIoU = (((hv_FwWeights.TupleSelect(
                                hv_ClsIdxValid)) * (hv_ClassIoU.TupleSelect(hv_ClsIdxValid)))).TupleSum()
                                ;
                        }
                    }
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "class_iou", hv_ClassIoU);
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "mean_iou", hv_MeanIoU);
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "frequency_weighted_iou",
                        hv_FWIoU);
                }
                //

                hv_CalcClassPixelAccuracy.Dispose();
                hv_CalcPixelAccuracy.Dispose();
                hv_CalcPixelConfusionMatrix.Dispose();
                hv_CalcMeanAccuracy.Dispose();
                hv_CalcMeanIou.Dispose();
                hv_CalcClassIou.Dispose();
                hv_CalcFWIou.Dispose();
                hv_Measures.Dispose();
                hv_M.Dispose();
                hv_ConfMatrix.Dispose();
                hv_TPMat.Dispose();
                hv_TP.Dispose();
                hv_SumRowMat.Dispose();
                hv_RowSum.Dispose();
                hv_FP.Dispose();
                hv_SumColMat.Dispose();
                hv_ColSum.Dispose();
                hv_FN.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_FPIgnore.Dispose();
                hv_GT.Dispose();
                hv_ClsIdxValid.Dispose();
                hv_ClassPixelAccuracy.Dispose();
                hv_MeanAccuracy.Dispose();
                hv_PixelAccuracy.Dispose();
                hv_ClassIoU.Dispose();
                hv_MeanIoU.Dispose();
                hv_FWIoU.Dispose();
                hv_FwWeights.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_CalcClassPixelAccuracy.Dispose();
                hv_CalcPixelAccuracy.Dispose();
                hv_CalcPixelConfusionMatrix.Dispose();
                hv_CalcMeanAccuracy.Dispose();
                hv_CalcMeanIou.Dispose();
                hv_CalcClassIou.Dispose();
                hv_CalcFWIou.Dispose();
                hv_Measures.Dispose();
                hv_M.Dispose();
                hv_ConfMatrix.Dispose();
                hv_TPMat.Dispose();
                hv_TP.Dispose();
                hv_SumRowMat.Dispose();
                hv_RowSum.Dispose();
                hv_FP.Dispose();
                hv_SumColMat.Dispose();
                hv_ColSum.Dispose();
                hv_FN.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_FPIgnore.Dispose();
                hv_GT.Dispose();
                hv_ClsIdxValid.Dispose();
                hv_ClassPixelAccuracy.Dispose();
                hv_MeanAccuracy.Dispose();
                hv_PixelAccuracy.Dispose();
                hv_ClassIoU.Dispose();
                hv_MeanIoU.Dispose();
                hv_FWIoU.Dispose();
                hv_FwWeights.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Classification
        // Short Description: Calculate top-K error. 
        public void compute_top_k_error(HTuple hv_ImageLabelIDs, HTuple hv_TopKPredictions,
            HTuple hv_K, out HTuple hv_TopKError)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_NumMatches = new HTuple(), hv_Index = new HTuple();
            HTuple hv_Predictions = new HTuple(), hv_PredictedClasses = new HTuple();
            // Initialize local and output iconic variables 
            hv_TopKError = new HTuple();
            try
            {
                //
                //This procedure calculates the top-K error out of the given predictions and labels.
                //
                hv_NumMatches.Dispose();
                hv_NumMatches = 0;
                //
                //Loop through all selected ground truth labels.
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_ImageLabelIDs.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    //Get the K best results.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Predictions.Dispose();
                        HOperatorSet.GetDictTuple(hv_TopKPredictions.TupleSelect(hv_Index), "predictions",
                            out hv_Predictions);
                    }
                    hv_PredictedClasses.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_PredictedClasses = hv_Predictions.TupleSelectRange(
                            0, hv_K - 1);
                    }
                    //Count how often the ground truth label
                    //and K predicted classes match.
                    if ((int)(new HTuple(((hv_PredictedClasses.TupleFind(hv_ImageLabelIDs.TupleSelect(
                        hv_Index)))).TupleNotEqual(-1))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_NumMatches = hv_NumMatches + 1;
                                hv_NumMatches.Dispose();
                                hv_NumMatches = ExpTmpLocalVar_NumMatches;
                            }
                        }
                    }
                }
                hv_TopKError.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TopKError = 1.0 - ((hv_NumMatches.TupleReal()
                        ) / (new HTuple(hv_ImageLabelIDs.TupleLength())));
                }
                //

                hv_NumMatches.Dispose();
                hv_Index.Dispose();
                hv_Predictions.Dispose();
                hv_PredictedClasses.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_NumMatches.Dispose();
                hv_Index.Dispose();
                hv_Predictions.Dispose();
                hv_PredictedClasses.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Generate a dictionary EvalParams, which contains default values for evaluation parameters. 
        public void create_evaluation_default_param(HTuple hv_EvaluationType, HTuple hv_ClassIDsModel,
            out HTuple hv_EvalParams)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_AvailableEvaluationTypes = new HTuple();
            HTuple hv_EvaluationTypesStr = new HTuple(), hv_Indices = new HTuple();
            HTuple hv_EvaluateInstances = new HTuple(), hv_Measures = new HTuple();
            HTuple hv_AnomalyScoreHistogram = new HTuple(), hv_AreaRanges = new HTuple();
            HTuple hv_AllocationBlockLength = new HTuple();
            // Initialize local and output iconic variables 
            hv_EvalParams = new HTuple();
            try
            {
                //
                //This procedure generates a dictionary EvalParams,
                //which contains default values for evaluation parameters.
                //Depending on the evaluation type, the corresponding default parameters and values are set.
                //The class IDs that the model can predict must be given via ClassIDsModel.
                //
                //Check inputs.
                hv_AvailableEvaluationTypes.Dispose();
                hv_AvailableEvaluationTypes = new HTuple();
                hv_AvailableEvaluationTypes[0] = "anomaly_detection";
                hv_AvailableEvaluationTypes[1] = "classification";
                hv_AvailableEvaluationTypes[2] = "detection";
                hv_AvailableEvaluationTypes[3] = "segmentation";
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_EvaluationTypesStr.Dispose();
                    HOperatorSet.TupleGenConst((2 * (new HTuple(hv_AvailableEvaluationTypes.TupleLength()
                        ))) - 1, new HTuple("','"), out hv_EvaluationTypesStr);
                }
                if (hv_EvaluationTypesStr == null)
                    hv_EvaluationTypesStr = new HTuple();
                hv_EvaluationTypesStr[HTuple.TupleGenSequence(0, new HTuple(hv_EvaluationTypesStr.TupleLength()
                    ), 2)] = hv_AvailableEvaluationTypes;
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_EvaluationTypesStr = hv_EvaluationTypesStr.TupleSum()
                            ;
                        hv_EvaluationTypesStr.Dispose();
                        hv_EvaluationTypesStr = ExpTmpLocalVar_EvaluationTypesStr;
                    }
                }
                hv_Indices.Dispose();
                HOperatorSet.TupleFind(hv_AvailableEvaluationTypes, hv_EvaluationType, out hv_Indices);
                if ((int)((new HTuple(hv_Indices.TupleEqual(-1))).TupleOr(new HTuple(hv_Indices.TupleEqual(
                    new HTuple())))) != 0)
                {
                    throw new HalconException(((("Unknown evaluation_type: " + hv_EvaluationType) + ". Choose one of ['") + hv_EvaluationTypesStr) + "']");
                }
                if ((int)(new HTuple((new HTuple(hv_ClassIDsModel.TupleLength())).TupleLess(
                    1))) != 0)
                {
                    throw new HalconException("ClassIDsModel should have at least one entry");
                }
                //
                //Initialize EvalParams.
                hv_EvalParams.Dispose();
                HOperatorSet.CreateDict(out hv_EvalParams);
                HOperatorSet.SetDictTuple(hv_EvalParams, "evaluation_type", hv_EvaluationType);
                //
                //Set the class IDs.
                HOperatorSet.SetDictTuple(hv_EvalParams, "class_ids", hv_ClassIDsModel);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_EvalParams, "num_classes", new HTuple(hv_ClassIDsModel.TupleLength()
                        ));
                }
                //
                //Set specific parameters depending on the evaluation type.
                hv_EvaluateInstances.Dispose();
                hv_EvaluateInstances = 0;
                if ((int)(new HTuple(hv_EvaluationType.TupleEqual("anomaly_detection"))) != 0)
                {
                    //
                    //Set default image level measures.
                    hv_Measures.Dispose();
                    hv_Measures = "anomaly_score_histogram";
                    //
                    //Create dictionary for anomaly score histogram and set default
                    //values. -1 means that the parameter is estimated during evaluation.
                    hv_AnomalyScoreHistogram.Dispose();
                    HOperatorSet.CreateDict(out hv_AnomalyScoreHistogram);
                    HOperatorSet.SetDictTuple(hv_AnomalyScoreHistogram, "min", 0.0);
                    HOperatorSet.SetDictTuple(hv_AnomalyScoreHistogram, "max", 1.0);
                    HOperatorSet.SetDictTuple(hv_AnomalyScoreHistogram, "num_bins", -1);
                    //
                    HOperatorSet.SetDictTuple(hv_EvalParams, "anomaly_score_histogram", hv_AnomalyScoreHistogram);
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("classification"))) != 0)
                {
                    //
                    //Set default classification measures.
                    hv_Measures.Dispose();
                    hv_Measures = "top1_error";
                    //
                    //Per default all classes are used for evaluation.
                    HOperatorSet.SetDictTuple(hv_EvalParams, "class_ids_to_evaluate", "global");
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("detection"))) != 0)
                {
                    //
                    //Set default detection measures.
                    hv_Measures.Dispose();
                    hv_Measures = "mean_ap";
                    //
                    //Set detection-specific default values.
                    hv_EvaluateInstances.Dispose();
                    hv_EvaluateInstances = 1;
                    HOperatorSet.SetDictTuple(hv_EvalParams, "instance_type", "rectangle1");
                    //Generate ten IoU-thresholds from 0.5 to 0.95 in steps of 0.05.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_EvalParams, "iou_threshold", HTuple.TupleGenSequence(
                            0.5, 0.96, 0.05));
                    }
                    //Set maximal number of detections to -1, i.e. all results per image will be evaluated.
                    HOperatorSet.SetDictTuple(hv_EvalParams, "max_num_detections", -1);
                    //Set default area range named 'all', thus areas from 0 to a value larger than all likely occurring values.
                    hv_AreaRanges.Dispose();
                    HOperatorSet.CreateDict(out hv_AreaRanges);
                    HOperatorSet.SetDictTuple(hv_AreaRanges, "name", "all");
                    HOperatorSet.SetDictTuple(hv_AreaRanges, "min", 0);
                    HOperatorSet.SetDictTuple(hv_AreaRanges, "max", 2e8);
                    HOperatorSet.SetDictTuple(hv_EvalParams, "area_ranges", hv_AreaRanges);
                    //Some tuples are changing their length during the evaluation. As this slows down the
                    //evaluation process they are allocated in blocks of AllocationBlockLength.
                    hv_AllocationBlockLength.Dispose();
                    hv_AllocationBlockLength = 200;
                    HOperatorSet.SetDictTuple(hv_EvalParams, "allocation_block_length", hv_AllocationBlockLength);
                    //Detailed evaluation is not switched on per default, as it slows down the evaluation-process.
                    HOperatorSet.SetDictTuple(hv_EvalParams, "detailed_evaluation", 0);
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("segmentation"))) != 0)
                {
                    //
                    //Set default pixel measures.
                    hv_Measures.Dispose();
                    hv_Measures = new HTuple();
                    hv_Measures[0] = "pixel_accuracy";
                    hv_Measures[1] = "mean_accuracy";
                    hv_Measures[2] = "mean_iou";
                    //
                    //Per default there are no ignored classes.
                    HOperatorSet.SetDictTuple(hv_EvalParams, "ignore_class_ids", new HTuple());
                }
                //
                HOperatorSet.SetDictTuple(hv_EvalParams, "evaluate_instances", hv_EvaluateInstances);
                HOperatorSet.SetDictTuple(hv_EvalParams, "measures", hv_Measures);
                //

                hv_AvailableEvaluationTypes.Dispose();
                hv_EvaluationTypesStr.Dispose();
                hv_Indices.Dispose();
                hv_EvaluateInstances.Dispose();
                hv_Measures.Dispose();
                hv_AnomalyScoreHistogram.Dispose();
                hv_AreaRanges.Dispose();
                hv_AllocationBlockLength.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_AvailableEvaluationTypes.Dispose();
                hv_EvaluationTypesStr.Dispose();
                hv_Indices.Dispose();
                hv_EvaluateInstances.Dispose();
                hv_Measures.Dispose();
                hv_AnomalyScoreHistogram.Dispose();
                hv_AreaRanges.Dispose();
                hv_AllocationBlockLength.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Window
        // Short Description: Close all window handles contained in a dictionary. 
        public void dev_close_window_dict(HTuple hv_WindowHandleDict)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_WindowHandleKeys = new HTuple();
            HTuple hv_Index = new HTuple(), hv_WindowHandles = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_RemovedWindowIndices = new HTuple();
            HTuple hv_WindowHandleIndex = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure closes all window handles
                //that are contained in the dictionary WindowHandleDict.
                //
                hv_WindowHandleKeys.Dispose();
                HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_WindowHandleKeys);
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_WindowHandleKeys.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    try
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_WindowHandles.Dispose();
                            HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKeys.TupleSelect(
                                hv_Index), out hv_WindowHandles);
                        }
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException1)
                    {
                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        continue;
                    }
                    hv_RemovedWindowIndices.Dispose();
                    hv_RemovedWindowIndices = new HTuple();
                    for (hv_WindowHandleIndex = 0; (int)hv_WindowHandleIndex <= (int)((new HTuple(hv_WindowHandles.TupleLength()
                        )) - 1); hv_WindowHandleIndex = (int)hv_WindowHandleIndex + 1)
                    {
                        //Not every entry has to be a window handle, therefore use try-catch.
                        try
                        {
                            //Call set_window_param to check if the handle is a window handle.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowHandleIndex),
                                    "flush", "false");
                            }
                            HDevWindowStack.SetActive(hv_WindowHandles.TupleSelect(
                                hv_WindowHandleIndex));
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_RemovedWindowIndices = hv_RemovedWindowIndices.TupleConcat(
                                        hv_WindowHandleIndex);
                                    hv_RemovedWindowIndices.Dispose();
                                    hv_RemovedWindowIndices = ExpTmpLocalVar_RemovedWindowIndices;
                                }
                            }
                        }
                        // catch (Exception) 
                        catch (HalconException HDevExpDefaultException1)
                        {
                            HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        }
                    }
                    {
                        HTuple ExpTmpOutVar_0;
                        HOperatorSet.TupleRemove(hv_WindowHandles, hv_RemovedWindowIndices, out ExpTmpOutVar_0);
                        hv_WindowHandles.Dispose();
                        hv_WindowHandles = ExpTmpOutVar_0;
                    }
                    //If some entries remained, set reduced tuple. Otherwise, remove whole key entry.
                    if ((int)(new HTuple((new HTuple(hv_WindowHandles.TupleLength())).TupleGreater(
                        0))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_WindowHandleDict, hv_WindowHandleKeys.TupleSelect(
                                hv_Index), hv_WindowHandles);
                        }
                    }
                    else
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.RemoveDictKey(hv_WindowHandleDict, hv_WindowHandleKeys.TupleSelect(
                                hv_Index));
                        }
                    }
                }
                //

                hv_WindowHandleKeys.Dispose();
                hv_Index.Dispose();
                hv_WindowHandles.Dispose();
                hv_Exception.Dispose();
                hv_RemovedWindowIndices.Dispose();
                hv_WindowHandleIndex.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_WindowHandleKeys.Dispose();
                hv_Index.Dispose();
                hv_WindowHandles.Dispose();
                hv_Exception.Dispose();
                hv_RemovedWindowIndices.Dispose();
                hv_WindowHandleIndex.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: Display a map of the confidences. 
        public void dev_display_confidence_regions(HObject ho_ImageConfidence, HTuple hv_DrawTransparency,
            out HTuple hv_Colors)
        {




            // Local iconic variables 

            HObject ho_Region = null;

            // Local control variables 

            HTuple hv_NumColors = new HTuple(), hv_WeightsColorsAlpha = new HTuple();
            HTuple hv_ColorIndex = new HTuple(), hv_Threshold = new HTuple();
            HTuple hv_MinGray = new HTuple(), hv_MaxGray = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Region);
            hv_Colors = new HTuple();
            try
            {
                //
                //This procedure displays a map of the confidences
                //given in ImageConfidence as regions.
                //DrawTransparency determines the alpha value of the colors.
                //The used colors are returned.
                //
                //Define colors.
                hv_NumColors.Dispose();
                hv_NumColors = 20;
                hv_Colors.Dispose();
                get_distinct_colors(hv_NumColors, 0, 0, 100, out hv_Colors);
                hv_WeightsColorsAlpha.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WeightsColorsAlpha = hv_Colors + hv_DrawTransparency;
                }
                hv_ColorIndex.Dispose();
                hv_ColorIndex = 0;
                //
                //Threshold the image according to
                //the number of colors and
                //display resulting regions.
                HTuple end_val15 = hv_NumColors - 1;
                HTuple step_val15 = 1;
                for (hv_ColorIndex = 0; hv_ColorIndex.Continue(end_val15, step_val15); hv_ColorIndex = hv_ColorIndex.TupleAdd(step_val15))
                {
                    hv_Threshold.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Threshold = hv_ColorIndex * (1.0 / hv_NumColors);
                    }
                    hv_MinGray.Dispose();
                    hv_MinGray = new HTuple(hv_Threshold);
                    hv_MaxGray.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxGray = hv_Threshold + (1 / hv_NumColors);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_Region.Dispose();
                        HOperatorSet.Threshold(ho_ImageConfidence, out ho_Region, hv_Threshold, hv_Threshold + (1.0 / hv_NumColors));
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_WeightsColorsAlpha.TupleSelect(
                                hv_ColorIndex));
                        }
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_Region, HDevWindowStack.GetActive());
                    }
                }
                ho_Region.Dispose();

                hv_NumColors.Dispose();
                hv_WeightsColorsAlpha.Dispose();
                hv_ColorIndex.Dispose();
                hv_Threshold.Dispose();
                hv_MinGray.Dispose();
                hv_MaxGray.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Region.Dispose();

                hv_NumColors.Dispose();
                hv_WeightsColorsAlpha.Dispose();
                hv_ColorIndex.Dispose();
                hv_Threshold.Dispose();
                hv_MinGray.Dispose();
                hv_MaxGray.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Display the confusion matrix for the evaluation results of a model with type detection. 
        public void dev_display_detection_confusion_matrix(HTuple hv_WindowHandles, HTuple hv_IoUEvaluationResult,
            HTuple hv_ClassIDs, HTuple hv_GenParam)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_DisplayAbsoluteMatrix = new HTuple();
            HTuple hv_DisplayRelativeMatrix = new HTuple(), hv_DisplayColor = new HTuple();
            HTuple hv_DisplayColumnWidth = new HTuple(), hv_GenParamKeys = new HTuple();
            HTuple hv_KeyExists = new HTuple(), hv_ValueTmp = new HTuple();
            HTuple hv_DisplayColumnWidthTmp = new HTuple(), hv_CalculateRelativeMatrix = new HTuple();
            HTuple hv_ConfusionMatrix = new HTuple(), hv_NumRows = new HTuple();
            HTuple hv_NumColumns = new HTuple(), hv_Values = new HTuple();
            HTuple hv_ConfusionMatrixRelative = new HTuple(), hv_C = new HTuple();
            HTuple hv_RowValues = new HTuple(), hv_NumTPAndFN = new HTuple();
            HTuple hv_ValueColors = new HTuple(), hv_DiagonalColor = new HTuple();
            HTuple hv_Seq = new HTuple(), hv_DiagonalIndices = new HTuple();
            HTuple hv_ClassStrings = new HTuple(), hv_FPStrings = new HTuple();
            HTuple hv_ColumnNames = new HTuple(), hv_RowNames = new HTuple();
            HTuple hv_MatrixMaxID = new HTuple(), hv_MaxValue = new HTuple();
            HTuple hv_NumberFormat = new HTuple(), hv_ValuesRelative = new HTuple();
            HTuple hv_GenParam_COPY_INP_TMP = new HTuple(hv_GenParam);

            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure displays the detection confusion matrix
                //given in IoUEvaluationResult.
                //Thereby, the matrix can be displayed with absolute or
                //relative values.
                //
                //Set generic parameter default values.
                hv_DisplayAbsoluteMatrix.Dispose();
                hv_DisplayAbsoluteMatrix = 1;
                hv_DisplayRelativeMatrix.Dispose();
                hv_DisplayRelativeMatrix = 0;
                hv_DisplayColor.Dispose();
                hv_DisplayColor = 1;
                hv_DisplayColumnWidth.Dispose();
                hv_DisplayColumnWidth = "equal";
                //
                //Parse generic parameters.
                if ((int)(new HTuple((new HTuple(hv_GenParam_COPY_INP_TMP.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    hv_GenParamKeys.Dispose();
                    hv_GenParamKeys = new HTuple();
                    hv_GenParamKeys[0] = "display_color";
                    hv_GenParamKeys[1] = "display_relative_matrix";
                    hv_GenParamKeys[2] = "display_absolute_matrix";
                    hv_GenParamKeys[3] = "display_column_width";
                    hv_KeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam_COPY_INP_TMP, "key_exists", hv_GenParamKeys,
                        out hv_KeyExists);
                    //DisplayColor
                    if ((int)(hv_KeyExists.TupleSelect(0)) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, "display_color", out hv_ValueTmp);
                        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
                            1))).TupleOr(new HTuple((new HTuple(((new HTuple(1)).TupleConcat(0)).TupleFind(
                            hv_ValueTmp))).TupleEqual(-1)))) != 0)
                        {
                            throw new HalconException("Invalid value for 'display_color'");
                        }
                        else
                        {
                            hv_DisplayColor.Dispose();
                            hv_DisplayColor = new HTuple(hv_ValueTmp);
                        }
                    }
                    //DisplayRelativeMatrix
                    if ((int)(hv_KeyExists.TupleSelect(1)) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, "display_relative_matrix",
                            out hv_ValueTmp);
                        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
                            1))).TupleOr(new HTuple((new HTuple(((new HTuple(1)).TupleConcat(0)).TupleFind(
                            hv_ValueTmp))).TupleEqual(-1)))) != 0)
                        {
                            throw new HalconException("Invalid value for 'display_relative_matrix'");
                        }
                        else
                        {
                            hv_DisplayRelativeMatrix.Dispose();
                            hv_DisplayRelativeMatrix = new HTuple(hv_ValueTmp);
                        }
                    }
                    //DisplayAbsoluteMatrix
                    if ((int)(hv_KeyExists.TupleSelect(2)) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, "display_absolute_matrix",
                            out hv_ValueTmp);
                        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
                            1))).TupleOr(new HTuple((new HTuple(((new HTuple(1)).TupleConcat(0)).TupleFind(
                            hv_ValueTmp))).TupleEqual(-1)))) != 0)
                        {
                            throw new HalconException("Invalid value for 'display_absolute_matrix'");
                        }
                        else
                        {
                            hv_DisplayAbsoluteMatrix.Dispose();
                            hv_DisplayAbsoluteMatrix = new HTuple(hv_ValueTmp);
                        }
                    }
                    if ((int)(hv_KeyExists.TupleSelect(3)) != 0)
                    {
                        hv_DisplayColumnWidthTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, "display_column_width",
                            out hv_DisplayColumnWidthTmp);
                        if ((int)((new HTuple((new HTuple(hv_DisplayColumnWidthTmp.TupleLength()
                            )).TupleNotEqual(1))).TupleOr(new HTuple((new HTuple(((new HTuple("equal")).TupleConcat(
                            "minimal")).TupleFind(hv_DisplayColumnWidthTmp))).TupleEqual(-1)))) != 0)
                        {
                            throw new HalconException("Invalid value for 'display_column_width'");
                        }
                        else
                        {
                            hv_DisplayColumnWidth.Dispose();
                            hv_DisplayColumnWidth = new HTuple(hv_DisplayColumnWidthTmp);
                        }
                    }
                }
                //
                if ((int)((new HTuple(hv_DisplayRelativeMatrix.TupleOr(hv_DisplayAbsoluteMatrix))).TupleNot()
                    ) != 0)
                {
                    throw new HalconException("At least one of 'display_absolute_matrix' and 'display_relative_matrix' should be true");
                }
                if ((int)(new HTuple(((hv_DisplayRelativeMatrix + hv_DisplayAbsoluteMatrix)).TupleNotEqual(
                    new HTuple(hv_WindowHandles.TupleLength())))) != 0)
                {
                    throw new HalconException("Wrong number of WindowHandles");
                }
                if ((int)(hv_DisplayRelativeMatrix.TupleOr(hv_DisplayColor)) != 0)
                {
                    hv_CalculateRelativeMatrix.Dispose();
                    hv_CalculateRelativeMatrix = 1;
                }
                else
                {
                    hv_CalculateRelativeMatrix.Dispose();
                    hv_CalculateRelativeMatrix = 0;
                }
                //
                //Calculate the confusion matrix with absolute values
                //and the confusion matrix with relative errors.
                //We start with an empty matrix
                //and add the number of matching labels.
                hv_ConfusionMatrix.Dispose();
                HOperatorSet.GetDictTuple(hv_IoUEvaluationResult, "detection_confusion_matrix",
                    out hv_ConfusionMatrix);
                hv_NumRows.Dispose(); hv_NumColumns.Dispose();
                HOperatorSet.GetSizeMatrix(hv_ConfusionMatrix, out hv_NumRows, out hv_NumColumns);
                hv_Values.Dispose();
                HOperatorSet.GetFullMatrix(hv_ConfusionMatrix, out hv_Values);
                //
                if ((int)(hv_CalculateRelativeMatrix) != 0)
                {
                    //Calculate the relative matrix.
                    hv_ConfusionMatrixRelative.Dispose();
                    HOperatorSet.CopyMatrix(hv_ConfusionMatrix, out hv_ConfusionMatrixRelative);
                    //For each class:
                    for (hv_C = 0; (int)hv_C <= (int)((new HTuple(hv_ClassIDs.TupleLength())) - 1); hv_C = (int)hv_C + 1)
                    {
                        //Get the total number of predictions and calculate the relative values.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_RowValues.Dispose();
                            HOperatorSet.GetValueMatrix(hv_ConfusionMatrix, HTuple.TupleGenConst(hv_NumColumns,
                                hv_C), HTuple.TupleGenSequence(0, hv_NumColumns - 1, 1), out hv_RowValues);
                        }
                        if ((int)(new HTuple(((hv_RowValues.TupleSum())).TupleGreater(0))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetValueMatrix(hv_ConfusionMatrixRelative, HTuple.TupleGenConst(
                                    hv_NumColumns, hv_C), HTuple.TupleGenSequence(0, hv_NumColumns - 1, 1),
                                    (hv_RowValues.TupleReal()) / (hv_RowValues.TupleSum()));
                            }
                        }
                        else
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetValueMatrix(hv_ConfusionMatrixRelative, HTuple.TupleGenConst(
                                    hv_NumColumns, hv_C), HTuple.TupleGenSequence(0, hv_NumColumns - 1, 1),
                                    hv_RowValues.TupleReal());
                            }
                        }
                        //Get the total number of ground truth and calculate relative false negatives.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_NumTPAndFN.Dispose();
                            HOperatorSet.GetValueMatrix(hv_ConfusionMatrix, hv_C.TupleConcat(new HTuple(hv_ClassIDs.TupleLength()
                                )), hv_C.TupleConcat(hv_C), out hv_NumTPAndFN);
                        }
                        if ((int)(new HTuple(((hv_NumTPAndFN.TupleSum())).TupleGreater(0))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetValueMatrix(hv_ConfusionMatrixRelative, new HTuple(hv_ClassIDs.TupleLength()
                                    ), hv_C, (((hv_NumTPAndFN.TupleSelect(1))).TupleReal()) / (hv_NumTPAndFN.TupleSum()
                                    ));
                            }
                        }
                        else
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetValueMatrix(hv_ConfusionMatrixRelative, new HTuple(hv_ClassIDs.TupleLength()
                                    ), hv_C, ((hv_NumTPAndFN.TupleSelect(1))).TupleReal());
                            }
                        }
                    }
                }
                //
                //Set color for displayed confusion matrix.
                hv_ValueColors.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ValueColors = HTuple.TupleGenConst(
                        new HTuple(hv_Values.TupleLength()), "#666666");
                }
                if ((int)(hv_DisplayColor) != 0)
                {
                    //Display off-diagonal values in red.
                    hv_ValueColors.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ValueColors = HTuple.TupleGenConst(
                            new HTuple(hv_Values.TupleLength()), "#ff4500");
                    }
                    //Display diagonal values in green.
                    hv_DiagonalColor.Dispose();
                    hv_DiagonalColor = "#00ff00";
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Seq.Dispose();
                        HOperatorSet.TupleGenSequence(0, (new HTuple(hv_ClassIDs.TupleLength())) - 1,
                            1, out hv_Seq);
                    }
                    hv_DiagonalIndices.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DiagonalIndices = (hv_NumColumns * hv_Seq) + hv_Seq;
                    }
                    if (hv_ValueColors == null)
                        hv_ValueColors = new HTuple();
                    hv_ValueColors[hv_DiagonalIndices] = hv_DiagonalColor;
                }
                //
                //Display the matrix.
                //
                //Collect column and row names.
                hv_ClassStrings.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ClassStrings = "class_" + hv_ClassIDs;
                }
                hv_FPStrings.Dispose();
                hv_FPStrings = new HTuple();
                hv_FPStrings[0] = "FP bg";
                hv_FPStrings[1] = "FP loc";
                hv_FPStrings[2] = "FP dup";
                hv_FPStrings[3] = "FP mult";
                hv_ColumnNames.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ColumnNames = new HTuple();
                    hv_ColumnNames = hv_ColumnNames.TupleConcat(hv_ClassStrings, hv_FPStrings);
                }
                hv_RowNames.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RowNames = new HTuple();
                    hv_RowNames = hv_RowNames.TupleConcat(hv_ClassStrings);
                    hv_RowNames = hv_RowNames.TupleConcat("FN");
                }
                //
                //Create GenParam for matrix display.
                hv_GenParam_COPY_INP_TMP.Dispose();
                HOperatorSet.CreateDict(out hv_GenParam_COPY_INP_TMP);
                HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "display_column_width",
                    hv_DisplayColumnWidth);
                HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "display_color", hv_DisplayColor);
                //The last 4 values are meaningless and therefore not displayed.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "idxs_no_display", HTuple.TupleGenSequence(
                        (new HTuple(hv_Values.TupleLength())) - 4, (new HTuple(hv_Values.TupleLength()
                        )) - 1, 1));
                }
                HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "axis_titles", (new HTuple("Ground truth")).TupleConcat(
                    "Predicted"));
                HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "value_colors", hv_ValueColors);
                if ((int)(hv_DisplayAbsoluteMatrix) != 0)
                {
                    //Display absolute matrix.
                    //Calculate proper number format.
                    hv_MatrixMaxID.Dispose();
                    HOperatorSet.MaxMatrix(hv_ConfusionMatrix, "full", out hv_MatrixMaxID);
                    hv_MaxValue.Dispose();
                    HOperatorSet.GetFullMatrix(hv_MatrixMaxID, out hv_MaxValue);
                    if ((int)(new HTuple(hv_MaxValue.TupleGreater(0))) != 0)
                    {
                        hv_NumberFormat.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_NumberFormat = (((((hv_MaxValue.TupleLog10()
                                )).TupleCeil())).TupleInt()) + ".0f";
                        }
                    }
                    else
                    {
                        hv_NumberFormat.Dispose();
                        hv_NumberFormat = "1.0f";
                    }
                    HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "number_format", hv_NumberFormat);
                    //Set title.
                    HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "title", new HTuple("Detection confusion matrix, absolute"));
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        dev_display_matrix(hv_ConfusionMatrix, hv_ColumnNames, hv_RowNames, hv_WindowHandles.TupleSelect(
                            0), hv_GenParam_COPY_INP_TMP);
                    }
                }
                if ((int)(hv_DisplayRelativeMatrix) != 0)
                {
                    //Display relative matrix.
                    //Convert relative matrix values to percent.
                    hv_ValuesRelative.Dispose();
                    HOperatorSet.GetFullMatrix(hv_ConfusionMatrixRelative, out hv_ValuesRelative);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetFullMatrix(hv_ConfusionMatrixRelative, 100 * hv_ValuesRelative);
                    }
                    //Set number format.
                    hv_NumberFormat.Dispose();
                    hv_NumberFormat = "2.1f";
                    HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "number_format", hv_NumberFormat);
                    //Set title.
                    HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "title", new HTuple("Detection confusion matrix, relative [%]"));
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        dev_display_matrix(hv_ConfusionMatrixRelative, hv_ColumnNames, hv_RowNames,
                            hv_WindowHandles.TupleSelect(hv_DisplayAbsoluteMatrix), hv_GenParam_COPY_INP_TMP);
                    }
                }


                hv_GenParam_COPY_INP_TMP.Dispose();
                hv_DisplayAbsoluteMatrix.Dispose();
                hv_DisplayRelativeMatrix.Dispose();
                hv_DisplayColor.Dispose();
                hv_DisplayColumnWidth.Dispose();
                hv_GenParamKeys.Dispose();
                hv_KeyExists.Dispose();
                hv_ValueTmp.Dispose();
                hv_DisplayColumnWidthTmp.Dispose();
                hv_CalculateRelativeMatrix.Dispose();
                hv_ConfusionMatrix.Dispose();
                hv_NumRows.Dispose();
                hv_NumColumns.Dispose();
                hv_Values.Dispose();
                hv_ConfusionMatrixRelative.Dispose();
                hv_C.Dispose();
                hv_RowValues.Dispose();
                hv_NumTPAndFN.Dispose();
                hv_ValueColors.Dispose();
                hv_DiagonalColor.Dispose();
                hv_Seq.Dispose();
                hv_DiagonalIndices.Dispose();
                hv_ClassStrings.Dispose();
                hv_FPStrings.Dispose();
                hv_ColumnNames.Dispose();
                hv_RowNames.Dispose();
                hv_MatrixMaxID.Dispose();
                hv_MaxValue.Dispose();
                hv_NumberFormat.Dispose();
                hv_ValuesRelative.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_GenParam_COPY_INP_TMP.Dispose();
                hv_DisplayAbsoluteMatrix.Dispose();
                hv_DisplayRelativeMatrix.Dispose();
                hv_DisplayColor.Dispose();
                hv_DisplayColumnWidth.Dispose();
                hv_GenParamKeys.Dispose();
                hv_KeyExists.Dispose();
                hv_ValueTmp.Dispose();
                hv_DisplayColumnWidthTmp.Dispose();
                hv_CalculateRelativeMatrix.Dispose();
                hv_ConfusionMatrix.Dispose();
                hv_NumRows.Dispose();
                hv_NumColumns.Dispose();
                hv_Values.Dispose();
                hv_ConfusionMatrixRelative.Dispose();
                hv_C.Dispose();
                hv_RowValues.Dispose();
                hv_NumTPAndFN.Dispose();
                hv_ValueColors.Dispose();
                hv_DiagonalColor.Dispose();
                hv_Seq.Dispose();
                hv_DiagonalIndices.Dispose();
                hv_ClassStrings.Dispose();
                hv_FPStrings.Dispose();
                hv_ColumnNames.Dispose();
                hv_RowNames.Dispose();
                hv_MatrixMaxID.Dispose();
                hv_MaxValue.Dispose();
                hv_NumberFormat.Dispose();
                hv_ValuesRelative.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Visualize the results of a detailed evaluation for a model of type detection. 
        public void dev_display_detection_detailed_evaluation(HTuple hv_EvaluationResult,
            HTuple hv_EvalParam, HTuple hv_GenParam, HTuple hv_WindowHandleDict)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_DisplayPieChartsPrecision = new HTuple();
            HTuple hv_DisplayPieChartsRecall = new HTuple(), hv_DisplayConfusionAbsolute = new HTuple();
            HTuple hv_DisplayConfusionRelative = new HTuple(), hv_BaseWindowRow = new HTuple();
            HTuple hv_BaseWindowColumn = new HTuple(), hv_DetailedEvaluation = new HTuple();
            HTuple hv_AvailableIoUThresholds = new HTuple(), hv_MaxNumDetections = new HTuple();
            HTuple hv_AreaRanges = new HTuple(), hv_ClassIDs = new HTuple();
            HTuple hv_IoUThreshold = new HTuple(), hv_AreaRangeName = new HTuple();
            HTuple hv_MaxNumDetStr = new HTuple(), hv_MaxNumEvaluationResult = new HTuple();
            HTuple hv_AreaEvaluationResult = new HTuple(), hv_IoUEvaluationResult = new HTuple();
            HTuple hv_GenParamKeys = new HTuple(), hv_Keys = new HTuple();
            HTuple hv_IndexKeys = new HTuple(), hv_KeyExists = new HTuple();
            HTuple hv_Value = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_WindowExists = new HTuple(), hv_WindowHandlePieChartsPrecision = new HTuple();
            HTuple hv_WindowHandlePieChartsRecall = new HTuple(), hv_WindowHandlesConfusion = new HTuple();
            HTuple hv_WindowHandleConfusionAbsolute = new HTuple();
            HTuple hv_WindowHandleConfusionRelative = new HTuple();
            HTuple hv_ColConfusion = new HTuple(), hv_RowConfusion = new HTuple();
            HTuple hv_WidthConf = new HTuple(), hv_HeightConf = new HTuple();
            HTuple hv__ = new HTuple(), hv_Width = new HTuple(), hv_Height = new HTuple();
            HTuple hv_Row = new HTuple(), hv_Column = new HTuple();
            HTuple hv_GenParam_COPY_INP_TMP = new HTuple(hv_GenParam);
            HTuple hv_WindowHandleDict_COPY_INP_TMP = new HTuple(hv_WindowHandleDict);

            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure visualizes the detailed evaluation results for a model of type detection.
                //
                //Set the default values.
                hv_DisplayPieChartsPrecision.Dispose();
                hv_DisplayPieChartsPrecision = 1;
                hv_DisplayPieChartsRecall.Dispose();
                hv_DisplayPieChartsRecall = 0;
                hv_DisplayConfusionAbsolute.Dispose();
                hv_DisplayConfusionAbsolute = 0;
                hv_DisplayConfusionRelative.Dispose();
                hv_DisplayConfusionRelative = 0;
                //
                //Default settings for window placement.
                hv_BaseWindowRow.Dispose();
                hv_BaseWindowRow = 0;
                hv_BaseWindowColumn.Dispose();
                hv_BaseWindowColumn = 0;
                //
                //Get some evaluation parameters.
                hv_DetailedEvaluation.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParam, "detailed_evaluation", out hv_DetailedEvaluation);
                if ((int)(hv_DetailedEvaluation.TupleNot()) != 0)
                {
                    throw new HalconException("detailed_evaluation has to be set to true for this visualization");
                }
                hv_AvailableIoUThresholds.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParam, "iou_threshold", out hv_AvailableIoUThresholds);
                hv_MaxNumDetections.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParam, "max_num_detections", out hv_MaxNumDetections);
                hv_AreaRanges.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParam, "area_ranges", out hv_AreaRanges);
                hv_ClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParam, "class_ids", out hv_ClassIDs);
                //
                //Use the first value under IoU threshold, MaxNumDetections and area-range.
                hv_IoUThreshold.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_IoUThreshold = hv_AvailableIoUThresholds.TupleSelect(
                        0);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_MaxNumDetections = hv_MaxNumDetections.TupleSelect(
                            0);
                        hv_MaxNumDetections.Dispose();
                        hv_MaxNumDetections = ExpTmpLocalVar_MaxNumDetections;
                    }
                }
                hv_AreaRangeName.Dispose();
                HOperatorSet.GetDictTuple(hv_AreaRanges, "name", out hv_AreaRangeName);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_AreaRangeName = hv_AreaRangeName.TupleSelect(
                            0);
                        hv_AreaRangeName.Dispose();
                        hv_AreaRangeName = ExpTmpLocalVar_AreaRangeName;
                    }
                }
                //Get detailed evaluation results.
                hv_MaxNumDetStr.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_MaxNumDetStr = "" + hv_MaxNumDetections;
                }
                if ((int)(new HTuple(hv_MaxNumDetections.TupleEqual(-1))) != 0)
                {
                    hv_MaxNumDetStr.Dispose();
                    hv_MaxNumDetStr = "all";
                }
                //
                //Get the detailed evaluation results for the first IoU-threshold, although it might be changed below depending on generic parameters.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_MaxNumEvaluationResult.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvaluationResult, "max_num_detections_" + hv_MaxNumDetStr,
                        out hv_MaxNumEvaluationResult);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_AreaEvaluationResult.Dispose();
                    HOperatorSet.GetDictTuple(hv_MaxNumEvaluationResult, "area_" + hv_AreaRangeName,
                        out hv_AreaEvaluationResult);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_IoUEvaluationResult.Dispose();
                    HOperatorSet.GetDictTuple(hv_AreaEvaluationResult, "detailed_evaluation_iou_" + ((("" + hv_IoUThreshold)).TupleRegexpReplace(
                        "\\.", "")), out hv_IoUEvaluationResult);
                }
                //
                //Handle the generic parameters.
                if ((int)(new HTuple((new HTuple(hv_GenParam_COPY_INP_TMP.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    hv_GenParamKeys.Dispose();
                    hv_GenParamKeys = new HTuple();
                    hv_GenParamKeys[0] = "display_mode";
                    hv_GenParamKeys[1] = "window_row";
                    hv_GenParamKeys[2] = "window_column";
                    hv_GenParamKeys[3] = "max_num_detections";
                    hv_GenParamKeys[4] = "area_range_name";
                    hv_GenParamKeys[5] = "iou_threshold";
                    hv_Keys.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam_COPY_INP_TMP, "keys", new HTuple(),
                        out hv_Keys);
                    for (hv_IndexKeys = 0; (int)hv_IndexKeys <= (int)((new HTuple(hv_Keys.TupleLength()
                        )) - 1); hv_IndexKeys = (int)hv_IndexKeys + 1)
                    {
                        if ((int)(new HTuple(((hv_GenParamKeys.TupleFind(hv_Keys.TupleSelect(hv_IndexKeys)))).TupleEqual(
                            -1))) != 0)
                        {
                            throw new HalconException(("Invalid GenParam key '" + (hv_Keys.TupleSelect(
                                hv_IndexKeys))) + "'");
                        }
                    }
                    hv_KeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam_COPY_INP_TMP, "key_exists", hv_GenParamKeys,
                        out hv_KeyExists);
                    //Display mode.
                    if ((int)(hv_KeyExists.TupleSelect(0)) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Value.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, hv_GenParamKeys.TupleSelect(
                                0), out hv_Value);
                        }
                        if ((int)(new HTuple((new HTuple(hv_Value.TupleLength())).TupleEqual(0))) != 0)
                        {
                            throw new HalconException("GenParam key 'display_mode' cannot be an empty tuple");
                        }
                        else
                        {
                            //Pie chart precision.
                            hv_DisplayPieChartsPrecision.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_DisplayPieChartsPrecision = hv_Value.TupleFind(
                                    "pie_charts_precision");
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_DisplayPieChartsPrecision = (new HTuple((new HTuple(hv_DisplayPieChartsPrecision.TupleLength()
                                        )).TupleGreater(0))).TupleAnd(new HTuple(hv_DisplayPieChartsPrecision.TupleNotEqual(
                                        -1)));
                                    hv_DisplayPieChartsPrecision.Dispose();
                                    hv_DisplayPieChartsPrecision = ExpTmpLocalVar_DisplayPieChartsPrecision;
                                }
                            }
                            //Pie chart recall.
                            hv_DisplayPieChartsRecall.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_DisplayPieChartsRecall = hv_Value.TupleFind(
                                    "pie_charts_recall");
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_DisplayPieChartsRecall = (new HTuple((new HTuple(hv_DisplayPieChartsRecall.TupleLength()
                                        )).TupleGreater(0))).TupleAnd(new HTuple(hv_DisplayPieChartsRecall.TupleNotEqual(
                                        -1)));
                                    hv_DisplayPieChartsRecall.Dispose();
                                    hv_DisplayPieChartsRecall = ExpTmpLocalVar_DisplayPieChartsRecall;
                                }
                            }
                            //Absolute confusion matrix.
                            hv_DisplayConfusionAbsolute.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_DisplayConfusionAbsolute = hv_Value.TupleFind(
                                    "absolute_confusion_matrix");
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_DisplayConfusionAbsolute = (new HTuple((new HTuple(hv_DisplayConfusionAbsolute.TupleLength()
                                        )).TupleGreater(0))).TupleAnd(new HTuple(hv_DisplayConfusionAbsolute.TupleNotEqual(
                                        -1)));
                                    hv_DisplayConfusionAbsolute.Dispose();
                                    hv_DisplayConfusionAbsolute = ExpTmpLocalVar_DisplayConfusionAbsolute;
                                }
                            }
                            //Relative confusion matrix.
                            hv_DisplayConfusionRelative.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_DisplayConfusionRelative = hv_Value.TupleFind(
                                    "relative_confusion_matrix");
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_DisplayConfusionRelative = (new HTuple((new HTuple(hv_DisplayConfusionRelative.TupleLength()
                                        )).TupleGreater(0))).TupleAnd(new HTuple(hv_DisplayConfusionRelative.TupleNotEqual(
                                        -1)));
                                    hv_DisplayConfusionRelative.Dispose();
                                    hv_DisplayConfusionRelative = ExpTmpLocalVar_DisplayConfusionRelative;
                                }
                            }
                            if ((int)((new HTuple((new HTuple((new HTuple(hv_DisplayPieChartsPrecision.TupleOr(
                                hv_DisplayPieChartsRecall))).TupleOr(hv_DisplayConfusionAbsolute))).TupleOr(
                                hv_DisplayConfusionRelative))).TupleNot()) != 0)
                            {
                                throw new HalconException("'display_mode' not supported.");
                            }
                        }
                    }
                    //BaseWindowRow.
                    if ((int)(hv_KeyExists.TupleSelect(1)) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Value.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, hv_GenParamKeys.TupleSelect(
                                1), out hv_Value);
                        }
                        if ((int)((new HTuple((new HTuple(hv_Value.TupleLength())).TupleEqual(1))).TupleAnd(
                            new HTuple(hv_Value.TupleGreaterEqual(0)))) != 0)
                        {
                            hv_BaseWindowRow.Dispose();
                            hv_BaseWindowRow = new HTuple(hv_Value);
                        }
                        else
                        {
                            throw new HalconException("Invalid GenParam 'window_row'.");
                        }
                    }
                    //BaseWindowColumn.
                    if ((int)(hv_KeyExists.TupleSelect(2)) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Value.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, hv_GenParamKeys.TupleSelect(
                                2), out hv_Value);
                        }
                        if ((int)((new HTuple((new HTuple(hv_Value.TupleLength())).TupleEqual(1))).TupleAnd(
                            new HTuple(hv_Value.TupleGreaterEqual(0)))) != 0)
                        {
                            hv_BaseWindowColumn.Dispose();
                            hv_BaseWindowColumn = new HTuple(hv_Value);
                        }
                        else
                        {
                            throw new HalconException("Invalid GenParam 'window_column'.");
                        }
                    }
                    //MaxNumDetections.
                    if ((int)(hv_KeyExists.TupleSelect(3)) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Value.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, hv_GenParamKeys.TupleSelect(
                                3), out hv_Value);
                        }
                        hv_MaxNumDetStr.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MaxNumDetStr = "" + hv_Value;
                        }
                        if ((int)(new HTuple(hv_Value.TupleEqual(-1))) != 0)
                        {
                            hv_MaxNumDetStr.Dispose();
                            hv_MaxNumDetStr = "all";
                        }
                        try
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_MaxNumEvaluationResult.Dispose();
                                HOperatorSet.GetDictTuple(hv_EvaluationResult, "max_num_detections_" + hv_MaxNumDetStr,
                                    out hv_MaxNumEvaluationResult);
                            }
                        }
                        // catch (Exception) 
                        catch (HalconException HDevExpDefaultException1)
                        {
                            HDevExpDefaultException1.ToHTuple(out hv_Exception);
                            throw new HalconException("Invalid GenParam 'max_num_detections'");
                        }
                        hv_MaxNumDetections.Dispose();
                        hv_MaxNumDetections = new HTuple(hv_Value);
                    }
                    //AreaRange.
                    if ((int)(hv_KeyExists.TupleSelect(4)) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Value.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, hv_GenParamKeys.TupleSelect(
                                4), out hv_Value);
                        }
                        try
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_AreaEvaluationResult.Dispose();
                                HOperatorSet.GetDictTuple(hv_MaxNumEvaluationResult, "area_" + hv_Value,
                                    out hv_AreaEvaluationResult);
                            }
                        }
                        // catch (Exception) 
                        catch (HalconException HDevExpDefaultException1)
                        {
                            HDevExpDefaultException1.ToHTuple(out hv_Exception);
                            throw new HalconException("Invalid GenParam 'area_range_name'");
                        }
                        hv_AreaRangeName.Dispose();
                        hv_AreaRangeName = new HTuple(hv_Value);
                    }
                    //IoUThreshold.
                    if ((int)(hv_KeyExists.TupleSelect(5)) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Value.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, hv_GenParamKeys.TupleSelect(
                                5), out hv_Value);
                        }
                        try
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_IoUEvaluationResult.Dispose();
                                HOperatorSet.GetDictTuple(hv_AreaEvaluationResult, "detailed_evaluation_iou_" + ((("" + hv_Value)).TupleRegexpReplace(
                                    "\\.", "")), out hv_IoUEvaluationResult);
                            }
                        }
                        // catch (Exception) 
                        catch (HalconException HDevExpDefaultException1)
                        {
                            HDevExpDefaultException1.ToHTuple(out hv_Exception);
                            throw new HalconException("Invalid GenParam 'iou_threshold'");
                        }
                        hv_IoUThreshold.Dispose();
                        hv_IoUThreshold = new HTuple(hv_Value);
                    }
                }
                //
                //Check that the WindowHandleDict is of type dictionary.
                try
                {
                    hv_Keys.Dispose();
                    HOperatorSet.GetDictParam(hv_WindowHandleDict_COPY_INP_TMP, "keys", new HTuple(),
                        out hv_Keys);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    if ((int)(new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(1401))) != 0)
                    {
                        throw new HalconException("WindowHandleDict has to be of type dictionary. Use create_dict to create an empty dictionary.");
                    }
                    else
                    {
                        throw new HalconException(hv_Exception);
                    }
                }
                //
                //Update the IoUEvaluationResult in case MaxNumDetections, AreaRange or IoUThreshold have changed.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_MaxNumEvaluationResult.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvaluationResult, "max_num_detections_" + hv_MaxNumDetStr,
                        out hv_MaxNumEvaluationResult);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_AreaEvaluationResult.Dispose();
                    HOperatorSet.GetDictTuple(hv_MaxNumEvaluationResult, "area_" + hv_AreaRangeName,
                        out hv_AreaEvaluationResult);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_IoUEvaluationResult.Dispose();
                    HOperatorSet.GetDictTuple(hv_AreaEvaluationResult, "detailed_evaluation_iou_" + ((("" + hv_IoUThreshold)).TupleRegexpReplace(
                        "\\.", "")), out hv_IoUEvaluationResult);
                }
                HOperatorSet.SetDictTuple(hv_IoUEvaluationResult, "iou_threshold", hv_IoUThreshold);
                //
                //Generate pie-charts with false positives information.
                if ((int)(hv_DisplayPieChartsPrecision) != 0)
                {
                    hv_WindowExists.Dispose();
                    HOperatorSet.GetDictParam(hv_WindowHandleDict_COPY_INP_TMP, "key_exists",
                        "window_pie_chart_precision", out hv_WindowExists);
                    if ((int)(hv_WindowExists.TupleNot()) != 0)
                    {
                        HOperatorSet.SetWindowAttr("background_color", "black");
                        HOperatorSet.OpenWindow(hv_BaseWindowRow, hv_BaseWindowColumn, 512, 512, 0, "visible", "", out hv_WindowHandlePieChartsPrecision);
                        HDevWindowStack.Push(hv_WindowHandlePieChartsPrecision);
                        HOperatorSet.SetDictTuple(hv_WindowHandleDict_COPY_INP_TMP, "window_pie_chart_precision",
                            hv_WindowHandlePieChartsPrecision);
                    }
                    else
                    {
                        hv_WindowHandlePieChartsPrecision.Dispose();
                        HOperatorSet.GetDictTuple(hv_WindowHandleDict_COPY_INP_TMP, "window_pie_chart_precision",
                            out hv_WindowHandlePieChartsPrecision);
                    }
                    dev_display_detection_evaluation_pie_charts(hv_WindowHandlePieChartsPrecision,
                        hv_IoUEvaluationResult, hv_ClassIDs, "precision", hv_BaseWindowRow, hv_BaseWindowColumn);
                }
                //
                //Generate pie-charts with false negatives information.
                if ((int)(hv_DisplayPieChartsRecall) != 0)
                {
                    hv_WindowExists.Dispose();
                    HOperatorSet.GetDictParam(hv_WindowHandleDict_COPY_INP_TMP, "key_exists",
                        "window_pie_chart_recall", out hv_WindowExists);
                    if ((int)(hv_WindowExists.TupleNot()) != 0)
                    {
                        HOperatorSet.SetWindowAttr("background_color", "black");
                        HOperatorSet.OpenWindow(hv_BaseWindowRow, hv_BaseWindowColumn, 512, 512, 0, "visible", "", out hv_WindowHandlePieChartsRecall);
                        HDevWindowStack.Push(hv_WindowHandlePieChartsRecall);
                        HOperatorSet.SetDictTuple(hv_WindowHandleDict_COPY_INP_TMP, "window_pie_chart_recall",
                            hv_WindowHandlePieChartsRecall);
                    }
                    else
                    {
                        hv_WindowHandlePieChartsRecall.Dispose();
                        HOperatorSet.GetDictTuple(hv_WindowHandleDict_COPY_INP_TMP, "window_pie_chart_recall",
                            out hv_WindowHandlePieChartsRecall);
                    }
                    dev_display_detection_evaluation_pie_charts(hv_WindowHandlePieChartsRecall,
                        hv_IoUEvaluationResult, hv_ClassIDs, "recall", hv_BaseWindowRow, hv_BaseWindowColumn);
                }
                //
                //Visualize detection confusion matrix.
                if ((int)(hv_DisplayConfusionAbsolute.TupleOr(hv_DisplayConfusionRelative)) != 0)
                {
                    hv_WindowHandlesConfusion.Dispose();
                    hv_WindowHandlesConfusion = new HTuple();
                    hv_GenParam_COPY_INP_TMP.Dispose();
                    HOperatorSet.CreateDict(out hv_GenParam_COPY_INP_TMP);
                    HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "display_relative_matrix",
                        hv_DisplayConfusionRelative);
                    HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "display_absolute_matrix",
                        hv_DisplayConfusionAbsolute);
                    HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "display_color", 1);
                    if ((int)(hv_DisplayConfusionAbsolute) != 0)
                    {
                        hv_WindowExists.Dispose();
                        HOperatorSet.GetDictParam(hv_WindowHandleDict_COPY_INP_TMP, "key_exists",
                            "window_absolute_confusion_matrix", out hv_WindowExists);
                        if ((int)(hv_WindowExists.TupleNot()) != 0)
                        {
                            HOperatorSet.SetWindowAttr("background_color", "black");
                            HOperatorSet.OpenWindow(hv_BaseWindowRow, hv_BaseWindowColumn, 512, 512, 0, "visible", "", out hv_WindowHandleConfusionAbsolute);
                            HDevWindowStack.Push(hv_WindowHandleConfusionAbsolute);
                            HOperatorSet.SetDictTuple(hv_WindowHandleDict_COPY_INP_TMP, "window_absolute_confusion_matrix",
                                hv_WindowHandleConfusionAbsolute);
                        }
                        else
                        {
                            hv_WindowHandleConfusionAbsolute.Dispose();
                            HOperatorSet.GetDictTuple(hv_WindowHandleDict_COPY_INP_TMP, "window_absolute_confusion_matrix",
                                out hv_WindowHandleConfusionAbsolute);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_WindowHandlesConfusion = hv_WindowHandlesConfusion.TupleConcat(
                                    hv_WindowHandleConfusionAbsolute);
                                hv_WindowHandlesConfusion.Dispose();
                                hv_WindowHandlesConfusion = ExpTmpLocalVar_WindowHandlesConfusion;
                            }
                        }
                    }
                    if ((int)(hv_DisplayConfusionRelative) != 0)
                    {
                        hv_WindowExists.Dispose();
                        HOperatorSet.GetDictParam(hv_WindowHandleDict_COPY_INP_TMP, "key_exists",
                            "window_relative_confusion_matrix", out hv_WindowExists);
                        if ((int)(hv_WindowExists.TupleNot()) != 0)
                        {
                            HOperatorSet.SetWindowAttr("background_color", "black");
                            HOperatorSet.OpenWindow(hv_BaseWindowRow, hv_BaseWindowColumn, 512, 512, 0, "visible", "", out hv_WindowHandleConfusionRelative);
                            HDevWindowStack.Push(hv_WindowHandleConfusionRelative);
                            HOperatorSet.SetDictTuple(hv_WindowHandleDict_COPY_INP_TMP, "window_relative_confusion_matrix",
                                hv_WindowHandleConfusionRelative);
                        }
                        else
                        {
                            hv_WindowHandleConfusionRelative.Dispose();
                            HOperatorSet.GetDictTuple(hv_WindowHandleDict_COPY_INP_TMP, "window_relative_confusion_matrix",
                                out hv_WindowHandleConfusionRelative);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_WindowHandlesConfusion = hv_WindowHandlesConfusion.TupleConcat(
                                    hv_WindowHandleConfusionRelative);
                                hv_WindowHandlesConfusion.Dispose();
                                hv_WindowHandlesConfusion = ExpTmpLocalVar_WindowHandlesConfusion;
                            }
                        }
                    }
                    dev_display_detection_confusion_matrix(hv_WindowHandlesConfusion, hv_IoUEvaluationResult,
                        hv_ClassIDs, hv_GenParam_COPY_INP_TMP);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_WindowHandleDict = hv_WindowHandleDict_COPY_INP_TMP.TupleConcat(
                                hv_WindowHandlesConfusion);
                            hv_WindowHandleDict_COPY_INP_TMP.Dispose();
                            hv_WindowHandleDict_COPY_INP_TMP = ExpTmpLocalVar_WindowHandleDict;
                        }
                    }
                }
                //
                //Rearrange windows.
                //If all four windows are used we display the pie-charts to the left,
                //while to the right the confusion matrices are shown below each other.
                //Else, if the pie-charts are not displayed, we display the confusion matrices next to each other.
                if ((int)(new HTuple((new HTuple(hv_WindowHandleDict_COPY_INP_TMP.TupleLength()
                    )).TupleGreaterEqual(1))) != 0)
                {
                    hv_ColConfusion.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ColConfusion = new HTuple();
                        hv_ColConfusion = hv_ColConfusion.TupleConcat(hv_BaseWindowColumn, hv_BaseWindowColumn);
                    }
                    hv_RowConfusion.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_RowConfusion = new HTuple();
                        hv_RowConfusion = hv_RowConfusion.TupleConcat(hv_BaseWindowRow, hv_BaseWindowRow);
                    }
                    hv_WidthConf.Dispose();
                    hv_WidthConf = -1;
                    hv_HeightConf.Dispose();
                    hv_HeightConf = -1;
                    if ((int)(hv_DisplayPieChartsPrecision.TupleOr(hv_DisplayPieChartsRecall)) != 0)
                    {
                        if ((int)(hv_DisplayPieChartsPrecision) != 0)
                        {
                            hv__.Dispose(); hv__.Dispose(); hv_Width.Dispose(); hv_Height.Dispose();
                            HOperatorSet.GetWindowExtents(hv_WindowHandlePieChartsPrecision, out hv__,
                                out hv__, out hv_Width, out hv_Height);
                            HDevWindowStack.SetActive(hv_WindowHandlePieChartsPrecision);
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_BaseWindowRow,
                                    hv_BaseWindowColumn, hv_Width, hv_Height);
                            }
                        }
                        else
                        {
                            hv__.Dispose(); hv__.Dispose(); hv_Width.Dispose(); hv_Height.Dispose();
                            HOperatorSet.GetWindowExtents(hv_WindowHandlePieChartsRecall, out hv__,
                                out hv__, out hv_Width, out hv_Height);
                            if ((int)(hv_DisplayPieChartsPrecision.TupleNot()) != 0)
                            {
                                HDevWindowStack.SetActive(hv_WindowHandlePieChartsRecall);
                                if (HDevWindowStack.IsOpen())
                                {
                                    HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_BaseWindowRow,
                                        hv_BaseWindowColumn, hv_Width, hv_Height);
                                }
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_ColConfusion = (hv_ColConfusion + hv_Width) + 8;
                                hv_ColConfusion.Dispose();
                                hv_ColConfusion = ExpTmpLocalVar_ColConfusion;
                            }
                        }
                        if ((int)(hv_DisplayPieChartsPrecision.TupleAnd(hv_DisplayPieChartsRecall)) != 0)
                        {
                            HDevWindowStack.SetActive(hv_WindowHandlePieChartsRecall);
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), (hv_BaseWindowRow + hv_Height) + 55,
                                        hv_BaseWindowColumn, hv_Width, hv_Height);
                                }
                            }
                        }
                    }
                    if ((int)(hv_DisplayConfusionAbsolute) != 0)
                    {
                        hv_Row.Dispose(); hv_Column.Dispose(); hv_WidthConf.Dispose(); hv_HeightConf.Dispose();
                        HOperatorSet.GetWindowExtents(hv_WindowHandleConfusionAbsolute, out hv_Row,
                            out hv_Column, out hv_WidthConf, out hv_HeightConf);
                        HDevWindowStack.SetActive(hv_WindowHandleConfusionAbsolute);
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_RowConfusion.TupleSelect(
                                    0), hv_ColConfusion.TupleSelect(0), hv_WidthConf, hv_HeightConf);
                            }
                        }
                        if ((int)(hv_DisplayPieChartsPrecision.TupleOr(hv_DisplayPieChartsRecall)) != 0)
                        {
                            if (hv_RowConfusion == null)
                                hv_RowConfusion = new HTuple();
                            hv_RowConfusion[1] = ((hv_RowConfusion.TupleSelect(1)) + hv_HeightConf) + 55;
                        }
                        else
                        {
                            if (hv_ColConfusion == null)
                                hv_ColConfusion = new HTuple();
                            hv_ColConfusion[1] = ((hv_ColConfusion.TupleSelect(1)) + hv_WidthConf) + 8;
                        }
                    }
                    if ((int)(hv_DisplayConfusionRelative) != 0)
                    {
                        HDevWindowStack.SetActive(hv_WindowHandleConfusionRelative);
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_RowConfusion.TupleSelect(
                                    1), hv_ColConfusion.TupleSelect(1), hv_WidthConf, hv_HeightConf);
                            }
                        }
                    }
                }
                //

                hv_GenParam_COPY_INP_TMP.Dispose();
                hv_WindowHandleDict_COPY_INP_TMP.Dispose();
                hv_DisplayPieChartsPrecision.Dispose();
                hv_DisplayPieChartsRecall.Dispose();
                hv_DisplayConfusionAbsolute.Dispose();
                hv_DisplayConfusionRelative.Dispose();
                hv_BaseWindowRow.Dispose();
                hv_BaseWindowColumn.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_AvailableIoUThresholds.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_ClassIDs.Dispose();
                hv_IoUThreshold.Dispose();
                hv_AreaRangeName.Dispose();
                hv_MaxNumDetStr.Dispose();
                hv_MaxNumEvaluationResult.Dispose();
                hv_AreaEvaluationResult.Dispose();
                hv_IoUEvaluationResult.Dispose();
                hv_GenParamKeys.Dispose();
                hv_Keys.Dispose();
                hv_IndexKeys.Dispose();
                hv_KeyExists.Dispose();
                hv_Value.Dispose();
                hv_Exception.Dispose();
                hv_WindowExists.Dispose();
                hv_WindowHandlePieChartsPrecision.Dispose();
                hv_WindowHandlePieChartsRecall.Dispose();
                hv_WindowHandlesConfusion.Dispose();
                hv_WindowHandleConfusionAbsolute.Dispose();
                hv_WindowHandleConfusionRelative.Dispose();
                hv_ColConfusion.Dispose();
                hv_RowConfusion.Dispose();
                hv_WidthConf.Dispose();
                hv_HeightConf.Dispose();
                hv__.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_GenParam_COPY_INP_TMP.Dispose();
                hv_WindowHandleDict_COPY_INP_TMP.Dispose();
                hv_DisplayPieChartsPrecision.Dispose();
                hv_DisplayPieChartsRecall.Dispose();
                hv_DisplayConfusionAbsolute.Dispose();
                hv_DisplayConfusionRelative.Dispose();
                hv_BaseWindowRow.Dispose();
                hv_BaseWindowColumn.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_AvailableIoUThresholds.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_ClassIDs.Dispose();
                hv_IoUThreshold.Dispose();
                hv_AreaRangeName.Dispose();
                hv_MaxNumDetStr.Dispose();
                hv_MaxNumEvaluationResult.Dispose();
                hv_AreaEvaluationResult.Dispose();
                hv_IoUEvaluationResult.Dispose();
                hv_GenParamKeys.Dispose();
                hv_Keys.Dispose();
                hv_IndexKeys.Dispose();
                hv_KeyExists.Dispose();
                hv_Value.Dispose();
                hv_Exception.Dispose();
                hv_WindowExists.Dispose();
                hv_WindowHandlePieChartsPrecision.Dispose();
                hv_WindowHandlePieChartsRecall.Dispose();
                hv_WindowHandlesConfusion.Dispose();
                hv_WindowHandleConfusionAbsolute.Dispose();
                hv_WindowHandleConfusionRelative.Dispose();
                hv_ColConfusion.Dispose();
                hv_RowConfusion.Dispose();
                hv_WidthConf.Dispose();
                hv_HeightConf.Dispose();
                hv__.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Display a pie-chart for the evaluation results of one class or all classes together. 
        public void dev_display_detection_eval_class_pie_chart(HTuple hv_WindowHandle,
            HTuple hv_ClassEvaluationResult, HTuple hv_CenterRow, HTuple hv_Mode, HTuple hv_CenterColumn,
            HTuple hv_Radius, HTuple hv_Colors, HTuple hv_Title, out HTuple hv_Ratios)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_ContCircle, ho_SectorFP;

            // Local control variables 

            HTuple hv_Keys = new HTuple(), hv_Numbers = new HTuple();
            HTuple hv_K = new HTuple(), hv_Num = new HTuple(), hv_NumTotal = new HTuple();
            HTuple hv_ColorsPieChart = new HTuple(), hv_GenParamPieChart = new HTuple();
            HTuple hv_NumFP = new HTuple(), hv_FullCircleAngle = new HTuple();
            HTuple hv_Row = new HTuple(), hv_Col = new HTuple(), hv_HomMat2DIdentity = new HTuple();
            HTuple hv_HomMat2DRotate = new HTuple(), hv_ContourStyle = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ContCircle);
            HOperatorSet.GenEmptyObj(out ho_SectorFP);
            hv_Ratios = new HTuple();
            try
            {
                //This procedure displays the evaluation results
                //in the dictionary ClassEvaluationResult as a pie-chart.
                //Thereby, the procedure plots one pie-chart
                //for a specific class or all classes together.
                //
                //num_fp has to be handled separately.
                if ((int)(new HTuple(hv_Mode.TupleEqual("precision"))) != 0)
                {
                    hv_Keys.Dispose();
                    hv_Keys = new HTuple();
                    hv_Keys[0] = "num_tp";
                    hv_Keys[1] = "num_fp_class";
                    hv_Keys[2] = "num_fp_background";
                    hv_Keys[3] = "num_fp_localization";
                    hv_Keys[4] = "num_fp_duplicate";
                    hv_Keys[5] = "num_fp_multiple";
                }
                else
                {
                    hv_Keys.Dispose();
                    hv_Keys = new HTuple();
                    hv_Keys[0] = "num_tp";
                    hv_Keys[1] = "num_fn";
                }
                hv_Numbers.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Numbers = HTuple.TupleGenConst(
                        new HTuple(hv_Keys.TupleLength()), 0);
                }
                for (hv_K = 0; (int)hv_K <= (int)((new HTuple(hv_Keys.TupleLength())) - 1); hv_K = (int)hv_K + 1)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Num.Dispose();
                        HOperatorSet.GetDictTuple(hv_ClassEvaluationResult, hv_Keys.TupleSelect(hv_K),
                            out hv_Num);
                    }
                    if (hv_Numbers == null)
                        hv_Numbers = new HTuple();
                    hv_Numbers[hv_K] = hv_Num;
                }
                hv_NumTotal.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumTotal = hv_Numbers.TupleSum()
                        ;
                }
                hv_ColorsPieChart.Dispose();
                hv_ColorsPieChart = new HTuple(hv_Colors);
                if ((int)(new HTuple(hv_NumTotal.TupleEqual(0))) != 0)
                {
                    //No predictions available, we print a full gray circle.
                    hv_Ratios.Dispose();
                    hv_Ratios = 1.0;
                    hv_ColorsPieChart.Dispose();
                    hv_ColorsPieChart = "gray";
                }
                else
                {
                    hv_Ratios.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Ratios = (hv_Numbers.TupleReal()
                            ) / hv_NumTotal;
                    }
                }
                //
                //Draw the pie-chart.
                hv_GenParamPieChart.Dispose();
                HOperatorSet.CreateDict(out hv_GenParamPieChart);
                if ((int)(new HTuple(hv_Title.TupleNotEqual(""))) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_GenParamPieChart, "title", hv_Title);
                }
                dev_display_pie_chart(hv_WindowHandle, hv_Ratios, hv_CenterRow, hv_CenterColumn,
                    hv_Radius, hv_ColorsPieChart, hv_GenParamPieChart);
                //
                //Highlight total number of false positives.
                if ((int)(new HTuple(hv_NumTotal.TupleGreater(0))) != 0)
                {
                    //Add ratio of all false positives to output if there are any detections.
                    hv_NumFP.Dispose();
                    HOperatorSet.GetDictTuple(hv_ClassEvaluationResult, "num_fp", out hv_NumFP);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Ratios = hv_Ratios.TupleConcat(
                                (hv_NumFP.TupleReal()) / hv_NumTotal);
                            hv_Ratios.Dispose();
                            hv_Ratios = ExpTmpLocalVar_Ratios;
                        }
                    }
                }
                hv_FullCircleAngle.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_FullCircleAngle = 2 * 3.14159;
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_ContCircle.Dispose();
                    HOperatorSet.GenCircleContourXld(out ho_ContCircle, hv_CenterRow, hv_CenterColumn,
                        hv_Radius + 2, (hv_Ratios.TupleSelect(0)) * hv_FullCircleAngle, hv_FullCircleAngle,
                        "positive", 1);
                }
                hv_Row.Dispose(); hv_Col.Dispose();
                HOperatorSet.GetContourXld(ho_ContCircle, out hv_Row, out hv_Col);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_SectorFP.Dispose();
                    HOperatorSet.GenContourPolygonXld(out ho_SectorFP, ((hv_CenterRow.TupleConcat(
                        hv_Row))).TupleConcat(hv_CenterRow), ((hv_CenterColumn.TupleConcat(hv_Col))).TupleConcat(
                        hv_CenterColumn));
                }
                //Rotate.
                hv_HomMat2DIdentity.Dispose();
                HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HomMat2DRotate.Dispose();
                    HOperatorSet.HomMat2dRotate(hv_HomMat2DIdentity, 0.25 * hv_FullCircleAngle, hv_CenterRow,
                        hv_CenterColumn, out hv_HomMat2DRotate);
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.AffineTransContourXld(ho_SectorFP, out ExpTmpOutVar_0, hv_HomMat2DRotate);
                    ho_SectorFP.Dispose();
                    ho_SectorFP = ExpTmpOutVar_0;
                }
                HDevWindowStack.SetActive(hv_WindowHandle);
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_ColorsPieChart.TupleSelect(
                            (new HTuple(hv_ColorsPieChart.TupleLength())) - 1));
                    }
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 3);
                }
                hv_ContourStyle.Dispose();
                HOperatorSet.GetContourStyle(hv_WindowHandle, out hv_ContourStyle);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetContourStyle(HDevWindowStack.GetActive(), "stroke");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispObj(ho_SectorFP, HDevWindowStack.GetActive());
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetContourStyle(HDevWindowStack.GetActive(), hv_ContourStyle);
                }
                ho_ContCircle.Dispose();
                ho_SectorFP.Dispose();

                hv_Keys.Dispose();
                hv_Numbers.Dispose();
                hv_K.Dispose();
                hv_Num.Dispose();
                hv_NumTotal.Dispose();
                hv_ColorsPieChart.Dispose();
                hv_GenParamPieChart.Dispose();
                hv_NumFP.Dispose();
                hv_FullCircleAngle.Dispose();
                hv_Row.Dispose();
                hv_Col.Dispose();
                hv_HomMat2DIdentity.Dispose();
                hv_HomMat2DRotate.Dispose();
                hv_ContourStyle.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_ContCircle.Dispose();
                ho_SectorFP.Dispose();

                hv_Keys.Dispose();
                hv_Numbers.Dispose();
                hv_K.Dispose();
                hv_Num.Dispose();
                hv_NumTotal.Dispose();
                hv_ColorsPieChart.Dispose();
                hv_GenParamPieChart.Dispose();
                hv_NumFP.Dispose();
                hv_FullCircleAngle.Dispose();
                hv_Row.Dispose();
                hv_Col.Dispose();
                hv_HomMat2DIdentity.Dispose();
                hv_HomMat2DRotate.Dispose();
                hv_ContourStyle.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Display the evaluation results as pie-charts. 
        public void dev_display_detection_evaluation_pie_charts(HTuple hv_WindowHandle,
            HTuple hv_IoUEvaluationResult, HTuple hv_ClassIDs, HTuple hv_Mode, HTuple hv_BaseWindowRow,
            HTuple hv_BaseWindowColumn)
        {



            // Local iconic variables 

            HObject ho_Image;

            // Local control variables 

            HTuple hv_FlushValue = new HTuple(), hv_CenterRowOverall = new HTuple();
            HTuple hv_CenterColOverall = new HTuple(), hv_RadiusOverall = new HTuple();
            HTuple hv_ClassChartsPerRow = new HTuple(), hv_RadiusClass = new HTuple();
            HTuple hv_ChartRowDistance = new HTuple(), hv_ChartColDistance = new HTuple();
            HTuple hv_StartRow = new HTuple(), hv_StartCol = new HTuple();
            HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
            HTuple hv_NumColors = new HTuple(), hv_Colors = new HTuple();
            HTuple hv_ColorsFP = new HTuple(), hv_Ratios = new HTuple();
            HTuple hv_Descriptions = new HTuple(), hv_IoUThreshold = new HTuple();
            HTuple hv_PercentStr = new HTuple(), hv_IndexDescription = new HTuple();
            HTuple hv_C = new HTuple(), hv_CenterRow = new HTuple();
            HTuple hv_CenterCol = new HTuple(), hv_ClassEvaluationResult = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Image);
            try
            {
                //Display the detailed evaluation results for TP and FP as pie-charts.
                //
                //Switch off automatic flushing to make visualization smooth.
                hv_FlushValue.Dispose();
                HOperatorSet.GetWindowParam(hv_WindowHandle, "flush", out hv_FlushValue);
                HOperatorSet.SetWindowParam(hv_WindowHandle, "flush", "false");
                //Drawing parameters.
                //Overall pie-chart.
                hv_CenterRowOverall.Dispose();
                hv_CenterRowOverall = 150;
                hv_CenterColOverall.Dispose();
                hv_CenterColOverall = 150;
                hv_RadiusOverall.Dispose();
                hv_RadiusOverall = 100;
                //Per-class pie-chart.
                hv_ClassChartsPerRow.Dispose();
                hv_ClassChartsPerRow = 10;
                hv_RadiusClass.Dispose();
                hv_RadiusClass = 40;
                hv_ChartRowDistance.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ChartRowDistance = 3 * hv_RadiusClass;
                }
                hv_ChartColDistance.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ChartColDistance = 2.5 * hv_RadiusClass;
                }
                hv_StartRow.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_StartRow = (hv_CenterRowOverall + (1.5 * hv_RadiusOverall)) + (1.5 * hv_RadiusClass);
                }
                hv_StartCol.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_StartCol = 1.5 * hv_RadiusClass;
                }
                //
                //Open Window and set font.
                hv_WindowWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowWidth = (new HTuple(600)).TupleMax2(
                        ((((new HTuple(hv_ClassIDs.TupleLength())).TupleMin2(hv_ClassChartsPerRow)) - 1) * hv_ChartColDistance) + (2 * hv_StartCol));
                }
                hv_WindowHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowHeight = (3 * hv_RadiusOverall) + (((((((new HTuple(hv_ClassIDs.TupleLength()
                        )).TupleReal()) / hv_ClassChartsPerRow)).TupleCeil()) * 3) * hv_RadiusClass);
                }
                HDevWindowStack.SetActive(hv_WindowHandle);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_BaseWindowRow,
                        hv_BaseWindowColumn, hv_WindowWidth, hv_WindowHeight);
                }
                ho_Image.Dispose();
                HOperatorSet.GenImageConst(out ho_Image, "byte", hv_WindowWidth, hv_WindowHeight);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                }
                set_display_font(hv_WindowHandle, 15, "mono", "true", "false");
                //
                //Generate different red colors for false positive categories.
                if ((int)(new HTuple(hv_Mode.TupleEqual("precision"))) != 0)
                {
                    hv_NumColors.Dispose();
                    hv_NumColors = 7;
                }
                else
                {
                    hv_NumColors.Dispose();
                    hv_NumColors = 2;
                }
                hv_Colors.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Colors = HTuple.TupleGenConst(
                        hv_NumColors, "");
                }
                if (hv_Colors == null)
                    hv_Colors = new HTuple();
                hv_Colors[0] = "green";
                if (hv_Colors == null)
                    hv_Colors = new HTuple();
                hv_Colors[hv_NumColors - 1] = "red";
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ColorsFP.Dispose();
                    get_distinct_colors(hv_NumColors - 1, 0, 10, 45, out hv_ColorsFP);
                }
                if (hv_Colors == null)
                    hv_Colors = new HTuple();
                hv_Colors[HTuple.TupleGenSequence(1, hv_NumColors - 2, 1)] = hv_ColorsFP.TupleSelectRange(
                    1, (new HTuple(hv_ColorsFP.TupleLength())) - 1);
                //
                hv_Ratios.Dispose();
                dev_display_detection_eval_class_pie_chart(hv_WindowHandle, hv_IoUEvaluationResult,
                    hv_CenterRowOverall, hv_Mode, hv_CenterColOverall, hv_RadiusOverall, hv_Colors,
                    "All classes", out hv_Ratios);
                //
                //Write descriptions for overall pie-chart.
                if ((int)(new HTuple((new HTuple(hv_Ratios.TupleLength())).TupleGreater(1))) != 0)
                {
                    if ((int)(new HTuple(hv_Mode.TupleEqual("precision"))) != 0)
                    {
                        hv_Descriptions.Dispose();
                        hv_Descriptions = new HTuple();
                        hv_Descriptions[0] = "true positives";
                        hv_Descriptions[1] = "false positives: wrong class";
                        hv_Descriptions[2] = "false positives: background";
                        hv_Descriptions[3] = "false positives: bad localization";
                        hv_Descriptions[4] = "false positives: duplicate";
                        hv_Descriptions[5] = "false positives: multiple reasons";
                        hv_Descriptions[6] = "false positives: total";
                    }
                    else
                    {
                        hv_Descriptions.Dispose();
                        hv_Descriptions = new HTuple();
                        hv_Descriptions[0] = "recall (TP / (TP + FN))";
                        hv_Descriptions[1] = "false negatives";
                    }
                    hv_IoUThreshold.Dispose();
                    HOperatorSet.GetDictTuple(hv_IoUEvaluationResult, "iou_threshold", out hv_IoUThreshold);
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), "Results @ IoU: " + hv_IoUThreshold,
                                "image", 20, (hv_CenterColOverall + hv_RadiusOverall) + 20, "white", "box",
                                "false");
                        }
                    }
                    hv_PercentStr.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_PercentStr = (((hv_Ratios * 100)).TupleString(
                            ".1f")) + "";
                    }
                    for (hv_IndexDescription = 0; (int)hv_IndexDescription <= (int)((new HTuple(hv_Descriptions.TupleLength()
                        )) - 2); hv_IndexDescription = (int)hv_IndexDescription + 1)
                    {
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), ((hv_PercentStr.TupleSelect(
                                    hv_IndexDescription)) + "%: ") + (hv_Descriptions.TupleSelect(hv_IndexDescription)),
                                    "image", 30 + ((hv_IndexDescription + 1) * 20), (hv_CenterColOverall + hv_RadiusOverall) + 20,
                                    hv_Colors.TupleSelect(hv_IndexDescription), "box", "false");
                            }
                        }
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), ((hv_PercentStr.TupleSelect(
                                hv_IndexDescription)) + "%: ") + (hv_Descriptions.TupleSelect(hv_IndexDescription)),
                                "image", 30 + ((hv_IndexDescription + 1) * 20), (hv_CenterColOverall + hv_RadiusOverall) + 20,
                                hv_Colors.TupleSelect(hv_IndexDescription), "box", "false");
                        }
                    }
                }
                else
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), "There are no predictions",
                                "image", 30, (hv_CenterColOverall + hv_RadiusOverall) + 20, "white", "box",
                                "false");
                        }
                    }
                }
                //
                //
                //Per-class pie-charts.
                //
                for (hv_C = 0; (int)hv_C <= (int)((new HTuple(hv_ClassIDs.TupleLength())) - 1); hv_C = (int)hv_C + 1)
                {
                    //Get the position of the class-pie-chart.
                    hv_CenterRow.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CenterRow = hv_StartRow + (((((hv_C.TupleReal()
                            ) / hv_ClassChartsPerRow)).TupleFloor()) * hv_ChartRowDistance);
                    }
                    hv_CenterCol.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CenterCol = hv_StartCol + ((hv_C % hv_ClassChartsPerRow) * hv_ChartColDistance);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassEvaluationResult.Dispose();
                        HOperatorSet.GetDictTuple(hv_IoUEvaluationResult, "class_" + (hv_ClassIDs.TupleSelect(
                            hv_C)), out hv_ClassEvaluationResult);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Ratios.Dispose();
                        dev_display_detection_eval_class_pie_chart(hv_WindowHandle, hv_ClassEvaluationResult,
                            hv_CenterRow, hv_Mode, hv_CenterCol, hv_RadiusClass, hv_Colors, "Class " + (hv_ClassIDs.TupleSelect(
                            hv_C)), out hv_Ratios);
                    }
                }
                //
                //Flush buffer and reset value for 'flush'.
                HOperatorSet.FlushBuffer(hv_WindowHandle);
                HOperatorSet.SetWindowParam(hv_WindowHandle, "flush", hv_FlushValue);
                //
                ho_Image.Dispose();

                hv_FlushValue.Dispose();
                hv_CenterRowOverall.Dispose();
                hv_CenterColOverall.Dispose();
                hv_RadiusOverall.Dispose();
                hv_ClassChartsPerRow.Dispose();
                hv_RadiusClass.Dispose();
                hv_ChartRowDistance.Dispose();
                hv_ChartColDistance.Dispose();
                hv_StartRow.Dispose();
                hv_StartCol.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_NumColors.Dispose();
                hv_Colors.Dispose();
                hv_ColorsFP.Dispose();
                hv_Ratios.Dispose();
                hv_Descriptions.Dispose();
                hv_IoUThreshold.Dispose();
                hv_PercentStr.Dispose();
                hv_IndexDescription.Dispose();
                hv_C.Dispose();
                hv_CenterRow.Dispose();
                hv_CenterCol.Dispose();
                hv_ClassEvaluationResult.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Image.Dispose();

                hv_FlushValue.Dispose();
                hv_CenterRowOverall.Dispose();
                hv_CenterColOverall.Dispose();
                hv_RadiusOverall.Dispose();
                hv_ClassChartsPerRow.Dispose();
                hv_RadiusClass.Dispose();
                hv_ChartRowDistance.Dispose();
                hv_ChartColDistance.Dispose();
                hv_StartRow.Dispose();
                hv_StartCol.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_NumColors.Dispose();
                hv_Colors.Dispose();
                hv_ColorsFP.Dispose();
                hv_Ratios.Dispose();
                hv_Descriptions.Dispose();
                hv_IoUThreshold.Dispose();
                hv_PercentStr.Dispose();
                hv_IndexDescription.Dispose();
                hv_C.Dispose();
                hv_CenterRow.Dispose();
                hv_CenterCol.Dispose();
                hv_ClassEvaluationResult.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Visualize different images, annotations and inference results for a sample. 
        public void dev_display_dl_data(HTuple hv_DLSample, HTuple hv_DLResult, HTuple hv_DLDatasetInfo,
            HTuple hv_KeysForDisplay, HTuple hv_GenParam, HTuple hv_WindowHandleDict)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Image = null, ho_AnomalyImage = null;
            HObject ho_AnomalyRegion = null, ho_PredictionColorFrame = null;
            HObject ho_ImageHeatmap = null, ho_ImageWeight = null, ho_ImageConfidence = null;
            HObject ho_SegmentationImagGroundTruth = null, ho_SegmentationImageResult = null;
            HObject ho_ImageAbsDiff = null, ho_DiffRegion = null;

            // Local control variables 

            HTuple hv_ThresholdWidth = new HTuple(), hv_ScaleWindows = new HTuple();
            HTuple hv_Font = new HTuple(), hv_FontSize = new HTuple();
            HTuple hv_LineWidth = new HTuple(), hv_MapTransparency = new HTuple();
            HTuple hv_MapColorBarWidth = new HTuple(), hv_AnomalyRegionThreshold = new HTuple();
            HTuple hv_AnomalyClassificationThreshold = new HTuple();
            HTuple hv_AnomalyRegionLabelColor = new HTuple(), hv_AnomalyColorTransparency = new HTuple();
            HTuple hv_AnomalyRegionResultColor = new HTuple(), hv_SegMaxWeight = new HTuple();
            HTuple hv_SegDraw = new HTuple(), hv_SegTransparency = new HTuple();
            HTuple hv_SegExcludeClassIDs = new HTuple(), hv_BboxLabelColor = new HTuple();
            HTuple hv_BboxDisplayConfidence = new HTuple(), hv_BboxTextColor = new HTuple();
            HTuple hv_ShowBottomDesc = new HTuple(), hv_ShowLegend = new HTuple();
            HTuple hv_ShowGroundTruthAnomalyRegions = new HTuple();
            HTuple hv_ShowClassificationIDs = new HTuple(), hv_ShowClassificationColorFrame = new HTuple();
            HTuple hv_ShowLabels = new HTuple(), hv_ShowDirection = new HTuple();
            HTuple hv_HeatmapColorScheme = new HTuple(), hv_GenParamNames = new HTuple();
            HTuple hv_ParamIndex = new HTuple(), hv_GenParamName = new HTuple();
            HTuple hv_GenParamValue = new HTuple(), hv_SampleKeys = new HTuple();
            HTuple hv_ResultKeys = new HTuple(), hv_ImageIDExists = new HTuple();
            HTuple hv_ImageID = new HTuple(), hv_ImageIDString = new HTuple();
            HTuple hv_ImageIDStringBraces = new HTuple(), hv_ImageIDStringCapital = new HTuple();
            HTuple hv_NeededKeys = new HTuple(), hv_Index = new HTuple();
            HTuple hv_DLDatasetInfoKeys = new HTuple(), hv_ClassNames = new HTuple();
            HTuple hv_ClassIDs = new HTuple(), hv_Colors = new HTuple();
            HTuple hv_ClassesLegend = new HTuple(), hv_PrevWindowCoordinates = new HTuple();
            HTuple hv_Keys = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_MetaInfoIndex = new HTuple(), hv_MetaInfo = new HTuple();
            HTuple hv_FlushValues = new HTuple(), hv_WindowHandleKeys = new HTuple();
            HTuple hv_KeyIndex = new HTuple(), hv_WindowHandles = new HTuple();
            HTuple hv_WindowIndex = new HTuple(), hv_FlushValue = new HTuple();
            HTuple hv_WidthImage = new HTuple(), hv_HeightImage = new HTuple();
            HTuple hv_CurrentWindowHandle = new HTuple(), hv_WindowImageRatio = new HTuple();
            HTuple hv_AnomalyLabelGroundTruth = new HTuple(), hv_AnomalyLabelIDGroundTruth = new HTuple();
            HTuple hv_AnomalyRegionExists = new HTuple(), hv_Text = new HTuple();
            HTuple hv_AnomalyScore = new HTuple(), hv_AnomalyClassID = new HTuple();
            HTuple hv_AnomalyRegionGroundTruthExists = new HTuple();
            HTuple hv_PredictionColor = new HTuple(), hv_LineColors = new HTuple();
            HTuple hv_ClassificationLabelIDGroundTruth = new HTuple();
            HTuple hv_ClassificationLabelIDResult = new HTuple(), hv_MarginBottom = new HTuple();
            HTuple hv_WindowCoordinates = new HTuple(), hv_CurrentWindowHeight = new HTuple();
            HTuple hv__ = new HTuple(), hv_MaxHeight = new HTuple();
            HTuple hv_PredictionText = new HTuple(), hv_BoarderOffset = new HTuple();
            HTuple hv_WindowImageRatioHeight = new HTuple(), hv_WindowImageRatioWidth = new HTuple();
            HTuple hv_BoarderOffsetRow = new HTuple(), hv_BoarderOffsetCol = new HTuple();
            HTuple hv_SelectedHeatmapMethod = new HTuple(), hv_DictHeatmap = new HTuple();
            HTuple hv_MethodName = new HTuple(), hv_HeatmapKeys = new HTuple();
            HTuple hv_HeatmapImageName = new HTuple(), hv_TargetClassID = new HTuple();
            HTuple hv_Confidences = new HTuple(), hv_MaxDeviation = new HTuple();
            HTuple hv_ClassificationLabelNameResult = new HTuple();
            HTuple hv_TargetClassConfidence = new HTuple(), hv_ClassificationLabelNamesGroundTruth = new HTuple();
            HTuple hv_BboxIDs = new HTuple(), hv_BboxColors = new HTuple();
            HTuple hv_BboxIDsUniq = new HTuple(), hv_BboxConfidences = new HTuple();
            HTuple hv_TextConf = new HTuple(), hv_BboxClassIndex = new HTuple();
            HTuple hv_BboxColorsResults = new HTuple(), hv_BboxClassIndexUniq = new HTuple();
            HTuple hv_BboxLabelIndex = new HTuple(), hv_BboxColorsBoth = new HTuple();
            HTuple hv_BboxClassLabelIndexUniq = new HTuple(), hv_ColorsSegmentation = new HTuple();
            HTuple hv_DrawMode = new HTuple(), hv_Width = new HTuple();
            HTuple hv_ImageClassIDs = new HTuple(), hv_ImageClassIDsUniq = new HTuple();
            HTuple hv_ColorsResults = new HTuple(), hv_GroundTruthIDs = new HTuple();
            HTuple hv_ResultIDs = new HTuple(), hv_StringSegExcludeClassIDs = new HTuple();
            HTuple hv_StringIndex = new HTuple(), hv_Min = new HTuple();
            HTuple hv_Max = new HTuple(), hv_Range = new HTuple();
            HTuple hv_MinWeight = new HTuple(), hv_WeightsColors = new HTuple();
            HTuple hv_ConfidenceColors = new HTuple(), hv_Indices = new HTuple();
            HTuple hv_WindowHandleKeysNew = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Image);
            HOperatorSet.GenEmptyObj(out ho_AnomalyImage);
            HOperatorSet.GenEmptyObj(out ho_AnomalyRegion);
            HOperatorSet.GenEmptyObj(out ho_PredictionColorFrame);
            HOperatorSet.GenEmptyObj(out ho_ImageHeatmap);
            HOperatorSet.GenEmptyObj(out ho_ImageWeight);
            HOperatorSet.GenEmptyObj(out ho_ImageConfidence);
            HOperatorSet.GenEmptyObj(out ho_SegmentationImagGroundTruth);
            HOperatorSet.GenEmptyObj(out ho_SegmentationImageResult);
            HOperatorSet.GenEmptyObj(out ho_ImageAbsDiff);
            HOperatorSet.GenEmptyObj(out ho_DiffRegion);
            try
            {
                //
                //This procedure displays the content of the provided DLSample and/or DLResult
                //depending on the input string KeysForDisplay.
                //DLDatasetInfo is a dictionary containing the information about the dataset.
                //The visualization can be adapted with GenParam.
                //
                //** Set the default values: ***
                //
                //Define the screen width when a new window row is started.
                hv_ThresholdWidth.Dispose();
                hv_ThresholdWidth = 1024;
                //Since potentially a lot of windows are opened,
                //scale the windows consistently.
                hv_ScaleWindows.Dispose();
                hv_ScaleWindows = 0.8;
                //Set a font and a font size.
                hv_Font.Dispose();
                hv_Font = "mono";
                hv_FontSize.Dispose();
                hv_FontSize = 14;
                //
                hv_LineWidth.Dispose();
                hv_LineWidth = 2;
                hv_MapTransparency.Dispose();
                hv_MapTransparency = "cc";
                hv_MapColorBarWidth.Dispose();
                hv_MapColorBarWidth = 140;
                //
                //Define anomaly detection-specific parameter values.
                hv_AnomalyRegionThreshold.Dispose();
                hv_AnomalyRegionThreshold = -1;
                hv_AnomalyClassificationThreshold.Dispose();
                hv_AnomalyClassificationThreshold = -1;
                hv_AnomalyRegionLabelColor.Dispose();
                hv_AnomalyRegionLabelColor = "#40e0d0";
                hv_AnomalyColorTransparency.Dispose();
                hv_AnomalyColorTransparency = "40";
                hv_AnomalyRegionResultColor.Dispose();
                hv_AnomalyRegionResultColor = "#ff0000c0";
                //
                //Define segmentation-specific parameter values.
                hv_SegMaxWeight.Dispose();
                hv_SegMaxWeight = 0;
                hv_SegDraw.Dispose();
                hv_SegDraw = "fill";
                hv_SegTransparency.Dispose();
                hv_SegTransparency = "aa";
                hv_SegExcludeClassIDs.Dispose();
                hv_SegExcludeClassIDs = new HTuple();
                //
                //Define bounding box-specific parameter values.
                hv_BboxLabelColor.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_BboxLabelColor = new HTuple("#000000") + "99";
                }
                hv_BboxDisplayConfidence.Dispose();
                hv_BboxDisplayConfidence = 1;
                hv_BboxTextColor.Dispose();
                hv_BboxTextColor = "#eeeeee";
                //
                //By default, display a description on the bottom.
                hv_ShowBottomDesc.Dispose();
                hv_ShowBottomDesc = 1;
                //
                //By default, show a legend with class IDs.
                hv_ShowLegend.Dispose();
                hv_ShowLegend = 1;
                //
                //By default, show the anomaly ground truth regions.
                hv_ShowGroundTruthAnomalyRegions.Dispose();
                hv_ShowGroundTruthAnomalyRegions = 1;
                //
                //By default, show class IDs and color frames for classification ground truth/results.
                hv_ShowClassificationIDs.Dispose();
                hv_ShowClassificationIDs = 1;
                hv_ShowClassificationColorFrame.Dispose();
                hv_ShowClassificationColorFrame = 1;
                //
                //By default, show class labels for detection ground truth/results.
                hv_ShowLabels.Dispose();
                hv_ShowLabels = 1;
                //
                //By default, show direction of the ground truth/results instances for detection with instance_type 'rectangle2'.
                hv_ShowDirection.Dispose();
                hv_ShowDirection = 1;
                //
                //By default, use color scheme 'Jet' for the heatmap display.
                hv_HeatmapColorScheme.Dispose();
                hv_HeatmapColorScheme = "jet";
                //** Set user defined values: ***
                //
                //Overwrite default values by given generic parameters.
                if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
                {
                    hv_GenParamNames.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_GenParamNames);
                    for (hv_ParamIndex = 0; (int)hv_ParamIndex <= (int)((new HTuple(hv_GenParamNames.TupleLength()
                        )) - 1); hv_ParamIndex = (int)hv_ParamIndex + 1)
                    {
                        hv_GenParamName.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_GenParamName = hv_GenParamNames.TupleSelect(
                                hv_ParamIndex);
                        }
                        hv_GenParamValue.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, hv_GenParamName, out hv_GenParamValue);
                        if ((int)(new HTuple(hv_GenParamName.TupleEqual("threshold_width"))) != 0)
                        {
                            hv_ThresholdWidth.Dispose();
                            hv_ThresholdWidth = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("scale_windows"))) != 0)
                        {
                            hv_ScaleWindows.Dispose();
                            hv_ScaleWindows = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("font"))) != 0)
                        {
                            hv_Font.Dispose();
                            hv_Font = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("font_size"))) != 0)
                        {
                            hv_FontSize.Dispose();
                            hv_FontSize = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("line_width"))) != 0)
                        {
                            hv_LineWidth.Dispose();
                            hv_LineWidth = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("map_transparency"))) != 0)
                        {
                            hv_MapTransparency.Dispose();
                            hv_MapTransparency = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("map_color_bar_width"))) != 0)
                        {
                            hv_MapColorBarWidth.Dispose();
                            hv_MapColorBarWidth = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("segmentation_max_weight"))) != 0)
                        {
                            hv_SegMaxWeight.Dispose();
                            hv_SegMaxWeight = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("segmentation_draw"))) != 0)
                        {
                            hv_SegDraw.Dispose();
                            hv_SegDraw = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("segmentation_transparency"))) != 0)
                        {
                            hv_SegTransparency.Dispose();
                            hv_SegTransparency = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("segmentation_exclude_class_ids"))) != 0)
                        {
                            hv_SegExcludeClassIDs.Dispose();
                            hv_SegExcludeClassIDs = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("bbox_label_color"))) != 0)
                        {
                            hv_BboxLabelColor.Dispose();
                            hv_BboxLabelColor = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("bbox_display_confidence"))) != 0)
                        {
                            hv_BboxDisplayConfidence.Dispose();
                            hv_BboxDisplayConfidence = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("bbox_text_color"))) != 0)
                        {
                            hv_BboxTextColor.Dispose();
                            hv_BboxTextColor = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("display_bottom_desc"))) != 0)
                        {
                            hv_ShowBottomDesc.Dispose();
                            hv_ShowBottomDesc = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("display_legend"))) != 0)
                        {
                            hv_ShowLegend.Dispose();
                            hv_ShowLegend = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("display_classification_ids"))) != 0)
                        {
                            hv_ShowClassificationIDs.Dispose();
                            hv_ShowClassificationIDs = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("display_classification_color_frame"))) != 0)
                        {
                            hv_ShowClassificationColorFrame.Dispose();
                            hv_ShowClassificationColorFrame = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("display_labels"))) != 0)
                        {
                            hv_ShowLabels.Dispose();
                            hv_ShowLabels = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("display_direction"))) != 0)
                        {
                            hv_ShowDirection.Dispose();
                            hv_ShowDirection = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("heatmap_color_scheme"))) != 0)
                        {
                            hv_HeatmapColorScheme.Dispose();
                            hv_HeatmapColorScheme = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("display_ground_truth_anomaly_regions"))) != 0)
                        {
                            hv_ShowGroundTruthAnomalyRegions.Dispose();
                            hv_ShowGroundTruthAnomalyRegions = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("anomaly_region_threshold"))) != 0)
                        {
                            hv_AnomalyRegionThreshold.Dispose();
                            hv_AnomalyRegionThreshold = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("anomaly_classification_threshold"))) != 0)
                        {
                            hv_AnomalyClassificationThreshold.Dispose();
                            hv_AnomalyClassificationThreshold = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("anomaly_region_label_color"))) != 0)
                        {
                            hv_AnomalyRegionLabelColor.Dispose();
                            hv_AnomalyRegionLabelColor = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("anomaly_region_result_color"))) != 0)
                        {
                            hv_AnomalyRegionResultColor.Dispose();
                            hv_AnomalyRegionResultColor = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("anomaly_color_transparency"))) != 0)
                        {
                            hv_AnomalyColorTransparency.Dispose();
                            hv_AnomalyColorTransparency = new HTuple(hv_GenParamValue);
                        }
                        else
                        {
                            throw new HalconException(("Unknown generic parameter: " + hv_GenParamName) + ".");
                        }
                    }
                }
                //
                //Get the dictionary keys.
                hv_SampleKeys.Dispose();
                HOperatorSet.GetDictParam(hv_DLSample, "keys", new HTuple(), out hv_SampleKeys);
                if ((int)(new HTuple(hv_DLResult.TupleNotEqual(new HTuple()))) != 0)
                {
                    hv_ResultKeys.Dispose();
                    HOperatorSet.GetDictParam(hv_DLResult, "keys", new HTuple(), out hv_ResultKeys);
                }
                //
                //Get image ID if it is available.
                hv_ImageIDExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "image_id", out hv_ImageIDExists);
                if ((int)(hv_ImageIDExists) != 0)
                {
                    hv_ImageID.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "image_id", out hv_ImageID);
                    hv_ImageIDString.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageIDString = "image ID " + hv_ImageID;
                    }
                    hv_ImageIDStringBraces.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageIDStringBraces = ("(image ID " + hv_ImageID) + ")";
                    }
                    hv_ImageIDStringCapital.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageIDStringCapital = "Image ID " + hv_ImageID;
                    }
                }
                else
                {
                    hv_ImageIDString.Dispose();
                    hv_ImageIDString = "";
                    hv_ImageIDStringBraces.Dispose();
                    hv_ImageIDStringBraces = new HTuple(hv_ImageIDString);
                    hv_ImageIDStringCapital.Dispose();
                    hv_ImageIDStringCapital = new HTuple(hv_ImageIDString);
                }
                //
                //Check if DLDatasetInfo is valid.
                if ((int)(new HTuple(hv_DLDatasetInfo.TupleEqual(new HTuple()))) != 0)
                {
                    //If DLDatasetInfo is empty, 'image' is the only key allowed in KeysForDisplay.
                    if ((int)((new HTuple((new HTuple(hv_KeysForDisplay.TupleLength())).TupleNotEqual(
                        1))).TupleOr(new HTuple(((hv_KeysForDisplay.TupleSelect(0))).TupleNotEqual(
                        "image")))) != 0)
                    {
                        throw new HalconException("DLDatasetInfo is needed for requested keys in KeysForDisplay.");
                    }
                }
                else
                {
                    //Check if DLDatasetInfo contains necessary keys.
                    hv_NeededKeys.Dispose();
                    hv_NeededKeys = new HTuple();
                    hv_NeededKeys[0] = "class_names";
                    hv_NeededKeys[1] = "class_ids";
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_NeededKeys.TupleLength()
                        )) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        hv_DLDatasetInfoKeys.Dispose();
                        HOperatorSet.GetDictParam(hv_DLDatasetInfo, "keys", new HTuple(), out hv_DLDatasetInfoKeys);
                        if ((int)(new HTuple(((hv_DLDatasetInfoKeys.TupleFindFirst(hv_NeededKeys.TupleSelect(
                            hv_Index)))).TupleEqual(-1))) != 0)
                        {
                            throw new HalconException(("Key " + (hv_NeededKeys.TupleSelect(
                                hv_Index))) + " is missing in DLDatasetInfo.");
                        }
                    }
                    //
                    //Get the general dataset information, if available.
                    hv_ClassNames.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLDatasetInfo, "class_names", out hv_ClassNames);
                    hv_ClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLDatasetInfo, "class_ids", out hv_ClassIDs);
                    //
                    //Define distinct colors for the classes.
                    hv_Colors.Dispose();
                    get_dl_class_colors(hv_ClassNames, out hv_Colors);
                    //
                    hv_ClassesLegend.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassesLegend = (hv_ClassIDs + " : ") + hv_ClassNames;
                    }
                }
                //
                //** Set window parameters: ***
                //
                //Set previous window coordinates.
                hv_PrevWindowCoordinates.Dispose();
                hv_PrevWindowCoordinates = new HTuple();
                hv_PrevWindowCoordinates[0] = 0;
                hv_PrevWindowCoordinates[1] = 0;
                hv_PrevWindowCoordinates[2] = 0;
                hv_PrevWindowCoordinates[3] = 0;
                hv_PrevWindowCoordinates[4] = 1;
                //
                //Check that the WindowHandleDict is of type dictionary.
                try
                {
                    hv_Keys.Dispose();
                    HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_Keys);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    if ((int)(new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(1401))) != 0)
                    {
                        throw new HalconException("WindowHandleDict has to be of type dictionary. Use create_dict to create an empty dictionary.");
                    }
                    else
                    {
                        throw new HalconException(hv_Exception);
                    }
                }
                //For better usage, add meta information about the window handles in WindowHandleDict.
                hv_MetaInfoIndex.Dispose();
                HOperatorSet.TupleFind(hv_Keys, "meta_information", out hv_MetaInfoIndex);
                if ((int)((new HTuple(hv_MetaInfoIndex.TupleEqual(-1))).TupleOr(new HTuple(hv_MetaInfoIndex.TupleEqual(
                    new HTuple())))) != 0)
                {
                    hv_MetaInfo.Dispose();
                    HOperatorSet.CreateDict(out hv_MetaInfo);
                    HOperatorSet.SetDictTuple(hv_WindowHandleDict, "meta_information", hv_MetaInfo);
                }
                //
                //For each window, set 'flush' to 'false' to avoid flickering.
                hv_FlushValues.Dispose();
                hv_FlushValues = new HTuple();
                hv_WindowHandleKeys.Dispose();
                HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_WindowHandleKeys);
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_WindowHandleKeys.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    //Only consider the WindowHandleKeys that are needed for the current visualization.
                    hv_KeyIndex.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_KeyIndex = hv_KeysForDisplay.TupleFind(
                            hv_WindowHandleKeys.TupleSelect(hv_Index));
                    }
                    if ((int)((new HTuple(hv_KeyIndex.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_KeyIndex.TupleNotEqual(
                        new HTuple())))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_WindowHandles.Dispose();
                            HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKeys.TupleSelect(
                                hv_Index), out hv_WindowHandles);
                        }
                        for (hv_WindowIndex = 0; (int)hv_WindowIndex <= (int)((new HTuple(hv_WindowHandles.TupleLength()
                            )) - 1); hv_WindowIndex = (int)hv_WindowIndex + 1)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_FlushValue.Dispose();
                                HOperatorSet.GetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex),
                                    "flush", out hv_FlushValue);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_FlushValues = hv_FlushValues.TupleConcat(
                                        hv_FlushValue);
                                    hv_FlushValues.Dispose();
                                    hv_FlushValues = ExpTmpLocalVar_FlushValues;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex),
                                    "flush", "false");
                            }
                        }
                    }
                }
                //
                //** Display the data: ***
                //
                //Display data dictionaries.
                for (hv_KeyIndex = 0; (int)hv_KeyIndex <= (int)((new HTuple(hv_KeysForDisplay.TupleLength()
                    )) - 1); hv_KeyIndex = (int)hv_KeyIndex + 1)
                {
                    if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "image"))) != 0)
                    {
                        //
                        //Image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ImageIDStringCapital,
                                    "window", "bottom", "left", "white", "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "anomaly_ground_truth"))) != 0)
                    {
                        //Image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        hv_AnomalyLabelGroundTruth.Dispose(); hv_AnomalyLabelIDGroundTruth.Dispose();
                        get_anomaly_ground_truth_label(hv_SampleKeys, hv_DLSample, out hv_AnomalyLabelGroundTruth,
                            out hv_AnomalyLabelIDGroundTruth);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualize image.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        hv_AnomalyRegionExists.Dispose();
                        hv_AnomalyRegionExists = "false";
                        if ((int)(hv_ShowGroundTruthAnomalyRegions) != 0)
                        {
                            //Show the ground truth region.
                            hv_AnomalyRegionExists.Dispose();
                            dev_display_ground_truth_anomaly_regions(hv_SampleKeys, hv_DLSample,
                                hv_CurrentWindowHandle, hv_LineWidth, hv_AnomalyRegionLabelColor,
                                hv_AnomalyColorTransparency, out hv_AnomalyRegionExists);
                        }
                        //
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Ground truth anomalies " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = ((hv_AnomalyLabelIDGroundTruth + " : '") + hv_AnomalyLabelGroundTruth) + "'";
                            if ((int)((new HTuple((new HTuple(hv_AnomalyRegionExists.TupleEqual("false"))).TupleAnd(
                                new HTuple(hv_AnomalyLabelIDGroundTruth.TupleEqual(1))))).TupleAnd(
                                hv_ShowGroundTruthAnomalyRegions)) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "No 'anomaly_ground_truth' exists!";
                            }
                            //
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", "white", "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "anomaly_result"))) != 0)
                    {
                        //
                        //Get image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        //
                        //Get the anomaly image out of DLResult.
                        ho_AnomalyImage.Dispose(); hv_AnomalyScore.Dispose(); hv_AnomalyClassID.Dispose();
                        get_anomaly_result(out ho_AnomalyImage, hv_ResultKeys, hv_DLResult, out hv_AnomalyScore,
                            out hv_AnomalyClassID);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualize image.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        //Display predicted anomaly regions.
                        if ((int)(new HTuple(hv_AnomalyRegionThreshold.TupleNotEqual(-1))) != 0)
                        {
                            ho_AnomalyRegion.Dispose();
                            dev_display_result_anomaly_regions(ho_AnomalyImage, out ho_AnomalyRegion,
                                hv_CurrentWindowHandle, hv_AnomalyRegionThreshold, hv_LineWidth,
                                hv_AnomalyRegionResultColor);
                        }
                        //
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Detected anomalies " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Results ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            if ((int)(new HTuple(hv_AnomalyClassID.TupleEqual(1))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID + " : 'nok'";
                            }
                            else
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID + " : 'ok'";
                            }
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Anomaly score: " + (hv_AnomalyScore.TupleString(
                                ".2f"));
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if ((int)((new HTuple(hv_AnomalyClassificationThreshold.TupleNotEqual(
                                -1))).TupleOr(new HTuple(hv_AnomalyRegionThreshold.TupleNotEqual(
                                -1)))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Thresholds ";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            }
                            //
                            if ((int)(new HTuple(hv_AnomalyClassificationThreshold.TupleNotEqual(
                                -1))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Classification: " + (hv_AnomalyClassificationThreshold.TupleString(
                                    ".2f"));
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            }
                            if ((int)(new HTuple(hv_AnomalyRegionThreshold.TupleNotEqual(-1))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Segmentation: " + (hv_AnomalyRegionThreshold.TupleString(
                                    ".2f"));
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            }
                            //
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", "white", "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "anomaly_both"))) != 0)
                    {
                        //
                        //Get image, ground truth and results.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        hv_AnomalyLabelGroundTruth.Dispose(); hv_AnomalyLabelIDGroundTruth.Dispose();
                        get_anomaly_ground_truth_label(hv_SampleKeys, hv_DLSample, out hv_AnomalyLabelGroundTruth,
                            out hv_AnomalyLabelIDGroundTruth);
                        ho_AnomalyImage.Dispose(); hv_AnomalyScore.Dispose(); hv_AnomalyClassID.Dispose();
                        get_anomaly_result(out ho_AnomalyImage, hv_ResultKeys, hv_DLResult, out hv_AnomalyScore,
                            out hv_AnomalyClassID);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualize image, ground truth (if available), and result regions.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        hv_AnomalyRegionGroundTruthExists.Dispose();
                        hv_AnomalyRegionGroundTruthExists = "false";
                        if ((int)(hv_ShowGroundTruthAnomalyRegions) != 0)
                        {
                            hv_AnomalyRegionGroundTruthExists.Dispose();
                            dev_display_ground_truth_anomaly_regions(hv_SampleKeys, hv_DLSample,
                                hv_CurrentWindowHandle, hv_LineWidth, hv_AnomalyRegionLabelColor,
                                hv_AnomalyColorTransparency, out hv_AnomalyRegionGroundTruthExists);
                        }
                        //
                        //Display result anomaly regions.
                        ho_AnomalyRegion.Dispose();
                        dev_display_result_anomaly_regions(ho_AnomalyImage, out ho_AnomalyRegion,
                            hv_CurrentWindowHandle, hv_AnomalyRegionThreshold, hv_LineWidth, hv_AnomalyRegionResultColor);
                        //
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "GT and detected anomalies " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Get prediction color.
                        hv_PredictionColor.Dispose();
                        hv_PredictionColor = "white";
                        if ((int)(new HTuple(hv_AnomalyLabelIDGroundTruth.TupleEqual(hv_AnomalyClassID))) != 0)
                        {
                            hv_PredictionColor.Dispose();
                            hv_PredictionColor = "green";
                        }
                        else
                        {
                            hv_PredictionColor.Dispose();
                            hv_PredictionColor = "red";
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Ground truth ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = ((hv_AnomalyLabelIDGroundTruth + " : '") + hv_AnomalyLabelGroundTruth) + "'";
                            if ((int)((new HTuple((new HTuple(hv_AnomalyRegionGroundTruthExists.TupleEqual(
                                "false"))).TupleAnd(new HTuple(hv_AnomalyLabelIDGroundTruth.TupleEqual(
                                1))))).TupleAnd(hv_ShowGroundTruthAnomalyRegions)) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = " No 'anomaly_ground_truth' exists!";
                            }
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Results ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            if ((int)(new HTuple(hv_AnomalyClassID.TupleEqual(1))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID + " : 'nok'";
                            }
                            else
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID + " : 'ok'";
                            }
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Anomaly score: " + (hv_AnomalyScore.TupleString(
                                ".2f"));
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if ((int)((new HTuple(hv_AnomalyClassificationThreshold.TupleNotEqual(
                                -1))).TupleOr(new HTuple(hv_AnomalyRegionThreshold.TupleNotEqual(
                                -1)))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Thresholds ";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            }
                            //
                            if ((int)(new HTuple(hv_AnomalyClassificationThreshold.TupleNotEqual(
                                -1))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Classification: " + (hv_AnomalyClassificationThreshold.TupleString(
                                    ".2f"));
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            }
                            if ((int)(new HTuple(hv_AnomalyRegionThreshold.TupleNotEqual(-1))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Segmentation: " + (hv_AnomalyRegionThreshold.TupleString(
                                    ".2f"));
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            }
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_LineColors.Dispose();
                                HOperatorSet.TupleGenConst(new HTuple(hv_Text.TupleLength()), "white",
                                    out hv_LineColors);
                            }
                            if (hv_LineColors == null)
                                hv_LineColors = new HTuple();
                            hv_LineColors[(new HTuple(hv_LineColors.TupleLength())) - 8] = hv_PredictionColor;
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", hv_LineColors, "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "anomaly_image"))) != 0)
                    {
                        //
                        //Image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        //
                        ho_AnomalyImage.Dispose(); hv_AnomalyScore.Dispose(); hv_AnomalyClassID.Dispose();
                        get_anomaly_result(out ho_AnomalyImage, hv_ResultKeys, hv_DLResult, out hv_AnomalyScore,
                            out hv_AnomalyClassID);
                        //
                        //Read in input image.
                        ho_Image.Dispose();
                        HOperatorSet.GetDictObject(out ho_Image, hv_DLSample, "image");
                        //Add the anomaly image to the input image.
                        {
                            HObject ExpTmpOutVar_0;
                            add_colormap_to_image(ho_AnomalyImage, ho_Image, out ExpTmpOutVar_0, hv_HeatmapColorScheme);
                            ho_AnomalyImage.Dispose();
                            ho_AnomalyImage = ExpTmpOutVar_0;
                        }
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_AnomalyImage, HDevWindowStack.GetActive());
                        }
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Anomaly image " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if ((int)(new HTuple(hv_AnomalyClassID.TupleEqual(1))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID + " : 'nok'";
                            }
                            else
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID + " : 'ok'";
                            }
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Anomaly score: " + (hv_AnomalyScore.TupleString(
                                ".2f"));
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", "white", "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "classification_ground_truth"))) != 0)
                    {
                        //
                        //Ground truth classification image and class label.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        //
                        hv_ClassificationLabelIDGroundTruth.Dispose();
                        get_classification_ground_truth(hv_SampleKeys, hv_DLSample, out hv_ClassificationLabelIDGroundTruth);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        if ((int)(hv_ShowClassificationIDs) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "GT label ID: " + hv_ClassificationLabelIDGroundTruth;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", "white", "box", "false");
                            }
                        }
                        //
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Ground truth classification " + hv_ImageIDStringBraces;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Ground truth class ID " + hv_ImageIDStringBraces;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                        hv_ClassesLegend.TupleSelect(hv_ClassificationLabelIDGroundTruth));
                                    hv_Text.Dispose();
                                    hv_Text = ExpTmpLocalVar_Text;
                                }
                            }
                            //
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                        "top", "left", (new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                                        hv_ClassificationLabelIDGroundTruth)), "box", "false");
                                }
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "classification_result"))) != 0)
                    {
                        //
                        //Ground truth classification image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        //
                        hv_ClassificationLabelIDResult.Dispose();
                        get_classification_result(hv_ResultKeys, hv_DLResult, out hv_ClassificationLabelIDResult);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        //Display the class IDs.
                        if ((int)(hv_ShowClassificationIDs) != 0)
                        {
                            hv_MetaInfo.Dispose();
                            HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
                            hv_MarginBottom.Dispose();
                            HOperatorSet.GetDictTuple(hv_MetaInfo, "classification_result_margin_bottom",
                                out hv_MarginBottom);
                            hv_WindowCoordinates.Dispose();
                            HOperatorSet.GetDictTuple(hv_MetaInfo, "classification_result_window_coordinates",
                                out hv_WindowCoordinates);
                            hv_CurrentWindowHeight.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_CurrentWindowHeight = (hv_WindowCoordinates.TupleSelect(
                                    3)) - (hv_WindowCoordinates.TupleSelect(0));
                            }
                            hv__.Dispose(); hv__.Dispose(); hv__.Dispose(); hv_MaxHeight.Dispose();
                            HOperatorSet.GetFontExtents(hv_CurrentWindowHandle, out hv__, out hv__,
                                out hv__, out hv_MaxHeight);
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Result class ID: " + hv_ClassificationLabelIDResult;
                            }
                            if ((int)(hv_ShowBottomDesc) != 0)
                            {
                                if (HDevWindowStack.IsOpen())
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                            hv_CurrentWindowHeight - ((hv_MarginBottom + hv_MaxHeight) + 10), "left",
                                            "white", "box", "false");
                                    }
                                }
                            }
                            else
                            {
                                if (HDevWindowStack.IsOpen())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                        "bottom", "left", "white", "box", "false");
                                }
                            }
                        }
                        //
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Result classification " + hv_ImageIDStringBraces;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Result class ID " + hv_ImageIDStringBraces;
                            }
                            if ((int)(new HTuple(hv_ClassificationLabelIDResult.TupleEqual(new HTuple()))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "No classification result is given!";
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                            hv_ClassesLegend.TupleSelect(hv_ClassificationLabelIDResult));
                                        hv_Text.Dispose();
                                        hv_Text = ExpTmpLocalVar_Text;
                                    }
                                }
                            }
                            //
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                        "top", "left", (new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                                        hv_ClassificationLabelIDResult)), "box", "false");
                                }
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "classification_both"))) != 0)
                    {
                        //
                        //Ground truth and result classification image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        //
                        hv_ClassificationLabelIDGroundTruth.Dispose();
                        get_classification_ground_truth(hv_SampleKeys, hv_DLSample, out hv_ClassificationLabelIDGroundTruth);
                        hv_ClassificationLabelIDResult.Dispose();
                        get_classification_result(hv_ResultKeys, hv_DLResult, out hv_ClassificationLabelIDResult);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        //
                        //Get prediction color.
                        hv_PredictionColor.Dispose();
                        hv_PredictionColor = "white";
                        if ((int)(new HTuple(hv_ClassificationLabelIDGroundTruth.TupleEqual(hv_ClassificationLabelIDResult))) != 0)
                        {
                            hv_PredictionText.Dispose();
                            hv_PredictionText = "Correct";
                            hv_PredictionColor.Dispose();
                            hv_PredictionColor = "green";
                        }
                        else
                        {
                            hv_PredictionText.Dispose();
                            hv_PredictionText = "Wrong";
                            hv_PredictionColor.Dispose();
                            hv_PredictionColor = "red";
                        }
                        //
                        //Generate prediction color frame and show image.
                        if ((int)(hv_ShowClassificationColorFrame) != 0)
                        {
                            //Create a frame with line width 7 that is completely displayed in the window.
                            hv_BoarderOffset.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_BoarderOffset = 7 / 2.0;
                            }
                            hv_MetaInfo.Dispose();
                            HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
                            hv_WindowImageRatioHeight.Dispose();
                            HOperatorSet.GetDictTuple(hv_MetaInfo, "classification_both_window_image_ratio_height",
                                out hv_WindowImageRatioHeight);
                            hv_WindowImageRatioWidth.Dispose();
                            HOperatorSet.GetDictTuple(hv_MetaInfo, "classification_both_window_image_ratio_width",
                                out hv_WindowImageRatioWidth);
                            hv_BoarderOffsetRow.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_BoarderOffsetRow = hv_BoarderOffset / hv_WindowImageRatioHeight;
                            }
                            hv_BoarderOffsetCol.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_BoarderOffsetCol = hv_BoarderOffset / hv_WindowImageRatioWidth;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_PredictionColorFrame.Dispose();
                                HOperatorSet.GenContourPolygonXld(out ho_PredictionColorFrame, ((((((((hv_BoarderOffsetRow - 0.5)).TupleConcat(
                                    hv_BoarderOffsetRow - 0.5))).TupleConcat((hv_HeightImage + 0.5) - hv_BoarderOffsetRow))).TupleConcat(
                                    (hv_HeightImage + 0.5) - hv_BoarderOffsetRow))).TupleConcat(hv_BoarderOffsetRow - 0.5),
                                    ((((((((hv_BoarderOffsetCol - 0.5)).TupleConcat((hv_WidthImage + 0.5) - hv_BoarderOffsetCol))).TupleConcat(
                                    (hv_WidthImage + 0.5) - hv_BoarderOffsetCol))).TupleConcat(hv_BoarderOffsetCol - 0.5))).TupleConcat(
                                    hv_BoarderOffsetCol - 0.5));
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 7);
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_PredictionColor);
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_PredictionColorFrame, HDevWindowStack.GetActive()
                                    );
                            }
                        }
                        else
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                            }
                        }
                        //
                        if ((int)(hv_ShowClassificationIDs) != 0)
                        {
                            hv_MetaInfo.Dispose();
                            HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_MarginBottom.Dispose();
                                HOperatorSet.GetDictTuple(hv_MetaInfo, (hv_KeysForDisplay.TupleSelect(
                                    hv_KeyIndex)) + "_margin_bottom", out hv_MarginBottom);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowCoordinates.Dispose();
                                HOperatorSet.GetDictTuple(hv_MetaInfo, (hv_KeysForDisplay.TupleSelect(
                                    hv_KeyIndex)) + "_window_coordinates", out hv_WindowCoordinates);
                            }
                            hv_CurrentWindowHeight.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_CurrentWindowHeight = (hv_WindowCoordinates.TupleSelect(
                                    3)) - (hv_WindowCoordinates.TupleSelect(0));
                            }
                            hv__.Dispose(); hv__.Dispose(); hv__.Dispose(); hv_MaxHeight.Dispose();
                            HOperatorSet.GetFontExtents(hv_CurrentWindowHandle, out hv__, out hv__,
                                out hv__, out hv_MaxHeight);
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "GT label ID: " + hv_ClassificationLabelIDGroundTruth;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", "white", "box", "false");
                            }
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Result class ID: " + hv_ClassificationLabelIDResult;
                            }
                            if ((int)(hv_ShowBottomDesc) != 0)
                            {
                                if (HDevWindowStack.IsOpen())
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                            hv_CurrentWindowHeight - ((hv_MarginBottom + hv_MaxHeight) + 10), "left",
                                            "white", "box", "false");
                                    }
                                }
                            }
                            else
                            {
                                if (HDevWindowStack.IsOpen())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                        "bottom", "left", "white", "box", "false");
                                }
                            }
                        }
                        //
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Result/Ground truth classification " + hv_ImageIDStringBraces;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Ground truth class ID " + hv_ImageIDStringBraces;
                            }
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = hv_ClassesLegend.TupleSelect(
                                hv_ClassificationLabelIDGroundTruth);
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Result class ID";
                            if ((int)(new HTuple(hv_ClassificationLabelIDResult.TupleEqual(new HTuple()))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "No classification result is given!";
                            }
                            else
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_ClassesLegend.TupleSelect(
                                    hv_ClassificationLabelIDResult);
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Prediction ";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_PredictionText;
                            }
                            //
                            //Get or open next child window.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_LineColors.Dispose();
                                HOperatorSet.TupleGenConst(new HTuple(hv_Text.TupleLength()), "white",
                                    out hv_LineColors);
                            }
                            if (hv_LineColors == null)
                                hv_LineColors = new HTuple();
                            hv_LineColors[1] = hv_Colors.TupleSelect(hv_ClassificationLabelIDGroundTruth);
                            if ((int)(new HTuple(hv_ClassificationLabelIDResult.TupleNotEqual(new HTuple()))) != 0)
                            {
                                if (hv_LineColors == null)
                                    hv_LineColors = new HTuple();
                                hv_LineColors[5] = hv_Colors.TupleSelect(hv_ClassificationLabelIDResult);
                                if (hv_LineColors == null)
                                    hv_LineColors = new HTuple();
                                hv_LineColors[9] = hv_PredictionColor;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", hv_LineColors, "box", "false");
                            }
                        }
                        //
                    }
                    else if ((int)((new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "heatmap_grad_cam"))).TupleOr(new HTuple(((hv_KeysForDisplay.TupleSelect(
                        hv_KeyIndex))).TupleEqual("heatmap_confidence_based")))) != 0)
                    {
                        //
                        //Display the heatmap image (method 'heatmap_grad_cam' or 'heatmap_confidence_based')
                        //in the selected color scheme.
                        //Retrieve heatmap image, inferred image, and inference results.
                        hv_SelectedHeatmapMethod.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_SelectedHeatmapMethod = hv_KeysForDisplay.TupleSelect(
                                hv_KeyIndex);
                        }
                        if ((int)((new HTuple(((hv_ResultKeys.TupleFind("heatmap_grad_cam"))).TupleNotEqual(
                            -1))).TupleOr(new HTuple(((hv_ResultKeys.TupleFind("heatmap_confidence_based"))).TupleNotEqual(
                            -1)))) != 0)
                        {
                            if ((int)(new HTuple(hv_SelectedHeatmapMethod.TupleEqual("heatmap_grad_cam"))) != 0)
                            {
                                hv_DictHeatmap.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLResult, "heatmap_grad_cam", out hv_DictHeatmap);
                                hv_MethodName.Dispose();
                                hv_MethodName = "Grad-CAM";
                            }
                            else
                            {
                                hv_DictHeatmap.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLResult, "heatmap_confidence_based",
                                    out hv_DictHeatmap);
                                hv_MethodName.Dispose();
                                hv_MethodName = "Confidence based";
                            }
                            hv_HeatmapKeys.Dispose();
                            HOperatorSet.GetDictParam(hv_DictHeatmap, "keys", new HTuple(), out hv_HeatmapKeys);
                            hv_HeatmapImageName.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_HeatmapImageName = hv_HeatmapKeys.TupleRegexpSelect(
                                    "heatmap_image_class_[0-9]*");
                            }
                            hv_TargetClassID.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TargetClassID = hv_HeatmapImageName.TupleRegexpMatch(
                                    "heatmap_image_class_([0-9]+)$");
                            }
                            ho_ImageHeatmap.Dispose();
                            HOperatorSet.GetDictObject(out ho_ImageHeatmap, hv_DictHeatmap, hv_HeatmapImageName);
                        }
                        else
                        {
                            throw new HalconException("Heatmap image could not be found in DLResult.");
                        }
                        //
                        if ((int)(new HTuple(hv_SelectedHeatmapMethod.TupleEqual("heatmap_grad_cam"))) != 0)
                        {
                            //Read in input image.
                            ho_Image.Dispose();
                            HOperatorSet.GetDictObject(out ho_Image, hv_DLSample, "image");
                            //Add the heatmap to the input image.
                            {
                                HObject ExpTmpOutVar_0;
                                add_colormap_to_image(ho_ImageHeatmap, ho_Image, out ExpTmpOutVar_0,
                                    hv_HeatmapColorScheme);
                                ho_ImageHeatmap.Dispose();
                                ho_ImageHeatmap = ExpTmpOutVar_0;
                            }
                        }
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_ImageHeatmap, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_ImageHeatmap, HDevWindowStack.GetActive());
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Classification heatmap " + hv_ImageIDStringBraces;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            hv_ClassNames.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLResult, "classification_class_names",
                                out hv_ClassNames);
                            hv_ClassIDs.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLResult, "classification_class_ids", out hv_ClassIDs);
                            hv_Confidences.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLResult, "classification_confidences",
                                out hv_Confidences);
                            if ((int)(new HTuple(hv_SelectedHeatmapMethod.TupleEqual("heatmap_confidence_based"))) != 0)
                            {
                                hv_MaxDeviation.Dispose();
                                HOperatorSet.GetDictTuple(hv_DictHeatmap, "classification_heatmap_maxdeviation",
                                    out hv_MaxDeviation);
                            }
                            hv_ClassificationLabelNameResult.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClassificationLabelNameResult = hv_ClassNames.TupleSelect(
                                    0);
                            }
                            hv_ClassificationLabelIDResult.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClassificationLabelIDResult = hv_ClassIDs.TupleSelect(
                                    0);
                            }
                            hv_TargetClassConfidence.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TargetClassConfidence = hv_Confidences.TupleSelect(
                                    hv_ClassIDs.TupleFind(hv_TargetClassID.TupleNumber()));
                            }
                            hv_Text.Dispose();
                            hv_Text = "--------- ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Image ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "--------- ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("image_label_id"))).TupleNotEqual(
                                -1))) != 0)
                            {
                                hv_ClassificationLabelIDGroundTruth.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLSample, "image_label_id", out hv_ClassificationLabelIDGroundTruth);
                                hv_ClassificationLabelNamesGroundTruth.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLDatasetInfo, "class_names", out hv_ClassificationLabelNamesGroundTruth);
                                //Get prediction color.
                                if ((int)(new HTuple(hv_ClassificationLabelIDGroundTruth.TupleEqual(
                                    hv_ClassificationLabelIDResult))) != 0)
                                {
                                    hv_PredictionColor.Dispose();
                                    hv_PredictionColor = "green";
                                }
                                else
                                {
                                    hv_PredictionColor.Dispose();
                                    hv_PredictionColor = "red";
                                }
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Ground truth class: ";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_ClassificationLabelNamesGroundTruth.TupleSelect(
                                    hv_ClassificationLabelIDGroundTruth);
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            }
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Predicted class: ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = hv_ClassificationLabelNameResult;
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Confidence: " + (((hv_Confidences.TupleSelect(
                                0))).TupleString(".2f"));
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "--------- ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Heatmap ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "--------- ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Method: " + hv_MethodName;
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Target class: " + hv_TargetClassID;
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Target class confidence: " + (hv_TargetClassConfidence.TupleString(
                                ".2f"));
                            if ((int)(new HTuple(hv_SelectedHeatmapMethod.TupleEqual("heatmap_confidence_based"))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Maximum deviation: " + (hv_MaxDeviation.TupleString(
                                    ".2f"));
                            }
                            //
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_LineColors.Dispose();
                                HOperatorSet.TupleGenConst(new HTuple(hv_Text.TupleLength()), "white",
                                    out hv_LineColors);
                            }
                            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("image_label_id"))).TupleNotEqual(
                                -1))) != 0)
                            {
                                if (hv_LineColors == null)
                                    hv_LineColors = new HTuple();
                                hv_LineColors[8] = hv_PredictionColor;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", hv_LineColors, "box", "false");
                            }
                        }
                        //
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "segmentation_weight"))) != 0)
                    {
                        //
                        //Weight image.
                        ho_ImageWeight.Dispose();
                        get_weight_image(out ho_ImageWeight, hv_SampleKeys, hv_DLSample);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_ImageWeight, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_ImageWeight, HDevWindowStack.GetActive());
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Weight image " + hv_ImageIDStringBraces,
                                        "window", "bottom", "left", "white", "box", "false");
                                }
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "segmentation_confidence"))) != 0)
                    {
                        //
                        //Segmentation confidences.
                        ho_ImageConfidence.Dispose();
                        get_confidence_image(out ho_ImageConfidence, hv_ResultKeys, hv_DLResult);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_ImageConfidence, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_ImageConfidence, HDevWindowStack.GetActive());
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Confidence image " + hv_ImageIDStringBraces,
                                        "window", "bottom", "left", "white", "box", "false");
                                }
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "bbox_ground_truth"))) != 0)
                    {
                        //
                        //Sample bounding boxes on image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        hv_BboxIDs.Dispose();
                        dev_display_ground_truth_detection(hv_DLSample, hv_SampleKeys, hv_LineWidth,
                            hv_ClassIDs, hv_Colors, hv_BboxLabelColor, hv_BboxTextColor, hv_ShowLabels,
                            hv_ShowDirection, hv_CurrentWindowHandle, out hv_BboxIDs);
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Ground truth " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            hv_BboxColors.Dispose();
                            hv_BboxColors = "white";
                            if ((int)(new HTuple(hv_BboxIDs.TupleLength())) != 0)
                            {
                                hv_BboxIDsUniq.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_BboxIDsUniq = ((hv_BboxIDs.TupleSort()
                                        )).TupleUniq();
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                            hv_ClassesLegend.TupleSelect(hv_BboxIDsUniq));
                                        hv_Text.Dispose();
                                        hv_Text = ExpTmpLocalVar_Text;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_BboxColors = hv_BboxColors.TupleConcat(
                                            hv_Colors.TupleSelect(hv_BboxIDsUniq));
                                        hv_BboxColors.Dispose();
                                        hv_BboxColors = ExpTmpLocalVar_BboxColors;
                                    }
                                }
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                            "No ground truth bounding boxes present.");
                                        hv_Text.Dispose();
                                        hv_Text = ExpTmpLocalVar_Text;
                                    }
                                }
                            }
                            //
                            //Get or open next child window.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", hv_BboxColors, "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "bbox_result"))) != 0)
                    {
                        //
                        //Result bounding boxes on image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        if ((int)(new HTuple(((hv_ResultKeys.TupleFind("bbox_confidence"))).TupleNotEqual(
                            -1))) != 0)
                        {
                            hv_BboxConfidences.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLResult, "bbox_confidence", out hv_BboxConfidences);
                        }
                        else
                        {
                            throw new HalconException("Result bounding box data could not be found in DLResult.");
                        }
                        if ((int)(hv_BboxDisplayConfidence) != 0)
                        {
                            hv_TextConf.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TextConf = (" (" + (hv_BboxConfidences.TupleString(
                                    ".2f"))) + ")";
                            }
                        }
                        else
                        {
                            hv_TextConf.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TextConf = HTuple.TupleGenConst(
                                    new HTuple(hv_BboxConfidences.TupleLength()), "");
                            }
                        }
                        hv_BboxClassIndex.Dispose();
                        dev_display_result_detection(hv_DLResult, hv_ResultKeys, hv_LineWidth,
                            hv_ClassIDs, hv_TextConf, hv_Colors, hv_BboxLabelColor, hv_WindowImageRatio,
                            "top", hv_BboxTextColor, hv_ShowLabels, hv_ShowDirection, hv_CurrentWindowHandle,
                            out hv_BboxClassIndex);
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Result bounding boxes " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            hv_BboxColorsResults.Dispose();
                            hv_BboxColorsResults = "white";
                            if ((int)(new HTuple((new HTuple(hv_BboxClassIndex.TupleLength())).TupleGreater(
                                0))) != 0)
                            {
                                hv_BboxClassIndexUniq.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_BboxClassIndexUniq = ((hv_BboxClassIndex.TupleSort()
                                        )).TupleUniq();
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                            hv_ClassesLegend.TupleSelect(hv_BboxClassIndexUniq));
                                        hv_Text.Dispose();
                                        hv_Text = ExpTmpLocalVar_Text;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_BboxColorsResults = hv_BboxColorsResults.TupleConcat(
                                            hv_Colors.TupleSelect(hv_BboxClassIndexUniq));
                                        hv_BboxColorsResults.Dispose();
                                        hv_BboxColorsResults = ExpTmpLocalVar_BboxColorsResults;
                                    }
                                }
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                            "No result bounding boxes present.");
                                        hv_Text.Dispose();
                                        hv_Text = ExpTmpLocalVar_Text;
                                    }
                                }
                            }
                            //
                            //Get or open next child window.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", hv_BboxColorsResults, "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "bbox_both"))) != 0)
                    {
                        //
                        //Ground truth and result bounding boxes on image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        //Visualization.
                        hv_BboxLabelIndex.Dispose();
                        dev_display_ground_truth_detection(hv_DLSample, hv_SampleKeys, hv_LineWidth,
                            hv_ClassIDs, hv_Colors, hv_BboxLabelColor, hv_BboxTextColor, hv_ShowLabels,
                            hv_ShowDirection, hv_CurrentWindowHandle, out hv_BboxLabelIndex);
                        if ((int)(new HTuple(((hv_ResultKeys.TupleFind("bbox_confidence"))).TupleNotEqual(
                            -1))) != 0)
                        {
                            hv_BboxConfidences.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLResult, "bbox_confidence", out hv_BboxConfidences);
                        }
                        else
                        {
                            throw new HalconException("Result bounding box data could not be found in DLResult.");
                        }
                        if ((int)(hv_BboxDisplayConfidence) != 0)
                        {
                            hv_TextConf.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TextConf = (" (" + (hv_BboxConfidences.TupleString(
                                    ".2f"))) + ")";
                            }
                        }
                        else
                        {
                            hv_TextConf.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TextConf = HTuple.TupleGenConst(
                                    new HTuple(hv_BboxConfidences.TupleLength()), "");
                            }
                        }
                        hv_BboxClassIndex.Dispose();
                        dev_display_result_detection(hv_DLResult, hv_ResultKeys, hv_LineWidth,
                            hv_ClassIDs, hv_TextConf, hv_Colors, hv_BboxLabelColor, hv_WindowImageRatio,
                            "bottom", hv_BboxTextColor, hv_ShowLabels, hv_ShowDirection, hv_CurrentWindowHandle,
                            out hv_BboxClassIndex);
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Ground truth and result bounding boxes " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        hv_Text.Dispose();
                        hv_Text = "Ground truth and";
                        if (hv_Text == null)
                            hv_Text = new HTuple();
                        hv_Text[new HTuple(hv_Text.TupleLength())] = "result bounding boxes " + hv_ImageIDStringBraces;
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            hv_BboxColorsBoth.Dispose();
                            hv_BboxColorsBoth = new HTuple();
                            hv_BboxColorsBoth[0] = "white";
                            hv_BboxColorsBoth[1] = "white";
                            if ((int)(new HTuple((new HTuple((new HTuple(hv_BboxClassIndex.TupleLength()
                                )) + (new HTuple(hv_BboxLabelIndex.TupleLength())))).TupleGreater(0))) != 0)
                            {
                                hv_BboxClassLabelIndexUniq.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_BboxClassLabelIndexUniq = ((((hv_BboxClassIndex.TupleConcat(
                                        hv_BboxLabelIndex))).TupleSort())).TupleUniq();
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                            hv_ClassesLegend.TupleSelect(hv_BboxClassLabelIndexUniq));
                                        hv_Text.Dispose();
                                        hv_Text = ExpTmpLocalVar_Text;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_BboxColorsBoth = hv_BboxColorsBoth.TupleConcat(
                                            hv_Colors.TupleSelect(hv_BboxClassLabelIndexUniq));
                                        hv_BboxColorsBoth.Dispose();
                                        hv_BboxColorsBoth = ExpTmpLocalVar_BboxColorsBoth;
                                    }
                                }
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                            "No ground truth nor result bounding boxes present.");
                                        hv_Text.Dispose();
                                        hv_Text = ExpTmpLocalVar_Text;
                                    }
                                }
                            }
                            //
                            //Get or open next child window.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", hv_BboxColorsBoth, "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "segmentation_image_ground_truth"))) != 0)
                    {
                        //
                        //Ground truth segmentation image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        ho_SegmentationImagGroundTruth.Dispose();
                        get_segmentation_image_ground_truth(out ho_SegmentationImagGroundTruth,
                            hv_SampleKeys, hv_DLSample);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        //Display segmentation regions.
                        hv_ColorsSegmentation.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ColorsSegmentation = hv_Colors + hv_SegTransparency;
                        }
                        hv_DrawMode.Dispose();
                        HOperatorSet.GetDraw(hv_CurrentWindowHandle, out hv_DrawMode);
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_SegDraw);
                        }
                        hv_Width.Dispose();
                        HOperatorSet.GetLineWidth(hv_CurrentWindowHandle, out hv_Width);
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidth);
                        }
                        hv_ImageClassIDs.Dispose();
                        dev_display_segmentation_regions(ho_SegmentationImagGroundTruth, hv_ClassIDs,
                            hv_ColorsSegmentation, hv_SegExcludeClassIDs, out hv_ImageClassIDs);
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_Width.TupleInt()
                                    );
                            }
                        }
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Ground truth segmentation " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            hv_ImageClassIDsUniq.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ImageClassIDsUniq = ((hv_ImageClassIDs.TupleSort()
                                    )).TupleUniq();
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                        hv_ClassesLegend.TupleSelect(hv_ImageClassIDsUniq));
                                    hv_Text.Dispose();
                                    hv_Text = ExpTmpLocalVar_Text;
                                }
                            }
                            //
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                        "top", "left", (new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                                        hv_ImageClassIDsUniq)), "box", "false");
                                }
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "segmentation_image_result"))) != 0)
                    {
                        //
                        //Result segmentation on image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        ho_SegmentationImageResult.Dispose();
                        get_segmentation_image_result(out ho_SegmentationImageResult, hv_ResultKeys,
                            hv_DLResult);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        //Display result segmentation regions.
                        hv_ColorsResults.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ColorsResults = hv_Colors + hv_SegTransparency;
                        }
                        hv_DrawMode.Dispose();
                        HOperatorSet.GetDraw(hv_CurrentWindowHandle, out hv_DrawMode);
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_SegDraw);
                        }
                        hv_Width.Dispose();
                        HOperatorSet.GetLineWidth(hv_CurrentWindowHandle, out hv_Width);
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidth);
                        }
                        hv_ImageClassIDs.Dispose();
                        dev_display_segmentation_regions(ho_SegmentationImageResult, hv_ClassIDs,
                            hv_ColorsResults, hv_SegExcludeClassIDs, out hv_ImageClassIDs);
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_Width.TupleInt()
                                    );
                            }
                        }
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Result segmentation " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            hv_ImageClassIDsUniq.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ImageClassIDsUniq = ((hv_ImageClassIDs.TupleSort()
                                    )).TupleUniq();
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                        hv_ClassesLegend.TupleSelect(hv_ImageClassIDsUniq));
                                    hv_Text.Dispose();
                                    hv_Text = ExpTmpLocalVar_Text;
                                }
                            }
                            //
                            //Get or open next child window.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                        "top", "left", (new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                                        hv_ImageClassIDsUniq)), "box", "false");
                                }
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "segmentation_image_both"))) != 0)
                    {
                        //
                        //Ground truth and result segmentation on image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        ho_SegmentationImagGroundTruth.Dispose();
                        get_segmentation_image_ground_truth(out ho_SegmentationImagGroundTruth,
                            hv_SampleKeys, hv_DLSample);
                        ho_SegmentationImageResult.Dispose();
                        get_segmentation_image_result(out ho_SegmentationImageResult, hv_ResultKeys,
                            hv_DLResult);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        //Display regions.
                        hv_ColorsResults.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ColorsResults = hv_Colors + hv_SegTransparency;
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 2);
                        }
                        hv_GroundTruthIDs.Dispose();
                        dev_display_segmentation_regions(ho_SegmentationImagGroundTruth, hv_ClassIDs,
                            hv_ColorsResults, hv_SegExcludeClassIDs, out hv_GroundTruthIDs);
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 6);
                        }
                        hv_ResultIDs.Dispose();
                        dev_display_segmentation_regions(ho_SegmentationImageResult, hv_ClassIDs,
                            hv_ColorsResults, hv_SegExcludeClassIDs, out hv_ResultIDs);
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
                        }
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Ground truth and result segmentation " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            hv_ImageClassIDsUniq.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ImageClassIDsUniq = ((((hv_GroundTruthIDs.TupleConcat(
                                    hv_ResultIDs))).TupleSort())).TupleUniq();
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                        hv_ClassesLegend.TupleSelect(hv_ImageClassIDsUniq));
                                    hv_Text.Dispose();
                                    hv_Text = ExpTmpLocalVar_Text;
                                }
                            }
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[(new HTuple(hv_Text.TupleLength())) + 1] = new HTuple("- thicker line: result, thinner lines: ground truth");
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "  (you may have to zoom in for a more detailed view)";
                            hv_StringSegExcludeClassIDs.Dispose();
                            hv_StringSegExcludeClassIDs = "";
                            for (hv_StringIndex = 0; (int)hv_StringIndex <= (int)((new HTuple(hv_SegExcludeClassIDs.TupleLength()
                                )) - 1); hv_StringIndex = (int)hv_StringIndex + 1)
                            {
                                if ((int)(new HTuple(hv_StringIndex.TupleEqual((new HTuple(hv_SegExcludeClassIDs.TupleLength()
                                    )) - 1))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_StringSegExcludeClassIDs = hv_StringSegExcludeClassIDs + (hv_SegExcludeClassIDs.TupleSelect(
                                                hv_StringIndex));
                                            hv_StringSegExcludeClassIDs.Dispose();
                                            hv_StringSegExcludeClassIDs = ExpTmpLocalVar_StringSegExcludeClassIDs;
                                        }
                                    }
                                }
                                else
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_StringSegExcludeClassIDs = (hv_StringSegExcludeClassIDs + (hv_SegExcludeClassIDs.TupleSelect(
                                                hv_StringIndex))) + new HTuple(", ");
                                            hv_StringSegExcludeClassIDs.Dispose();
                                            hv_StringSegExcludeClassIDs = ExpTmpLocalVar_StringSegExcludeClassIDs;
                                        }
                                    }
                                }
                            }
                            if ((int)(new HTuple(hv_SegExcludeClassIDs.TupleNotEqual(new HTuple()))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = ("- (excluded classID(s) " + hv_StringSegExcludeClassIDs) + " from visualization)";
                            }
                            //
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                        "top", "left", (((new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                                        hv_ImageClassIDsUniq)))).TupleConcat(((new HTuple("white")).TupleConcat(
                                        "white")).TupleConcat("white")), "box", "false");
                                }
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "segmentation_image_diff"))) != 0)
                    {
                        //
                        //Difference of ground truth and result segmentation on image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        ho_SegmentationImagGroundTruth.Dispose();
                        get_segmentation_image_ground_truth(out ho_SegmentationImagGroundTruth,
                            hv_SampleKeys, hv_DLSample);
                        ho_SegmentationImageResult.Dispose();
                        get_segmentation_image_result(out ho_SegmentationImageResult, hv_ResultKeys,
                            hv_DLResult);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        ho_ImageAbsDiff.Dispose();
                        HOperatorSet.AbsDiffImage(ho_SegmentationImagGroundTruth, ho_SegmentationImageResult,
                            out ho_ImageAbsDiff, 1);
                        hv_Min.Dispose(); hv_Max.Dispose(); hv_Range.Dispose();
                        HOperatorSet.MinMaxGray(ho_SegmentationImageResult, ho_ImageAbsDiff, 0,
                            out hv_Min, out hv_Max, out hv_Range);
                        if ((int)(new HTuple(hv_Min.TupleNotEqual(hv_Max))) != 0)
                        {
                            ho_DiffRegion.Dispose();
                            HOperatorSet.Threshold(ho_ImageAbsDiff, out ho_DiffRegion, 0.00001, hv_Max);
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetColor(HDevWindowStack.GetActive(), "#ff0000" + hv_SegTransparency);
                                }
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_DiffRegion, HDevWindowStack.GetActive());
                            }
                        }
                        else
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), "No difference found.",
                                    "window", "top", "left", "black", new HTuple(), new HTuple());
                            }
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Difference of ground truth and result segmentation " + hv_ImageIDStringBraces;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "segmentation_weight_map"))) != 0)
                    {
                        //
                        //Weight map on image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        ho_ImageWeight.Dispose();
                        get_weight_image(out ho_ImageWeight, hv_SampleKeys, hv_DLSample);
                        //
                        if ((int)(new HTuple(hv_SegMaxWeight.TupleEqual(0))) != 0)
                        {
                            //Calculate SegMaxWeight if not given in GenParam.
                            hv_MinWeight.Dispose(); hv_SegMaxWeight.Dispose(); hv_Range.Dispose();
                            HOperatorSet.MinMaxGray(ho_ImageWeight, ho_ImageWeight, 0, out hv_MinWeight,
                                out hv_SegMaxWeight, out hv_Range);
                        }
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, hv_MapColorBarWidth, hv_ScaleWindows, hv_ThresholdWidth,
                                hv_PrevWindowCoordinates, hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(
                                hv_KeyIndex), out hv_CurrentWindowHandle, out hv_WindowImageRatio,
                                out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        hv_WeightsColors.Dispose();
                        dev_display_weight_regions(ho_ImageWeight, hv_MapTransparency, hv_SegMaxWeight,
                            out hv_WeightsColors);
                        dev_display_map_color_bar(hv_WidthImage, hv_HeightImage, hv_MapColorBarWidth,
                            hv_WeightsColors, hv_SegMaxWeight, hv_WindowImageRatio, hv_CurrentWindowHandle);
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Weight map " + hv_ImageIDStringBraces,
                                        "window", "bottom", "left", "white", "box", "false");
                                }
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "segmentation_confidence_map"))) != 0)
                    {
                        //
                        //Segmentation confidence map on image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        ho_ImageConfidence.Dispose();
                        get_confidence_image(out ho_ImageConfidence, hv_ResultKeys, hv_DLResult);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, hv_MapColorBarWidth, hv_ScaleWindows, hv_ThresholdWidth,
                                hv_PrevWindowCoordinates, hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(
                                hv_KeyIndex), out hv_CurrentWindowHandle, out hv_WindowImageRatio,
                                out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        hv_ConfidenceColors.Dispose();
                        dev_display_confidence_regions(ho_ImageConfidence, hv_MapTransparency,
                            out hv_ConfidenceColors);
                        dev_display_map_color_bar(hv_WidthImage, hv_HeightImage, hv_MapColorBarWidth,
                            hv_ConfidenceColors, 1.0, hv_WindowImageRatio, hv_CurrentWindowHandle);
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Confidence map " + hv_ImageIDStringBraces,
                                        "window", "bottom", "left", "white", "box", "false");
                                }
                            }
                        }
                    }
                    else
                    {
                        //Reset flush buffer of existing windows before throwing an exception.
                        hv_WindowHandleKeys.Dispose();
                        HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_WindowHandleKeys);
                        for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_WindowHandleKeys.TupleLength()
                            )) - 1); hv_Index = (int)hv_Index + 1)
                        {
                            //Only consider the WindowHandleKeys that are needed for the current visualization.
                            hv_Indices.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Indices = hv_KeysForDisplay.TupleFind(
                                    hv_WindowHandleKeys.TupleSelect(hv_Index));
                            }
                            if ((int)((new HTuple(hv_Indices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_Indices.TupleNotEqual(
                                new HTuple())))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_WindowHandles.Dispose();
                                    HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKeys.TupleSelect(
                                        hv_Index), out hv_WindowHandles);
                                }
                                for (hv_WindowIndex = 0; (int)hv_WindowIndex <= (int)((new HTuple(hv_WindowHandles.TupleLength()
                                    )) - 1); hv_WindowIndex = (int)hv_WindowIndex + 1)
                                {
                                    //Reset values of windows that have been changed temporarily.
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex),
                                            "flush", hv_FlushValues.TupleSelect(hv_Index));
                                    }
                                }
                            }
                        }
                        throw new HalconException("Key for display unknown: " + (hv_KeysForDisplay.TupleSelect(
                            hv_KeyIndex)));
                    }
                }
                //
                //Display results.
                hv_WindowHandleKeysNew.Dispose();
                HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_WindowHandleKeysNew);
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_WindowHandleKeysNew.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    //Only consider the WindowHandleKeys that are needed for the current visualization.
                    hv_KeyIndex.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_KeyIndex = hv_KeysForDisplay.TupleFind(
                            hv_WindowHandleKeysNew.TupleSelect(hv_Index));
                    }
                    if ((int)((new HTuple(hv_KeyIndex.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_KeyIndex.TupleNotEqual(
                        new HTuple())))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_WindowHandles.Dispose();
                            HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKeysNew.TupleSelect(
                                hv_Index), out hv_WindowHandles);
                        }
                        for (hv_WindowIndex = 0; (int)hv_WindowIndex <= (int)((new HTuple(hv_WindowHandles.TupleLength()
                            )) - 1); hv_WindowIndex = (int)hv_WindowIndex + 1)
                        {
                            //Display content of window handle.
                            if ((int)(new HTuple((new HTuple(hv_WindowHandleKeys.TupleLength())).TupleEqual(
                                new HTuple(hv_WindowHandleKeysNew.TupleLength())))) != 0)
                            {
                                //Reset values of windows that have been changed temporarily.
                                if ((int)(new HTuple(((hv_FlushValues.TupleSelect(hv_WindowIndex))).TupleEqual(
                                    "true"))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.FlushBuffer(hv_WindowHandles.TupleSelect(hv_WindowIndex));
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex),
                                        "flush", hv_FlushValues.TupleSelect(hv_WindowIndex));
                                }
                            }
                            else
                            {
                                //Per default, 'flush' of new windows should be set to 'true'.
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.FlushBuffer(hv_WindowHandles.TupleSelect(hv_WindowIndex));
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex),
                                        "flush", "true");
                                }
                            }
                        }
                    }
                }
                //
                ho_Image.Dispose();
                ho_AnomalyImage.Dispose();
                ho_AnomalyRegion.Dispose();
                ho_PredictionColorFrame.Dispose();
                ho_ImageHeatmap.Dispose();
                ho_ImageWeight.Dispose();
                ho_ImageConfidence.Dispose();
                ho_SegmentationImagGroundTruth.Dispose();
                ho_SegmentationImageResult.Dispose();
                ho_ImageAbsDiff.Dispose();
                ho_DiffRegion.Dispose();

                hv_ThresholdWidth.Dispose();
                hv_ScaleWindows.Dispose();
                hv_Font.Dispose();
                hv_FontSize.Dispose();
                hv_LineWidth.Dispose();
                hv_MapTransparency.Dispose();
                hv_MapColorBarWidth.Dispose();
                hv_AnomalyRegionThreshold.Dispose();
                hv_AnomalyClassificationThreshold.Dispose();
                hv_AnomalyRegionLabelColor.Dispose();
                hv_AnomalyColorTransparency.Dispose();
                hv_AnomalyRegionResultColor.Dispose();
                hv_SegMaxWeight.Dispose();
                hv_SegDraw.Dispose();
                hv_SegTransparency.Dispose();
                hv_SegExcludeClassIDs.Dispose();
                hv_BboxLabelColor.Dispose();
                hv_BboxDisplayConfidence.Dispose();
                hv_BboxTextColor.Dispose();
                hv_ShowBottomDesc.Dispose();
                hv_ShowLegend.Dispose();
                hv_ShowGroundTruthAnomalyRegions.Dispose();
                hv_ShowClassificationIDs.Dispose();
                hv_ShowClassificationColorFrame.Dispose();
                hv_ShowLabels.Dispose();
                hv_ShowDirection.Dispose();
                hv_HeatmapColorScheme.Dispose();
                hv_GenParamNames.Dispose();
                hv_ParamIndex.Dispose();
                hv_GenParamName.Dispose();
                hv_GenParamValue.Dispose();
                hv_SampleKeys.Dispose();
                hv_ResultKeys.Dispose();
                hv_ImageIDExists.Dispose();
                hv_ImageID.Dispose();
                hv_ImageIDString.Dispose();
                hv_ImageIDStringBraces.Dispose();
                hv_ImageIDStringCapital.Dispose();
                hv_NeededKeys.Dispose();
                hv_Index.Dispose();
                hv_DLDatasetInfoKeys.Dispose();
                hv_ClassNames.Dispose();
                hv_ClassIDs.Dispose();
                hv_Colors.Dispose();
                hv_ClassesLegend.Dispose();
                hv_PrevWindowCoordinates.Dispose();
                hv_Keys.Dispose();
                hv_Exception.Dispose();
                hv_MetaInfoIndex.Dispose();
                hv_MetaInfo.Dispose();
                hv_FlushValues.Dispose();
                hv_WindowHandleKeys.Dispose();
                hv_KeyIndex.Dispose();
                hv_WindowHandles.Dispose();
                hv_WindowIndex.Dispose();
                hv_FlushValue.Dispose();
                hv_WidthImage.Dispose();
                hv_HeightImage.Dispose();
                hv_CurrentWindowHandle.Dispose();
                hv_WindowImageRatio.Dispose();
                hv_AnomalyLabelGroundTruth.Dispose();
                hv_AnomalyLabelIDGroundTruth.Dispose();
                hv_AnomalyRegionExists.Dispose();
                hv_Text.Dispose();
                hv_AnomalyScore.Dispose();
                hv_AnomalyClassID.Dispose();
                hv_AnomalyRegionGroundTruthExists.Dispose();
                hv_PredictionColor.Dispose();
                hv_LineColors.Dispose();
                hv_ClassificationLabelIDGroundTruth.Dispose();
                hv_ClassificationLabelIDResult.Dispose();
                hv_MarginBottom.Dispose();
                hv_WindowCoordinates.Dispose();
                hv_CurrentWindowHeight.Dispose();
                hv__.Dispose();
                hv_MaxHeight.Dispose();
                hv_PredictionText.Dispose();
                hv_BoarderOffset.Dispose();
                hv_WindowImageRatioHeight.Dispose();
                hv_WindowImageRatioWidth.Dispose();
                hv_BoarderOffsetRow.Dispose();
                hv_BoarderOffsetCol.Dispose();
                hv_SelectedHeatmapMethod.Dispose();
                hv_DictHeatmap.Dispose();
                hv_MethodName.Dispose();
                hv_HeatmapKeys.Dispose();
                hv_HeatmapImageName.Dispose();
                hv_TargetClassID.Dispose();
                hv_Confidences.Dispose();
                hv_MaxDeviation.Dispose();
                hv_ClassificationLabelNameResult.Dispose();
                hv_TargetClassConfidence.Dispose();
                hv_ClassificationLabelNamesGroundTruth.Dispose();
                hv_BboxIDs.Dispose();
                hv_BboxColors.Dispose();
                hv_BboxIDsUniq.Dispose();
                hv_BboxConfidences.Dispose();
                hv_TextConf.Dispose();
                hv_BboxClassIndex.Dispose();
                hv_BboxColorsResults.Dispose();
                hv_BboxClassIndexUniq.Dispose();
                hv_BboxLabelIndex.Dispose();
                hv_BboxColorsBoth.Dispose();
                hv_BboxClassLabelIndexUniq.Dispose();
                hv_ColorsSegmentation.Dispose();
                hv_DrawMode.Dispose();
                hv_Width.Dispose();
                hv_ImageClassIDs.Dispose();
                hv_ImageClassIDsUniq.Dispose();
                hv_ColorsResults.Dispose();
                hv_GroundTruthIDs.Dispose();
                hv_ResultIDs.Dispose();
                hv_StringSegExcludeClassIDs.Dispose();
                hv_StringIndex.Dispose();
                hv_Min.Dispose();
                hv_Max.Dispose();
                hv_Range.Dispose();
                hv_MinWeight.Dispose();
                hv_WeightsColors.Dispose();
                hv_ConfidenceColors.Dispose();
                hv_Indices.Dispose();
                hv_WindowHandleKeysNew.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Image.Dispose();
                ho_AnomalyImage.Dispose();
                ho_AnomalyRegion.Dispose();
                ho_PredictionColorFrame.Dispose();
                ho_ImageHeatmap.Dispose();
                ho_ImageWeight.Dispose();
                ho_ImageConfidence.Dispose();
                ho_SegmentationImagGroundTruth.Dispose();
                ho_SegmentationImageResult.Dispose();
                ho_ImageAbsDiff.Dispose();
                ho_DiffRegion.Dispose();

                hv_ThresholdWidth.Dispose();
                hv_ScaleWindows.Dispose();
                hv_Font.Dispose();
                hv_FontSize.Dispose();
                hv_LineWidth.Dispose();
                hv_MapTransparency.Dispose();
                hv_MapColorBarWidth.Dispose();
                hv_AnomalyRegionThreshold.Dispose();
                hv_AnomalyClassificationThreshold.Dispose();
                hv_AnomalyRegionLabelColor.Dispose();
                hv_AnomalyColorTransparency.Dispose();
                hv_AnomalyRegionResultColor.Dispose();
                hv_SegMaxWeight.Dispose();
                hv_SegDraw.Dispose();
                hv_SegTransparency.Dispose();
                hv_SegExcludeClassIDs.Dispose();
                hv_BboxLabelColor.Dispose();
                hv_BboxDisplayConfidence.Dispose();
                hv_BboxTextColor.Dispose();
                hv_ShowBottomDesc.Dispose();
                hv_ShowLegend.Dispose();
                hv_ShowGroundTruthAnomalyRegions.Dispose();
                hv_ShowClassificationIDs.Dispose();
                hv_ShowClassificationColorFrame.Dispose();
                hv_ShowLabels.Dispose();
                hv_ShowDirection.Dispose();
                hv_HeatmapColorScheme.Dispose();
                hv_GenParamNames.Dispose();
                hv_ParamIndex.Dispose();
                hv_GenParamName.Dispose();
                hv_GenParamValue.Dispose();
                hv_SampleKeys.Dispose();
                hv_ResultKeys.Dispose();
                hv_ImageIDExists.Dispose();
                hv_ImageID.Dispose();
                hv_ImageIDString.Dispose();
                hv_ImageIDStringBraces.Dispose();
                hv_ImageIDStringCapital.Dispose();
                hv_NeededKeys.Dispose();
                hv_Index.Dispose();
                hv_DLDatasetInfoKeys.Dispose();
                hv_ClassNames.Dispose();
                hv_ClassIDs.Dispose();
                hv_Colors.Dispose();
                hv_ClassesLegend.Dispose();
                hv_PrevWindowCoordinates.Dispose();
                hv_Keys.Dispose();
                hv_Exception.Dispose();
                hv_MetaInfoIndex.Dispose();
                hv_MetaInfo.Dispose();
                hv_FlushValues.Dispose();
                hv_WindowHandleKeys.Dispose();
                hv_KeyIndex.Dispose();
                hv_WindowHandles.Dispose();
                hv_WindowIndex.Dispose();
                hv_FlushValue.Dispose();
                hv_WidthImage.Dispose();
                hv_HeightImage.Dispose();
                hv_CurrentWindowHandle.Dispose();
                hv_WindowImageRatio.Dispose();
                hv_AnomalyLabelGroundTruth.Dispose();
                hv_AnomalyLabelIDGroundTruth.Dispose();
                hv_AnomalyRegionExists.Dispose();
                hv_Text.Dispose();
                hv_AnomalyScore.Dispose();
                hv_AnomalyClassID.Dispose();
                hv_AnomalyRegionGroundTruthExists.Dispose();
                hv_PredictionColor.Dispose();
                hv_LineColors.Dispose();
                hv_ClassificationLabelIDGroundTruth.Dispose();
                hv_ClassificationLabelIDResult.Dispose();
                hv_MarginBottom.Dispose();
                hv_WindowCoordinates.Dispose();
                hv_CurrentWindowHeight.Dispose();
                hv__.Dispose();
                hv_MaxHeight.Dispose();
                hv_PredictionText.Dispose();
                hv_BoarderOffset.Dispose();
                hv_WindowImageRatioHeight.Dispose();
                hv_WindowImageRatioWidth.Dispose();
                hv_BoarderOffsetRow.Dispose();
                hv_BoarderOffsetCol.Dispose();
                hv_SelectedHeatmapMethod.Dispose();
                hv_DictHeatmap.Dispose();
                hv_MethodName.Dispose();
                hv_HeatmapKeys.Dispose();
                hv_HeatmapImageName.Dispose();
                hv_TargetClassID.Dispose();
                hv_Confidences.Dispose();
                hv_MaxDeviation.Dispose();
                hv_ClassificationLabelNameResult.Dispose();
                hv_TargetClassConfidence.Dispose();
                hv_ClassificationLabelNamesGroundTruth.Dispose();
                hv_BboxIDs.Dispose();
                hv_BboxColors.Dispose();
                hv_BboxIDsUniq.Dispose();
                hv_BboxConfidences.Dispose();
                hv_TextConf.Dispose();
                hv_BboxClassIndex.Dispose();
                hv_BboxColorsResults.Dispose();
                hv_BboxClassIndexUniq.Dispose();
                hv_BboxLabelIndex.Dispose();
                hv_BboxColorsBoth.Dispose();
                hv_BboxClassLabelIndexUniq.Dispose();
                hv_ColorsSegmentation.Dispose();
                hv_DrawMode.Dispose();
                hv_Width.Dispose();
                hv_ImageClassIDs.Dispose();
                hv_ImageClassIDsUniq.Dispose();
                hv_ColorsResults.Dispose();
                hv_GroundTruthIDs.Dispose();
                hv_ResultIDs.Dispose();
                hv_StringSegExcludeClassIDs.Dispose();
                hv_StringIndex.Dispose();
                hv_Min.Dispose();
                hv_Max.Dispose();
                hv_Range.Dispose();
                hv_MinWeight.Dispose();
                hv_WeightsColors.Dispose();
                hv_ConfidenceColors.Dispose();
                hv_Indices.Dispose();
                hv_WindowHandleKeysNew.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection
        // Short Description: Display the ground truth anomaly regions of the given DLSample. 
        public void dev_display_ground_truth_anomaly_regions(HTuple hv_SampleKeys, HTuple hv_DLSample,
            HTuple hv_CurrentWindowHandle, HTuple hv_LineWidth, HTuple hv_AnomalyRegionLabelColor,
            HTuple hv_AnomalyColorTransparency, out HTuple hv_AnomalyRegionExists)
        {



            // Local iconic variables 

            HObject ho_AnomalyImage = null, ho_AnomalyRegion = null;

            // Local control variables 

            HTuple hv_Red = new HTuple(), hv_Green = new HTuple();
            HTuple hv_Blue = new HTuple(), hv_Alpha = new HTuple();
            HTuple hv_InitialColor = new HTuple(), hv_IndexColor = new HTuple();
            HTuple hv_Color_RGBA = new HTuple(), hv_Area = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_AnomalyImage);
            HOperatorSet.GenEmptyObj(out ho_AnomalyRegion);
            hv_AnomalyRegionExists = new HTuple();
            try
            {
                //
                //This procedure visualizes the ground truth anomalies
                //if there is an anomaly_ground_truth in DLSample.
                //
                //Get current set color.
                hv_Red.Dispose(); hv_Green.Dispose(); hv_Blue.Dispose(); hv_Alpha.Dispose();
                HOperatorSet.GetRgba(hv_CurrentWindowHandle, out hv_Red, out hv_Green, out hv_Blue,
                    out hv_Alpha);
                hv_InitialColor.Dispose();
                hv_InitialColor = new HTuple();
                for (hv_IndexColor = 0; (int)hv_IndexColor <= (int)((new HTuple(hv_Red.TupleLength()
                    )) - 1); hv_IndexColor = (int)hv_IndexColor + 1)
                {
                    hv_Color_RGBA.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Color_RGBA = ((("#" + (((hv_Red.TupleSelect(
                            hv_IndexColor))).TupleString("2x"))) + (((hv_Green.TupleSelect(hv_IndexColor))).TupleString(
                            "2x"))) + (((hv_Blue.TupleSelect(hv_IndexColor))).TupleString("2x"))) + (((hv_Alpha.TupleSelect(
                            hv_IndexColor))).TupleString("2x"));
                    }
                    {
                        HTuple ExpTmpOutVar_0;
                        HOperatorSet.TupleRegexpReplace(hv_Color_RGBA, (new HTuple(" ")).TupleConcat(
                            "replace_all"), "0", out ExpTmpOutVar_0);
                        hv_Color_RGBA.Dispose();
                        hv_Color_RGBA = ExpTmpOutVar_0;
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_InitialColor = hv_InitialColor.TupleConcat(
                                hv_Color_RGBA);
                            hv_InitialColor.Dispose();
                            hv_InitialColor = ExpTmpLocalVar_InitialColor;
                        }
                    }
                }
                //
                if ((int)(new HTuple(((hv_SampleKeys.TupleFind("anomaly_ground_truth"))).TupleNotEqual(
                    -1))) != 0)
                {
                    ho_AnomalyImage.Dispose();
                    HOperatorSet.GetDictObject(out ho_AnomalyImage, hv_DLSample, "anomaly_ground_truth");
                    ho_AnomalyRegion.Dispose();
                    HOperatorSet.Threshold(ho_AnomalyImage, out ho_AnomalyRegion, 1, 255);
                    //Get non-empty regions.
                    hv_Area.Dispose();
                    HOperatorSet.RegionFeatures(ho_AnomalyRegion, "area", out hv_Area);
                    if ((int)(new HTuple(hv_Area.TupleGreater(0))) != 0)
                    {
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_AnomalyRegionLabelColor + hv_AnomalyColorTransparency);
                            }
                        }
                        //Display the anomaly region.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_AnomalyRegion, HDevWindowStack.GetActive());
                        }
                    }
                    hv_AnomalyRegionExists.Dispose();
                    hv_AnomalyRegionExists = "true";
                }
                else
                {
                    hv_AnomalyRegionExists.Dispose();
                    hv_AnomalyRegionExists = "false";
                }
                //
                //Reset colors.
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_InitialColor);
                }
                //
                ho_AnomalyImage.Dispose();
                ho_AnomalyRegion.Dispose();

                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();
                hv_Alpha.Dispose();
                hv_InitialColor.Dispose();
                hv_IndexColor.Dispose();
                hv_Color_RGBA.Dispose();
                hv_Area.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_AnomalyImage.Dispose();
                ho_AnomalyRegion.Dispose();

                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();
                hv_Alpha.Dispose();
                hv_InitialColor.Dispose();
                hv_IndexColor.Dispose();
                hv_Color_RGBA.Dispose();
                hv_Area.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: Display the ground truth bounding boxes of DLSample. 
        public void dev_display_ground_truth_detection(HTuple hv_DLSample, HTuple hv_SampleKeys,
            HTuple hv_LineWidthBbox, HTuple hv_ClassIDs, HTuple hv_BboxColors, HTuple hv_BboxLabelColor,
            HTuple hv_TextColor, HTuple hv_ShowLabels, HTuple hv_ShowDirection, HTuple hv_WindowHandle,
            out HTuple hv_BboxIDs)
        {



            // Local iconic variables 

            HObject ho_BboxRectangle = null, ho_OrientationArrows = null;
            HObject ho_RectangleSelected = null, ho_ArrowSelected = null;

            // Local control variables 

            HTuple hv_InstanceType = new HTuple(), hv_BboxRow1 = new HTuple();
            HTuple hv_BboxCol1 = new HTuple(), hv_BboxRow2 = new HTuple();
            HTuple hv_BboxCol2 = new HTuple(), hv_BboxLabels = new HTuple();
            HTuple hv_BboxRow = new HTuple(), hv_BboxCol = new HTuple();
            HTuple hv_BboxLength1 = new HTuple(), hv_BboxLength2 = new HTuple();
            HTuple hv_BboxPhi = new HTuple(), hv_LabelRow = new HTuple();
            HTuple hv_LabelCol = new HTuple(), hv_HeadSize = new HTuple();
            HTuple hv_BboxClassIDs = new HTuple(), hv_ContourStyle = new HTuple();
            HTuple hv_IndexBbox = new HTuple(), hv_ClassID = new HTuple();
            HTuple hv_TxtColor = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_BboxRectangle);
            HOperatorSet.GenEmptyObj(out ho_OrientationArrows);
            HOperatorSet.GenEmptyObj(out ho_RectangleSelected);
            HOperatorSet.GenEmptyObj(out ho_ArrowSelected);
            hv_BboxIDs = new HTuple();
            try
            {
                //
                //This procedure displays the ground truth bounding boxes of DLSample.
                //
                hv_InstanceType.Dispose();
                hv_InstanceType = "rectangle1";
                if ((int)(new HTuple(((hv_SampleKeys.TupleFind("bbox_row1"))).TupleNotEqual(
                    -1))) != 0)
                {
                    hv_BboxRow1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row1", out hv_BboxRow1);
                    hv_BboxCol1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col1", out hv_BboxCol1);
                    hv_BboxRow2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row2", out hv_BboxRow2);
                    hv_BboxCol2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col2", out hv_BboxCol2);
                    hv_BboxLabels.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_label_id", out hv_BboxLabels);
                }
                else if ((int)(new HTuple(((hv_SampleKeys.TupleFind("bbox_phi"))).TupleNotEqual(
                    -1))) != 0)
                {
                    hv_BboxRow.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row", out hv_BboxRow);
                    hv_BboxCol.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col", out hv_BboxCol);
                    hv_BboxLength1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_length1", out hv_BboxLength1);
                    hv_BboxLength2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_length2", out hv_BboxLength2);
                    hv_BboxPhi.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_phi", out hv_BboxPhi);
                    hv_BboxLabels.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_label_id", out hv_BboxLabels);
                    hv_InstanceType.Dispose();
                    hv_InstanceType = "rectangle2";
                }
                else
                {
                    throw new HalconException("Ground truth bounding box data could not be found in DLSample.");
                }
                if ((int)(new HTuple((new HTuple(hv_BboxLabels.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    //Generate bounding box XLDs.
                    if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BboxPhi.Dispose();
                            HOperatorSet.TupleGenConst(new HTuple(hv_BboxRow1.TupleLength()), 0.0,
                                out hv_BboxPhi);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_BboxRectangle.Dispose();
                            HOperatorSet.GenRectangle2ContourXld(out ho_BboxRectangle, 0.5 * (hv_BboxRow1 + hv_BboxRow2),
                                0.5 * (hv_BboxCol1 + hv_BboxCol2), hv_BboxPhi, 0.5 * (hv_BboxCol2 - hv_BboxCol1),
                                0.5 * (hv_BboxRow2 - hv_BboxRow1));
                        }
                        hv_LabelRow.Dispose();
                        hv_LabelRow = new HTuple(hv_BboxRow1);
                        hv_LabelCol.Dispose();
                        hv_LabelCol = new HTuple(hv_BboxCol1);
                    }
                    else
                    {
                        ho_BboxRectangle.Dispose();
                        HOperatorSet.GenRectangle2ContourXld(out ho_BboxRectangle, hv_BboxRow,
                            hv_BboxCol, hv_BboxPhi, hv_BboxLength1, hv_BboxLength2);
                        hv_LabelRow.Dispose();
                        hv_LabelRow = new HTuple(hv_BboxRow);
                        hv_LabelCol.Dispose();
                        hv_LabelCol = new HTuple(hv_BboxCol);
                        if ((int)(hv_ShowDirection) != 0)
                        {
                            hv_HeadSize.Dispose();
                            hv_HeadSize = 20.0;
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_OrientationArrows.Dispose();
                                gen_arrow_contour_xld(out ho_OrientationArrows, hv_BboxRow, hv_BboxCol,
                                    hv_BboxRow - ((hv_BboxLength1 + hv_HeadSize) * (hv_BboxPhi.TupleSin())),
                                    hv_BboxCol + ((hv_BboxLength1 + hv_HeadSize) * (hv_BboxPhi.TupleCos())),
                                    hv_HeadSize, hv_HeadSize);
                            }
                        }
                    }
                    //
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidthBbox);
                    }
                    //
                    //Collect the ClassIDs of the bounding boxes.
                    hv_BboxIDs.Dispose();
                    hv_BboxIDs = new HTuple();
                    hv_BboxClassIDs.Dispose();
                    hv_BboxClassIDs = new HTuple();
                    //
                    //Draw the bounding boxes.
                    hv_ContourStyle.Dispose();
                    HOperatorSet.GetContourStyle(hv_WindowHandle, out hv_ContourStyle);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetContourStyle(HDevWindowStack.GetActive(), "stroke_and_fill");
                    }
                    for (hv_IndexBbox = 0; (int)hv_IndexBbox <= (int)((new HTuple(hv_BboxLabels.TupleLength()
                        )) - 1); hv_IndexBbox = (int)hv_IndexBbox + 1)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_RectangleSelected.Dispose();
                            HOperatorSet.SelectObj(ho_BboxRectangle, out ho_RectangleSelected, hv_IndexBbox + 1);
                        }
                        hv_ClassID.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClassID = hv_ClassIDs.TupleFind(
                                hv_BboxLabels.TupleSelect(hv_IndexBbox));
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_BboxClassIDs = hv_BboxClassIDs.TupleConcat(
                                    hv_ClassID);
                                hv_BboxClassIDs.Dispose();
                                hv_BboxClassIDs = ExpTmpLocalVar_BboxClassIDs;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_BboxIDs = hv_BboxIDs.TupleConcat(
                                    hv_ClassID);
                                hv_BboxIDs.Dispose();
                                hv_BboxIDs = ExpTmpLocalVar_BboxIDs;
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetColor(HDevWindowStack.GetActive(), (hv_BboxColors.TupleSelect(
                                    hv_ClassID)) + "60");
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_RectangleSelected, HDevWindowStack.GetActive()
                                );
                        }
                        if ((int)((new HTuple(hv_InstanceType.TupleEqual("rectangle2"))).TupleAnd(
                            hv_ShowDirection)) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_ArrowSelected.Dispose();
                                HOperatorSet.SelectObj(ho_OrientationArrows, out ho_ArrowSelected, hv_IndexBbox + 1);
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetColor(HDevWindowStack.GetActive(), (hv_BboxColors.TupleSelect(
                                        hv_ClassID)) + "FF");
                                }
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_ArrowSelected, HDevWindowStack.GetActive());
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetColor(HDevWindowStack.GetActive(), (hv_BboxColors.TupleSelect(
                                        hv_ClassID)) + "60");
                                }
                            }
                        }
                    }
                    //
                    //Write text to the bounding boxes.
                    if ((int)(hv_ShowLabels) != 0)
                    {
                        //For better visibility the text is displayed after all bounding boxes are drawn.
                        for (hv_IndexBbox = 0; (int)hv_IndexBbox <= (int)((new HTuple(hv_BboxLabels.TupleLength()
                            )) - 1); hv_IndexBbox = (int)hv_IndexBbox + 1)
                        {
                            hv_ClassID.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClassID = hv_BboxClassIDs.TupleSelect(
                                    hv_IndexBbox);
                            }
                            if ((int)(new HTuple(hv_TextColor.TupleEqual(""))) != 0)
                            {
                                hv_TxtColor.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_TxtColor = hv_BboxColors.TupleSelect(
                                        hv_ClassID);
                                }
                            }
                            else
                            {
                                hv_TxtColor.Dispose();
                                hv_TxtColor = new HTuple(hv_TextColor);
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_BboxLabels.TupleSelect(
                                        hv_IndexBbox), "image", hv_LabelRow.TupleSelect(hv_IndexBbox),
                                        hv_LabelCol.TupleSelect(hv_IndexBbox), hv_TextColor, ((new HTuple("box_color")).TupleConcat(
                                        "shadow")).TupleConcat("border_radius"), hv_BboxLabelColor.TupleConcat(
                                        (new HTuple("false")).TupleConcat(0)));
                                }
                            }
                        }
                    }
                    //
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetContourStyle(HDevWindowStack.GetActive(), hv_ContourStyle);
                    }
                }
                else
                {
                    //Do nothing if there are no ground truth bounding boxes.
                    hv_BboxIDs.Dispose();
                    hv_BboxIDs = new HTuple();
                }
                //
                ho_BboxRectangle.Dispose();
                ho_OrientationArrows.Dispose();
                ho_RectangleSelected.Dispose();
                ho_ArrowSelected.Dispose();

                hv_InstanceType.Dispose();
                hv_BboxRow1.Dispose();
                hv_BboxCol1.Dispose();
                hv_BboxRow2.Dispose();
                hv_BboxCol2.Dispose();
                hv_BboxLabels.Dispose();
                hv_BboxRow.Dispose();
                hv_BboxCol.Dispose();
                hv_BboxLength1.Dispose();
                hv_BboxLength2.Dispose();
                hv_BboxPhi.Dispose();
                hv_LabelRow.Dispose();
                hv_LabelCol.Dispose();
                hv_HeadSize.Dispose();
                hv_BboxClassIDs.Dispose();
                hv_ContourStyle.Dispose();
                hv_IndexBbox.Dispose();
                hv_ClassID.Dispose();
                hv_TxtColor.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_BboxRectangle.Dispose();
                ho_OrientationArrows.Dispose();
                ho_RectangleSelected.Dispose();
                ho_ArrowSelected.Dispose();

                hv_InstanceType.Dispose();
                hv_BboxRow1.Dispose();
                hv_BboxCol1.Dispose();
                hv_BboxRow2.Dispose();
                hv_BboxCol2.Dispose();
                hv_BboxLabels.Dispose();
                hv_BboxRow.Dispose();
                hv_BboxCol.Dispose();
                hv_BboxLength1.Dispose();
                hv_BboxLength2.Dispose();
                hv_BboxPhi.Dispose();
                hv_LabelRow.Dispose();
                hv_LabelCol.Dispose();
                hv_HeadSize.Dispose();
                hv_BboxClassIDs.Dispose();
                hv_ContourStyle.Dispose();
                hv_IndexBbox.Dispose();
                hv_ClassID.Dispose();
                hv_TxtColor.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: Display a color bar next to an image. 
        public void dev_display_map_color_bar(HTuple hv_ImageWidth, HTuple hv_ImageHeight,
            HTuple hv_MapColorBarWidth, HTuple hv_Colors, HTuple hv_MaxValue, HTuple hv_WindowImageRatio,
            HTuple hv_WindowHandle)
        {



            // Local iconic variables 

            HObject ho_Rectangle = null;

            // Local control variables 

            HTuple hv_ClipRegion = new HTuple(), hv_ColorIndex = new HTuple();
            HTuple hv_RectHeight = new HTuple(), hv_DrawMode = new HTuple();
            HTuple hv_Row = new HTuple(), hv_Row1 = new HTuple(), hv_Column1 = new HTuple();
            HTuple hv_Row2 = new HTuple(), hv_Column2 = new HTuple();
            HTuple hv__ = new HTuple(), hv_TextHeight = new HTuple();
            HTuple hv_Index = new HTuple(), hv_Text = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Rectangle);
            try
            {
                //
                //This procedure displays a color bar next to the image
                //specified with ImageWidth and ImageHeight.
                //
                hv_ClipRegion.Dispose();
                HOperatorSet.GetSystem("clip_region", out hv_ClipRegion);
                HOperatorSet.SetSystem("clip_region", "false");
                //
                //Display the color bar.
                hv_ColorIndex.Dispose();
                hv_ColorIndex = 0;
                hv_RectHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RectHeight = (1.0 * hv_ImageHeight) / (new HTuple(hv_Colors.TupleLength()
                        ));
                }
                //Set draw mode to fill
                hv_DrawMode.Dispose();
                HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
                }
                HTuple end_val13 = 0;
                HTuple step_val13 = -hv_RectHeight;
                for (hv_Row = hv_ImageHeight - 1; hv_Row.Continue(end_val13, step_val13); hv_Row = hv_Row.TupleAdd(step_val13))
                {
                    //The color bar consists of multiple rectangle1.
                    hv_Row1.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Row1 = hv_Row - hv_RectHeight;
                    }
                    hv_Column1.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Column1 = hv_ImageWidth + (20 / hv_WindowImageRatio);
                    }
                    hv_Row2.Dispose();
                    hv_Row2 = new HTuple(hv_Row);
                    hv_Column2.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Column2 = (hv_ImageWidth + 20) + (hv_MapColorBarWidth / hv_WindowImageRatio);
                    }
                    ho_Rectangle.Dispose();
                    HOperatorSet.GenRectangle1(out ho_Rectangle, hv_Row1, hv_Column1, hv_Row2,
                        hv_Column2);
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Colors.TupleSelect(
                                hv_ColorIndex));
                        }
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_Rectangle, HDevWindowStack.GetActive());
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ColorIndex = hv_ColorIndex + 1;
                            hv_ColorIndex.Dispose();
                            hv_ColorIndex = ExpTmpLocalVar_ColorIndex;
                        }
                    }
                }
                //
                //Display labels for color bar.
                hv__.Dispose(); hv__.Dispose(); hv__.Dispose(); hv_TextHeight.Dispose();
                HOperatorSet.GetStringExtents(hv_WindowHandle, "0123456789", out hv__, out hv__,
                    out hv__, out hv_TextHeight);
                for (hv_Index = (double)(0); (double)hv_Index <= 1; hv_Index = (double)hv_Index + 0.2)
                {
                    hv_Text.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Text = ((hv_MaxValue - (hv_Index * hv_MaxValue))).TupleString(
                            ".1f");
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "image", hv_Index * (hv_ImageHeight - (2 * (hv_TextHeight / hv_WindowImageRatio))),
                                hv_ImageWidth + (40 / hv_WindowImageRatio), "black", "box", "false");
                        }
                    }
                }
                //
                HOperatorSet.SetSystem("clip_region", hv_ClipRegion);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
                }
                ho_Rectangle.Dispose();

                hv_ClipRegion.Dispose();
                hv_ColorIndex.Dispose();
                hv_RectHeight.Dispose();
                hv_DrawMode.Dispose();
                hv_Row.Dispose();
                hv_Row1.Dispose();
                hv_Column1.Dispose();
                hv_Row2.Dispose();
                hv_Column2.Dispose();
                hv__.Dispose();
                hv_TextHeight.Dispose();
                hv_Index.Dispose();
                hv_Text.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Rectangle.Dispose();

                hv_ClipRegion.Dispose();
                hv_ColorIndex.Dispose();
                hv_RectHeight.Dispose();
                hv_DrawMode.Dispose();
                hv_Row.Dispose();
                hv_Row1.Dispose();
                hv_Column1.Dispose();
                hv_Row2.Dispose();
                hv_Column2.Dispose();
                hv__.Dispose();
                hv_TextHeight.Dispose();
                hv_Index.Dispose();
                hv_Text.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: Display a matrix inside a window 
        public void dev_display_matrix(HTuple hv_Matrix, HTuple hv_ColumnNames, HTuple hv_RowNames,
            HTuple hv_WindowHandle, HTuple hv_GenParam)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_NumRows = new HTuple(), hv_NumColumns = new HTuple();
            HTuple hv_DisplayColumnWidth = new HTuple(), hv_DisplayColor = new HTuple();
            HTuple hv_IdxsNoDisplay = new HTuple(), hv_AxisTitles = new HTuple();
            HTuple hv_ValueColors = new HTuple(), hv_NumberFormat = new HTuple();
            HTuple hv_Title = new HTuple(), hv_AxisColor = new HTuple();
            HTuple hv_GenParamKeys = new HTuple(), hv_KeyExists = new HTuple();
            HTuple hv_ValueTmp = new HTuple(), hv_ColStringWidths = new HTuple();
            HTuple hv_AllNames = new HTuple(), hv_MaxStringWidth = new HTuple();
            HTuple hv_StringIndex = new HTuple(), hv_String = new HTuple();
            HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
            HTuple hv_StringWidth = new HTuple(), hv_StringHeight = new HTuple();
            HTuple hv_TitleHeight = new HTuple(), hv_AxisTitleHeight = new HTuple();
            HTuple hv_TitleAscent = new HTuple(), hv_TitleDescent = new HTuple();
            HTuple hv_TitleWidth = new HTuple(), hv_AxisTitleAscent = new HTuple();
            HTuple hv_AxisTitleDescent = new HTuple(), hv_AxisTitleWidth = new HTuple();
            HTuple hv_RowStart = new HTuple(), hv_RowDistance = new HTuple();
            HTuple hv_RowEnd = new HTuple(), hv_ColumnStart = new HTuple();
            HTuple hv_ColumnOffset = new HTuple(), hv_ColumnEnd = new HTuple();
            HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
            HTuple hv_WidthLimit = new HTuple(), hv_HeightLimit = new HTuple();
            HTuple hv_TextRow = new HTuple(), hv_TextColumn = new HTuple();
            HTuple hv_RowStartTmp = new HTuple(), hv_ColumnDistance = new HTuple();
            HTuple hv_Index = new HTuple(), hv_AxisTitleRowX = new HTuple();
            HTuple hv_MatrixText = new HTuple(), hv_IdxsDisplay = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //Display a matrix in a window.
                //
                //GenParam (all are optional):
                //  - display_column_width: Either 'equal' or 'minimal'. For 'equal', all columns have the same width
                //                          that equals the width of the longest row or column-name.
                //  - display_color:        If true, the values will be displayed with the colors that are given by
                //                          'value_colors'.
                //                          Else, all values are displayed in white.
                //  - idxs_no_display:      Indices of the matrix that should not be displayed. The indices should be
                //                          given in row-major order, according to get_full_matrix. If not given or if
                //                          set to an empty tuple, all matrix values are displayed.
                //  - axis_titles:          Titles for the matrix x- and y-axis that are displayed at the top-right
                //                          and bottom-left of the matrix, respectively. Should be a tuple of length
                //                          two or an empty tuple if no axis titles should be displayed.
                //  - value_colors:         Tuple containing the hex color-string for each value of the matrix. If a
                //                          single value is given, this color is used for all values, else it must have
                //                          the length of the number of values in the matrix. Is ignored if
                //                          display_color is false.
                //  - number_format:        Format of the numbers when they are converted to strings for display.
                //                          Default: 2.0f
                //  - title:                Title of the displayed matrix, if given shown in the top-left.
                //  - row_col_names_color:  Color of column and row names. Default: 'light gray'
                //
                //
                //Get the matrix dimensions.
                hv_NumRows.Dispose(); hv_NumColumns.Dispose();
                HOperatorSet.GetSizeMatrix(hv_Matrix, out hv_NumRows, out hv_NumColumns);
                //Set defaults parameters.
                hv_DisplayColumnWidth.Dispose();
                hv_DisplayColumnWidth = "equal";
                hv_DisplayColor.Dispose();
                hv_DisplayColor = 0;
                hv_IdxsNoDisplay.Dispose();
                hv_IdxsNoDisplay = new HTuple();
                hv_AxisTitles.Dispose();
                hv_AxisTitles = new HTuple();
                hv_ValueColors.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ValueColors = HTuple.TupleGenConst(
                        hv_NumRows * hv_NumColumns, "white");
                }
                hv_NumberFormat.Dispose();
                hv_NumberFormat = "2.0f";
                hv_Title.Dispose();
                hv_Title = new HTuple();
                hv_AxisColor.Dispose();
                hv_AxisColor = "light gray";
                //Get parameters and overwrite
                hv_GenParamKeys.Dispose();
                hv_GenParamKeys = new HTuple();
                hv_GenParamKeys[0] = "display_column_width";
                hv_GenParamKeys[1] = "display_color";
                hv_GenParamKeys[2] = "idxs_no_display";
                hv_GenParamKeys[3] = "axis_titles";
                hv_GenParamKeys[4] = "value_colors";
                hv_GenParamKeys[5] = "number_format";
                hv_GenParamKeys[6] = "title";
                hv_GenParamKeys[7] = "row_col_names_color";
                if ((int)(new HTuple((new HTuple(hv_GenParam.TupleLength())).TupleGreater(0))) != 0)
                {
                    hv_KeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "key_exists", hv_GenParamKeys, out hv_KeyExists);
                    //DisplayColumnWidth.
                    if ((int)(hv_KeyExists.TupleSelect(0)) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "display_column_width", out hv_ValueTmp);
                        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
                            1))).TupleOr(new HTuple((new HTuple(((new HTuple("equal")).TupleConcat(
                            "minimal")).TupleFind(hv_ValueTmp))).TupleEqual(-1)))) != 0)
                        {
                            throw new HalconException("Invalid value for 'display_column_width'");
                        }
                        else
                        {
                            hv_DisplayColumnWidth.Dispose();
                            hv_DisplayColumnWidth = new HTuple(hv_ValueTmp);
                        }
                    }
                    //DisplayColor.
                    if ((int)(hv_KeyExists.TupleSelect(1)) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "display_color", out hv_ValueTmp);
                        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
                            1))).TupleOr(new HTuple((new HTuple(((new HTuple(1)).TupleConcat(0)).TupleFind(
                            hv_ValueTmp))).TupleEqual(-1)))) != 0)
                        {
                            throw new HalconException("Invalid value for 'display_color'");
                        }
                        else
                        {
                            hv_DisplayColor.Dispose();
                            hv_DisplayColor = new HTuple(hv_ValueTmp);
                        }
                    }
                    //ValueIdxsNoDisplay.
                    if ((int)(hv_KeyExists.TupleSelect(2)) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "idxs_no_display", out hv_ValueTmp);
                        if ((int)(new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleGreater(
                            0))) != 0)
                        {
                            if ((int)((new HTuple((new HTuple((new HTuple(((hv_ValueTmp.TupleMin()
                                )).TupleLess(0))).TupleOr(new HTuple(((hv_ValueTmp.TupleMax())).TupleGreater(
                                (hv_NumRows * hv_NumColumns) - 1))))).TupleOr(((hv_ValueTmp.TupleIsInt()
                                )).TupleNot()))).TupleOr(new HTuple((new HTuple(hv_ValueTmp.TupleLength()
                                )).TupleGreater(hv_NumRows * hv_NumColumns)))) != 0)
                            {
                                throw new HalconException("Invalid value for 'idxs_no_display'");
                            }
                        }
                        hv_IdxsNoDisplay.Dispose();
                        hv_IdxsNoDisplay = new HTuple(hv_ValueTmp);
                    }
                    //AxisTitles.
                    if ((int)(hv_KeyExists.TupleSelect(3)) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "axis_titles", out hv_ValueTmp);
                        if ((int)(new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleGreater(
                            0))) != 0)
                        {
                            if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleGreater(
                                2))).TupleOr(new HTuple(((hv_ValueTmp.TupleIsStringElem())).TupleNotEqual(
                                HTuple.TupleGenConst(new HTuple(hv_ValueTmp.TupleLength()), 1))))) != 0)
                            {
                                throw new HalconException("Invalid value for 'axis_titles'");
                            }
                        }
                        hv_AxisTitles.Dispose();
                        hv_AxisTitles = new HTuple(hv_ValueTmp);
                    }
                    //ValueColors.
                    if ((int)(((hv_KeyExists.TupleSelect(4))).TupleAnd(hv_DisplayColor)) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "value_colors", out hv_ValueTmp);
                        if ((int)(new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleGreater(
                            0))) != 0)
                        {
                            if ((int)((new HTuple((new HTuple((new HTuple(hv_ValueTmp.TupleLength()
                                )).TupleNotEqual(hv_NumColumns * hv_NumRows))).TupleAnd(new HTuple((new HTuple(hv_ValueTmp.TupleLength()
                                )).TupleNotEqual(1))))).TupleOr(((hv_ValueTmp.TupleIsString())).TupleNot()
                                )) != 0)
                            {
                                throw new HalconException("Invalid value for 'value_colors'");
                            }
                            if ((int)(new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleEqual(
                                1))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_ValueTmp = HTuple.TupleGenConst(
                                            hv_NumRows * hv_NumColumns, hv_ValueTmp);
                                        hv_ValueTmp.Dispose();
                                        hv_ValueTmp = ExpTmpLocalVar_ValueTmp;
                                    }
                                }
                            }
                        }
                        hv_ValueColors.Dispose();
                        hv_ValueColors = new HTuple(hv_ValueTmp);
                    }
                    //NumberFormat.
                    if ((int)(hv_KeyExists.TupleSelect(5)) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "number_format", out hv_ValueTmp);
                        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
                            1))).TupleOr(((hv_ValueTmp.TupleIsString())).TupleNot())) != 0)
                        {
                            throw new HalconException("Invalid value for 'number_format'");
                        }
                        else
                        {
                            hv_NumberFormat.Dispose();
                            hv_NumberFormat = new HTuple(hv_ValueTmp);
                        }
                    }
                    //Title.
                    if ((int)(hv_KeyExists.TupleSelect(6)) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "title", out hv_ValueTmp);
                        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
                            1))).TupleOr(((hv_ValueTmp.TupleIsString())).TupleNot())) != 0)
                        {
                            throw new HalconException("Invalid value for 'title'");
                        }
                        else
                        {
                            hv_Title.Dispose();
                            hv_Title = new HTuple(hv_ValueTmp);
                        }
                    }
                    //Color of column and row names.
                    if ((int)(hv_KeyExists.TupleSelect(7)) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "row_col_names_color", out hv_ValueTmp);
                        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
                            1))).TupleOr(((hv_ValueTmp.TupleIsString())).TupleNot())) != 0)
                        {
                            throw new HalconException("Invalid value for 'row_col_names_color'");
                        }
                        else
                        {
                            hv_AxisColor.Dispose();
                            hv_AxisColor = new HTuple(hv_ValueTmp);
                        }
                    }
                }
                //
                //
                //Calculate the width of row and column-name-strings.
                hv_ColStringWidths.Dispose();
                hv_ColStringWidths = new HTuple();
                hv_AllNames.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_AllNames = new HTuple();
                    hv_AllNames = hv_AllNames.TupleConcat(hv_ColumnNames, hv_RowNames);
                }
                hv_MaxStringWidth.Dispose();
                hv_MaxStringWidth = 0;
                for (hv_StringIndex = 0; (int)hv_StringIndex <= (int)((new HTuple(hv_AllNames.TupleLength()
                    )) - 1); hv_StringIndex = (int)hv_StringIndex + 1)
                {
                    hv_String.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_String = hv_AllNames.TupleSelect(
                            hv_StringIndex);
                    }
                    hv_Ascent.Dispose(); hv_Descent.Dispose(); hv_StringWidth.Dispose(); hv_StringHeight.Dispose();
                    HOperatorSet.GetStringExtents(hv_WindowHandle, hv_String, out hv_Ascent,
                        out hv_Descent, out hv_StringWidth, out hv_StringHeight);
                    if ((int)(new HTuple(hv_StringIndex.TupleLess(new HTuple(hv_ColumnNames.TupleLength()
                        )))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_ColStringWidths = hv_ColStringWidths.TupleConcat(
                                    hv_StringWidth);
                                hv_ColStringWidths.Dispose();
                                hv_ColStringWidths = ExpTmpLocalVar_ColStringWidths;
                            }
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_MaxStringWidth = hv_MaxStringWidth.TupleMax2(
                                hv_StringWidth);
                            hv_MaxStringWidth.Dispose();
                            hv_MaxStringWidth = ExpTmpLocalVar_MaxStringWidth;
                        }
                    }
                }
                //The columns should have a minimum width for 4 characters.
                hv_Ascent.Dispose(); hv_Descent.Dispose(); hv_StringWidth.Dispose(); hv_StringHeight.Dispose();
                HOperatorSet.GetStringExtents(hv_WindowHandle, "test", out hv_Ascent, out hv_Descent,
                    out hv_StringWidth, out hv_StringHeight);
                //Update the maximum string width.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_MaxStringWidth = hv_MaxStringWidth.TupleMax2(
                            hv_StringWidth);
                        hv_MaxStringWidth.Dispose();
                        hv_MaxStringWidth = ExpTmpLocalVar_MaxStringWidth;
                    }
                }
                //
                //Set parameters for nice display, e.g. distances from window border, row- and column-offsets,
                //axis titles and title.
                hv_TitleHeight.Dispose();
                hv_TitleHeight = 0;
                hv_AxisTitleHeight.Dispose();
                hv_AxisTitleHeight = 0;
                if ((int)(new HTuple((new HTuple(hv_AxisTitles.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    if ((int)(new HTuple((new HTuple(hv_Title.TupleLength())).TupleGreater(0))) != 0)
                    {
                        hv_TitleAscent.Dispose(); hv_TitleDescent.Dispose(); hv_TitleWidth.Dispose(); hv_TitleHeight.Dispose();
                        HOperatorSet.GetStringExtents(hv_WindowHandle, hv_Title, out hv_TitleAscent,
                            out hv_TitleDescent, out hv_TitleWidth, out hv_TitleHeight);
                        hv_AxisTitleAscent.Dispose(); hv_AxisTitleDescent.Dispose(); hv_AxisTitleWidth.Dispose(); hv_AxisTitleHeight.Dispose();
                        HOperatorSet.GetStringExtents(hv_WindowHandle, hv_AxisTitles, out hv_AxisTitleAscent,
                            out hv_AxisTitleDescent, out hv_AxisTitleWidth, out hv_AxisTitleHeight);
                    }
                }
                hv_RowStart.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RowStart = (80 + hv_TitleHeight) + hv_AxisTitleHeight;
                }
                hv_RowDistance.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RowDistance = hv_StringHeight + 10;
                }
                hv_RowEnd.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RowEnd = hv_StringHeight * 7;
                }
                hv_ColumnStart.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ColumnStart = 50 + hv_MaxStringWidth;
                }
                hv_ColumnOffset.Dispose();
                hv_ColumnOffset = 30;
                hv_ColumnEnd.Dispose();
                hv_ColumnEnd = new HTuple(hv_ColumnOffset);
                //
                //Adapt the window size to fit the confusion matrix.
                if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("minimal"))) != 0)
                {
                    //Every column of the confusion matrix is as narrow as possible
                    //based to the respective string widths.
                    hv_Width.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Width = (((hv_ColStringWidths.TupleSum()
                            ) + (hv_ColumnOffset * hv_NumColumns)) + hv_ColumnStart) + hv_ColumnEnd;
                    }
                }
                else if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("equal"))) != 0)
                {
                    //Every column of the confusion matrix should have the same width.
                    //based on the maximum string width.
                    hv_Width.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Width = (((hv_MaxStringWidth + hv_ColumnOffset) * hv_NumColumns) + hv_ColumnStart) + hv_ColumnEnd;
                    }
                }
                hv_Height.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Height = ((hv_RowDistance * hv_NumRows) + hv_RowStart) + hv_RowEnd;
                }
                HDevWindowStack.SetActive(hv_WindowHandle);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                }
                //
                //Set reasonable limits for graphics window (adapt if necessary).
                hv_WidthLimit.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WidthLimit = new HTuple();
                    hv_WidthLimit[0] = 450;
                    hv_WidthLimit = hv_WidthLimit.TupleConcat(hv_Width);
                }
                hv_HeightLimit.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HeightLimit = new HTuple();
                    hv_HeightLimit[0] = 250;
                    hv_HeightLimit = hv_HeightLimit.TupleConcat(hv_Height);
                }
                dev_resize_window_fit_size(0, 0, hv_Width, hv_Height, hv_WidthLimit, hv_HeightLimit);
                //
                //
                //Calculate row and column coordinates for display of values.
                hv_TextRow.Dispose();
                hv_TextRow = new HTuple();
                hv_TextColumn.Dispose();
                hv_TextColumn = new HTuple();
                hv_RowStartTmp.Dispose();
                hv_RowStartTmp = 0;
                hv_ColumnDistance.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ColumnDistance = new HTuple();
                    hv_ColumnDistance[0] = 0;
                    hv_ColumnDistance = hv_ColumnDistance.TupleConcat((((hv_ColStringWidths.TupleSelectRange(
                        0, hv_NumColumns - 2)) + hv_ColumnOffset)).TupleCumul());
                }
                if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("equal"))) != 0)
                {
                    hv_ColumnDistance.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ColumnDistance = HTuple.TupleGenSequence(
                            0, hv_NumColumns - 1, 1) * (hv_MaxStringWidth + hv_ColumnOffset);
                    }
                }
                HTuple end_val183 = hv_NumRows - 1;
                HTuple step_val183 = 1;
                for (hv_Index = 0; hv_Index.Continue(end_val183, step_val183); hv_Index = hv_Index.TupleAdd(step_val183))
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_TextRow = hv_TextRow.TupleConcat(
                                HTuple.TupleGenConst(hv_NumColumns, hv_RowStartTmp));
                            hv_TextRow.Dispose();
                            hv_TextRow = ExpTmpLocalVar_TextRow;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_RowStartTmp = hv_RowStartTmp + hv_RowDistance;
                            hv_RowStartTmp.Dispose();
                            hv_RowStartTmp = ExpTmpLocalVar_RowStartTmp;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_TextColumn = hv_TextColumn.TupleConcat(
                                hv_ColumnDistance);
                            hv_TextColumn.Dispose();
                            hv_TextColumn = ExpTmpLocalVar_TextColumn;
                        }
                    }
                }
                //Display the confusion matrix with a margin from the top and left.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_TextColumn = hv_TextColumn + hv_ColumnStart;
                        hv_TextColumn.Dispose();
                        hv_TextColumn = ExpTmpLocalVar_TextColumn;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_TextRow = hv_TextRow + hv_RowStart;
                        hv_TextRow.Dispose();
                        hv_TextRow = ExpTmpLocalVar_TextRow;
                    }
                }
                //
                //Display axis titles.
                if ((int)(new HTuple((new HTuple(hv_AxisTitles.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    if ((int)(new HTuple((new HTuple(hv_Title.TupleLength())).TupleGreater(0))) != 0)
                    {
                        hv_TitleAscent.Dispose(); hv_TitleDescent.Dispose(); hv_TitleWidth.Dispose(); hv_TitleHeight.Dispose();
                        HOperatorSet.GetStringExtents(hv_WindowHandle, hv_Title, out hv_TitleAscent,
                            out hv_TitleDescent, out hv_TitleWidth, out hv_TitleHeight);
                        hv_AxisTitleRowX.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_AxisTitleRowX = 1.5 * (hv_TitleHeight.TupleCeil()
                                );
                        }
                    }
                    else
                    {
                        hv_AxisTitleRowX.Dispose();
                        hv_AxisTitleRowX = "top";
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_AxisTitles.TupleSelect(
                                0), "window", hv_AxisTitleRowX, "right", "white", "box", "false");
                        }
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_AxisTitles.TupleSelect(
                                1), "window", "bottom", "left", "white", "box", "false");
                        }
                    }
                }
                //
                //Display title.
                if ((int)(new HTuple((new HTuple(hv_Title.TupleLength())).TupleGreater(0))) != 0)
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Title, "window",
                            "top", "left", "white", "box", "false");
                    }
                }
                //
                //Display row names.
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_RowNames, "window",
                            hv_TextRow.TupleSelect(HTuple.TupleGenSequence(0, hv_NumColumns * (hv_NumRows - 1),
                            hv_NumColumns)), HTuple.TupleGenConst(hv_NumRows, ((hv_TextColumn.TupleSelect(
                            0)) - hv_MaxStringWidth) - hv_ColumnOffset), hv_AxisColor, "box", "false");
                    }
                }
                //
                //Display column names.
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ColumnNames, "window",
                            HTuple.TupleGenConst(hv_NumColumns, (hv_TextRow.TupleSelect(0)) - hv_RowDistance),
                            hv_TextColumn.TupleSelectRange(0, hv_NumColumns - 1), hv_AxisColor, "box",
                            "false");
                    }
                }
                //
                //
                //Align the numbers right.
                hv_MatrixText.Dispose();
                HOperatorSet.GetFullMatrix(hv_Matrix, out hv_MatrixText);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_MatrixText = hv_MatrixText.TupleString(
                            hv_NumberFormat);
                        hv_MatrixText.Dispose();
                        hv_MatrixText = ExpTmpLocalVar_MatrixText;
                    }
                }
                //
                //
                //Handle no-display indices.
                hv_IdxsDisplay.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_IdxsDisplay = (HTuple.TupleGenSequence(
                        0, (new HTuple(hv_MatrixText.TupleLength())) - 1, 1)).TupleDifference(hv_IdxsNoDisplay);
                }
                //
                //Display confusion matrix.
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_MatrixText.TupleSelect(
                            hv_IdxsDisplay), "window", hv_TextRow.TupleSelect(hv_IdxsDisplay), hv_TextColumn.TupleSelect(
                            hv_IdxsDisplay), hv_ValueColors.TupleSelect(hv_IdxsDisplay), "box", "false");
                    }
                }

                hv_NumRows.Dispose();
                hv_NumColumns.Dispose();
                hv_DisplayColumnWidth.Dispose();
                hv_DisplayColor.Dispose();
                hv_IdxsNoDisplay.Dispose();
                hv_AxisTitles.Dispose();
                hv_ValueColors.Dispose();
                hv_NumberFormat.Dispose();
                hv_Title.Dispose();
                hv_AxisColor.Dispose();
                hv_GenParamKeys.Dispose();
                hv_KeyExists.Dispose();
                hv_ValueTmp.Dispose();
                hv_ColStringWidths.Dispose();
                hv_AllNames.Dispose();
                hv_MaxStringWidth.Dispose();
                hv_StringIndex.Dispose();
                hv_String.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_StringWidth.Dispose();
                hv_StringHeight.Dispose();
                hv_TitleHeight.Dispose();
                hv_AxisTitleHeight.Dispose();
                hv_TitleAscent.Dispose();
                hv_TitleDescent.Dispose();
                hv_TitleWidth.Dispose();
                hv_AxisTitleAscent.Dispose();
                hv_AxisTitleDescent.Dispose();
                hv_AxisTitleWidth.Dispose();
                hv_RowStart.Dispose();
                hv_RowDistance.Dispose();
                hv_RowEnd.Dispose();
                hv_ColumnStart.Dispose();
                hv_ColumnOffset.Dispose();
                hv_ColumnEnd.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_WidthLimit.Dispose();
                hv_HeightLimit.Dispose();
                hv_TextRow.Dispose();
                hv_TextColumn.Dispose();
                hv_RowStartTmp.Dispose();
                hv_ColumnDistance.Dispose();
                hv_Index.Dispose();
                hv_AxisTitleRowX.Dispose();
                hv_MatrixText.Dispose();
                hv_IdxsDisplay.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_NumRows.Dispose();
                hv_NumColumns.Dispose();
                hv_DisplayColumnWidth.Dispose();
                hv_DisplayColor.Dispose();
                hv_IdxsNoDisplay.Dispose();
                hv_AxisTitles.Dispose();
                hv_ValueColors.Dispose();
                hv_NumberFormat.Dispose();
                hv_Title.Dispose();
                hv_AxisColor.Dispose();
                hv_GenParamKeys.Dispose();
                hv_KeyExists.Dispose();
                hv_ValueTmp.Dispose();
                hv_ColStringWidths.Dispose();
                hv_AllNames.Dispose();
                hv_MaxStringWidth.Dispose();
                hv_StringIndex.Dispose();
                hv_String.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_StringWidth.Dispose();
                hv_StringHeight.Dispose();
                hv_TitleHeight.Dispose();
                hv_AxisTitleHeight.Dispose();
                hv_TitleAscent.Dispose();
                hv_TitleDescent.Dispose();
                hv_TitleWidth.Dispose();
                hv_AxisTitleAscent.Dispose();
                hv_AxisTitleDescent.Dispose();
                hv_AxisTitleWidth.Dispose();
                hv_RowStart.Dispose();
                hv_RowDistance.Dispose();
                hv_RowEnd.Dispose();
                hv_ColumnStart.Dispose();
                hv_ColumnOffset.Dispose();
                hv_ColumnEnd.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_WidthLimit.Dispose();
                hv_HeightLimit.Dispose();
                hv_TextRow.Dispose();
                hv_TextColumn.Dispose();
                hv_RowStartTmp.Dispose();
                hv_ColumnDistance.Dispose();
                hv_Index.Dispose();
                hv_AxisTitleRowX.Dispose();
                hv_MatrixText.Dispose();
                hv_IdxsDisplay.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: This procedure draws a pie chart into the active window handle. 
        public void dev_display_pie_chart(HTuple hv_WindowHandle, HTuple hv_Ratios, HTuple hv_Row,
            HTuple hv_Column, HTuple hv_Radius, HTuple hv_Colors, HTuple hv_GenParam)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Sectors, ho_Arc = null, ho_Sector = null;

            // Local control variables 

            HTuple hv_Tolerance = new HTuple(), hv_InitialWindowHandle = new HTuple();
            HTuple hv_NoInitialWindow = new HTuple(), hv_Red = new HTuple();
            HTuple hv_Green = new HTuple(), hv_Blue = new HTuple();
            HTuple hv_Alpha = new HTuple(), hv_InitialColor = new HTuple();
            HTuple hv_IndexColor = new HTuple(), hv_Color_RGBA = new HTuple();
            HTuple hv_Title = new HTuple(), hv_TitleColor = new HTuple();
            HTuple hv_TitleKeyExists = new HTuple(), hv_TitleColorKeyExists = new HTuple();
            HTuple hv_GivenTitle = new HTuple(), hv_GivenTitleColor = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_FullCircleAngle = new HTuple();
            HTuple hv_StartAngle = new HTuple(), hv_DrawColors = new HTuple();
            HTuple hv_K = new HTuple(), hv_EndAngle = new HTuple();
            HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
            HTuple hv_HomMat2DIdentity = new HTuple(), hv_HomMat2DRotate = new HTuple();
            HTuple hv_ContourStyle = new HTuple(), hv_Ascent = new HTuple();
            HTuple hv_Descent = new HTuple(), hv_Width = new HTuple();
            HTuple hv_Height = new HTuple();
            HTuple hv_Colors_COPY_INP_TMP = new HTuple(hv_Colors);
            HTuple hv_Ratios_COPY_INP_TMP = new HTuple(hv_Ratios);

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Sectors);
            HOperatorSet.GenEmptyObj(out ho_Arc);
            HOperatorSet.GenEmptyObj(out ho_Sector);
            try
            {
                //
                //Draw a pie-chart into the active window.
                //
                //Check input Ratios.
                if ((int)(new HTuple(((((hv_Ratios_COPY_INP_TMP.TupleLessElem(0.0))).TupleSum()
                    )).TupleGreater(0))) != 0)
                {
                    throw new HalconException("Values of parameter Ratios must be positive.");
                }
                hv_Tolerance.Dispose();
                hv_Tolerance = 0.1;
                if ((int)(new HTuple(((((1 - (hv_Ratios_COPY_INP_TMP.TupleSum()))).TupleAbs()
                    )).TupleGreaterEqual(hv_Tolerance))) != 0)
                {
                    throw new HalconException("Sum of Ratios differs too much from 1.");
                }
                //
                //Get current window handle.
                if (HDevWindowStack.IsOpen())
                {
                    hv_InitialWindowHandle = HDevWindowStack.GetActive();
                }
                //In case there is no open window, no initial values are to be reset.
                hv_NoInitialWindow.Dispose();
                hv_NoInitialWindow = 0;
                if ((int)(new HTuple(hv_InitialWindowHandle.TupleEqual(-1))) != 0)
                {
                    hv_NoInitialWindow.Dispose();
                    hv_NoInitialWindow = 1;
                }
                else
                {
                    //Get current set color.
                    hv_Red.Dispose(); hv_Green.Dispose(); hv_Blue.Dispose(); hv_Alpha.Dispose();
                    HOperatorSet.GetRgba(hv_InitialWindowHandle, out hv_Red, out hv_Green, out hv_Blue,
                        out hv_Alpha);
                    hv_InitialColor.Dispose();
                    hv_InitialColor = new HTuple();
                    for (hv_IndexColor = 0; (int)hv_IndexColor <= (int)((new HTuple(hv_Red.TupleLength()
                        )) - 1); hv_IndexColor = (int)hv_IndexColor + 1)
                    {
                        hv_Color_RGBA.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Color_RGBA = ((("#" + (((hv_Red.TupleSelect(
                                hv_IndexColor))).TupleString("2x"))) + (((hv_Green.TupleSelect(hv_IndexColor))).TupleString(
                                "2x"))) + (((hv_Blue.TupleSelect(hv_IndexColor))).TupleString("2x"))) + (((hv_Alpha.TupleSelect(
                                hv_IndexColor))).TupleString("2x"));
                        }
                        {
                            HTuple ExpTmpOutVar_0;
                            HOperatorSet.TupleRegexpReplace(hv_Color_RGBA, (new HTuple(" ")).TupleConcat(
                                "replace_all"), "0", out ExpTmpOutVar_0);
                            hv_Color_RGBA.Dispose();
                            hv_Color_RGBA = ExpTmpOutVar_0;
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_InitialColor = hv_InitialColor.TupleConcat(
                                    hv_Color_RGBA);
                                hv_InitialColor.Dispose();
                                hv_InitialColor = ExpTmpLocalVar_InitialColor;
                            }
                        }
                    }
                }
                HDevWindowStack.SetActive(hv_WindowHandle);
                //
                //In case no segment colors are specified, generate random colors.
                if ((int)(new HTuple((new HTuple(hv_Colors_COPY_INP_TMP.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    //Generate random colors.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Colors_COPY_INP_TMP.Dispose();
                        get_distinct_colors_dev_display_pie_chart(new HTuple(hv_Ratios_COPY_INP_TMP.TupleLength()
                            ), 1, 0, 220, out hv_Colors_COPY_INP_TMP);
                    }
                }
                //
                //Set default parameters.
                hv_Title.Dispose();
                hv_Title = new HTuple();
                hv_TitleColor.Dispose();
                hv_TitleColor = "white";
                //Get generic parameters.
                if ((int)(new HTuple((new HTuple(hv_GenParam.TupleLength())).TupleGreater(0))) != 0)
                {
                    hv_TitleKeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "key_exists", "title", out hv_TitleKeyExists);
                    hv_TitleColorKeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "key_exists", "title_color", out hv_TitleColorKeyExists);
                    //
                    //Title text.
                    if ((int)(hv_TitleKeyExists) != 0)
                    {
                        hv_GivenTitle.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "title", out hv_GivenTitle);
                        if ((int)((new HTuple(((hv_GivenTitle.TupleIsString())).TupleNot())).TupleOr(
                            new HTuple(((hv_GivenTitle.TupleStrlen())).TupleLess(1)))) != 0)
                        {
                            throw new HalconException("Invalid value for key 'title'");
                        }
                        hv_Title.Dispose();
                        hv_Title = new HTuple(hv_GivenTitle);
                    }
                    //Title color.
                    if ((int)(hv_TitleColorKeyExists) != 0)
                    {
                        hv_GivenTitleColor.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "title_color", out hv_GivenTitleColor);
                        if ((int)(((hv_GivenTitleColor.TupleIsString())).TupleNot()) != 0)
                        {
                            throw new HalconException("Invalid value for key 'title_color'");
                        }
                        try
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_GivenTitleColor);
                            }
                        }
                        // catch (Exception) 
                        catch (HalconException HDevExpDefaultException1)
                        {
                            HDevExpDefaultException1.ToHTuple(out hv_Exception);
                            throw new HalconException("Invalid value for key 'title_color'");
                        }
                        hv_TitleColor.Dispose();
                        hv_TitleColor = new HTuple(hv_GivenTitleColor);
                    }
                }
                hv_FullCircleAngle.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_FullCircleAngle = 2 * 3.14159;
                }
                hv_StartAngle.Dispose();
                hv_StartAngle = 0;
                //
                //Generate circle-sectors.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_Ratios = hv_Ratios_COPY_INP_TMP / (hv_Ratios_COPY_INP_TMP.TupleSum()
                            );
                        hv_Ratios_COPY_INP_TMP.Dispose();
                        hv_Ratios_COPY_INP_TMP = ExpTmpLocalVar_Ratios;
                    }
                }
                hv_DrawColors.Dispose();
                hv_DrawColors = new HTuple();
                ho_Sectors.Dispose();
                HOperatorSet.GenEmptyObj(out ho_Sectors);
                for (hv_K = 0; (int)hv_K <= (int)((new HTuple(hv_Ratios_COPY_INP_TMP.TupleLength()
                    )) - 1); hv_K = (int)hv_K + 1)
                {
                    if ((int)(new HTuple(((hv_Ratios_COPY_INP_TMP.TupleSelect(hv_K))).TupleGreater(
                        0))) != 0)
                    {
                        hv_EndAngle.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_EndAngle = hv_StartAngle + ((hv_Ratios_COPY_INP_TMP.TupleSelect(
                                hv_K)) * hv_FullCircleAngle);
                        }
                        ho_Arc.Dispose();
                        HOperatorSet.GenCircleContourXld(out ho_Arc, hv_Row, hv_Column, hv_Radius,
                            hv_StartAngle, hv_EndAngle, "positive", 1);
                        hv_Rows.Dispose(); hv_Columns.Dispose();
                        HOperatorSet.GetContourXld(ho_Arc, out hv_Rows, out hv_Columns);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_Sector.Dispose();
                            HOperatorSet.GenContourPolygonXld(out ho_Sector, ((hv_Row.TupleConcat(hv_Rows))).TupleConcat(
                                hv_Row), ((hv_Column.TupleConcat(hv_Columns))).TupleConcat(hv_Column));
                        }
                        hv_StartAngle.Dispose();
                        hv_StartAngle = new HTuple(hv_EndAngle);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_DrawColors = hv_DrawColors.TupleConcat(
                                    hv_Colors_COPY_INP_TMP.TupleSelect(hv_K));
                                hv_DrawColors.Dispose();
                                hv_DrawColors = ExpTmpLocalVar_DrawColors;
                            }
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_Sectors, ho_Sector, out ExpTmpOutVar_0);
                            ho_Sectors.Dispose();
                            ho_Sectors = ExpTmpOutVar_0;
                        }
                    }
                }
                //Rotate 90 degrees such that the first sector starts at the top.
                hv_HomMat2DIdentity.Dispose();
                HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HomMat2DRotate.Dispose();
                    HOperatorSet.HomMat2dRotate(hv_HomMat2DIdentity, 0.25 * hv_FullCircleAngle, hv_Row,
                        hv_Column, out hv_HomMat2DRotate);
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.AffineTransContourXld(ho_Sectors, out ExpTmpOutVar_0, hv_HomMat2DRotate);
                    ho_Sectors.Dispose();
                    ho_Sectors = ExpTmpOutVar_0;
                }
                //
                //Display sectors.
                HDevWindowStack.SetActive(hv_WindowHandle);
                hv_ContourStyle.Dispose();
                HOperatorSet.GetContourStyle(hv_WindowHandle, out hv_ContourStyle);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetContourStyle(HDevWindowStack.GetActive(), "stroke_and_fill");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_DrawColors);
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispObj(ho_Sectors, HDevWindowStack.GetActive());
                }
                //(Optional) title.
                if ((int)(new HTuple(hv_Title.TupleNotEqual(new HTuple()))) != 0)
                {
                    hv_Ascent.Dispose(); hv_Descent.Dispose(); hv_Width.Dispose(); hv_Height.Dispose();
                    HOperatorSet.GetStringExtents(hv_WindowHandle, hv_Title, out hv_Ascent, out hv_Descent,
                        out hv_Width, out hv_Height);
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Title, "image", (((hv_Row - hv_Radius) - hv_Height) - hv_Ascent) - hv_Descent,
                                hv_Column - (hv_Width / 2), hv_TitleColor, "box", "false");
                        }
                    }
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetContourStyle(HDevWindowStack.GetActive(), hv_ContourStyle);
                }
                //
                //Reset original window and colors (and close the window in case there was none open).
                if ((int)(hv_NoInitialWindow) != 0)
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                    }
                }
                else
                {
                    HDevWindowStack.SetActive(hv_InitialWindowHandle);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_InitialColor);
                    }
                }
                ho_Sectors.Dispose();
                ho_Arc.Dispose();
                ho_Sector.Dispose();

                hv_Colors_COPY_INP_TMP.Dispose();
                hv_Ratios_COPY_INP_TMP.Dispose();
                hv_Tolerance.Dispose();
                hv_InitialWindowHandle.Dispose();
                hv_NoInitialWindow.Dispose();
                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();
                hv_Alpha.Dispose();
                hv_InitialColor.Dispose();
                hv_IndexColor.Dispose();
                hv_Color_RGBA.Dispose();
                hv_Title.Dispose();
                hv_TitleColor.Dispose();
                hv_TitleKeyExists.Dispose();
                hv_TitleColorKeyExists.Dispose();
                hv_GivenTitle.Dispose();
                hv_GivenTitleColor.Dispose();
                hv_Exception.Dispose();
                hv_FullCircleAngle.Dispose();
                hv_StartAngle.Dispose();
                hv_DrawColors.Dispose();
                hv_K.Dispose();
                hv_EndAngle.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_HomMat2DIdentity.Dispose();
                hv_HomMat2DRotate.Dispose();
                hv_ContourStyle.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Sectors.Dispose();
                ho_Arc.Dispose();
                ho_Sector.Dispose();

                hv_Colors_COPY_INP_TMP.Dispose();
                hv_Ratios_COPY_INP_TMP.Dispose();
                hv_Tolerance.Dispose();
                hv_InitialWindowHandle.Dispose();
                hv_NoInitialWindow.Dispose();
                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();
                hv_Alpha.Dispose();
                hv_InitialColor.Dispose();
                hv_IndexColor.Dispose();
                hv_Color_RGBA.Dispose();
                hv_Title.Dispose();
                hv_TitleColor.Dispose();
                hv_TitleKeyExists.Dispose();
                hv_TitleColorKeyExists.Dispose();
                hv_GivenTitle.Dispose();
                hv_GivenTitleColor.Dispose();
                hv_Exception.Dispose();
                hv_FullCircleAngle.Dispose();
                hv_StartAngle.Dispose();
                hv_DrawColors.Dispose();
                hv_K.Dispose();
                hv_EndAngle.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_HomMat2DIdentity.Dispose();
                hv_HomMat2DRotate.Dispose();
                hv_ContourStyle.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection
        // Short Description: Display the detected anomaly regions. 
        public void dev_display_result_anomaly_regions(HObject ho_AnomalyImage, out HObject ho_AnomalyRegion,
            HTuple hv_CurrentWindowHandle, HTuple hv_AnomalyRegionThreshold, HTuple hv_LineWidth,
            HTuple hv_AnomalyRegionResultColor)
        {




            // Local iconic variables 

            // Local control variables 

            HTuple hv_Red = new HTuple(), hv_Green = new HTuple();
            HTuple hv_Blue = new HTuple(), hv_Alpha = new HTuple();
            HTuple hv_InitialColor = new HTuple(), hv_IndexColor = new HTuple();
            HTuple hv_Color_RGBA = new HTuple(), hv_Area = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_AnomalyRegion);
            try
            {
                //
                //This procedure displays the result anomaly regions
                //given in DLResult as anomaly_image.
                //
                //Get current set color.
                hv_Red.Dispose(); hv_Green.Dispose(); hv_Blue.Dispose(); hv_Alpha.Dispose();
                HOperatorSet.GetRgba(hv_CurrentWindowHandle, out hv_Red, out hv_Green, out hv_Blue,
                    out hv_Alpha);
                hv_InitialColor.Dispose();
                hv_InitialColor = new HTuple();
                for (hv_IndexColor = 0; (int)hv_IndexColor <= (int)((new HTuple(hv_Red.TupleLength()
                    )) - 1); hv_IndexColor = (int)hv_IndexColor + 1)
                {
                    hv_Color_RGBA.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Color_RGBA = ((("#" + (((hv_Red.TupleSelect(
                            hv_IndexColor))).TupleString("2x"))) + (((hv_Green.TupleSelect(hv_IndexColor))).TupleString(
                            "2x"))) + (((hv_Blue.TupleSelect(hv_IndexColor))).TupleString("2x"))) + (((hv_Alpha.TupleSelect(
                            hv_IndexColor))).TupleString("2x"));
                    }
                    {
                        HTuple ExpTmpOutVar_0;
                        HOperatorSet.TupleRegexpReplace(hv_Color_RGBA, (new HTuple(" ")).TupleConcat(
                            "replace_all"), "0", out ExpTmpOutVar_0);
                        hv_Color_RGBA.Dispose();
                        hv_Color_RGBA = ExpTmpOutVar_0;
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_InitialColor = hv_InitialColor.TupleConcat(
                                hv_Color_RGBA);
                            hv_InitialColor.Dispose();
                            hv_InitialColor = ExpTmpLocalVar_InitialColor;
                        }
                    }
                }
                //
                if ((int)((new HTuple(hv_AnomalyRegionThreshold.TupleGreater(1))).TupleOr(new HTuple(hv_AnomalyRegionThreshold.TupleLess(
                    0)))) != 0)
                {
                    throw new HalconException("Selected 'anomaly_region_threshold' out of range. It must be between 0 and 1.");
                }
                ho_AnomalyRegion.Dispose();
                HOperatorSet.Threshold(ho_AnomalyImage, out ho_AnomalyRegion, hv_AnomalyRegionThreshold,
                    1);
                //
                //Display anomaly regions.
                //Get non-empty regions.
                hv_Area.Dispose();
                HOperatorSet.RegionFeatures(ho_AnomalyRegion, "area", out hv_Area);
                //
                //Display all non-empty class regions in distinct colors.
                if ((int)(new HTuple(hv_Area.TupleGreater(0))) != 0)
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_AnomalyRegionResultColor);
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidth);
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_AnomalyRegion, HDevWindowStack.GetActive());
                    }
                }
                //
                //Reset colors.
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_InitialColor);
                }
                //

                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();
                hv_Alpha.Dispose();
                hv_InitialColor.Dispose();
                hv_IndexColor.Dispose();
                hv_Color_RGBA.Dispose();
                hv_Area.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();
                hv_Alpha.Dispose();
                hv_InitialColor.Dispose();
                hv_IndexColor.Dispose();
                hv_Color_RGBA.Dispose();
                hv_Area.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: Display result bounding boxes. 
        public void dev_display_result_detection(HTuple hv_DLResult, HTuple hv_ResultKeys,
            HTuple hv_LineWidthBbox, HTuple hv_ClassIDs, HTuple hv_TextConf, HTuple hv_Colors,
            HTuple hv_BoxLabelColor, HTuple hv_WindowImageRatio, HTuple hv_TextPositionRow,
            HTuple hv_TextColor, HTuple hv_ShowLabels, HTuple hv_ShowDirection, HTuple hv_WindowHandle,
            out HTuple hv_BboxIDs)
        {



            // Local iconic variables 

            HObject ho_BboxRectangle = null, ho_OrientationArrows = null;
            HObject ho_RectangleSelected = null, ho_ArrowSelected = null;

            // Local control variables 

            HTuple hv_InstanceType = new HTuple(), hv_BboxRow1 = new HTuple();
            HTuple hv_BboxCol1 = new HTuple(), hv_BboxRow2 = new HTuple();
            HTuple hv_BboxCol2 = new HTuple(), hv_BboxClasses = new HTuple();
            HTuple hv_BboxRow = new HTuple(), hv_BboxCol = new HTuple();
            HTuple hv_BboxLength1 = new HTuple(), hv_BboxLength2 = new HTuple();
            HTuple hv_BboxPhi = new HTuple(), hv_LabelRow1 = new HTuple();
            HTuple hv_LabelRow2 = new HTuple(), hv_LabelCol = new HTuple();
            HTuple hv_HeadSize = new HTuple(), hv_DrawMode = new HTuple();
            HTuple hv_Style = new HTuple(), hv_BboxClassIDs = new HTuple();
            HTuple hv_IndexBbox = new HTuple(), hv_ClassID = new HTuple();
            HTuple hv_LineWidth = new HTuple(), hv_Text = new HTuple();
            HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
            HTuple hv__ = new HTuple(), hv_TextRow = new HTuple();
            HTuple hv_TxtColor = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_BboxRectangle);
            HOperatorSet.GenEmptyObj(out ho_OrientationArrows);
            HOperatorSet.GenEmptyObj(out ho_RectangleSelected);
            HOperatorSet.GenEmptyObj(out ho_ArrowSelected);
            hv_BboxIDs = new HTuple();
            try
            {
                //
                //This procedure displays the bounding boxes defined by DLResult.
                //The ClassIDs are necessary to display bounding boxes from the same class
                //always with the same color.
                //
                hv_InstanceType.Dispose();
                hv_InstanceType = "rectangle1";
                if ((int)(new HTuple(((hv_ResultKeys.TupleFind("bbox_row1"))).TupleNotEqual(
                    -1))) != 0)
                {
                    hv_BboxRow1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_row1", out hv_BboxRow1);
                    hv_BboxCol1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_col1", out hv_BboxCol1);
                    hv_BboxRow2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_row2", out hv_BboxRow2);
                    hv_BboxCol2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_col2", out hv_BboxCol2);
                    hv_BboxClasses.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_class_id", out hv_BboxClasses);
                }
                else if ((int)(new HTuple(((hv_ResultKeys.TupleFind("bbox_phi"))).TupleNotEqual(
                    -1))) != 0)
                {
                    hv_BboxRow.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_row", out hv_BboxRow);
                    hv_BboxCol.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_col", out hv_BboxCol);
                    hv_BboxLength1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_length1", out hv_BboxLength1);
                    hv_BboxLength2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_length2", out hv_BboxLength2);
                    hv_BboxPhi.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_phi", out hv_BboxPhi);
                    hv_BboxClasses.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_class_id", out hv_BboxClasses);
                    hv_InstanceType.Dispose();
                    hv_InstanceType = "rectangle2";
                }
                else
                {
                    throw new HalconException("Result bounding box data could not be found in DLResult.");
                }
                if ((int)(new HTuple((new HTuple(hv_BboxClasses.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    //Generate bounding box XLDs.
                    if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BboxPhi.Dispose();
                            HOperatorSet.TupleGenConst(new HTuple(hv_BboxRow1.TupleLength()), 0.0,
                                out hv_BboxPhi);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_BboxRectangle.Dispose();
                            HOperatorSet.GenRectangle2ContourXld(out ho_BboxRectangle, 0.5 * (hv_BboxRow1 + hv_BboxRow2),
                                0.5 * (hv_BboxCol1 + hv_BboxCol2), hv_BboxPhi, 0.5 * (hv_BboxCol2 - hv_BboxCol1),
                                0.5 * (hv_BboxRow2 - hv_BboxRow1));
                        }
                        hv_LabelRow1.Dispose();
                        hv_LabelRow1 = new HTuple(hv_BboxRow1);
                        hv_LabelRow2.Dispose();
                        hv_LabelRow2 = new HTuple(hv_BboxRow2);
                        hv_LabelCol.Dispose();
                        hv_LabelCol = new HTuple(hv_BboxCol1);
                    }
                    else
                    {
                        ho_BboxRectangle.Dispose();
                        HOperatorSet.GenRectangle2ContourXld(out ho_BboxRectangle, hv_BboxRow,
                            hv_BboxCol, hv_BboxPhi, hv_BboxLength1, hv_BboxLength2);
                        hv_LabelRow1.Dispose();
                        hv_LabelRow1 = new HTuple(hv_BboxRow);
                        hv_LabelRow2.Dispose();
                        hv_LabelRow2 = new HTuple(hv_BboxRow);
                        hv_LabelCol.Dispose();
                        hv_LabelCol = new HTuple(hv_BboxCol);
                        if ((int)(hv_ShowDirection) != 0)
                        {
                            hv_HeadSize.Dispose();
                            hv_HeadSize = 20.0;
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_OrientationArrows.Dispose();
                                gen_arrow_contour_xld(out ho_OrientationArrows, hv_BboxRow, hv_BboxCol,
                                    hv_BboxRow - ((hv_BboxLength1 + hv_HeadSize) * (hv_BboxPhi.TupleSin())),
                                    hv_BboxCol + ((hv_BboxLength1 + hv_HeadSize) * (hv_BboxPhi.TupleCos())),
                                    hv_HeadSize, hv_HeadSize);
                            }
                        }
                    }
                    //
                    hv_DrawMode.Dispose();
                    HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
                    }
                    hv_Style.Dispose();
                    HOperatorSet.GetLineStyle(hv_WindowHandle, out hv_Style);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidthBbox);
                    }
                    //
                    //Collect ClassIDs of the bounding boxes.
                    hv_BboxIDs.Dispose();
                    hv_BboxIDs = new HTuple();
                    hv_BboxClassIDs.Dispose();
                    hv_BboxClassIDs = new HTuple();
                    //
                    //Draw bounding boxes.
                    for (hv_IndexBbox = 0; (int)hv_IndexBbox <= (int)((new HTuple(hv_BboxClasses.TupleLength()
                        )) - 1); hv_IndexBbox = (int)hv_IndexBbox + 1)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_RectangleSelected.Dispose();
                            HOperatorSet.SelectObj(ho_BboxRectangle, out ho_RectangleSelected, hv_IndexBbox + 1);
                        }
                        hv_ClassID.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClassID = hv_ClassIDs.TupleFind(
                                hv_BboxClasses.TupleSelect(hv_IndexBbox));
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_BboxClassIDs = hv_BboxClassIDs.TupleConcat(
                                    hv_ClassID);
                                hv_BboxClassIDs.Dispose();
                                hv_BboxClassIDs = ExpTmpLocalVar_BboxClassIDs;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_BboxIDs = hv_BboxIDs.TupleConcat(
                                    hv_ClassID);
                                hv_BboxIDs.Dispose();
                                hv_BboxIDs = ExpTmpLocalVar_BboxIDs;
                            }
                        }
                        hv_LineWidth.Dispose();
                        HOperatorSet.GetLineWidth(hv_WindowHandle, out hv_LineWidth);
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), ((hv_LineWidth + 2)).TupleInt()
                                    );
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetColor(HDevWindowStack.GetActive(), "black");
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_RectangleSelected, HDevWindowStack.GetActive()
                                );
                        }
                        if ((int)((new HTuple(hv_InstanceType.TupleEqual("rectangle2"))).TupleAnd(
                            hv_ShowDirection)) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_ArrowSelected.Dispose();
                                HOperatorSet.SelectObj(ho_OrientationArrows, out ho_ArrowSelected, hv_IndexBbox + 1);
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_ArrowSelected, HDevWindowStack.GetActive());
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidth.TupleInt()
                                    );
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Colors.TupleSelect(
                                    hv_ClassID));
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_RectangleSelected, HDevWindowStack.GetActive()
                                );
                        }
                        if ((int)((new HTuple(hv_InstanceType.TupleEqual("rectangle2"))).TupleAnd(
                            hv_ShowDirection)) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_ArrowSelected, HDevWindowStack.GetActive());
                            }
                        }
                    }
                    //
                    //Draw text of bounding boxes.
                    if ((int)(hv_ShowLabels) != 0)
                    {
                        //For better visibility the text is displayed after all bounding boxes are drawn.
                        for (hv_IndexBbox = 0; (int)hv_IndexBbox <= (int)((new HTuple(hv_BboxClasses.TupleLength()
                            )) - 1); hv_IndexBbox = (int)hv_IndexBbox + 1)
                        {
                            hv_ClassID.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClassID = hv_BboxClassIDs.TupleSelect(
                                    hv_IndexBbox);
                            }
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = (hv_BboxClasses.TupleSelect(
                                    hv_IndexBbox)) + (hv_TextConf.TupleSelect(hv_IndexBbox));
                            }
                            hv_Ascent.Dispose(); hv_Descent.Dispose(); hv__.Dispose(); hv__.Dispose();
                            HOperatorSet.GetStringExtents(hv_WindowHandle, hv_Text, out hv_Ascent,
                                out hv_Descent, out hv__, out hv__);
                            if ((int)(new HTuple(hv_TextPositionRow.TupleEqual("bottom"))) != 0)
                            {
                                hv_TextRow.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_TextRow = (hv_LabelRow2.TupleSelect(
                                        hv_IndexBbox)) - ((hv_Ascent + hv_Descent) / hv_WindowImageRatio);
                                }
                            }
                            else
                            {
                                hv_TextRow.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_TextRow = hv_LabelRow1.TupleSelect(
                                        hv_IndexBbox);
                                }
                            }
                            if ((int)(new HTuple(hv_TextColor.TupleEqual(""))) != 0)
                            {
                                hv_TxtColor.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_TxtColor = hv_Colors.TupleSelect(
                                        hv_ClassID);
                                }
                            }
                            else
                            {
                                hv_TxtColor.Dispose();
                                hv_TxtColor = new HTuple(hv_TextColor);
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "image",
                                        hv_TextRow, hv_LabelCol.TupleSelect(hv_IndexBbox), hv_TxtColor,
                                        ((new HTuple("box_color")).TupleConcat("shadow")).TupleConcat("border_radius"),
                                        hv_BoxLabelColor.TupleConcat((new HTuple("false")).TupleConcat(
                                        0)));
                                }
                            }
                        }
                    }
                    //
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
                    }
                    HOperatorSet.SetLineStyle(hv_WindowHandle, hv_Style);
                }
                else
                {
                    //Do nothing if no results are present.
                    hv_BboxIDs.Dispose();
                    hv_BboxIDs = new HTuple();
                }
                //
                ho_BboxRectangle.Dispose();
                ho_OrientationArrows.Dispose();
                ho_RectangleSelected.Dispose();
                ho_ArrowSelected.Dispose();

                hv_InstanceType.Dispose();
                hv_BboxRow1.Dispose();
                hv_BboxCol1.Dispose();
                hv_BboxRow2.Dispose();
                hv_BboxCol2.Dispose();
                hv_BboxClasses.Dispose();
                hv_BboxRow.Dispose();
                hv_BboxCol.Dispose();
                hv_BboxLength1.Dispose();
                hv_BboxLength2.Dispose();
                hv_BboxPhi.Dispose();
                hv_LabelRow1.Dispose();
                hv_LabelRow2.Dispose();
                hv_LabelCol.Dispose();
                hv_HeadSize.Dispose();
                hv_DrawMode.Dispose();
                hv_Style.Dispose();
                hv_BboxClassIDs.Dispose();
                hv_IndexBbox.Dispose();
                hv_ClassID.Dispose();
                hv_LineWidth.Dispose();
                hv_Text.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv__.Dispose();
                hv_TextRow.Dispose();
                hv_TxtColor.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_BboxRectangle.Dispose();
                ho_OrientationArrows.Dispose();
                ho_RectangleSelected.Dispose();
                ho_ArrowSelected.Dispose();

                hv_InstanceType.Dispose();
                hv_BboxRow1.Dispose();
                hv_BboxCol1.Dispose();
                hv_BboxRow2.Dispose();
                hv_BboxCol2.Dispose();
                hv_BboxClasses.Dispose();
                hv_BboxRow.Dispose();
                hv_BboxCol.Dispose();
                hv_BboxLength1.Dispose();
                hv_BboxLength2.Dispose();
                hv_BboxPhi.Dispose();
                hv_LabelRow1.Dispose();
                hv_LabelRow2.Dispose();
                hv_LabelCol.Dispose();
                hv_HeadSize.Dispose();
                hv_DrawMode.Dispose();
                hv_Style.Dispose();
                hv_BboxClassIDs.Dispose();
                hv_IndexBbox.Dispose();
                hv_ClassID.Dispose();
                hv_LineWidth.Dispose();
                hv_Text.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv__.Dispose();
                hv_TextRow.Dispose();
                hv_TxtColor.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: Display the ground truth/result segmentation as regions. 
        public void dev_display_segmentation_regions(HObject ho_SegmentationImage, HTuple hv_ClassIDs,
            HTuple hv_ColorsSegmentation, HTuple hv_ExcludeClassIDs, out HTuple hv_ImageClassIDs)
        {




            // Local iconic variables 

            HObject ho_Regions, ho_SelectedRegion = null;

            // Local control variables 

            HTuple hv_IncludedClassIDs = new HTuple();
            HTuple hv_Area = new HTuple(), hv_Index = new HTuple();
            HTuple hv_ClassID = new HTuple(), hv_IndexColor = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Regions);
            HOperatorSet.GenEmptyObj(out ho_SelectedRegion);
            hv_ImageClassIDs = new HTuple();
            try
            {
                //
                //This procedure displays the ground truth/result segmentation
                //given in SegmentationImage as regions. The ClassIDs are necessary to
                //display ground truth/result segmentations from the same class
                //always with the same color. It is possible to exclude certain ClassIDs
                //from being displayed. The displayed classes are returned in ImageClassIDs.
                //
                //
                //Remove excluded class IDs from the list.
                hv_IncludedClassIDs.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_IncludedClassIDs = hv_ClassIDs.TupleDifference(
                        hv_ExcludeClassIDs);
                }
                //
                //Get a region for each class ID.
                ho_Regions.Dispose();
                HOperatorSet.Threshold(ho_SegmentationImage, out ho_Regions, hv_IncludedClassIDs,
                    hv_IncludedClassIDs);
                //
                //Get classes with non-empty regions.
                hv_Area.Dispose();
                HOperatorSet.RegionFeatures(ho_Regions, "area", out hv_Area);
                hv_ImageClassIDs.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ImageClassIDs = hv_IncludedClassIDs.TupleSelectMask(
                        hv_Area.TupleGreaterElem(0));
                }
                //
                //Display all non-empty class regions in distinct colors.
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_IncludedClassIDs.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    if ((int)(new HTuple(((hv_Area.TupleSelect(hv_Index))).TupleGreater(0))) != 0)
                    {
                        //Use class ID to determine region color.
                        hv_ClassID.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClassID = hv_IncludedClassIDs.TupleSelect(
                                hv_Index);
                        }
                        hv_IndexColor.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_IndexColor = hv_ClassIDs.TupleFindFirst(
                                hv_ClassID);
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_ColorsSegmentation.TupleSelect(
                                    hv_IndexColor));
                            }
                        }
                        //Display the segmentation region.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_SelectedRegion.Dispose();
                            HOperatorSet.SelectObj(ho_Regions, out ho_SelectedRegion, hv_Index + 1);
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_SelectedRegion, HDevWindowStack.GetActive());
                        }
                    }
                }
                ho_Regions.Dispose();
                ho_SelectedRegion.Dispose();

                hv_IncludedClassIDs.Dispose();
                hv_Area.Dispose();
                hv_Index.Dispose();
                hv_ClassID.Dispose();
                hv_IndexColor.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Regions.Dispose();
                ho_SelectedRegion.Dispose();

                hv_IncludedClassIDs.Dispose();
                hv_Area.Dispose();
                hv_Index.Dispose();
                hv_ClassID.Dispose();
                hv_IndexColor.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: Display a map of weights. 
        public void dev_display_weight_regions(HObject ho_ImageWeight, HTuple hv_DrawTransparency,
            HTuple hv_SegMaxWeight, out HTuple hv_Colors)
        {




            // Local iconic variables 

            HObject ho_Domain, ho_WeightsRegion = null;

            // Local control variables 

            HTuple hv_NumColors = new HTuple(), hv_WeightsColorsAlpha = new HTuple();
            HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
            HTuple hv_GrayVal = new HTuple(), hv_GrayValWeight = new HTuple();
            HTuple hv_ColorIndex = new HTuple(), hv_ClassColor = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Domain);
            HOperatorSet.GenEmptyObj(out ho_WeightsRegion);
            hv_Colors = new HTuple();
            try
            {
                //
                //This procedure displays a map of the weights
                //given in ImageWeight as regions.
                //The transparency can be adjusted.
                //The used colors are returned.
                //
                //Define colors.
                hv_NumColors.Dispose();
                hv_NumColors = 20;
                hv_Colors.Dispose();
                get_distinct_colors(hv_NumColors, 0, 0, 160, out hv_Colors);
                {
                    HTuple ExpTmpOutVar_0;
                    HOperatorSet.TupleInverse(hv_Colors, out ExpTmpOutVar_0);
                    hv_Colors.Dispose();
                    hv_Colors = ExpTmpOutVar_0;
                }
                hv_WeightsColorsAlpha.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WeightsColorsAlpha = hv_Colors + hv_DrawTransparency;
                }
                //
                //Get gay values of ImageWeight.
                ho_Domain.Dispose();
                HOperatorSet.GetDomain(ho_ImageWeight, out ho_Domain);
                hv_Rows.Dispose(); hv_Columns.Dispose();
                HOperatorSet.GetRegionPoints(ho_Domain, out hv_Rows, out hv_Columns);
                hv_GrayVal.Dispose();
                HOperatorSet.GetGrayval(ho_ImageWeight, hv_Rows, hv_Columns, out hv_GrayVal);
                //
                //Check that the gray values of the image
                //are below the specified maximum.
                if ((int)(new HTuple(((hv_GrayVal.TupleMax())).TupleGreater(hv_SegMaxWeight))) != 0)
                {
                    throw new HalconException(((("The maximum weight (" + (hv_GrayVal.TupleMax()
                        )) + ") in the weight image is greater than the given SegMaxWeight (") + hv_SegMaxWeight) + ").");
                }
                //
                while ((int)(new HTuple(hv_GrayVal.TupleNotEqual(new HTuple()))) != 0)
                {
                    //Go through all gray value 'groups',
                    //starting from the maximum.
                    hv_GrayValWeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_GrayValWeight = hv_GrayVal.TupleMax()
                            ;
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_GrayVal = hv_GrayVal.TupleRemove(
                                hv_GrayVal.TupleFind(hv_GrayValWeight));
                            hv_GrayVal.Dispose();
                            hv_GrayVal = ExpTmpLocalVar_GrayVal;
                        }
                    }
                    ho_WeightsRegion.Dispose();
                    HOperatorSet.Threshold(ho_ImageWeight, out ho_WeightsRegion, hv_GrayValWeight,
                        hv_GrayValWeight);
                    //
                    //Visualize the respective group.
                    hv_ColorIndex.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ColorIndex = (((((hv_GrayValWeight / hv_SegMaxWeight) * (hv_NumColors - 1))).TupleCeil()
                            )).TupleInt();
                    }
                    hv_ClassColor.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassColor = hv_WeightsColorsAlpha.TupleSelect(
                            hv_ColorIndex);
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_ClassColor);
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_WeightsRegion, HDevWindowStack.GetActive());
                    }
                }
                ho_Domain.Dispose();
                ho_WeightsRegion.Dispose();

                hv_NumColors.Dispose();
                hv_WeightsColorsAlpha.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_GrayVal.Dispose();
                hv_GrayValWeight.Dispose();
                hv_ColorIndex.Dispose();
                hv_ClassColor.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Domain.Dispose();
                ho_WeightsRegion.Dispose();

                hv_NumColors.Dispose();
                hv_WeightsColorsAlpha.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_GrayVal.Dispose();
                hv_GrayValWeight.Dispose();
                hv_ColorIndex.Dispose();
                hv_ClassColor.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Develop
        // Short Description: Open a new graphics window that preserves the aspect ratio of the given image size. 
        public void dev_open_window_fit_size(HTuple hv_Row, HTuple hv_Column, HTuple hv_Width,
            HTuple hv_Height, HTuple hv_WidthLimit, HTuple hv_HeightLimit, out HTuple hv_WindowHandle)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_MinWidth = new HTuple(), hv_MaxWidth = new HTuple();
            HTuple hv_MinHeight = new HTuple(), hv_MaxHeight = new HTuple();
            HTuple hv_ResizeFactor = new HTuple(), hv_TempWidth = new HTuple();
            HTuple hv_TempHeight = new HTuple(), hv_WindowWidth = new HTuple();
            HTuple hv_WindowHeight = new HTuple();
            // Initialize local and output iconic variables 
            hv_WindowHandle = new HTuple();
            try
            {
                //This procedure open a new graphic window
                //such that it fits into the limits specified by WidthLimit
                //and HeightLimit, but also maintains the correct aspect ratio
                //given by Width and Height.
                //
                //If it is impossible to match the minimum and maximum extent requirements
                //at the same time (f.e. if the image is very long but narrow),
                //the maximum value gets a higher priority.
                //
                //Parse input tuple WidthLimit
                if ((int)((new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_WidthLimit.TupleLess(0)))) != 0)
                {
                    hv_MinWidth.Dispose();
                    hv_MinWidth = 500;
                    hv_MaxWidth.Dispose();
                    hv_MaxWidth = 800;
                }
                else if ((int)(new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
                    1))) != 0)
                {
                    hv_MinWidth.Dispose();
                    hv_MinWidth = 0;
                    hv_MaxWidth.Dispose();
                    hv_MaxWidth = new HTuple(hv_WidthLimit);
                }
                else
                {
                    hv_MinWidth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MinWidth = hv_WidthLimit.TupleSelect(
                            0);
                    }
                    hv_MaxWidth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxWidth = hv_WidthLimit.TupleSelect(
                            1);
                    }
                }
                //Parse input tuple HeightLimit
                if ((int)((new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_HeightLimit.TupleLess(0)))) != 0)
                {
                    hv_MinHeight.Dispose();
                    hv_MinHeight = 400;
                    hv_MaxHeight.Dispose();
                    hv_MaxHeight = 600;
                }
                else if ((int)(new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
                    1))) != 0)
                {
                    hv_MinHeight.Dispose();
                    hv_MinHeight = 0;
                    hv_MaxHeight.Dispose();
                    hv_MaxHeight = new HTuple(hv_HeightLimit);
                }
                else
                {
                    hv_MinHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MinHeight = hv_HeightLimit.TupleSelect(
                            0);
                    }
                    hv_MaxHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxHeight = hv_HeightLimit.TupleSelect(
                            1);
                    }
                }
                //
                //Test, if window size has to be changed.
                hv_ResizeFactor.Dispose();
                hv_ResizeFactor = 1;
                //First, expand window to the minimum extents (if necessary).
                if ((int)((new HTuple(hv_MinWidth.TupleGreater(hv_Width))).TupleOr(new HTuple(hv_MinHeight.TupleGreater(
                    hv_Height)))) != 0)
                {
                    hv_ResizeFactor.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ResizeFactor = (((((hv_MinWidth.TupleReal()
                            ) / hv_Width)).TupleConcat((hv_MinHeight.TupleReal()) / hv_Height))).TupleMax()
                            ;
                    }
                }
                hv_TempWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TempWidth = hv_Width * hv_ResizeFactor;
                }
                hv_TempHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TempHeight = hv_Height * hv_ResizeFactor;
                }
                //Then, shrink window to maximum extents (if necessary).
                if ((int)((new HTuple(hv_MaxWidth.TupleLess(hv_TempWidth))).TupleOr(new HTuple(hv_MaxHeight.TupleLess(
                    hv_TempHeight)))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResizeFactor = hv_ResizeFactor * ((((((hv_MaxWidth.TupleReal()
                                ) / hv_TempWidth)).TupleConcat((hv_MaxHeight.TupleReal()) / hv_TempHeight))).TupleMin()
                                );
                            hv_ResizeFactor.Dispose();
                            hv_ResizeFactor = ExpTmpLocalVar_ResizeFactor;
                        }
                    }
                }
                hv_WindowWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowWidth = hv_Width * hv_ResizeFactor;
                }
                hv_WindowHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowHeight = hv_Height * hv_ResizeFactor;
                }
                //Resize window
                HOperatorSet.SetWindowAttr("background_color", "black");
                HOperatorSet.OpenWindow(hv_Row, hv_Column, hv_WindowWidth, hv_WindowHeight, 0, "visible", "", out hv_WindowHandle);
                HDevWindowStack.Push(hv_WindowHandle);
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_Height - 1, hv_Width - 1);
                    }
                }

                hv_MinWidth.Dispose();
                hv_MaxWidth.Dispose();
                hv_MinHeight.Dispose();
                hv_MaxHeight.Dispose();
                hv_ResizeFactor.Dispose();
                hv_TempWidth.Dispose();
                hv_TempHeight.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_MinWidth.Dispose();
                hv_MaxWidth.Dispose();
                hv_MinHeight.Dispose();
                hv_MaxHeight.Dispose();
                hv_ResizeFactor.Dispose();
                hv_TempWidth.Dispose();
                hv_TempHeight.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Develop
        // Short Description: Resizes a graphics window with a given maximum extent such that it preserves the aspect ratio of a given width and height 
        public void dev_resize_window_fit_size(HTuple hv_Row, HTuple hv_Column, HTuple hv_Width,
            HTuple hv_Height, HTuple hv_WidthLimit, HTuple hv_HeightLimit)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_MinWidth = new HTuple(), hv_MaxWidth = new HTuple();
            HTuple hv_MinHeight = new HTuple(), hv_MaxHeight = new HTuple();
            HTuple hv_ResizeFactor = new HTuple(), hv_TempWidth = new HTuple();
            HTuple hv_TempHeight = new HTuple(), hv_WindowWidth = new HTuple();
            HTuple hv_WindowHeight = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure adjusts the size of the current window
                //such that it fits into the limits specified by WidthLimit
                //and HeightLimit, but also maintains the correct aspect ratio
                //given by Width and Height.
                //
                //If it is impossible to match the minimum and maximum extent requirements
                //at the same time (f.e. if the image is very long but narrow),
                //the maximum value gets a higher priority.
                //
                //Parse input tuple WidthLimit
                if ((int)((new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_WidthLimit.TupleLess(0)))) != 0)
                {
                    hv_MinWidth.Dispose();
                    hv_MinWidth = 500;
                    hv_MaxWidth.Dispose();
                    hv_MaxWidth = 800;
                }
                else if ((int)(new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
                    1))) != 0)
                {
                    hv_MinWidth.Dispose();
                    hv_MinWidth = 0;
                    hv_MaxWidth.Dispose();
                    hv_MaxWidth = new HTuple(hv_WidthLimit);
                }
                else
                {
                    hv_MinWidth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MinWidth = hv_WidthLimit.TupleSelect(
                            0);
                    }
                    hv_MaxWidth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxWidth = hv_WidthLimit.TupleSelect(
                            1);
                    }
                }
                //Parse input tuple HeightLimit
                if ((int)((new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_HeightLimit.TupleLess(0)))) != 0)
                {
                    hv_MinHeight.Dispose();
                    hv_MinHeight = 400;
                    hv_MaxHeight.Dispose();
                    hv_MaxHeight = 600;
                }
                else if ((int)(new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
                    1))) != 0)
                {
                    hv_MinHeight.Dispose();
                    hv_MinHeight = 0;
                    hv_MaxHeight.Dispose();
                    hv_MaxHeight = new HTuple(hv_HeightLimit);
                }
                else
                {
                    hv_MinHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MinHeight = hv_HeightLimit.TupleSelect(
                            0);
                    }
                    hv_MaxHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxHeight = hv_HeightLimit.TupleSelect(
                            1);
                    }
                }
                //
                //Test, if window size has to be changed.
                hv_ResizeFactor.Dispose();
                hv_ResizeFactor = 1;
                //First, expand window to the minimum extents (if necessary).
                if ((int)((new HTuple(hv_MinWidth.TupleGreater(hv_Width))).TupleOr(new HTuple(hv_MinHeight.TupleGreater(
                    hv_Height)))) != 0)
                {
                    hv_ResizeFactor.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ResizeFactor = (((((hv_MinWidth.TupleReal()
                            ) / hv_Width)).TupleConcat((hv_MinHeight.TupleReal()) / hv_Height))).TupleMax()
                            ;
                    }
                }
                hv_TempWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TempWidth = hv_Width * hv_ResizeFactor;
                }
                hv_TempHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TempHeight = hv_Height * hv_ResizeFactor;
                }
                //Then, shrink window to maximum extents (if necessary).
                if ((int)((new HTuple(hv_MaxWidth.TupleLess(hv_TempWidth))).TupleOr(new HTuple(hv_MaxHeight.TupleLess(
                    hv_TempHeight)))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResizeFactor = hv_ResizeFactor * ((((((hv_MaxWidth.TupleReal()
                                ) / hv_TempWidth)).TupleConcat((hv_MaxHeight.TupleReal()) / hv_TempHeight))).TupleMin()
                                );
                            hv_ResizeFactor.Dispose();
                            hv_ResizeFactor = ExpTmpLocalVar_ResizeFactor;
                        }
                    }
                }
                hv_WindowWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowWidth = hv_Width * hv_ResizeFactor;
                }
                hv_WindowHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowHeight = hv_Height * hv_ResizeFactor;
                }
                //Resize window
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_Row, hv_Column,
                        hv_WindowWidth, hv_WindowHeight);
                }
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_Height - 1, hv_Width - 1);
                    }
                }

                hv_MinWidth.Dispose();
                hv_MaxWidth.Dispose();
                hv_MinHeight.Dispose();
                hv_MaxHeight.Dispose();
                hv_ResizeFactor.Dispose();
                hv_TempWidth.Dispose();
                hv_TempHeight.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_MinWidth.Dispose();
                hv_MaxWidth.Dispose();
                hv_MinHeight.Dispose();
                hv_MaxHeight.Dispose();
                hv_ResizeFactor.Dispose();
                hv_TempWidth.Dispose();
                hv_TempHeight.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Develop
        // Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
        public void dev_update_off()
        {

            // Initialize local and output iconic variables 
            //This procedure sets different update settings to 'off'.
            //This is useful to get the best performance and reduce overhead.
            //
            // dev_update_pc(...); only in hdevelop
            // dev_update_var(...); only in hdevelop
            // dev_update_window(...); only in hdevelop


            return;
        }

        // Chapter: Time
        // Short Description: Estimate the remaining time for a task given the current progress. 
        public void estimate_progress(HTuple hv_SecondsStart, HTuple hv_ProgressMin, HTuple hv_ProgressCurrent,
            HTuple hv_ProgressMax, out HTuple hv_SecondsElapsed, out HTuple hv_SecondsRemaining,
            out HTuple hv_ProgressPercent, out HTuple hv_ProgressPerSecond)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_SecondsNow = new HTuple(), hv_Epsilon = new HTuple();
            HTuple hv_ProgressRemaining = new HTuple();
            // Initialize local and output iconic variables 
            hv_SecondsElapsed = new HTuple();
            hv_SecondsRemaining = new HTuple();
            hv_ProgressPercent = new HTuple();
            hv_ProgressPerSecond = new HTuple();
            try
            {
                //
                //This procedure estimates the remaining time in seconds,
                //given a start time and a progress value.
                //
                //Get current time.
                hv_SecondsNow.Dispose();
                HOperatorSet.CountSeconds(out hv_SecondsNow);
                //
                //Get elapsed time span.
                hv_SecondsElapsed.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SecondsElapsed = hv_SecondsNow - hv_SecondsStart;
                }
                //
                //A very small additive constant to avoid division by zero.
                hv_Epsilon.Dispose();
                hv_Epsilon = 1e-6;
                //
                //Estimate remaining time based on elapsed time.
                hv_ProgressRemaining.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ProgressRemaining = hv_ProgressMax - hv_ProgressCurrent;
                }
                hv_ProgressPerSecond.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ProgressPerSecond = (((hv_ProgressCurrent - hv_ProgressMin)).TupleReal()
                        ) / ((hv_SecondsElapsed.TupleReal()) + hv_Epsilon);
                }
                hv_SecondsRemaining.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SecondsRemaining = hv_ProgressRemaining / (hv_ProgressPerSecond + hv_Epsilon);
                }
                //
                //Get current progress in percent.
                hv_ProgressPercent.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ProgressPercent = (100 * (((hv_ProgressCurrent - hv_ProgressMin)).TupleReal()
                        )) / ((((hv_ProgressMax - hv_ProgressMin)).TupleReal()) + hv_Epsilon);
                }

                hv_SecondsNow.Dispose();
                hv_Epsilon.Dispose();
                hv_ProgressRemaining.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_SecondsNow.Dispose();
                hv_Epsilon.Dispose();
                hv_ProgressRemaining.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Evaluate the model given by DLModelHandle on the selected samples of DLDataset. 
        public void evaluate_dl_model(HTuple hv_DLDataset, HTuple hv_DLModelHandle, HTuple hv_SampleSelectMethod,
            HTuple hv_SampleSelectValues, HTuple hv_GenParam, out HTuple hv_EvaluationResult,
            out HTuple hv_EvalParams)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ModelType = new HTuple(), hv_ClassIDs = new HTuple();
            HTuple hv_BatchSize = new HTuple(), hv_InstanceType = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_IgnoreDirection = new HTuple();
            HTuple hv_Measures = new HTuple(), hv_ModelIgnoreClassIDs = new HTuple();
            HTuple hv_ShowProgress = new HTuple(), hv_GenParamKeys = new HTuple();
            HTuple hv_GenParamIndex = new HTuple(), hv_EvaluationType = new HTuple();
            HTuple hv_NumClasses = new HTuple(), hv_EvaluateInstances = new HTuple();
            HTuple hv_IoUThreshold = new HTuple(), hv_MaxNumDetections = new HTuple();
            HTuple hv_AreaRanges = new HTuple(), hv_DetailedEvaluation = new HTuple();
            HTuple hv_AllocationBlockLength = new HTuple(), hv_IgnoreClassIDs = new HTuple();
            HTuple hv_AllIgnoreClassIDs = new HTuple(), hv_EvaluateClassIDs = new HTuple();
            HTuple hv_ClassesToEvaluate = new HTuple(), hv_ClassNames = new HTuple();
            HTuple hv_KeyExists = new HTuple(), hv_ClassIDsToEvaluate = new HTuple();
            HTuple hv_AnomalyNumBins = new HTuple(), hv_AnomalyHistogram = new HTuple();
            HTuple hv_AnomalyMinValue = new HTuple(), hv_AnomalyMaxValue = new HTuple();
            HTuple hv_ClassInfoExists = new HTuple(), hv_DatasetClassIDs = new HTuple();
            HTuple hv_ClassIDsToClassNames = new HTuple(), hv_EvaluateClassNames = new HTuple();
            HTuple hv_DLSamples = new HTuple(), hv_SampleIndices = new HTuple();
            HTuple hv_NumSamples = new HTuple(), hv_NumBatches = new HTuple();
            HTuple hv_RunningMeasures = new HTuple(), hv_Progress = new HTuple();
            HTuple hv_TaskInfo = new HTuple(), hv_SecondsStart = new HTuple();
            HTuple hv_BatchIndex = new HTuple(), hv_BatchStart = new HTuple();
            HTuple hv_BatchEnd = new HTuple(), hv_SamplesIndicesBatch = new HTuple();
            HTuple hv_DLSamplesBatch = new HTuple(), hv_DLResultsBatch = new HTuple();
            HTuple hv_SecondsElapsed = new HTuple(), hv_SecondsRemaining = new HTuple();
            HTuple hv_ProgressPercent = new HTuple(), hv_ProgressPerSecond = new HTuple();
            HTuple hv_TimeElapsedString = new HTuple(), hv_TimeRemainingString = new HTuple();
            // Initialize local and output iconic variables 
            hv_EvaluationResult = new HTuple();
            hv_EvalParams = new HTuple();
            try
            {
                //This procedure applies the model given by DLModelHandle on the selected samples
                //of DLDataset and evaluates the results against the ground truth annotations
                //to calculate evaluation measures.
                //
                //Input:
                // - DLDataset.
                // - DLModelHandle.
                // - SampleSelectMethod: Method by which the samples are selected.
                // - SampleSelectValues: Identifier used to retrieve the samples from the DLDataset
                //                       for the corresponding selection method.
                // - GenParam: Parameters of the evaluation that should be changed from the default.
                //
                //Output:
                // - EvaluationResult: Dictionary containing the output measures.
                // - EvalParams: Dictionary with the used evaluation parameters.
                //
                //** Initialization: ***
                //
                hv_ModelType.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "type", out hv_ModelType);
                if ((int)((new HTuple((new HTuple((new HTuple(hv_ModelType.TupleNotEqual("anomaly_detection"))).TupleAnd(
                    new HTuple(hv_ModelType.TupleNotEqual("classification"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual(
                    "detection"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual("segmentation")))) != 0)
                {
                    throw new HalconException("Unknown model type");
                }
                //
                //Get the class IDs as set in the model.
                if ((int)(new HTuple(hv_ModelType.TupleEqual("anomaly_detection"))) != 0)
                {
                    //Default for anomaly detection is 0,1.
                    hv_ClassIDs.Dispose();
                    hv_ClassIDs = new HTuple();
                    hv_ClassIDs[0] = 0;
                    hv_ClassIDs[1] = 1;
                }
                else
                {
                    hv_ClassIDs.Dispose();
                    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "class_ids", out hv_ClassIDs);
                }
                //
                //Get the batch size as set in the model.
                hv_BatchSize.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "batch_size", out hv_BatchSize);
                //
                //Generate default parameters.
                hv_EvalParams.Dispose();
                create_evaluation_default_param(hv_ModelType, hv_ClassIDs, out hv_EvalParams);
                //
                //Get model specific information.
                if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
                {
                    try
                    {
                        hv_InstanceType.Dispose();
                        HOperatorSet.GetDlModelParam(hv_DLModelHandle, "instance_type", out hv_InstanceType);
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException1)
                    {
                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        hv_InstanceType.Dispose();
                        hv_InstanceType = "rectangle1";
                    }
                    //Overwrite the instance_type.
                    HOperatorSet.SetDictTuple(hv_EvalParams, "instance_type", hv_InstanceType);
                    //For rectangle2 detection with ignore_direction set to false, we also evaluate the
                    //precision of the predicted angle using the Score of Angle Precision (SoAP).
                    if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
                    {
                        hv_IgnoreDirection.Dispose();
                        HOperatorSet.GetDlModelParam(hv_DLModelHandle, "ignore_direction", out hv_IgnoreDirection);
                        if ((int)(new HTuple(hv_IgnoreDirection.TupleEqual("false"))) != 0)
                        {
                            hv_Measures.Dispose();
                            HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_EvalParams, "measures", hv_Measures.TupleConcat(
                                    "soap"));
                            }
                        }
                    }
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("segmentation"))) != 0)
                {
                    hv_ModelIgnoreClassIDs.Dispose();
                    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "ignore_class_ids", out hv_ModelIgnoreClassIDs);
                }
                //
                //By default we do not show the progress of evaluation.
                hv_ShowProgress.Dispose();
                hv_ShowProgress = 0;
                //
                //Set user specified parameters.
                if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
                {
                    hv_GenParamKeys.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_GenParamKeys);
                    for (hv_GenParamIndex = 0; (int)hv_GenParamIndex <= (int)((new HTuple(hv_GenParamKeys.TupleLength()
                        )) - 1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
                    {
                        if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "measures"))) != 0)
                        {
                            //Set measures.
                            hv_Measures.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "measures", out hv_Measures);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "measures", hv_Measures);
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "evaluation_type"))) != 0)
                        {
                            //Set evaluation type.
                            hv_EvaluationType.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "evaluation_type", out hv_EvaluationType);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "evaluation_type", hv_EvaluationType);
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "class_ids"))) != 0)
                        {
                            //Set class ids.
                            hv_ClassIDs.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "class_ids", out hv_ClassIDs);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "class_ids", hv_ClassIDs);
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "num_classes"))) != 0)
                        {
                            //Set number of classes.
                            hv_NumClasses.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "num_classes", out hv_NumClasses);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "num_classes", hv_NumClasses);
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "evaluate_instances"))) != 0)
                        {
                            //Set boolean for instance-based evaluation.
                            hv_EvaluateInstances.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "evaluate_instances", out hv_EvaluateInstances);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "evaluate_instances", hv_EvaluateInstances);
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "show_progress"))) != 0)
                        {
                            //Show the progress of the evaluation.
                            hv_ShowProgress.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "show_progress", out hv_ShowProgress);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ShowProgress = (new HTuple(hv_ShowProgress.TupleEqual(
                                        "true"))).TupleOr(new HTuple(hv_ShowProgress.TupleEqual(1)));
                                    hv_ShowProgress.Dispose();
                                    hv_ShowProgress = ExpTmpLocalVar_ShowProgress;
                                }
                            }
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "iou_threshold"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual("detection")))) != 0)
                        {
                            //Set IoU threshold.
                            hv_IoUThreshold.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "iou_threshold", out hv_IoUThreshold);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "iou_threshold", hv_IoUThreshold);
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "max_num_detections"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual(
                            "detection")))) != 0)
                        {
                            //Set maximal number detections.
                            hv_MaxNumDetections.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "max_num_detections", out hv_MaxNumDetections);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "max_num_detections", hv_MaxNumDetections);
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "area_ranges"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual("detection")))) != 0)
                        {
                            //Set area ranges.
                            hv_AreaRanges.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "area_ranges", out hv_AreaRanges);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "area_ranges", hv_AreaRanges);
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "detailed_evaluation"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual(
                            "detection")))) != 0)
                        {
                            //Set detailed evaluation.
                            hv_DetailedEvaluation.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "detailed_evaluation", out hv_DetailedEvaluation);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "detailed_evaluation", hv_DetailedEvaluation);
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "allocation_block_length"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual(
                            "detection")))) != 0)
                        {
                            //Set length of blocks that are allocated during evaluation.
                            hv_AllocationBlockLength.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "allocation_block_length", out hv_AllocationBlockLength);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "allocation_block_length", hv_AllocationBlockLength);
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "ignore_class_ids"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual("segmentation")))) != 0)
                        {
                            //Set ignore class IDs.
                            hv_IgnoreClassIDs.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "ignore_class_ids", out hv_IgnoreClassIDs);
                            //Merge the specified ignore class IDs with the model ignore class IDs.
                            hv_AllIgnoreClassIDs.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_AllIgnoreClassIDs = ((((hv_ModelIgnoreClassIDs.TupleConcat(
                                    hv_IgnoreClassIDs))).TupleSort())).TupleUniq();
                            }
                            HOperatorSet.SetDictTuple(hv_EvalParams, "ignore_class_ids", hv_AllIgnoreClassIDs);
                            //Remove the ignore class IDs from the model class IDs.
                            hv_EvaluateClassIDs.Dispose();
                            HOperatorSet.TupleDifference(hv_ClassIDs, hv_IgnoreClassIDs, out hv_EvaluateClassIDs);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "class_ids", hv_EvaluateClassIDs);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_EvalParams, "num_classes", new HTuple(hv_EvaluateClassIDs.TupleLength()
                                    ));
                            }
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "class_names_to_evaluate"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual(
                            "classification")))) != 0)
                        {
                            //Class names to be used in evaluation.
                            //To transform the names to IDs later, one has to remember the class names.
                            hv_ClassesToEvaluate.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "class_names_to_evaluate", out hv_ClassesToEvaluate);
                            hv_ClassNames.Dispose();
                            HOperatorSet.GetDlModelParam(hv_DLModelHandle, "class_names", out hv_ClassNames);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "class_names_to_evaluate", hv_ClassesToEvaluate);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "class_names", hv_ClassNames);
                            hv_KeyExists.Dispose();
                            HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "class_ids_to_evaluate",
                                out hv_KeyExists);
                            if ((int)(hv_KeyExists) != 0)
                            {
                                //To avoid inconsistent class names/IDs, remove the older ones.
                                HOperatorSet.RemoveDictKey(hv_EvalParams, "class_ids_to_evaluate");
                            }
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "class_ids_to_evaluate"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual(
                            "classification")))) != 0)
                        {
                            //Class IDs to be used in evaluation.
                            hv_ClassIDsToEvaluate.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "class_ids_to_evaluate", out hv_ClassIDsToEvaluate);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "class_ids_to_evaluate", hv_ClassIDsToEvaluate);
                            hv_KeyExists.Dispose();
                            HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "class_names_to_evaluate",
                                out hv_KeyExists);
                            if ((int)(hv_KeyExists) != 0)
                            {
                                //To avoid inconsistent class names/IDs, remove the older ones.
                                HOperatorSet.RemoveDictKey(hv_EvalParams, "class_names_to_evaluate");
                            }
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "anomaly_num_bins"))) != 0)
                        {
                            //
                            //Set anomaly histogram number of bins.
                            hv_AnomalyNumBins.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "anomaly_num_bins", out hv_AnomalyNumBins);
                            hv_AnomalyHistogram.Dispose();
                            HOperatorSet.GetDictTuple(hv_EvalParams, "anomaly_score_histogram", out hv_AnomalyHistogram);
                            HOperatorSet.SetDictTuple(hv_AnomalyHistogram, "num_bins", hv_AnomalyNumBins);
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "anomaly_min_value"))) != 0)
                        {
                            //
                            //Set anomaly histogram minimum value.
                            hv_AnomalyMinValue.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "anomaly_min_value", out hv_AnomalyMinValue);
                            hv_AnomalyHistogram.Dispose();
                            HOperatorSet.GetDictTuple(hv_EvalParams, "anomaly_score_histogram", out hv_AnomalyHistogram);
                            HOperatorSet.SetDictTuple(hv_AnomalyHistogram, "min", hv_AnomalyMinValue);
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "anomaly_max_value"))) != 0)
                        {
                            //
                            //Set anomaly histogram maximum value.
                            hv_AnomalyMaxValue.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "anomaly_max_value", out hv_AnomalyMaxValue);
                            hv_AnomalyHistogram.Dispose();
                            HOperatorSet.GetDictTuple(hv_EvalParams, "anomaly_score_histogram", out hv_AnomalyHistogram);
                            HOperatorSet.SetDictTuple(hv_AnomalyHistogram, "max", hv_AnomalyMaxValue);
                        }
                        else
                        {
                            throw new HalconException(("Unknown parameter : '" + (hv_GenParamKeys.TupleSelect(
                                hv_GenParamIndex))) + "'");
                        }
                    }
                }
                //
                //Get the class names from the dataset if present.
                hv_ClassInfoExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLDataset, "key_exists", (new HTuple("class_names")).TupleConcat(
                    "class_ids"), out hv_ClassInfoExists);
                if ((int)(new HTuple(((hv_ClassInfoExists.TupleSum())).TupleEqual(new HTuple(hv_ClassInfoExists.TupleLength()
                    )))) != 0)
                {
                    hv_ClassNames.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLDataset, "class_names", out hv_ClassNames);
                    hv_DatasetClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLDataset, "class_ids", out hv_DatasetClassIDs);
                    //Set the class names only for the class IDs that are evaluated.
                    hv_EvaluateClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_EvaluateClassIDs);
                    hv_ClassIDsToClassNames.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassIDsToClassNames = HTuple.TupleGenConst(
                            (hv_DatasetClassIDs.TupleMax()) + 1, "");
                    }
                    if (hv_ClassIDsToClassNames == null)
                        hv_ClassIDsToClassNames = new HTuple();
                    hv_ClassIDsToClassNames[hv_DatasetClassIDs] = hv_ClassNames;
                    hv_EvaluateClassNames.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_EvaluateClassNames = hv_ClassIDsToClassNames.TupleSelect(
                            hv_EvaluateClassIDs);
                    }
                    //Set the class names to EvalParams.
                    HOperatorSet.SetDictTuple(hv_EvalParams, "class_names", hv_EvaluateClassNames);
                }
                //
                //Get indices of samples to read from the dataset.
                hv_DLSamples.Dispose();
                HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLSamples);
                //
                //Check if there are samples present in the dataset.
                if ((int)(new HTuple((new HTuple(hv_DLSamples.TupleLength())).TupleEqual(0))) != 0)
                {
                    throw new HalconException("The provided set of samples in the dataset must be non-empty.");
                }
                //
                //Check for empty SampleSelectValues.
                if ((int)(new HTuple((new HTuple(hv_SampleSelectValues.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    if ((int)(new HTuple(hv_SampleSelectMethod.TupleEqual("image_ids"))) != 0)
                    {
                        throw new HalconException("The provided set of samples of the 'image_ids' selection must be non-empty.");
                    }
                    else if ((int)(new HTuple(hv_SampleSelectMethod.TupleEqual("sample_indices"))) != 0)
                    {
                        throw new HalconException("The provided set of samples of the 'sample_indices' selection must be non-empty.");
                    }
                    else
                    {
                        throw new HalconException("Provide a name for 'split' selection.");
                    }
                }
                //
                //
                //Get the sample indices according to the sample selection method.
                hv_SampleIndices.Dispose();
                hv_SampleIndices = new HTuple();
                if ((int)(new HTuple(hv_SampleSelectMethod.TupleEqual("split"))) != 0)
                {
                    //Get the samples of the split specified.
                    hv_SampleIndices.Dispose();
                    find_dl_samples(hv_DLSamples, "split", hv_SampleSelectValues, "or", out hv_SampleIndices);
                }
                else if ((int)(new HTuple(hv_SampleSelectMethod.TupleEqual("image_ids"))) != 0)
                {
                    //Get the samples specified by 'image_ids'.
                    if ((int)(new HTuple((new HTuple(hv_SampleSelectValues.TupleLength())).TupleGreater(
                        new HTuple(hv_DLSamples.TupleLength())))) != 0)
                    {
                        throw new HalconException("The number of the image ids provided through 'image_id' is invalid.");
                    }
                    hv_SampleIndices.Dispose();
                    find_dl_samples(hv_DLSamples, "image_id", hv_SampleSelectValues, "or", out hv_SampleIndices);
                }
                else if ((int)(new HTuple(hv_SampleSelectMethod.TupleEqual("sample_indices"))) != 0)
                {
                    //Get the samples specified by 'sample_indices'.
                    if ((int)((new HTuple(((hv_SampleSelectValues.TupleMin())).TupleLess(0))).TupleOr(
                        new HTuple(((hv_SampleSelectValues.TupleMax())).TupleGreater((new HTuple(hv_DLSamples.TupleLength()
                        )) - 1)))) != 0)
                    {
                        throw new HalconException("The range of the indices provided through 'sample_indices' is invalid.");
                    }
                    hv_SampleIndices.Dispose();
                    hv_SampleIndices = new HTuple(hv_SampleSelectValues);
                }
                else
                {
                    throw new HalconException(("Unknown sample selection method : '" + hv_SampleSelectMethod) + "'");
                }
                //
                //Get the number of batches.
                hv_NumSamples.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumSamples = new HTuple(hv_SampleIndices.TupleLength()
                        );
                }
                hv_NumBatches.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumBatches = ((((hv_NumSamples / (hv_BatchSize.TupleReal()
                        ))).TupleCeil())).TupleInt();
                }
                //
                //Check for empty samples selected by the selection method.
                if ((int)(new HTuple(hv_NumSamples.TupleEqual(0))) != 0)
                {
                    throw new HalconException(("No samples present in the dataset that are part of the '" + hv_SampleSelectMethod) + "' selection.");
                }
                //
                //
                //** Running measures are initialized according to evaluation method.
                //
                hv_RunningMeasures.Dispose();
                init_running_evaluation_measures(hv_EvalParams, out hv_RunningMeasures);
                //
                //
                //** Apply model to each image and gather evaluation information: ***
                //
                //Initialize progress variables.
                if ((int)(hv_ShowProgress) != 0)
                {
                    hv_Progress.Dispose();
                    hv_Progress = new HTuple();
                    hv_Progress[0] = "Procedure: evaluate_dl_model";
                    hv_Progress[1] = "";
                    hv_Progress[2] = "";
                    hv_Progress[3] = "";
                    if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
                    {
                        hv_TaskInfo.Dispose();
                        hv_TaskInfo = "Task: 1/2: Applying the model and collecting running evaluation measures";
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Progress = hv_Progress.TupleConcat(
                                    hv_TaskInfo);
                                hv_Progress.Dispose();
                                hv_Progress = ExpTmpLocalVar_Progress;
                            }
                        }
                    }
                    hv_SecondsStart.Dispose();
                    HOperatorSet.CountSeconds(out hv_SecondsStart);
                    // dev_inspect_ctrl(...); only in hdevelop
                }
                //
                //Loop batchwise over the samples to be evaluated.
                HTuple end_val249 = hv_NumBatches - 1;
                HTuple step_val249 = 1;
                for (hv_BatchIndex = 0; hv_BatchIndex.Continue(end_val249, step_val249); hv_BatchIndex = hv_BatchIndex.TupleAdd(step_val249))
                {
                    hv_BatchStart.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BatchStart = hv_BatchIndex * hv_BatchSize;
                    }
                    hv_BatchEnd.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BatchEnd = (((hv_BatchStart + hv_BatchSize) - 1)).TupleMin2(
                            hv_NumSamples - 1);
                    }
                    hv_SamplesIndicesBatch.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SamplesIndicesBatch = hv_SampleIndices.TupleSelectRange(
                            hv_BatchStart, hv_BatchEnd);
                    }
                    //
                    //Read samples
                    hv_DLSamplesBatch.Dispose();
                    read_dl_samples(hv_DLDataset, hv_SamplesIndicesBatch, out hv_DLSamplesBatch);
                    //
                    //Apply the model.
                    hv_DLResultsBatch.Dispose();
                    HOperatorSet.ApplyDlModel(hv_DLModelHandle, hv_DLSamplesBatch, new HTuple(),
                        out hv_DLResultsBatch);
                    //
                    //Update the running measures.
                    update_running_evaluation_measures(hv_DLSamplesBatch, hv_DLResultsBatch,
                        hv_EvalParams, hv_RunningMeasures);
                    //
                    //Provide progress information.
                    if ((int)(hv_ShowProgress.TupleAnd((new HTuple(((hv_BatchIndex % 10)).TupleEqual(
                        1))).TupleOr(new HTuple(hv_BatchIndex.TupleEqual(hv_NumBatches - 1))))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_SecondsElapsed.Dispose(); hv_SecondsRemaining.Dispose(); hv_ProgressPercent.Dispose(); hv_ProgressPerSecond.Dispose();
                            estimate_progress(hv_SecondsStart, 0, hv_BatchIndex, hv_NumBatches - 1, out hv_SecondsElapsed,
                                out hv_SecondsRemaining, out hv_ProgressPercent, out hv_ProgressPerSecond);
                        }
                        hv_TimeElapsedString.Dispose();
                        timespan_string(hv_SecondsElapsed, "auto", out hv_TimeElapsedString);
                        hv_TimeRemainingString.Dispose();
                        timespan_string(hv_SecondsRemaining, "top2", out hv_TimeRemainingString);
                        if (hv_Progress == null)
                            hv_Progress = new HTuple();
                        hv_Progress[1] = ("Progress: " + (hv_ProgressPercent.TupleRound())) + " %";
                        if (hv_Progress == null)
                            hv_Progress = new HTuple();
                        hv_Progress[2] = "Time elapsed: " + hv_TimeElapsedString;
                        if (hv_Progress == null)
                            hv_Progress = new HTuple();
                        hv_Progress[3] = "Time left: " + hv_TimeRemainingString;
                    }
                }
                //
                //Provide progress information.
                if ((int)(hv_ShowProgress.TupleAnd(new HTuple(hv_ModelType.TupleEqual("detection")))) != 0)
                {
                    hv_Progress.Dispose();
                    hv_Progress = new HTuple();
                    hv_Progress[0] = "Procedure: evaluate_dl_model";
                    hv_Progress[1] = "";
                    hv_Progress[2] = "";
                    if (hv_Progress == null)
                        hv_Progress = new HTuple();
                    hv_Progress[1] = "Please wait...";
                    if (hv_Progress == null)
                        hv_Progress = new HTuple();
                    hv_Progress[2] = "Task: 2/2: Calculating final evaluation measures";
                }
                //
                //
                //** Do the actual calculation of measures: ***
                //
                hv_EvaluationResult.Dispose();
                calculate_evaluation_measures(hv_RunningMeasures, hv_EvalParams, out hv_EvaluationResult);
                //
                //Close progress inspect.
                if ((int)(hv_ShowProgress) != 0)
                {
                    hv_Progress.Dispose();
                    hv_Progress = "Done.";
                    // dev_close_inspect_ctrl(...); only in hdevelop
                }
                //

                hv_ModelType.Dispose();
                hv_ClassIDs.Dispose();
                hv_BatchSize.Dispose();
                hv_InstanceType.Dispose();
                hv_Exception.Dispose();
                hv_IgnoreDirection.Dispose();
                hv_Measures.Dispose();
                hv_ModelIgnoreClassIDs.Dispose();
                hv_ShowProgress.Dispose();
                hv_GenParamKeys.Dispose();
                hv_GenParamIndex.Dispose();
                hv_EvaluationType.Dispose();
                hv_NumClasses.Dispose();
                hv_EvaluateInstances.Dispose();
                hv_IoUThreshold.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_AllIgnoreClassIDs.Dispose();
                hv_EvaluateClassIDs.Dispose();
                hv_ClassesToEvaluate.Dispose();
                hv_ClassNames.Dispose();
                hv_KeyExists.Dispose();
                hv_ClassIDsToEvaluate.Dispose();
                hv_AnomalyNumBins.Dispose();
                hv_AnomalyHistogram.Dispose();
                hv_AnomalyMinValue.Dispose();
                hv_AnomalyMaxValue.Dispose();
                hv_ClassInfoExists.Dispose();
                hv_DatasetClassIDs.Dispose();
                hv_ClassIDsToClassNames.Dispose();
                hv_EvaluateClassNames.Dispose();
                hv_DLSamples.Dispose();
                hv_SampleIndices.Dispose();
                hv_NumSamples.Dispose();
                hv_NumBatches.Dispose();
                hv_RunningMeasures.Dispose();
                hv_Progress.Dispose();
                hv_TaskInfo.Dispose();
                hv_SecondsStart.Dispose();
                hv_BatchIndex.Dispose();
                hv_BatchStart.Dispose();
                hv_BatchEnd.Dispose();
                hv_SamplesIndicesBatch.Dispose();
                hv_DLSamplesBatch.Dispose();
                hv_DLResultsBatch.Dispose();
                hv_SecondsElapsed.Dispose();
                hv_SecondsRemaining.Dispose();
                hv_ProgressPercent.Dispose();
                hv_ProgressPerSecond.Dispose();
                hv_TimeElapsedString.Dispose();
                hv_TimeRemainingString.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ModelType.Dispose();
                hv_ClassIDs.Dispose();
                hv_BatchSize.Dispose();
                hv_InstanceType.Dispose();
                hv_Exception.Dispose();
                hv_IgnoreDirection.Dispose();
                hv_Measures.Dispose();
                hv_ModelIgnoreClassIDs.Dispose();
                hv_ShowProgress.Dispose();
                hv_GenParamKeys.Dispose();
                hv_GenParamIndex.Dispose();
                hv_EvaluationType.Dispose();
                hv_NumClasses.Dispose();
                hv_EvaluateInstances.Dispose();
                hv_IoUThreshold.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_AllIgnoreClassIDs.Dispose();
                hv_EvaluateClassIDs.Dispose();
                hv_ClassesToEvaluate.Dispose();
                hv_ClassNames.Dispose();
                hv_KeyExists.Dispose();
                hv_ClassIDsToEvaluate.Dispose();
                hv_AnomalyNumBins.Dispose();
                hv_AnomalyHistogram.Dispose();
                hv_AnomalyMinValue.Dispose();
                hv_AnomalyMaxValue.Dispose();
                hv_ClassInfoExists.Dispose();
                hv_DatasetClassIDs.Dispose();
                hv_ClassIDsToClassNames.Dispose();
                hv_EvaluateClassNames.Dispose();
                hv_DLSamples.Dispose();
                hv_SampleIndices.Dispose();
                hv_NumSamples.Dispose();
                hv_NumBatches.Dispose();
                hv_RunningMeasures.Dispose();
                hv_Progress.Dispose();
                hv_TaskInfo.Dispose();
                hv_SecondsStart.Dispose();
                hv_BatchIndex.Dispose();
                hv_BatchStart.Dispose();
                hv_BatchEnd.Dispose();
                hv_SamplesIndicesBatch.Dispose();
                hv_DLSamplesBatch.Dispose();
                hv_DLResultsBatch.Dispose();
                hv_SecondsElapsed.Dispose();
                hv_SecondsRemaining.Dispose();
                hv_ProgressPercent.Dispose();
                hv_ProgressPerSecond.Dispose();
                hv_TimeElapsedString.Dispose();
                hv_TimeRemainingString.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Retrieve the indices of Samples that contain KeyName matching KeyValue according to the Mode set. 
        public void find_dl_samples(HTuple hv_Samples, HTuple hv_KeyName, HTuple hv_KeyValue,
            HTuple hv_Mode, out HTuple hv_SampleIndices)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_NumKeyValues = new HTuple(), hv_SampleIndex = new HTuple();
            HTuple hv_Sample = new HTuple(), hv_KeyExists = new HTuple();
            HTuple hv_Tuple = new HTuple(), hv_Hit = new HTuple();
            HTuple hv_ValueIndex = new HTuple(), hv_Value = new HTuple();
            // Initialize local and output iconic variables 
            hv_SampleIndices = new HTuple();
            try
            {
                //
                //This procedure gets the indices of the samples that contain the
                //requested KeyName matching the requested KeyValue according to the Mode.
                //If there is no match, an empty tuple [] will be returned.
                //
                //Check input parameters.
                if ((int)(new HTuple((new HTuple(hv_KeyName.TupleLength())).TupleNotEqual(1))) != 0)
                {
                    throw new HalconException(new HTuple("Invalid KeyName size: ") + (new HTuple(hv_KeyName.TupleLength()
                        )));
                }
                if ((int)(new HTuple((new HTuple(hv_Mode.TupleLength())).TupleNotEqual(1))) != 0)
                {
                    throw new HalconException(new HTuple("Invalid Mode size: ") + (new HTuple(hv_Mode.TupleLength()
                        )));
                }
                if ((int)((new HTuple((new HTuple(hv_Mode.TupleNotEqual("match"))).TupleAnd(
                    new HTuple(hv_Mode.TupleNotEqual("or"))))).TupleAnd(new HTuple(hv_Mode.TupleNotEqual(
                    "contain")))) != 0)
                {
                    throw new HalconException("Invalid Mode value: " + hv_Mode);
                }
                hv_NumKeyValues.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumKeyValues = new HTuple(hv_KeyValue.TupleLength()
                        );
                }
                if ((int)((new HTuple(hv_Mode.TupleEqual("contain"))).TupleAnd(new HTuple(hv_NumKeyValues.TupleLess(
                    1)))) != 0)
                {
                    throw new HalconException("Invalid KeyValue size for contain Mode: " + hv_NumKeyValues);
                }
                //
                //Find the indices.
                hv_SampleIndices.Dispose();
                hv_SampleIndices = new HTuple();
                for (hv_SampleIndex = 0; (int)hv_SampleIndex <= (int)((new HTuple(hv_Samples.TupleLength()
                    )) - 1); hv_SampleIndex = (int)hv_SampleIndex + 1)
                {
                    hv_Sample.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Sample = hv_Samples.TupleSelect(
                            hv_SampleIndex);
                    }
                    hv_KeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_Sample, "key_exists", hv_KeyName, out hv_KeyExists);
                    if ((int)(hv_KeyExists) != 0)
                    {
                        hv_Tuple.Dispose();
                        HOperatorSet.GetDictTuple(hv_Sample, hv_KeyName, out hv_Tuple);
                        if ((int)(new HTuple(hv_Mode.TupleEqual("match"))) != 0)
                        {
                            //Mode 'match': Tuple must be equal KeyValue.
                            hv_Hit.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Hit = new HTuple(hv_Tuple.TupleEqual(
                                    hv_KeyValue));
                            }
                        }
                        else if ((int)((new HTuple(hv_Mode.TupleEqual("or"))).TupleAnd(
                            new HTuple((new HTuple(hv_Tuple.TupleLength())).TupleEqual(1)))) != 0)
                        {
                            //Mode 'or': Tuple must have only 1 element and it has to be equal to any of KeyValues elements.
                            hv_Hit.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Hit = new HTuple(((hv_KeyValue.TupleFindFirst(
                                    hv_Tuple))).TupleGreaterEqual(0));
                            }
                        }
                        else if ((int)(new HTuple(hv_Mode.TupleEqual("contain"))) != 0)
                        {
                            //Mode 'contain': Tuple must contain any of the elements in KeyValue.
                            HTuple end_val35 = hv_NumKeyValues - 1;
                            HTuple step_val35 = 1;
                            for (hv_ValueIndex = 0; hv_ValueIndex.Continue(end_val35, step_val35); hv_ValueIndex = hv_ValueIndex.TupleAdd(step_val35))
                            {
                                hv_Value.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Value = hv_KeyValue.TupleSelect(
                                        hv_ValueIndex);
                                }
                                hv_Hit.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Hit = new HTuple(((hv_Tuple.TupleFindFirst(
                                        hv_Value))).TupleGreaterEqual(0));
                                }
                                if ((int)(hv_Hit) != 0)
                                {
                                    break;
                                }
                            }
                        }
                        else
                        {
                            //Unsupported configuration.
                            hv_Hit.Dispose();
                            hv_Hit = 0;
                        }
                        if ((int)(hv_Hit) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_SampleIndices = hv_SampleIndices.TupleConcat(
                                        hv_SampleIndex);
                                    hv_SampleIndices.Dispose();
                                    hv_SampleIndices = ExpTmpLocalVar_SampleIndices;
                                }
                            }
                        }
                    }
                }

                hv_NumKeyValues.Dispose();
                hv_SampleIndex.Dispose();
                hv_Sample.Dispose();
                hv_KeyExists.Dispose();
                hv_Tuple.Dispose();
                hv_Hit.Dispose();
                hv_ValueIndex.Dispose();
                hv_Value.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_NumKeyValues.Dispose();
                hv_SampleIndex.Dispose();
                hv_Sample.Dispose();
                hv_KeyExists.Dispose();
                hv_Tuple.Dispose();
                hv_Hit.Dispose();
                hv_ValueIndex.Dispose();
                hv_Value.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: XLD / Creation
        // Short Description: Creates an arrow shaped XLD contour. 
        public void gen_arrow_contour_xld(out HObject ho_Arrow, HTuple hv_Row1, HTuple hv_Column1,
            HTuple hv_Row2, HTuple hv_Column2, HTuple hv_HeadLength, HTuple hv_HeadWidth)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_TempArrow = null;

            // Local control variables 

            HTuple hv_Length = new HTuple(), hv_ZeroLengthIndices = new HTuple();
            HTuple hv_DR = new HTuple(), hv_DC = new HTuple(), hv_HalfHeadWidth = new HTuple();
            HTuple hv_RowP1 = new HTuple(), hv_ColP1 = new HTuple();
            HTuple hv_RowP2 = new HTuple(), hv_ColP2 = new HTuple();
            HTuple hv_Index = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Arrow);
            HOperatorSet.GenEmptyObj(out ho_TempArrow);
            try
            {
                //This procedure generates arrow shaped XLD contours,
                //pointing from (Row1, Column1) to (Row2, Column2).
                //If starting and end point are identical, a contour consisting
                //of a single point is returned.
                //
                //input parameteres:
                //Row1, Column1: Coordinates of the arrows' starting points
                //Row2, Column2: Coordinates of the arrows' end points
                //HeadLength, HeadWidth: Size of the arrow heads in pixels
                //
                //output parameter:
                //Arrow: The resulting XLD contour
                //
                //The input tuples Row1, Column1, Row2, and Column2 have to be of
                //the same length.
                //HeadLength and HeadWidth either have to be of the same length as
                //Row1, Column1, Row2, and Column2 or have to be a single element.
                //If one of the above restrictions is violated, an error will occur.
                //
                //
                //Init
                ho_Arrow.Dispose();
                HOperatorSet.GenEmptyObj(out ho_Arrow);
                //
                //Calculate the arrow length
                hv_Length.Dispose();
                HOperatorSet.DistancePp(hv_Row1, hv_Column1, hv_Row2, hv_Column2, out hv_Length);
                //
                //Mark arrows with identical start and end point
                //(set Length to -1 to avoid division-by-zero exception)
                hv_ZeroLengthIndices.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ZeroLengthIndices = hv_Length.TupleFind(
                        0);
                }
                if ((int)(new HTuple(hv_ZeroLengthIndices.TupleNotEqual(-1))) != 0)
                {
                    if (hv_Length == null)
                        hv_Length = new HTuple();
                    hv_Length[hv_ZeroLengthIndices] = -1;
                }
                //
                //Calculate auxiliary variables.
                hv_DR.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_DR = (1.0 * (hv_Row2 - hv_Row1)) / hv_Length;
                }
                hv_DC.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_DC = (1.0 * (hv_Column2 - hv_Column1)) / hv_Length;
                }
                hv_HalfHeadWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HalfHeadWidth = hv_HeadWidth / 2.0;
                }
                //
                //Calculate end points of the arrow head.
                hv_RowP1.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RowP1 = (hv_Row1 + ((hv_Length - hv_HeadLength) * hv_DR)) + (hv_HalfHeadWidth * hv_DC);
                }
                hv_ColP1.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ColP1 = (hv_Column1 + ((hv_Length - hv_HeadLength) * hv_DC)) - (hv_HalfHeadWidth * hv_DR);
                }
                hv_RowP2.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RowP2 = (hv_Row1 + ((hv_Length - hv_HeadLength) * hv_DR)) - (hv_HalfHeadWidth * hv_DC);
                }
                hv_ColP2.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ColP2 = (hv_Column1 + ((hv_Length - hv_HeadLength) * hv_DC)) + (hv_HalfHeadWidth * hv_DR);
                }
                //
                //Finally create output XLD contour for each input point pair
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Length.TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
                {
                    if ((int)(new HTuple(((hv_Length.TupleSelect(hv_Index))).TupleEqual(-1))) != 0)
                    {
                        //Create_ single points for arrows with identical start and end point
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_TempArrow.Dispose();
                            HOperatorSet.GenContourPolygonXld(out ho_TempArrow, hv_Row1.TupleSelect(
                                hv_Index), hv_Column1.TupleSelect(hv_Index));
                        }
                    }
                    else
                    {
                        //Create arrow contour
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_TempArrow.Dispose();
                            HOperatorSet.GenContourPolygonXld(out ho_TempArrow, ((((((((((hv_Row1.TupleSelect(
                                hv_Index))).TupleConcat(hv_Row2.TupleSelect(hv_Index)))).TupleConcat(
                                hv_RowP1.TupleSelect(hv_Index)))).TupleConcat(hv_Row2.TupleSelect(hv_Index)))).TupleConcat(
                                hv_RowP2.TupleSelect(hv_Index)))).TupleConcat(hv_Row2.TupleSelect(hv_Index)),
                                ((((((((((hv_Column1.TupleSelect(hv_Index))).TupleConcat(hv_Column2.TupleSelect(
                                hv_Index)))).TupleConcat(hv_ColP1.TupleSelect(hv_Index)))).TupleConcat(
                                hv_Column2.TupleSelect(hv_Index)))).TupleConcat(hv_ColP2.TupleSelect(
                                hv_Index)))).TupleConcat(hv_Column2.TupleSelect(hv_Index)));
                        }
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_Arrow, ho_TempArrow, out ExpTmpOutVar_0);
                        ho_Arrow.Dispose();
                        ho_Arrow = ExpTmpOutVar_0;
                    }
                }
                ho_TempArrow.Dispose();

                hv_Length.Dispose();
                hv_ZeroLengthIndices.Dispose();
                hv_DR.Dispose();
                hv_DC.Dispose();
                hv_HalfHeadWidth.Dispose();
                hv_RowP1.Dispose();
                hv_ColP1.Dispose();
                hv_RowP2.Dispose();
                hv_ColP2.Dispose();
                hv_Index.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_TempArrow.Dispose();

                hv_Length.Dispose();
                hv_ZeroLengthIndices.Dispose();
                hv_DR.Dispose();
                hv_DC.Dispose();
                hv_HalfHeadWidth.Dispose();
                hv_RowP1.Dispose();
                hv_ColP1.Dispose();
                hv_RowP2.Dispose();
                hv_ColP2.Dispose();
                hv_Index.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Classification
        // Short Description: Compute a confusion matrix, which an be visualized and/or returned. 
        public void gen_confusion_matrix(HTuple hv_GroundTruthLabels, HTuple hv_PredictedClasses,
            HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple hv_WindowHandle, out HTuple hv_ConfusionMatrix)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_DisplayMatrix = new HTuple(), hv_ReturnMatrix = new HTuple();
            HTuple hv_DisplayColor = new HTuple(), hv_DisplayColumnWidth = new HTuple();
            HTuple hv_GenParamIndex = new HTuple(), hv_CalculateRelativeMatrix = new HTuple();
            HTuple hv_Classes = new HTuple(), hv_NumClasses = new HTuple();
            HTuple hv_AbsoluteMatrixID = new HTuple(), hv_RelativeMatrixID = new HTuple();
            HTuple hv_ColumnMatrix = new HTuple(), hv_Class = new HTuple();
            HTuple hv_ThisLabel = new HTuple(), hv_NumClassGroundTruth = new HTuple();
            HTuple hv_RowMatrix = new HTuple(), hv_PredictedClass = new HTuple();
            HTuple hv_ThisPredictedClass = new HTuple(), hv_NumMatches = new HTuple();
            HTuple hv_RelativeError = new HTuple(), hv_StringWidths = new HTuple();
            HTuple hv_StringIndex = new HTuple(), hv_String = new HTuple();
            HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
            HTuple hv_StringWidth = new HTuple(), hv_StringHeight = new HTuple();
            HTuple hv_MaxStringWidth = new HTuple(), hv_RowStart = new HTuple();
            HTuple hv_RowDistance = new HTuple(), hv_RowEnd = new HTuple();
            HTuple hv_ColumnStart = new HTuple(), hv_ColumnOffset = new HTuple();
            HTuple hv_ColumnEnd = new HTuple(), hv_Width = new HTuple();
            HTuple hv_Height = new HTuple(), hv_WidthLimit = new HTuple();
            HTuple hv_HeightLimit = new HTuple(), hv_TextRow = new HTuple();
            HTuple hv_TextColumn = new HTuple(), hv_Index = new HTuple();
            HTuple hv_Text = new HTuple(), hv_Row = new HTuple(), hv_Column = new HTuple();
            HTuple hv_AbsoluteTransposedMatrixID = new HTuple(), hv_MatrixText = new HTuple();
            HTuple hv_MatrixMaxID = new HTuple(), hv_MaxValue = new HTuple();
            HTuple hv_StringConversion = new HTuple(), hv_RelativeTransposedMatrixID = new HTuple();
            HTuple hv_TextColor = new HTuple(), hv_RelativeValues = new HTuple();
            HTuple hv_Thresholds = new HTuple(), hv_Colors = new HTuple();
            HTuple hv_Greater = new HTuple(), hv_Indices = new HTuple();
            HTuple hv_DiagonalIndex = new HTuple(), hv_Value = new HTuple();
            // Initialize local and output iconic variables 
            hv_ConfusionMatrix = new HTuple();
            try
            {
                //This procedure computes a confusion matrix.
                //Therefore, it compares the classes
                //assigned in GroundTruthLabels and PredictedClasses.
                //The resulting confusion matrix can be
                //visualized, returned, or both.
                //In each case, the output can be changed
                //via generic parameters using GenParamName and GenParamValue.
                //For the visualization, the graphics window
                //must be specified with WindowHandle.
                //
                if ((int)(new HTuple((new HTuple(hv_GroundTruthLabels.TupleLength())).TupleNotEqual(
                    new HTuple(hv_PredictedClasses.TupleLength())))) != 0)
                {
                    throw new HalconException("Number of ground truth labels and predicted classes must be equal.");
                }
                //
                //Set generic parameter defaults.
                hv_DisplayMatrix.Dispose();
                hv_DisplayMatrix = "absolute";
                hv_ReturnMatrix.Dispose();
                hv_ReturnMatrix = "absolute";
                hv_DisplayColor.Dispose();
                hv_DisplayColor = "true";
                hv_DisplayColumnWidth.Dispose();
                hv_DisplayColumnWidth = "minimal";
                //
                //Parse generic parameters.
                for (hv_GenParamIndex = 0; (int)hv_GenParamIndex <= (int)((new HTuple(hv_GenParamName.TupleLength()
                    )) - 1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
                {
                    if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "display_matrix"))) != 0)
                    {
                        //Set 'display_matrix'.
                        hv_DisplayMatrix.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_DisplayMatrix = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "return_matrix"))) != 0)
                    {
                        //Set 'return_matrix'.
                        hv_ReturnMatrix.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ReturnMatrix = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "display_color"))) != 0)
                    {
                        //Set 'display_color'.
                        hv_DisplayColor.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_DisplayColor = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "display_column_width"))) != 0)
                    {
                        //Set 'display_column_width'.
                        hv_DisplayColumnWidth.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_DisplayColumnWidth = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                    }
                    else
                    {
                        throw new HalconException(("Unknown generic parameter: '" + (hv_GenParamName.TupleSelect(
                            hv_GenParamIndex))) + "'");
                    }
                }
                //
                if ((int)((new HTuple((new HTuple(hv_DisplayMatrix.TupleEqual("relative"))).TupleOr(
                    new HTuple(hv_ReturnMatrix.TupleEqual("relative"))))).TupleOr(new HTuple(hv_DisplayColor.TupleEqual(
                    "true")))) != 0)
                {
                    hv_CalculateRelativeMatrix.Dispose();
                    hv_CalculateRelativeMatrix = 1;
                }
                else
                {
                    hv_CalculateRelativeMatrix.Dispose();
                    hv_CalculateRelativeMatrix = 0;
                }
                //
                //Calculate the confusion matrix with absolute values
                //and the confusion matrix with relative errors.
                //We start with an empty matrix
                //and add the number of matching labels.
                hv_Classes.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Classes = ((hv_GroundTruthLabels.TupleSort()
                        )).TupleUniq();
                }
                hv_NumClasses.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumClasses = new HTuple(hv_Classes.TupleLength()
                        );
                }
                hv_AbsoluteMatrixID.Dispose();
                HOperatorSet.CreateMatrix(hv_NumClasses, hv_NumClasses, 0, out hv_AbsoluteMatrixID);
                if ((int)(hv_CalculateRelativeMatrix) != 0)
                {
                    hv_RelativeMatrixID.Dispose();
                    HOperatorSet.CreateMatrix(hv_NumClasses, hv_NumClasses, 0, out hv_RelativeMatrixID);
                }
                HTuple end_val55 = hv_NumClasses - 1;
                HTuple step_val55 = 1;
                for (hv_ColumnMatrix = 0; hv_ColumnMatrix.Continue(end_val55, step_val55); hv_ColumnMatrix = hv_ColumnMatrix.TupleAdd(step_val55))
                {
                    hv_Class.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Class = hv_Classes.TupleSelect(
                            hv_ColumnMatrix);
                    }
                    hv_ThisLabel.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ThisLabel = hv_GroundTruthLabels.TupleEqualElem(
                            hv_Class);
                    }
                    if ((int)(hv_CalculateRelativeMatrix) != 0)
                    {
                        //Obtain the number of ground truth labels per class.
                        hv_NumClassGroundTruth.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_NumClassGroundTruth = hv_ThisLabel.TupleSum()
                                ;
                        }
                    }
                    HTuple end_val62 = hv_NumClasses - 1;
                    HTuple step_val62 = 1;
                    for (hv_RowMatrix = 0; hv_RowMatrix.Continue(end_val62, step_val62); hv_RowMatrix = hv_RowMatrix.TupleAdd(step_val62))
                    {
                        //Select classes for this row/column.
                        hv_PredictedClass.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_PredictedClass = hv_Classes.TupleSelect(
                                hv_RowMatrix);
                        }
                        //Check whether the input data
                        //corresponds to these classes.
                        hv_ThisPredictedClass.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ThisPredictedClass = hv_PredictedClasses.TupleEqualElem(
                                hv_PredictedClass);
                        }
                        //Count the number of elements where the predicted class
                        //matches the ground truth label.
                        hv_NumMatches.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_NumMatches = ((((hv_ThisLabel + hv_ThisPredictedClass)).TupleEqualElem(
                                2))).TupleSum();
                        }
                        //Set value in matrix.
                        HOperatorSet.SetValueMatrix(hv_AbsoluteMatrixID, hv_RowMatrix, hv_ColumnMatrix,
                            hv_NumMatches);
                        if ((int)(hv_CalculateRelativeMatrix) != 0)
                        {
                            if ((int)(new HTuple(hv_NumClassGroundTruth.TupleGreater(0))) != 0)
                            {
                                hv_RelativeError.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_RelativeError = (hv_NumMatches.TupleReal()
                                        ) / hv_NumClassGroundTruth;
                                }
                            }
                            else
                            {
                                hv_RelativeError.Dispose();
                                hv_RelativeError = 0;
                            }
                            HOperatorSet.SetValueMatrix(hv_RelativeMatrixID, hv_RowMatrix, hv_ColumnMatrix,
                                hv_RelativeError);
                        }
                    }
                }
                //
                //Return the result.
                if ((int)(new HTuple(hv_ReturnMatrix.TupleEqual("absolute"))) != 0)
                {
                    hv_ConfusionMatrix.Dispose();
                    HOperatorSet.CopyMatrix(hv_AbsoluteMatrixID, out hv_ConfusionMatrix);
                }
                else if ((int)(new HTuple(hv_ReturnMatrix.TupleEqual("relative"))) != 0)
                {
                    hv_ConfusionMatrix.Dispose();
                    HOperatorSet.CopyMatrix(hv_RelativeMatrixID, out hv_ConfusionMatrix);
                }
                else if ((int)(new HTuple(hv_ReturnMatrix.TupleEqual("none"))) != 0)
                {
                    //No matrix is returned.
                }
                else
                {
                    throw new HalconException("Unsupported mode for 'return_matrix'");
                }
                //
                //Display the matrix.
                if ((int)(new HTuple(hv_DisplayMatrix.TupleNotEqual("none"))) != 0)
                {
                    //
                    //Find maximal string width and set display position parameters.
                    hv_StringWidths.Dispose();
                    hv_StringWidths = new HTuple();
                    //Get the string width of each class.
                    for (hv_StringIndex = 0; (int)hv_StringIndex <= (int)((new HTuple(hv_Classes.TupleLength()
                        )) - 1); hv_StringIndex = (int)hv_StringIndex + 1)
                    {
                        hv_String.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_String = hv_Classes.TupleSelect(
                                hv_StringIndex);
                        }
                        hv_Ascent.Dispose(); hv_Descent.Dispose(); hv_StringWidth.Dispose(); hv_StringHeight.Dispose();
                        HOperatorSet.GetStringExtents(hv_WindowHandle, hv_String, out hv_Ascent,
                            out hv_Descent, out hv_StringWidth, out hv_StringHeight);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_StringWidths = hv_StringWidths.TupleConcat(
                                    hv_StringWidth);
                                hv_StringWidths.Dispose();
                                hv_StringWidths = ExpTmpLocalVar_StringWidths;
                            }
                        }
                    }
                    //The columns should have a minimum width for 4 characters.
                    hv_Ascent.Dispose(); hv_Descent.Dispose(); hv_StringWidth.Dispose(); hv_StringHeight.Dispose();
                    HOperatorSet.GetStringExtents(hv_WindowHandle, "test", out hv_Ascent, out hv_Descent,
                        out hv_StringWidth, out hv_StringHeight);
                    hv_MaxStringWidth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxStringWidth = ((hv_StringWidths.TupleMax()
                            )).TupleMax2(hv_StringWidth);
                    }
                    //Get the maximum string width
                    //and resize the window accordingly.
                    hv_RowStart.Dispose();
                    hv_RowStart = 80;
                    hv_RowDistance.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_RowDistance = hv_StringHeight + 10;
                    }
                    hv_RowEnd.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_RowEnd = hv_StringHeight * 7;
                    }
                    hv_ColumnStart.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ColumnStart = 50 + hv_MaxStringWidth;
                    }
                    hv_ColumnOffset.Dispose();
                    hv_ColumnOffset = 20;
                    hv_ColumnEnd.Dispose();
                    hv_ColumnEnd = new HTuple(hv_ColumnOffset);
                    //
                    //Adapt the window size to fit the confusion matrix.
                    if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("minimal"))) != 0)
                    {
                        //Every column of the confusion matrix is as narrow as possible
                        //based to the respective string widths.
                        hv_Width.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Width = (((hv_StringWidths.TupleSum()
                                ) + (hv_ColumnOffset * hv_NumClasses)) + hv_ColumnStart) + hv_ColumnEnd;
                        }
                    }
                    else if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("equal"))) != 0)
                    {
                        //Every column of the confusion matrix should have the same width.
                        //based on the maximum string width.
                        hv_Width.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Width = (((hv_MaxStringWidth + hv_ColumnOffset) * hv_NumClasses) + hv_ColumnStart) + hv_ColumnEnd;
                        }
                    }
                    else
                    {
                        throw new HalconException("");
                    }
                    hv_Height.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Height = ((hv_RowDistance * hv_NumClasses) + hv_RowStart) + hv_RowEnd;
                    }
                    HDevWindowStack.SetActive(hv_WindowHandle);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                    }
                    //
                    //Set reasonable limits for graphics window (adapt if necessary).
                    hv_WidthLimit.Dispose();
                    hv_WidthLimit = new HTuple();
                    hv_WidthLimit[0] = 450;
                    hv_WidthLimit[1] = 1920;
                    hv_HeightLimit.Dispose();
                    hv_HeightLimit = new HTuple();
                    hv_HeightLimit[0] = 250;
                    hv_HeightLimit[1] = 1080;
                    if ((int)((new HTuple(hv_Width.TupleGreater(hv_WidthLimit.TupleSelect(1)))).TupleOr(
                        new HTuple(hv_Height.TupleGreater(hv_HeightLimit.TupleSelect(1))))) != 0)
                    {
                        throw new HalconException("Confusion Matrix does not fit into graphics window. Please adapt font and/or size limits.");
                    }
                    dev_resize_window_fit_size(0, 0, hv_Width, hv_Height, hv_WidthLimit, hv_HeightLimit);
                    //
                    //Get display coordinates.
                    //Get row coordinates for display.
                    hv_TextRow.Dispose();
                    hv_TextRow = new HTuple();
                    HTuple end_val145 = hv_NumClasses - 1;
                    HTuple step_val145 = 1;
                    for (hv_ColumnMatrix = 0; hv_ColumnMatrix.Continue(end_val145, step_val145); hv_ColumnMatrix = hv_ColumnMatrix.TupleAdd(step_val145))
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_TextRow = hv_TextRow.TupleConcat(
                                    HTuple.TupleGenSequence(0, (hv_NumClasses - 1) * hv_RowDistance, hv_RowDistance));
                                hv_TextRow.Dispose();
                                hv_TextRow = ExpTmpLocalVar_TextRow;
                            }
                        }
                    }
                    //Get column coordinates for display.
                    hv_TextColumn.Dispose();
                    hv_TextColumn = new HTuple();
                    HTuple end_val150 = hv_NumClasses - 1;
                    HTuple step_val150 = 1;
                    for (hv_Index = 0; hv_Index.Continue(end_val150, step_val150); hv_Index = hv_Index.TupleAdd(step_val150))
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_TextColumn = hv_TextColumn.TupleConcat(
                                    HTuple.TupleGenConst(hv_NumClasses, hv_ColumnStart));
                                hv_TextColumn.Dispose();
                                hv_TextColumn = ExpTmpLocalVar_TextColumn;
                            }
                        }
                        if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("minimal"))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ColumnStart = (hv_ColumnStart + (hv_StringWidths.TupleSelect(
                                        hv_Index))) + hv_ColumnOffset;
                                    hv_ColumnStart.Dispose();
                                    hv_ColumnStart = ExpTmpLocalVar_ColumnStart;
                                }
                            }
                        }
                        else if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual(
                            "equal"))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ColumnStart = (hv_ColumnStart + hv_MaxStringWidth) + hv_ColumnOffset;
                                    hv_ColumnStart.Dispose();
                                    hv_ColumnStart = ExpTmpLocalVar_ColumnStart;
                                }
                            }
                        }
                    }
                    //Display the confusion matrix with a margin from the top.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_TextRow = hv_TextRow + hv_RowStart;
                            hv_TextRow.Dispose();
                            hv_TextRow = ExpTmpLocalVar_TextRow;
                        }
                    }
                    //Display axis titles.
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Ground truth labels",
                            "window", "top", "right", "white", "box", "false");
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Predicted classes",
                            "window", "bottom", "left", "white", "box", "false");
                    }
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Classes.TupleLength()
                        )) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = hv_Classes.TupleSelect(
                                hv_Index);
                        }
                        //Display predicted class names.
                        hv_Row.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Row = hv_TextRow.TupleSelect(
                                hv_Index);
                        }
                        hv_Column.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Column = ((hv_TextColumn.TupleSelect(
                                0)) - hv_MaxStringWidth) - hv_ColumnOffset;
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                hv_Row, hv_Column, "light gray", "box", "false");
                        }
                        //Display ground truth label names.
                        hv_Row.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Row = (hv_TextRow.TupleSelect(
                                0)) - hv_RowDistance;
                        }
                        hv_Column.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Column = hv_TextColumn.TupleSelect(
                                hv_Index * hv_NumClasses);
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                hv_Row, hv_Column, "light gray", "box", "false");
                        }
                    }
                    //
                    //Get the confusion matrix values for display.
                    if ((int)(new HTuple(hv_DisplayMatrix.TupleEqual("absolute"))) != 0)
                    {
                        //Displayed matrix corresponds to the transposed returned matrix.
                        hv_AbsoluteTransposedMatrixID.Dispose();
                        HOperatorSet.TransposeMatrix(hv_AbsoluteMatrixID, out hv_AbsoluteTransposedMatrixID);
                        hv_MatrixText.Dispose();
                        HOperatorSet.GetFullMatrix(hv_AbsoluteTransposedMatrixID, out hv_MatrixText);
                        HOperatorSet.ClearMatrix(hv_AbsoluteTransposedMatrixID);
                        //Align the numbers right.
                        hv_MatrixMaxID.Dispose();
                        HOperatorSet.MaxMatrix(hv_AbsoluteMatrixID, "full", out hv_MatrixMaxID);
                        hv_MaxValue.Dispose();
                        HOperatorSet.GetFullMatrix(hv_MatrixMaxID, out hv_MaxValue);
                        HOperatorSet.ClearMatrix(hv_MatrixMaxID);
                        hv_StringConversion.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_StringConversion = (((((hv_MaxValue.TupleLog10()
                                )).TupleCeil())).TupleInt()) + ".0f";
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_MatrixText = hv_MatrixText.TupleString(
                                    hv_StringConversion);
                                hv_MatrixText.Dispose();
                                hv_MatrixText = ExpTmpLocalVar_MatrixText;
                            }
                        }
                    }
                    else
                    {
                        //Displayed matrix corresponds to the transposed returned matrix.
                        hv_RelativeTransposedMatrixID.Dispose();
                        HOperatorSet.TransposeMatrix(hv_RelativeMatrixID, out hv_RelativeTransposedMatrixID);
                        hv_MatrixText.Dispose();
                        HOperatorSet.GetFullMatrix(hv_RelativeTransposedMatrixID, out hv_MatrixText);
                        HOperatorSet.ClearMatrix(hv_RelativeTransposedMatrixID);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_MatrixText = hv_MatrixText.TupleString(
                                    ".2f");
                                hv_MatrixText.Dispose();
                                hv_MatrixText = ExpTmpLocalVar_MatrixText;
                            }
                        }
                    }
                    //Set color for displayed confusion matrix.
                    if ((int)(new HTuple(hv_DisplayColor.TupleEqual("true"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TextColor.Dispose();
                            HOperatorSet.TupleGenConst(new HTuple(hv_MatrixText.TupleLength()), "#666666",
                                out hv_TextColor);
                        }
                        //Use the relative values to adapt the color of the text.
                        hv_RelativeTransposedMatrixID.Dispose();
                        HOperatorSet.TransposeMatrix(hv_RelativeMatrixID, out hv_RelativeTransposedMatrixID);
                        hv_RelativeValues.Dispose();
                        HOperatorSet.GetFullMatrix(hv_RelativeTransposedMatrixID, out hv_RelativeValues);
                        HOperatorSet.ClearMatrix(hv_RelativeTransposedMatrixID);
                        //Set the colors and respective thresholds for the off-diagonal values.
                        hv_Thresholds.Dispose();
                        hv_Thresholds = new HTuple();
                        hv_Thresholds[0] = 0.0;
                        hv_Thresholds[1] = 0.05;
                        hv_Thresholds[2] = 0.1;
                        hv_Thresholds[3] = 0.2;
                        hv_Colors.Dispose();
                        hv_Colors = new HTuple();
                        hv_Colors[0] = "#8C4D4D";
                        hv_Colors[1] = "#B33333";
                        hv_Colors[2] = "#D91A1A";
                        hv_Colors[3] = "#FF0000";
                        for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Thresholds.TupleLength()
                            )) - 1); hv_Index = (int)hv_Index + 1)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Greater.Dispose();
                                HOperatorSet.TupleGreaterElem(hv_RelativeValues, hv_Thresholds.TupleSelect(
                                    hv_Index), out hv_Greater);
                            }
                            hv_Indices.Dispose();
                            HOperatorSet.TupleFind(hv_Greater, 1, out hv_Indices);
                            if ((int)(new HTuple(hv_Indices.TupleNotEqual(-1))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HTuple ExpTmpOutVar_0;
                                    HOperatorSet.TupleReplace(hv_TextColor, hv_Indices, hv_Colors.TupleSelect(
                                        hv_Index), out ExpTmpOutVar_0);
                                    hv_TextColor.Dispose();
                                    hv_TextColor = ExpTmpOutVar_0;
                                }
                            }
                            else
                            {
                                break;
                            }
                        }
                        //Set the colors and respective thresholds for the diagonal values.
                        hv_Thresholds.Dispose();
                        hv_Thresholds = new HTuple();
                        hv_Thresholds[0] = -0.01;
                        hv_Thresholds[1] = 0.60;
                        hv_Thresholds[2] = 0.80;
                        hv_Thresholds[3] = 0.90;
                        hv_Thresholds[4] = 0.95;
                        hv_Thresholds[5] = 0.98;
                        hv_Colors.Dispose();
                        hv_Colors = new HTuple();
                        hv_Colors[0] = "#666666";
                        hv_Colors[1] = "#508650";
                        hv_Colors[2] = "#419C41";
                        hv_Colors[3] = "#2BBD2B";
                        hv_Colors[4] = "#15DE15";
                        hv_Colors[5] = "#00FF00";
                        HTuple end_val216 = hv_NumClasses - 1;
                        HTuple step_val216 = 1;
                        for (hv_DiagonalIndex = 0; hv_DiagonalIndex.Continue(end_val216, step_val216); hv_DiagonalIndex = hv_DiagonalIndex.TupleAdd(step_val216))
                        {
                            hv_Value.Dispose();
                            HOperatorSet.GetValueMatrix(hv_RelativeMatrixID, hv_DiagonalIndex, hv_DiagonalIndex,
                                out hv_Value);
                            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Thresholds.TupleLength()
                                )) - 1); hv_Index = (int)hv_Index + 1)
                            {
                                if ((int)(new HTuple(hv_Value.TupleGreater(hv_Thresholds.TupleSelect(
                                    hv_Index)))) != 0)
                                {
                                    if (hv_TextColor == null)
                                        hv_TextColor = new HTuple();
                                    hv_TextColor[hv_DiagonalIndex * (hv_NumClasses + 1)] = hv_Colors.TupleSelect(
                                        hv_Index);
                                }
                                else
                                {
                                    break;
                                }
                            }
                        }
                    }
                    else
                    {
                        //Default value for the text color.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TextColor.Dispose();
                            HOperatorSet.TupleGenConst(new HTuple(hv_MatrixText.TupleLength()), "white",
                                out hv_TextColor);
                        }
                    }
                    //
                    //Display confusion matrix.
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_MatrixText, "window",
                            hv_TextRow, hv_TextColumn, hv_TextColor, "box", "false");
                    }
                    //
                    //Clean up.
                    if ((int)(hv_CalculateRelativeMatrix) != 0)
                    {
                        HOperatorSet.ClearMatrix(hv_RelativeMatrixID);
                    }
                    HOperatorSet.ClearMatrix(hv_AbsoluteMatrixID);
                }

                hv_DisplayMatrix.Dispose();
                hv_ReturnMatrix.Dispose();
                hv_DisplayColor.Dispose();
                hv_DisplayColumnWidth.Dispose();
                hv_GenParamIndex.Dispose();
                hv_CalculateRelativeMatrix.Dispose();
                hv_Classes.Dispose();
                hv_NumClasses.Dispose();
                hv_AbsoluteMatrixID.Dispose();
                hv_RelativeMatrixID.Dispose();
                hv_ColumnMatrix.Dispose();
                hv_Class.Dispose();
                hv_ThisLabel.Dispose();
                hv_NumClassGroundTruth.Dispose();
                hv_RowMatrix.Dispose();
                hv_PredictedClass.Dispose();
                hv_ThisPredictedClass.Dispose();
                hv_NumMatches.Dispose();
                hv_RelativeError.Dispose();
                hv_StringWidths.Dispose();
                hv_StringIndex.Dispose();
                hv_String.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_StringWidth.Dispose();
                hv_StringHeight.Dispose();
                hv_MaxStringWidth.Dispose();
                hv_RowStart.Dispose();
                hv_RowDistance.Dispose();
                hv_RowEnd.Dispose();
                hv_ColumnStart.Dispose();
                hv_ColumnOffset.Dispose();
                hv_ColumnEnd.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_WidthLimit.Dispose();
                hv_HeightLimit.Dispose();
                hv_TextRow.Dispose();
                hv_TextColumn.Dispose();
                hv_Index.Dispose();
                hv_Text.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();
                hv_AbsoluteTransposedMatrixID.Dispose();
                hv_MatrixText.Dispose();
                hv_MatrixMaxID.Dispose();
                hv_MaxValue.Dispose();
                hv_StringConversion.Dispose();
                hv_RelativeTransposedMatrixID.Dispose();
                hv_TextColor.Dispose();
                hv_RelativeValues.Dispose();
                hv_Thresholds.Dispose();
                hv_Colors.Dispose();
                hv_Greater.Dispose();
                hv_Indices.Dispose();
                hv_DiagonalIndex.Dispose();
                hv_Value.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_DisplayMatrix.Dispose();
                hv_ReturnMatrix.Dispose();
                hv_DisplayColor.Dispose();
                hv_DisplayColumnWidth.Dispose();
                hv_GenParamIndex.Dispose();
                hv_CalculateRelativeMatrix.Dispose();
                hv_Classes.Dispose();
                hv_NumClasses.Dispose();
                hv_AbsoluteMatrixID.Dispose();
                hv_RelativeMatrixID.Dispose();
                hv_ColumnMatrix.Dispose();
                hv_Class.Dispose();
                hv_ThisLabel.Dispose();
                hv_NumClassGroundTruth.Dispose();
                hv_RowMatrix.Dispose();
                hv_PredictedClass.Dispose();
                hv_ThisPredictedClass.Dispose();
                hv_NumMatches.Dispose();
                hv_RelativeError.Dispose();
                hv_StringWidths.Dispose();
                hv_StringIndex.Dispose();
                hv_String.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_StringWidth.Dispose();
                hv_StringHeight.Dispose();
                hv_MaxStringWidth.Dispose();
                hv_RowStart.Dispose();
                hv_RowDistance.Dispose();
                hv_RowEnd.Dispose();
                hv_ColumnStart.Dispose();
                hv_ColumnOffset.Dispose();
                hv_ColumnEnd.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_WidthLimit.Dispose();
                hv_HeightLimit.Dispose();
                hv_TextRow.Dispose();
                hv_TextColumn.Dispose();
                hv_Index.Dispose();
                hv_Text.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();
                hv_AbsoluteTransposedMatrixID.Dispose();
                hv_MatrixText.Dispose();
                hv_MatrixMaxID.Dispose();
                hv_MaxValue.Dispose();
                hv_StringConversion.Dispose();
                hv_RelativeTransposedMatrixID.Dispose();
                hv_TextColor.Dispose();
                hv_RelativeValues.Dispose();
                hv_Thresholds.Dispose();
                hv_Colors.Dispose();
                hv_Greater.Dispose();
                hv_Indices.Dispose();
                hv_DiagonalIndex.Dispose();
                hv_Value.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: The procedure returns DLSample dicts for given sample indices of a DLDataset. 
        public void gen_dl_samples(HTuple hv_DLDataset, HTuple hv_SampleIndices, HTuple hv_RestrictKeysDLSample,
            HTuple hv_GenParam, out HTuple hv_DLSampleBatch)
        {



            // Local iconic variables 

            HObject ho_ImageRaw = null, ho_ImageAnomaly = null;
            HObject ho_RegionAnomaly = null, ho_ImageSegmentation = null;

            // Local control variables 

            HTuple hv_ImageDir = new HTuple(), hv_DLSamples = new HTuple();
            HTuple hv_MinIndex = new HTuple(), hv_MaxIndex = new HTuple();
            HTuple hv_InstanceType = new HTuple(), hv_IgnoreMissing = new HTuple();
            HTuple hv_GenParamName = new HTuple(), hv_IndexGenParam = new HTuple();
            HTuple hv_DLSamplesProc = new HTuple(), hv_BboxKeyList = new HTuple();
            HTuple hv_ImageIndex = new HTuple(), hv_DLSample = new HTuple();
            HTuple hv_ImageID = new HTuple(), hv_ImageName = new HTuple();
            HTuple hv_FileName = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_AnomalyLabelExists = new HTuple(), hv_AnomalyLabel = new HTuple();
            HTuple hv_AnomalyFileNameExists = new HTuple(), hv_AnomalyDir = new HTuple();
            HTuple hv_AnomalyFileName = new HTuple(), hv_ExceptionImageAnomaly = new HTuple();
            HTuple hv_ExceptionRegionAnomaly = new HTuple(), hv_Width = new HTuple();
            HTuple hv_Height = new HTuple(), hv_ImageLabelIDExists = new HTuple();
            HTuple hv_ImageLabelID = new HTuple(), hv_BboxExists = new HTuple();
            HTuple hv_BboxLabels = new HTuple(), hv_KeysExist = new HTuple();
            HTuple hv_MissingKeyIndices = new HTuple(), hv_IndexParam = new HTuple();
            HTuple hv_BboxCoord = new HTuple(), hv_SegKeyExists = new HTuple();
            HTuple hv_SegmentationDir = new HTuple(), hv_SegmentationName = new HTuple();
            HTuple hv_ExceptionSegmentation = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ImageRaw);
            HOperatorSet.GenEmptyObj(out ho_ImageAnomaly);
            HOperatorSet.GenEmptyObj(out ho_RegionAnomaly);
            HOperatorSet.GenEmptyObj(out ho_ImageSegmentation);
            hv_DLSampleBatch = new HTuple();
            try
            {
                //
                //This procedure creates DLSampleBatch, a tuple of DLSample dictionaries, with
                //the image data for each DLDataset sample, that was selected through SampleIndices.
                //The keys to be transferred can be restricted using RestrictKeysDLSample,
                //which is switched off ('off') by default.
                //The procedure returns all generated DLSample dictionaries in the tuple
                //DLSampleBatch.
                //Setting the GenParam 'ignore_missing_labels' controls whether an error is thrown,
                //if no ground truth annotation information is available for a given image.
                //
                //Get the image directory.
                hv_ImageDir.Dispose();
                HOperatorSet.GetDictTuple(hv_DLDataset, "image_dir", out hv_ImageDir);
                //
                //Get the samples from the DLDataset.
                hv_DLSamples.Dispose();
                HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLSamples);
                //
                //Check the input values.
                //
                //Check that the given indices are valid.
                hv_MinIndex.Dispose();
                HOperatorSet.TupleMin(hv_SampleIndices, out hv_MinIndex);
                hv_MaxIndex.Dispose();
                HOperatorSet.TupleMax(hv_SampleIndices, out hv_MaxIndex);
                if ((int)((new HTuple(hv_MinIndex.TupleLess(0))).TupleOr(new HTuple(hv_MaxIndex.TupleGreater(
                    (new HTuple(hv_DLSamples.TupleLength())) - 1)))) != 0)
                {
                    throw new HalconException("The given SampleIndices are not within the range of available samples in DLDataset.");
                }
                //
                //Check if the given method is valid.
                if ((int)(new HTuple((new HTuple(hv_RestrictKeysDLSample.TupleLength())).TupleEqual(
                    1))) != 0)
                {
                    if ((int)(new HTuple((new HTuple((new HTuple(((((((new HTuple("anomaly_detection")).TupleConcat(
                        "detection")).TupleConcat("segmentation")).TupleConcat("classification")).TupleConcat(
                        "image_only")).TupleConcat("off")).TupleFind(hv_RestrictKeysDLSample))).TupleMax()
                        )).TupleEqual(-1))) != 0)
                    {
                        throw new HalconException("Unknown RestrictKeysDLSample : " + hv_RestrictKeysDLSample);
                    }
                }
                else
                {
                    throw new HalconException("RestrictKeysDLSample must be specified by one string.");
                }
                //
                //Generic Parameters.
                //Set default values.
                hv_InstanceType.Dispose();
                hv_InstanceType = "rectangle1";
                //For missing labels an error is thrown.
                if ((int)(new HTuple(hv_RestrictKeysDLSample.TupleEqual("off"))) != 0)
                {
                    hv_IgnoreMissing.Dispose();
                    hv_IgnoreMissing = 1;
                }
                else
                {
                    hv_IgnoreMissing.Dispose();
                    hv_IgnoreMissing = 0;
                }
                //
                //Transfer generic parameters.
                if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
                {
                    hv_GenParamName.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_GenParamName);
                    for (hv_IndexGenParam = 0; (int)hv_IndexGenParam <= (int)((new HTuple(hv_GenParamName.TupleLength()
                        )) - 1); hv_IndexGenParam = (int)hv_IndexGenParam + 1)
                    {
                        if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_IndexGenParam))).TupleEqual(
                            "ignore_missing_labels"))) != 0)
                        {
                            hv_IgnoreMissing.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "ignore_missing_labels", out hv_IgnoreMissing);
                            if ((int)((new HTuple((new HTuple(hv_IgnoreMissing.TupleEqual(1))).TupleOr(
                                new HTuple(hv_IgnoreMissing.TupleEqual(0))))).TupleNot()) != 0)
                            {
                                throw new HalconException("The GenParam ignore_missing_labels must be true or false.");
                            }
                        }
                        else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_IndexGenParam))).TupleEqual(
                            "instance_type"))) != 0)
                        {
                            if ((int)(new HTuple((new HTuple((new HTuple(((new HTuple("detection")).TupleConcat(
                                "off")).TupleFind(hv_RestrictKeysDLSample))).TupleMax())).TupleEqual(
                                -1))) != 0)
                            {
                                throw new HalconException("The GenParam instance_type can only be set for RestrictKeysDLSample detection or off.");
                            }
                            hv_InstanceType.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "instance_type", out hv_InstanceType);
                            if ((int)(new HTuple((new HTuple((new HTuple(((new HTuple("rectangle1")).TupleConcat(
                                "rectangle2")).TupleFind(hv_InstanceType))).TupleMax())).TupleEqual(
                                -1))) != 0)
                            {
                                throw new HalconException("The GenParam instance_type must be either 'rectangle1' or 'rectangle2'.");
                            }
                        }
                        else
                        {
                            throw new HalconException("Unknown GenParam key : " + (hv_GenParamName.TupleSelect(
                                hv_IndexGenParam)));
                        }
                    }
                }
                //
                //Get the samples to be processed.
                hv_DLSamplesProc.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_DLSamplesProc = hv_DLSamples.TupleSelect(
                        hv_SampleIndices);
                }
                //
                //Initialize the tuple for collection the DLSample dictionaries.
                hv_DLSampleBatch.Dispose();
                hv_DLSampleBatch = new HTuple();
                //
                //Set the BboxKeyList according to the InstanceType.
                if ((int)(new HTuple((new HTuple((new HTuple(((new HTuple("detection")).TupleConcat(
                    "off")).TupleFind(hv_RestrictKeysDLSample))).TupleMax())).TupleNotEqual(
                    -1))) != 0)
                {
                    hv_BboxKeyList.Dispose();
                    hv_BboxKeyList = new HTuple();
                    hv_BboxKeyList[0] = "bbox_col1";
                    hv_BboxKeyList[1] = "bbox_row1";
                    hv_BboxKeyList[2] = "bbox_col2";
                    hv_BboxKeyList[3] = "bbox_row2";
                    if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
                    {
                        hv_BboxKeyList.Dispose();
                        hv_BboxKeyList = new HTuple();
                        hv_BboxKeyList[0] = "bbox_row";
                        hv_BboxKeyList[1] = "bbox_col";
                        hv_BboxKeyList[2] = "bbox_length1";
                        hv_BboxKeyList[3] = "bbox_length2";
                        hv_BboxKeyList[4] = "bbox_phi";
                    }
                }
                //Loop over all selected samples and create a DLSample dictionary
                //for each dictionary in the DLDataset samples.
                for (hv_ImageIndex = 0; (int)hv_ImageIndex <= (int)((new HTuple(hv_SampleIndices.TupleLength()
                    )) - 1); hv_ImageIndex = (int)hv_ImageIndex + 1)
                {
                    //
                    //Create the DLSample dictionary
                    hv_DLSample.Dispose();
                    HOperatorSet.CreateDict(out hv_DLSample);
                    //
                    //Set the image key.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageID.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex), "image_id",
                            out hv_ImageID);
                    }
                    HOperatorSet.SetDictTuple(hv_DLSample, "image_id", hv_ImageID);
                    //
                    //Read image.
                    //The relative file path of the image is specified in image_name.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageName.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex), "image_file_name",
                            out hv_ImageName);
                    }
                    //
                    if ((int)(new HTuple(((hv_ImageDir.TupleStrlen())).TupleEqual(0))) != 0)
                    {
                        hv_FileName.Dispose();
                        hv_FileName = new HTuple(hv_ImageName);
                    }
                    else
                    {
                        hv_FileName.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FileName = (hv_ImageDir + "/") + hv_ImageName;
                        }
                    }
                    try
                    {
                        ho_ImageRaw.Dispose();
                        HOperatorSet.ReadImage(out ho_ImageRaw, hv_FileName);
                        //Insert image into dictionary.
                        HOperatorSet.SetDictObject(ho_ImageRaw, hv_DLSample, "image");
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException1)
                    {
                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        throw new HalconException((((("Error for reading/setting image " + hv_FileName) + " with ID ") + hv_ImageID) + " : Error code ") + (hv_Exception.TupleSelect(
                            0)));
                    }
                    //
                    //Read specific data.
                    //
                    if ((int)(new HTuple(hv_RestrictKeysDLSample.TupleNotEqual("image_only"))) != 0)
                    {
                        //
                        //Transfer anomaly detection relevant data.
                        if ((int)(new HTuple((new HTuple((new HTuple(((new HTuple("anomaly_detection")).TupleConcat(
                            "off")).TupleFind(hv_RestrictKeysDLSample))).TupleMax())).TupleNotEqual(
                            -1))) != 0)
                        {
                            //Check the existence of the label key.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_AnomalyLabelExists.Dispose();
                                HOperatorSet.GetDictParam(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                                    "key_exists", "anomaly_label", out hv_AnomalyLabelExists);
                            }
                            if ((int)(hv_AnomalyLabelExists) != 0)
                            {
                                //Get the image label.
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_AnomalyLabel.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                                        "anomaly_label", out hv_AnomalyLabel);
                                }
                                //Check the existence of the anomaly file name key. If not found it is just ignored.
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_AnomalyFileNameExists.Dispose();
                                    HOperatorSet.GetDictParam(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                                        "key_exists", "anomaly_file_name", out hv_AnomalyFileNameExists);
                                }
                                if ((int)(hv_AnomalyFileNameExists) != 0)
                                {
                                    //Get the ground truth anomaly directory.
                                    hv_AnomalyDir.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLDataset, "anomaly_dir", out hv_AnomalyDir);
                                    //Get the image file name.
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_AnomalyFileName.Dispose();
                                        HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                                            "anomaly_file_name", out hv_AnomalyFileName);
                                    }
                                    //Read the ground truth anomaly image.
                                    try
                                    {
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            ho_ImageAnomaly.Dispose();
                                            HOperatorSet.ReadImage(out ho_ImageAnomaly, (hv_AnomalyDir + "/") + hv_AnomalyFileName);
                                        }
                                    }
                                    // catch (ExceptionImageAnomaly) 
                                    catch (HalconException HDevExpDefaultException1)
                                    {
                                        HDevExpDefaultException1.ToHTuple(out hv_ExceptionImageAnomaly);
                                        //If the file is not an image, try to read the ground truth anomaly region.
                                        //Then, convert this region to a ground truth anomaly image.
                                        try
                                        {
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                ho_RegionAnomaly.Dispose();
                                                HOperatorSet.ReadRegion(out ho_RegionAnomaly, (hv_AnomalyDir + "/") + hv_AnomalyFileName);
                                            }
                                        }
                                        // catch (ExceptionRegionAnomaly) 
                                        catch (HalconException HDevExpDefaultException2)
                                        {
                                            HDevExpDefaultException2.ToHTuple(out hv_ExceptionRegionAnomaly);
                                            throw new HalconException((("Error: Could not read the anomaly ground truth information of image_id " + hv_ImageID) + " : Error code ") + (hv_ExceptionImageAnomaly.TupleSelect(
                                                0)));
                                        }
                                        hv_Width.Dispose(); hv_Height.Dispose();
                                        HOperatorSet.GetImageSize(ho_ImageRaw, out hv_Width, out hv_Height);
                                        ho_ImageAnomaly.Dispose();
                                        HOperatorSet.GenImageConst(out ho_ImageAnomaly, "byte", hv_Width,
                                            hv_Height);
                                        HOperatorSet.OverpaintRegion(ho_ImageAnomaly, ho_ImageAnomaly,
                                            0, "fill");
                                        HOperatorSet.OverpaintRegion(ho_ImageAnomaly, ho_RegionAnomaly,
                                            1, "fill");
                                    }
                                    //Insert anomaly image into DLSample dictionary.
                                    HOperatorSet.SetDictObject(ho_ImageAnomaly, hv_DLSample, "anomaly_ground_truth");
                                }
                                //
                                //Insert anomaly label into DLSample dictionary.
                                HOperatorSet.SetDictTuple(hv_DLSample, "anomaly_label", hv_AnomalyLabel);
                                //Insert anomaly label id into DLSample dictionary.
                                if ((int)(new HTuple(hv_AnomalyLabel.TupleEqual("nok"))) != 0)
                                {
                                    HOperatorSet.SetDictTuple(hv_DLSample, "anomaly_label_id", 1);
                                }
                                else
                                {
                                    HOperatorSet.SetDictTuple(hv_DLSample, "anomaly_label_id", 0);
                                }
                            }
                            else if ((int)((new HTuple(hv_AnomalyLabelExists.TupleNot()
                                )).TupleAnd(hv_IgnoreMissing.TupleNot())) != 0)
                            {
                                throw new HalconException(("For image_id " + hv_ImageID) + " the key 'anomaly_label' is missing. Missing keys can be ignored using the GenParam ignore_missing_labels.");
                            }
                        }
                        //
                        //Transfer classification relevant data.
                        if ((int)(new HTuple((new HTuple((new HTuple(((new HTuple("classification")).TupleConcat(
                            "off")).TupleFind(hv_RestrictKeysDLSample))).TupleMax())).TupleNotEqual(
                            -1))) != 0)
                        {
                            //Check the existence of the required key.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ImageLabelIDExists.Dispose();
                                HOperatorSet.GetDictParam(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                                    "key_exists", "image_label_id", out hv_ImageLabelIDExists);
                            }
                            if ((int)(hv_ImageLabelIDExists) != 0)
                            {
                                //Transfer the image label.
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ImageLabelID.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                                        "image_label_id", out hv_ImageLabelID);
                                }
                                HOperatorSet.SetDictTuple(hv_DLSample, "image_label_id", hv_ImageLabelID);
                            }
                            else if ((int)((new HTuple(hv_ImageLabelIDExists.TupleNot()
                                )).TupleAnd(hv_IgnoreMissing.TupleNot())) != 0)
                            {
                                throw new HalconException(("For image_id " + hv_ImageID) + " the key 'image_label_id' is missing. Missing keys can be ignored using the GenParam ignore_missing_labels.");
                            }
                        }
                        //
                        //Transfer detection relevant data.
                        if ((int)(new HTuple((new HTuple((new HTuple(((new HTuple("detection")).TupleConcat(
                            "off")).TupleFind(hv_RestrictKeysDLSample))).TupleMax())).TupleNotEqual(
                            -1))) != 0)
                        {
                            //Check the existence of the required key.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_BboxExists.Dispose();
                                HOperatorSet.GetDictParam(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                                    "key_exists", "bbox_label_id", out hv_BboxExists);
                            }
                            if ((int)(hv_BboxExists) != 0)
                            {
                                //Transfer the bounding box labels.
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_BboxLabels.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                                        "bbox_label_id", out hv_BboxLabels);
                                }
                                HOperatorSet.SetDictTuple(hv_DLSample, "bbox_label_id", hv_BboxLabels);
                                //Transfer the bounding box coordinates.
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_KeysExist.Dispose();
                                    HOperatorSet.GetDictParam(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                                        "key_exists", hv_BboxKeyList, out hv_KeysExist);
                                }
                                if ((int)((new HTuple(((hv_KeysExist.TupleSum())).TupleNotEqual(new HTuple(hv_KeysExist.TupleLength()
                                    )))).TupleAnd(hv_IgnoreMissing.TupleNot())) != 0)
                                {
                                    hv_MissingKeyIndices.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_MissingKeyIndices = ((hv_KeysExist.TupleEqualElem(
                                            0))).TupleFind(1);
                                    }
                                    throw new HalconException((("For image_id " + hv_ImageID) + new HTuple(", an error has occurred when transferring the key ")) + (hv_BboxKeyList.TupleSelect(
                                        hv_MissingKeyIndices)));
                                }
                                for (hv_IndexParam = 0; (int)hv_IndexParam <= (int)((new HTuple(hv_BboxKeyList.TupleLength()
                                    )) - 1); hv_IndexParam = (int)hv_IndexParam + 1)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_BboxCoord.Dispose();
                                        HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                                            hv_BboxKeyList.TupleSelect(hv_IndexParam), out hv_BboxCoord);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_DLSample, hv_BboxKeyList.TupleSelect(
                                            hv_IndexParam), hv_BboxCoord);
                                    }
                                }
                            }
                            else if ((int)(hv_IgnoreMissing.TupleNot()) != 0)
                            {
                                throw new HalconException(("For image_id " + hv_ImageID) + " there is no key bbox_label_id. Missing keys can be ignored using the GenParam ignore_missing_labels.");
                            }
                        }
                        //
                        //Transfer segmentation relevant data.
                        if ((int)(new HTuple((new HTuple((new HTuple(((new HTuple("segmentation")).TupleConcat(
                            "off")).TupleFind(hv_RestrictKeysDLSample))).TupleMax())).TupleNotEqual(
                            -1))) != 0)
                        {
                            //Check the existence of the required keys.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_SegKeyExists.Dispose();
                                HOperatorSet.GetDictParam(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                                    "key_exists", "segmentation_file_name", out hv_SegKeyExists);
                            }
                            if ((int)(hv_SegKeyExists) != 0)
                            {
                                //Get the ground truth segmentation directory.
                                hv_SegmentationDir.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLDataset, "segmentation_dir", out hv_SegmentationDir);
                                //Get the image file name.
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_SegmentationName.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                                        "segmentation_file_name", out hv_SegmentationName);
                                }
                                //Read the ground truth segmentation image.
                                try
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        ho_ImageSegmentation.Dispose();
                                        HOperatorSet.ReadImage(out ho_ImageSegmentation, (hv_SegmentationDir + "/") + hv_SegmentationName);
                                    }
                                }
                                // catch (ExceptionSegmentation) 
                                catch (HalconException HDevExpDefaultException1)
                                {
                                    HDevExpDefaultException1.ToHTuple(out hv_ExceptionSegmentation);
                                    throw new HalconException((("Error for reading segmentation file of image_id " + hv_ImageID) + " : Error code ") + (hv_ExceptionSegmentation.TupleSelect(
                                        0)));
                                }
                                //Insert image into DLSample dictionary.
                                HOperatorSet.SetDictObject(ho_ImageSegmentation, hv_DLSample, "segmentation_image");
                            }
                            else if ((int)(hv_IgnoreMissing.TupleNot()) != 0)
                            {
                                throw new HalconException(("For image_id " + hv_ImageID) + " there is no key segmentation_file_name. Missing keys can be ignored using the GenParam ignore_missing_labels.");
                            }
                        }
                    }
                    //
                    //Collect all data dictionaries of all processed indices.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_DLSampleBatch = hv_DLSampleBatch.TupleConcat(
                                hv_DLSample);
                            hv_DLSampleBatch.Dispose();
                            hv_DLSampleBatch = ExpTmpLocalVar_DLSampleBatch;
                        }
                    }
                }
                ho_ImageRaw.Dispose();
                ho_ImageAnomaly.Dispose();
                ho_RegionAnomaly.Dispose();
                ho_ImageSegmentation.Dispose();

                hv_ImageDir.Dispose();
                hv_DLSamples.Dispose();
                hv_MinIndex.Dispose();
                hv_MaxIndex.Dispose();
                hv_InstanceType.Dispose();
                hv_IgnoreMissing.Dispose();
                hv_GenParamName.Dispose();
                hv_IndexGenParam.Dispose();
                hv_DLSamplesProc.Dispose();
                hv_BboxKeyList.Dispose();
                hv_ImageIndex.Dispose();
                hv_DLSample.Dispose();
                hv_ImageID.Dispose();
                hv_ImageName.Dispose();
                hv_FileName.Dispose();
                hv_Exception.Dispose();
                hv_AnomalyLabelExists.Dispose();
                hv_AnomalyLabel.Dispose();
                hv_AnomalyFileNameExists.Dispose();
                hv_AnomalyDir.Dispose();
                hv_AnomalyFileName.Dispose();
                hv_ExceptionImageAnomaly.Dispose();
                hv_ExceptionRegionAnomaly.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_ImageLabelIDExists.Dispose();
                hv_ImageLabelID.Dispose();
                hv_BboxExists.Dispose();
                hv_BboxLabels.Dispose();
                hv_KeysExist.Dispose();
                hv_MissingKeyIndices.Dispose();
                hv_IndexParam.Dispose();
                hv_BboxCoord.Dispose();
                hv_SegKeyExists.Dispose();
                hv_SegmentationDir.Dispose();
                hv_SegmentationName.Dispose();
                hv_ExceptionSegmentation.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_ImageRaw.Dispose();
                ho_ImageAnomaly.Dispose();
                ho_RegionAnomaly.Dispose();
                ho_ImageSegmentation.Dispose();

                hv_ImageDir.Dispose();
                hv_DLSamples.Dispose();
                hv_MinIndex.Dispose();
                hv_MaxIndex.Dispose();
                hv_InstanceType.Dispose();
                hv_IgnoreMissing.Dispose();
                hv_GenParamName.Dispose();
                hv_IndexGenParam.Dispose();
                hv_DLSamplesProc.Dispose();
                hv_BboxKeyList.Dispose();
                hv_ImageIndex.Dispose();
                hv_DLSample.Dispose();
                hv_ImageID.Dispose();
                hv_ImageName.Dispose();
                hv_FileName.Dispose();
                hv_Exception.Dispose();
                hv_AnomalyLabelExists.Dispose();
                hv_AnomalyLabel.Dispose();
                hv_AnomalyFileNameExists.Dispose();
                hv_AnomalyDir.Dispose();
                hv_AnomalyFileName.Dispose();
                hv_ExceptionImageAnomaly.Dispose();
                hv_ExceptionRegionAnomaly.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_ImageLabelIDExists.Dispose();
                hv_ImageLabelID.Dispose();
                hv_BboxExists.Dispose();
                hv_BboxLabels.Dispose();
                hv_KeysExist.Dispose();
                hv_MissingKeyIndices.Dispose();
                hv_IndexParam.Dispose();
                hv_BboxCoord.Dispose();
                hv_SegKeyExists.Dispose();
                hv_SegmentationDir.Dispose();
                hv_SegmentationName.Dispose();
                hv_ExceptionSegmentation.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection
        // Short Description: Get the ground truth anomaly label and label ID. 
        public void get_anomaly_ground_truth_label(HTuple hv_SampleKeys, HTuple hv_DLSample,
            out HTuple hv_AnomalyLabelGroundTruth, out HTuple hv_AnomalyLabelIDGroundTruth)
        {


            // Initialize local and output iconic variables 
            hv_AnomalyLabelGroundTruth = new HTuple();
            hv_AnomalyLabelIDGroundTruth = new HTuple();
            //
            //This procedure returns the anomaly ground truth label.
            //
            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("anomaly_label"))).TupleNotEqual(
                -1))) != 0)
            {
                hv_AnomalyLabelGroundTruth.Dispose();
                HOperatorSet.GetDictTuple(hv_DLSample, "anomaly_label", out hv_AnomalyLabelGroundTruth);
            }
            else
            {
                throw new HalconException("Ground truth class label cannot be found in DLSample.");
            }
            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("anomaly_label_id"))).TupleNotEqual(
                -1))) != 0)
            {
                hv_AnomalyLabelIDGroundTruth.Dispose();
                HOperatorSet.GetDictTuple(hv_DLSample, "anomaly_label_id", out hv_AnomalyLabelIDGroundTruth);
            }
            else
            {
                throw new HalconException("Ground truth class label id cannot be found in DLSample.");
            }
            //


            return;
        }

        // Chapter: Deep Learning / Anomaly Detection
        // Short Description: Get the anomaly image out of DLResult. 
        public void get_anomaly_result(out HObject ho_AnomalyImage, HTuple hv_ResultKeys,
            HTuple hv_DLResult, out HTuple hv_AnomalyScore, out HTuple hv_AnomalyClassID)
        {



            // Local control variables 

            HTuple hv_AnomalyImageExists = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_AnomalyImage);
            hv_AnomalyScore = new HTuple();
            hv_AnomalyClassID = new HTuple();
            try
            {
                //
                //This procedure returns the anomaly image of DLResult.
                //
                if ((int)(new HTuple(((hv_ResultKeys.TupleFind("anomaly_image"))).TupleNotEqual(
                    -1))) != 0)
                {
                    hv_AnomalyImageExists.Dispose();
                    HOperatorSet.GetDictParam(hv_DLResult, "key_exists", "anomaly_image", out hv_AnomalyImageExists);
                    if ((int)(hv_AnomalyImageExists) != 0)
                    {
                        ho_AnomalyImage.Dispose();
                        HOperatorSet.GetDictObject(out ho_AnomalyImage, hv_DLResult, "anomaly_image");
                    }
                    else
                    {
                        throw new HalconException("Result anomaly image could not be found in DLResult.");
                    }
                }
                else
                {
                    throw new HalconException("Result anomaly image could not be found in DLResult.");
                }
                //
                //This procedure returns the anomaly score of DLResult.
                //
                if ((int)(new HTuple(((hv_ResultKeys.TupleFind("anomaly_score"))).TupleNotEqual(
                    -1))) != 0)
                {
                    hv_AnomalyScore.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "anomaly_score", out hv_AnomalyScore);
                }
                else
                {
                    throw new HalconException("Result anomaly score could not be found in DLResult.");
                }
                //
                //This procedure returns the anomaly class id of DLResult.
                //
                if ((int)(new HTuple(((hv_ResultKeys.TupleFind("anomaly_class_id"))).TupleNotEqual(
                    -1))) != 0)
                {
                    hv_AnomalyClassID.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "anomaly_class_id", out hv_AnomalyClassID);
                }
                else
                {
                    throw new HalconException("Result anomaly class ID could not be found in DLResult.");
                }

                hv_AnomalyImageExists.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_AnomalyImageExists.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Window
        // Short Description: Get the next child window that can be used for visualization. 
        public void get_child_window(HTuple hv_HeightImage, HTuple hv_Font, HTuple hv_FontSize,
            HTuple hv_Text, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict,
            HTuple hv_WindowHandleKey, out HTuple hv_WindowImageRatio, out HTuple hv_PrevWindowCoordinatesOut)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_OpenNewWindow = new HTuple(), hv_WindowHandles = new HTuple();
            HTuple hv_ParentWindowHandle = new HTuple(), hv_ChildWindowHandle = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_MetaInfo = new HTuple();
            HTuple hv_WindowRow = new HTuple(), hv_WindowColumn = new HTuple();
            HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
            // Initialize local and output iconic variables 
            hv_WindowImageRatio = new HTuple();
            hv_PrevWindowCoordinatesOut = new HTuple();
            try
            {
                //
                //This procedure returns the next child window that
                //is used for visualization. If ReuseWindows is true
                //and WindowHandleList is suitable, the window handles
                //that are passed over are used. Else, this procedure
                //opens a new window, either next to the last ones, or
                //in a new row.
                //
                //First, check if the requested window is already available.
                hv_OpenNewWindow.Dispose();
                hv_OpenNewWindow = 0;
                try
                {
                    hv_WindowHandles.Dispose();
                    HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, out hv_WindowHandles);
                    hv_ParentWindowHandle.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ParentWindowHandle = hv_WindowHandles.TupleSelect(
                            0);
                    }
                    hv_ChildWindowHandle.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ChildWindowHandle = hv_WindowHandles.TupleSelect(
                            1);
                    }
                    //Check if window handle is valid.
                    try
                    {
                        HOperatorSet.FlushBuffer(hv_ChildWindowHandle);
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException2)
                    {
                        HDevExpDefaultException2.ToHTuple(out hv_Exception);
                        //Since there is something wrong with the current window, create a new one.
                        hv_OpenNewWindow.Dispose();
                        hv_OpenNewWindow = 1;
                    }
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    hv_OpenNewWindow.Dispose();
                    hv_OpenNewWindow = 1;
                }
                //
                //Get next child window.
                if ((int)(hv_OpenNewWindow.TupleNot()) != 0)
                {
                    //
                    //If possible, reuse existing window handles.
                    HDevWindowStack.SetActive(hv_ChildWindowHandle);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                    }
                    set_display_font(hv_ChildWindowHandle, hv_FontSize, hv_Font, "true", "false");
                    //
                    hv_MetaInfo.Dispose();
                    HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
                    //
                    //Get previous window coordinates.
                    hv_WindowRow.Dispose(); hv_WindowColumn.Dispose(); hv_WindowWidth.Dispose(); hv_WindowHeight.Dispose();
                    HOperatorSet.GetWindowExtents(hv_ParentWindowHandle, out hv_WindowRow, out hv_WindowColumn,
                        out hv_WindowWidth, out hv_WindowHeight);
                    hv_WindowImageRatio.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_WindowImageRatio = hv_WindowHeight / (hv_HeightImage * 1.0);
                    }
                    //
                    try
                    {
                        //
                        //Get WindowImageRatio from parent window.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_WindowImageRatio.Dispose();
                            HOperatorSet.GetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_window_image_ratio_height",
                                out hv_WindowImageRatio);
                        }
                        //
                        //Get previous window coordinates.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_PrevWindowCoordinatesOut.Dispose();
                            HOperatorSet.GetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_child_window_coordinates",
                                out hv_PrevWindowCoordinatesOut);
                        }
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException1)
                    {
                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        //
                        //Set WindowImageRatio from parent window.
                        hv_WindowRow.Dispose(); hv_WindowColumn.Dispose(); hv_WindowWidth.Dispose(); hv_WindowHeight.Dispose();
                        HOperatorSet.GetWindowExtents(hv_ParentWindowHandle, out hv_WindowRow,
                            out hv_WindowColumn, out hv_WindowWidth, out hv_WindowHeight);
                        hv_WindowImageRatio.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_WindowImageRatio = hv_WindowHeight / (hv_HeightImage * 1.0);
                        }
                        //
                        //Set previous window coordinates.
                        if (hv_PrevWindowCoordinatesOut == null)
                            hv_PrevWindowCoordinatesOut = new HTuple();
                        hv_PrevWindowCoordinatesOut[0] = hv_WindowRow;
                        if (hv_PrevWindowCoordinatesOut == null)
                            hv_PrevWindowCoordinatesOut = new HTuple();
                        hv_PrevWindowCoordinatesOut[1] = hv_WindowColumn;
                        if (hv_PrevWindowCoordinatesOut == null)
                            hv_PrevWindowCoordinatesOut = new HTuple();
                        hv_PrevWindowCoordinatesOut[2] = hv_WindowWidth;
                        if (hv_PrevWindowCoordinatesOut == null)
                            hv_PrevWindowCoordinatesOut = new HTuple();
                        hv_PrevWindowCoordinatesOut[3] = hv_WindowHeight;
                    }
                }
                else
                {
                    //
                    //Open a new child window.
                    hv_ChildWindowHandle.Dispose(); hv_PrevWindowCoordinatesOut.Dispose();
                    open_child_window(hv_ParentWindowHandle, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                        hv_WindowHandleDict, hv_WindowHandleKey, out hv_ChildWindowHandle, out hv_PrevWindowCoordinatesOut);
                    HOperatorSet.SetWindowParam(hv_ChildWindowHandle, "flush", "false");
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, hv_ParentWindowHandle.TupleConcat(
                            hv_ChildWindowHandle));
                    }
                }
                //

                hv_OpenNewWindow.Dispose();
                hv_WindowHandles.Dispose();
                hv_ParentWindowHandle.Dispose();
                hv_ChildWindowHandle.Dispose();
                hv_Exception.Dispose();
                hv_MetaInfo.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowColumn.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_OpenNewWindow.Dispose();
                hv_WindowHandles.Dispose();
                hv_ParentWindowHandle.Dispose();
                hv_ChildWindowHandle.Dispose();
                hv_Exception.Dispose();
                hv_MetaInfo.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowColumn.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Classification
        // Short Description: Get the ground truth classification label id. 
        public void get_classification_ground_truth(HTuple hv_SampleKeys, HTuple hv_DLSample,
            out HTuple hv_ClassificationLabelIDGroundTruth)
        {


            // Initialize local and output iconic variables 
            hv_ClassificationLabelIDGroundTruth = new HTuple();
            //
            //This procedure returns the classification ground truth label ID.
            //
            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("image_label_id"))).TupleNotEqual(
                -1))) != 0)
            {
                hv_ClassificationLabelIDGroundTruth.Dispose();
                HOperatorSet.GetDictTuple(hv_DLSample, "image_label_id", out hv_ClassificationLabelIDGroundTruth);
            }
            else
            {
                throw new HalconException("Ground truth class label cannot be found in DLSample.");
            }
            //


            return;
        }

        // Chapter: Deep Learning / Classification
        // Short Description: Get the predicted classification class ID. 
        public void get_classification_result(HTuple hv_ResultKeys, HTuple hv_DLResult,
            out HTuple hv_ClassificationClassID)
        {



            // Local iconic variables 
            // Initialize local and output iconic variables 
            hv_ClassificationClassID = new HTuple();
            //
            //This procedure returns the predicted classification class ID.
            //
            if ((int)(new HTuple(((hv_ResultKeys.TupleFind("classification_class_ids"))).TupleNotEqual(
                -1))) != 0)
            {
                hv_ClassificationClassID.Dispose();
                HOperatorSet.GetDictTuple(hv_DLResult, "classification_class_ids", out hv_ClassificationClassID);
                if ((int)(new HTuple((new HTuple(hv_ClassificationClassID.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ClassificationClassID = hv_ClassificationClassID.TupleSelect(
                                0);
                            hv_ClassificationClassID.Dispose();
                            hv_ClassificationClassID = ExpTmpLocalVar_ClassificationClassID;
                        }
                    }
                }
            }
            else
            {
                throw new HalconException("Key entry 'classification_class_ids' could not be found in DLResult.");
            }
            //


            return;
        }

        // Chapter: Deep Learning / Semantic Segmentation
        // Short Description: Get the confidences of the segmentation result. 
        public void get_confidence_image(out HObject ho_ImageConfidence, HTuple hv_ResultKeys,
            HTuple hv_DLResult)
        {


            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ImageConfidence);
            //
            //This procedure returns confidences of the segmentation result.
            //
            if ((int)(new HTuple(((hv_ResultKeys.TupleFind("segmentation_confidence"))).TupleNotEqual(
                -1))) != 0)
            {
                ho_ImageConfidence.Dispose();
                HOperatorSet.GetDictObject(out ho_ImageConfidence, hv_DLResult, "segmentation_confidence");
            }
            else if ((int)(new HTuple(((hv_ResultKeys.TupleFind("segmentation_confidences"))).TupleNotEqual(
                -1))) != 0)
            {
                ho_ImageConfidence.Dispose();
                HOperatorSet.GetDictObject(out ho_ImageConfidence, hv_DLResult, "segmentation_confidences");
            }
            else
            {
                throw new HalconException("Confidence image could not be found in DLSample.");
            }


            return;
        }

        // Chapter: Deep Learning / Model
        // Short Description: Generate NumColors distinct colors 
        public void get_distinct_colors(HTuple hv_NumColors, HTuple hv_Random, HTuple hv_StartColor,
            HTuple hv_EndColor, out HTuple hv_Colors)
        {



            // Local iconic variables 

            HObject ho_HLSImageH, ho_HLSImageL, ho_HLSImageS;
            HObject ho_ImageR, ho_ImageG, ho_ImageB;

            // Local control variables 

            HTuple hv_IsString = new HTuple(), hv_Hue = new HTuple();
            HTuple hv_Lightness = new HTuple(), hv_Saturation = new HTuple();
            HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
            HTuple hv_Red = new HTuple(), hv_Green = new HTuple();
            HTuple hv_Blue = new HTuple();
            HTuple hv_EndColor_COPY_INP_TMP = new HTuple(hv_EndColor);
            HTuple hv_Random_COPY_INP_TMP = new HTuple(hv_Random);

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_HLSImageH);
            HOperatorSet.GenEmptyObj(out ho_HLSImageL);
            HOperatorSet.GenEmptyObj(out ho_HLSImageS);
            HOperatorSet.GenEmptyObj(out ho_ImageR);
            HOperatorSet.GenEmptyObj(out ho_ImageG);
            HOperatorSet.GenEmptyObj(out ho_ImageB);
            hv_Colors = new HTuple();
            try
            {
                //
                //We get distinct color-values first in HLS color-space.
                //Assumes hue [0, EndColor), lightness [0, 1), saturation [0, 1).
                //
                //Parameter checks.
                //NumColors.
                if ((int)(new HTuple(hv_NumColors.TupleLess(1))) != 0)
                {
                    throw new HalconException("NumColors should be at least 1");
                }
                if ((int)(((hv_NumColors.TupleIsInt())).TupleNot()) != 0)
                {
                    throw new HalconException("NumColors should be of type int");
                }
                if ((int)(new HTuple((new HTuple(hv_NumColors.TupleLength())).TupleNotEqual(
                    1))) != 0)
                {
                    throw new HalconException("NumColors should have length 1");
                }
                //Random.
                if ((int)((new HTuple(hv_Random_COPY_INP_TMP.TupleNotEqual(0))).TupleAnd(new HTuple(hv_Random_COPY_INP_TMP.TupleNotEqual(
                    1)))) != 0)
                {
                    hv_IsString.Dispose();
                    HOperatorSet.TupleIsString(hv_Random_COPY_INP_TMP, out hv_IsString);
                    if ((int)(hv_IsString) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Random = (new HTuple(hv_Random_COPY_INP_TMP.TupleEqual(
                                    "true"))).TupleOr("false");
                                hv_Random_COPY_INP_TMP.Dispose();
                                hv_Random_COPY_INP_TMP = ExpTmpLocalVar_Random;
                            }
                        }
                    }
                    else
                    {
                        throw new HalconException("Random should be either true or false");
                    }
                }
                //StartColor.
                if ((int)(new HTuple((new HTuple(hv_StartColor.TupleLength())).TupleNotEqual(
                    1))) != 0)
                {
                    throw new HalconException("StartColor should have length 1");
                }
                if ((int)((new HTuple(hv_StartColor.TupleLess(0))).TupleOr(new HTuple(hv_StartColor.TupleGreater(
                    255)))) != 0)
                {
                    throw new HalconException(new HTuple("StartColor should be in the range [0, 255]"));
                }
                if ((int)(((hv_StartColor.TupleIsInt())).TupleNot()) != 0)
                {
                    throw new HalconException("StartColor should be of type int");
                }
                //EndColor.
                if ((int)(new HTuple((new HTuple(hv_EndColor_COPY_INP_TMP.TupleLength())).TupleNotEqual(
                    1))) != 0)
                {
                    throw new HalconException("EndColor should have length 1");
                }
                if ((int)((new HTuple(hv_EndColor_COPY_INP_TMP.TupleLess(0))).TupleOr(new HTuple(hv_EndColor_COPY_INP_TMP.TupleGreater(
                    255)))) != 0)
                {
                    throw new HalconException(new HTuple("EndColor should be in the range [0, 255]"));
                }
                if ((int)(((hv_EndColor_COPY_INP_TMP.TupleIsInt())).TupleNot()) != 0)
                {
                    throw new HalconException("EndColor should be of type int");
                }
                //
                //Color generation.
                if ((int)(new HTuple(hv_StartColor.TupleGreater(hv_EndColor_COPY_INP_TMP))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_EndColor = hv_EndColor_COPY_INP_TMP + 255;
                            hv_EndColor_COPY_INP_TMP.Dispose();
                            hv_EndColor_COPY_INP_TMP = ExpTmpLocalVar_EndColor;
                        }
                    }
                }
                if ((int)(new HTuple(hv_NumColors.TupleNotEqual(1))) != 0)
                {
                    hv_Hue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Hue = (hv_StartColor + (((((hv_EndColor_COPY_INP_TMP - hv_StartColor) * ((HTuple.TupleGenSequence(
                            0, hv_NumColors - 1, 1)).TupleReal())) / (((hv_NumColors - 1)).TupleReal()))).TupleInt()
                            )) % 255;
                    }
                }
                else
                {
                    hv_Hue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Hue = ((hv_StartColor.TupleConcat(
                            hv_EndColor_COPY_INP_TMP))).TupleMean();
                    }
                }
                if ((int)(hv_Random_COPY_INP_TMP) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Hue = hv_Hue.TupleSelect(
                                (HTuple.TupleRand(hv_NumColors)).TupleSortIndex());
                            hv_Hue.Dispose();
                            hv_Hue = ExpTmpLocalVar_Hue;
                        }
                    }
                    hv_Lightness.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Lightness = ((((5.0 + HTuple.TupleRand(
                            hv_NumColors)) * 255.0) / 10.0)).TupleInt();
                    }
                    hv_Saturation.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Saturation = ((((9.0 + HTuple.TupleRand(
                            hv_NumColors)) * 255.0) / 10.0)).TupleInt();
                    }
                }
                else
                {
                    hv_Lightness.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Lightness = ((HTuple.TupleGenConst(
                            hv_NumColors, 0.55) * 255.0)).TupleInt();
                    }
                    hv_Saturation.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Saturation = ((HTuple.TupleGenConst(
                            hv_NumColors, 0.95) * 255.0)).TupleInt();
                    }
                }
                //
                //Write colors to a 3-channel image in order to transform easier.
                ho_HLSImageH.Dispose();
                HOperatorSet.GenImageConst(out ho_HLSImageH, "byte", 1, hv_NumColors);
                ho_HLSImageL.Dispose();
                HOperatorSet.GenImageConst(out ho_HLSImageL, "byte", 1, hv_NumColors);
                ho_HLSImageS.Dispose();
                HOperatorSet.GenImageConst(out ho_HLSImageS, "byte", 1, hv_NumColors);
                hv_Rows.Dispose(); hv_Columns.Dispose();
                HOperatorSet.GetRegionPoints(ho_HLSImageH, out hv_Rows, out hv_Columns);
                HOperatorSet.SetGrayval(ho_HLSImageH, hv_Rows, hv_Columns, hv_Hue);
                HOperatorSet.SetGrayval(ho_HLSImageL, hv_Rows, hv_Columns, hv_Lightness);
                HOperatorSet.SetGrayval(ho_HLSImageS, hv_Rows, hv_Columns, hv_Saturation);
                //
                //Convert from HLS to RGB.
                ho_ImageR.Dispose(); ho_ImageG.Dispose(); ho_ImageB.Dispose();
                HOperatorSet.TransToRgb(ho_HLSImageH, ho_HLSImageL, ho_HLSImageS, out ho_ImageR,
                    out ho_ImageG, out ho_ImageB, "hls");
                //
                //Get RGB-values and transform to Hex.
                hv_Red.Dispose();
                HOperatorSet.GetGrayval(ho_ImageR, hv_Rows, hv_Columns, out hv_Red);
                hv_Green.Dispose();
                HOperatorSet.GetGrayval(ho_ImageG, hv_Rows, hv_Columns, out hv_Green);
                hv_Blue.Dispose();
                HOperatorSet.GetGrayval(ho_ImageB, hv_Rows, hv_Columns, out hv_Blue);
                hv_Colors.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Colors = (("#" + (hv_Red.TupleString(
                        "02x"))) + (hv_Green.TupleString("02x"))) + (hv_Blue.TupleString("02x"));
                }
                ho_HLSImageH.Dispose();
                ho_HLSImageL.Dispose();
                ho_HLSImageS.Dispose();
                ho_ImageR.Dispose();
                ho_ImageG.Dispose();
                ho_ImageB.Dispose();

                hv_EndColor_COPY_INP_TMP.Dispose();
                hv_Random_COPY_INP_TMP.Dispose();
                hv_IsString.Dispose();
                hv_Hue.Dispose();
                hv_Lightness.Dispose();
                hv_Saturation.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();

                return;
                //
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_HLSImageH.Dispose();
                ho_HLSImageL.Dispose();
                ho_HLSImageS.Dispose();
                ho_ImageR.Dispose();
                ho_ImageG.Dispose();
                ho_ImageB.Dispose();

                hv_EndColor_COPY_INP_TMP.Dispose();
                hv_Random_COPY_INP_TMP.Dispose();
                hv_IsString.Dispose();
                hv_Hue.Dispose();
                hv_Lightness.Dispose();
                hv_Saturation.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Generate NumColors distinct colors 
        public void get_distinct_colors_dev_display_pie_chart(HTuple hv_NumColors, HTuple hv_Random,
            HTuple hv_StartColor, HTuple hv_EndColor, out HTuple hv_Colors)
        {



            // Local iconic variables 

            HObject ho_HLSImageH, ho_HLSImageL, ho_HLSImageS;
            HObject ho_ImageR, ho_ImageG, ho_ImageB;

            // Local control variables 

            HTuple hv_IsString = new HTuple(), hv_Hue = new HTuple();
            HTuple hv_Lightness = new HTuple(), hv_Saturation = new HTuple();
            HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
            HTuple hv_Red = new HTuple(), hv_Green = new HTuple();
            HTuple hv_Blue = new HTuple();
            HTuple hv_EndColor_COPY_INP_TMP = new HTuple(hv_EndColor);
            HTuple hv_Random_COPY_INP_TMP = new HTuple(hv_Random);

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_HLSImageH);
            HOperatorSet.GenEmptyObj(out ho_HLSImageL);
            HOperatorSet.GenEmptyObj(out ho_HLSImageS);
            HOperatorSet.GenEmptyObj(out ho_ImageR);
            HOperatorSet.GenEmptyObj(out ho_ImageG);
            HOperatorSet.GenEmptyObj(out ho_ImageB);
            hv_Colors = new HTuple();
            try
            {
                //
                //We get distinct color-values first in HLS color-space.
                //Assumes hue [0, EndColor), lightness [0, 1), saturation [0, 1).
                //
                //Parameter checks.
                //NumColors.
                if ((int)(new HTuple(hv_NumColors.TupleLess(1))) != 0)
                {
                    throw new HalconException("NumColors should be at least 1");
                }
                if ((int)(((hv_NumColors.TupleIsInt())).TupleNot()) != 0)
                {
                    throw new HalconException("NumColors should be of type int");
                }
                if ((int)(new HTuple((new HTuple(hv_NumColors.TupleLength())).TupleNotEqual(
                    1))) != 0)
                {
                    throw new HalconException("NumColors should have length 1");
                }
                //Random.
                if ((int)((new HTuple(hv_Random_COPY_INP_TMP.TupleNotEqual(0))).TupleAnd(new HTuple(hv_Random_COPY_INP_TMP.TupleNotEqual(
                    1)))) != 0)
                {
                    hv_IsString.Dispose();
                    HOperatorSet.TupleIsString(hv_Random_COPY_INP_TMP, out hv_IsString);
                    if ((int)(hv_IsString) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Random = (new HTuple(hv_Random_COPY_INP_TMP.TupleEqual(
                                    "true"))).TupleOr("false");
                                hv_Random_COPY_INP_TMP.Dispose();
                                hv_Random_COPY_INP_TMP = ExpTmpLocalVar_Random;
                            }
                        }
                    }
                    else
                    {
                        throw new HalconException("Random should be either true or false");
                    }
                }
                //StartColor.
                if ((int)(new HTuple((new HTuple(hv_StartColor.TupleLength())).TupleNotEqual(
                    1))) != 0)
                {
                    throw new HalconException("StartColor should have length 1");
                }
                if ((int)((new HTuple(hv_StartColor.TupleLess(0))).TupleOr(new HTuple(hv_StartColor.TupleGreater(
                    255)))) != 0)
                {
                    throw new HalconException(new HTuple("StartColor should be in the range [0, 255]"));
                }
                if ((int)(((hv_StartColor.TupleIsInt())).TupleNot()) != 0)
                {
                    throw new HalconException("StartColor should be of type int");
                }
                //EndColor.
                if ((int)(new HTuple((new HTuple(hv_EndColor_COPY_INP_TMP.TupleLength())).TupleNotEqual(
                    1))) != 0)
                {
                    throw new HalconException("EndColor should have length 1");
                }
                if ((int)((new HTuple(hv_EndColor_COPY_INP_TMP.TupleLess(0))).TupleOr(new HTuple(hv_EndColor_COPY_INP_TMP.TupleGreater(
                    255)))) != 0)
                {
                    throw new HalconException(new HTuple("EndColor should be in the range [0, 255]"));
                }
                if ((int)(((hv_EndColor_COPY_INP_TMP.TupleIsInt())).TupleNot()) != 0)
                {
                    throw new HalconException("EndColor should be of type int");
                }
                //
                //Color generation.
                if ((int)(new HTuple(hv_StartColor.TupleGreater(hv_EndColor_COPY_INP_TMP))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_EndColor = hv_EndColor_COPY_INP_TMP + 255;
                            hv_EndColor_COPY_INP_TMP.Dispose();
                            hv_EndColor_COPY_INP_TMP = ExpTmpLocalVar_EndColor;
                        }
                    }
                }
                if ((int)(new HTuple(hv_NumColors.TupleNotEqual(1))) != 0)
                {
                    hv_Hue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Hue = (hv_StartColor + (((((hv_EndColor_COPY_INP_TMP - hv_StartColor) * ((HTuple.TupleGenSequence(
                            0, hv_NumColors - 1, 1)).TupleReal())) / (((hv_NumColors - 1)).TupleReal()))).TupleInt()
                            )) % 255;
                    }
                }
                else
                {
                    hv_Hue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Hue = ((hv_StartColor.TupleConcat(
                            hv_EndColor_COPY_INP_TMP))).TupleMean();
                    }
                }
                if ((int)(hv_Random_COPY_INP_TMP) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Hue = hv_Hue.TupleSelect(
                                (HTuple.TupleRand(hv_NumColors)).TupleSortIndex());
                            hv_Hue.Dispose();
                            hv_Hue = ExpTmpLocalVar_Hue;
                        }
                    }
                    hv_Lightness.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Lightness = ((((5.0 + HTuple.TupleRand(
                            hv_NumColors)) * 255.0) / 10.0)).TupleInt();
                    }
                    hv_Saturation.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Saturation = ((((9.0 + HTuple.TupleRand(
                            hv_NumColors)) * 255.0) / 10.0)).TupleInt();
                    }
                }
                else
                {
                    hv_Lightness.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Lightness = ((HTuple.TupleGenConst(
                            hv_NumColors, 0.55) * 255.0)).TupleInt();
                    }
                    hv_Saturation.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Saturation = ((HTuple.TupleGenConst(
                            hv_NumColors, 0.95) * 255.0)).TupleInt();
                    }
                }
                //
                //Write colors to a 3-channel image in order to transform easier.
                ho_HLSImageH.Dispose();
                HOperatorSet.GenImageConst(out ho_HLSImageH, "byte", 1, hv_NumColors);
                ho_HLSImageL.Dispose();
                HOperatorSet.GenImageConst(out ho_HLSImageL, "byte", 1, hv_NumColors);
                ho_HLSImageS.Dispose();
                HOperatorSet.GenImageConst(out ho_HLSImageS, "byte", 1, hv_NumColors);
                hv_Rows.Dispose(); hv_Columns.Dispose();
                HOperatorSet.GetRegionPoints(ho_HLSImageH, out hv_Rows, out hv_Columns);
                HOperatorSet.SetGrayval(ho_HLSImageH, hv_Rows, hv_Columns, hv_Hue);
                HOperatorSet.SetGrayval(ho_HLSImageL, hv_Rows, hv_Columns, hv_Lightness);
                HOperatorSet.SetGrayval(ho_HLSImageS, hv_Rows, hv_Columns, hv_Saturation);
                //
                //Convert from HLS to RGB.
                ho_ImageR.Dispose(); ho_ImageG.Dispose(); ho_ImageB.Dispose();
                HOperatorSet.TransToRgb(ho_HLSImageH, ho_HLSImageL, ho_HLSImageS, out ho_ImageR,
                    out ho_ImageG, out ho_ImageB, "hls");
                //
                //Get RGB-values and transform to Hex.
                hv_Red.Dispose();
                HOperatorSet.GetGrayval(ho_ImageR, hv_Rows, hv_Columns, out hv_Red);
                hv_Green.Dispose();
                HOperatorSet.GetGrayval(ho_ImageG, hv_Rows, hv_Columns, out hv_Green);
                hv_Blue.Dispose();
                HOperatorSet.GetGrayval(ho_ImageB, hv_Rows, hv_Columns, out hv_Blue);
                hv_Colors.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Colors = (("#" + (hv_Red.TupleString(
                        "02x"))) + (hv_Green.TupleString("02x"))) + (hv_Blue.TupleString("02x"));
                }
                ho_HLSImageH.Dispose();
                ho_HLSImageL.Dispose();
                ho_HLSImageS.Dispose();
                ho_ImageR.Dispose();
                ho_ImageG.Dispose();
                ho_ImageB.Dispose();

                hv_EndColor_COPY_INP_TMP.Dispose();
                hv_Random_COPY_INP_TMP.Dispose();
                hv_IsString.Dispose();
                hv_Hue.Dispose();
                hv_Lightness.Dispose();
                hv_Saturation.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();

                return;
                //
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_HLSImageH.Dispose();
                ho_HLSImageL.Dispose();
                ho_HLSImageS.Dispose();
                ho_ImageR.Dispose();
                ho_ImageG.Dispose();
                ho_ImageB.Dispose();

                hv_EndColor_COPY_INP_TMP.Dispose();
                hv_Random_COPY_INP_TMP.Dispose();
                hv_IsString.Dispose();
                hv_Hue.Dispose();
                hv_Lightness.Dispose();
                hv_Saturation.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Generates certain colors for different ClassNames 
        public void get_dl_class_colors(HTuple hv_ClassNames, out HTuple hv_Colors)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_NumColors = new HTuple(), hv_ColorsRainbow = new HTuple();
            HTuple hv_ClassNamesGood = new HTuple(), hv_IndexFind = new HTuple();
            HTuple hv_GoodIdx = new HTuple(), hv_CurrentColor = new HTuple();
            HTuple hv_GreenIdx = new HTuple();
            // Initialize local and output iconic variables 
            hv_Colors = new HTuple();
            try
            {
                //
                //This procedure returns for each class a certain color.
                //
                //Define distinct colors for the classes.
                hv_NumColors.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumColors = new HTuple(hv_ClassNames.TupleLength()
                        );
                }
                //Get distinct colors without randomness makes neighboring colors look very similar.
                //We use a workaround to get deterministic colors where subsequent colors are distinguishable.
                hv_ColorsRainbow.Dispose();
                get_distinct_colors(hv_NumColors, 0, 0, 200, out hv_ColorsRainbow);
                {
                    HTuple ExpTmpOutVar_0;
                    HOperatorSet.TupleInverse(hv_ColorsRainbow, out ExpTmpOutVar_0);
                    hv_ColorsRainbow.Dispose();
                    hv_ColorsRainbow = ExpTmpOutVar_0;
                }
                hv_Colors.Dispose();
                make_neighboring_colors_distinguishable(hv_ColorsRainbow, out hv_Colors);
                //If a class 'OK','ok', 'good' or 'GOOD' is present set this class to green.
                //Only the first occurrence found is set to a green shade.
                hv_ClassNamesGood.Dispose();
                hv_ClassNamesGood = new HTuple();
                hv_ClassNamesGood[0] = "good";
                hv_ClassNamesGood[1] = "GOOD";
                hv_ClassNamesGood[2] = "ok";
                hv_ClassNamesGood[3] = "OK";
                for (hv_IndexFind = 0; (int)hv_IndexFind <= (int)((new HTuple(hv_ClassNamesGood.TupleLength()
                    )) - 1); hv_IndexFind = (int)hv_IndexFind + 1)
                {
                    hv_GoodIdx.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_GoodIdx = hv_ClassNames.TupleFindFirst(
                            hv_ClassNamesGood.TupleSelect(hv_IndexFind));
                    }
                    if ((int)((new HTuple(hv_GoodIdx.TupleNotEqual(-1))).TupleAnd(new HTuple((new HTuple(hv_ClassNames.TupleLength()
                        )).TupleLessEqual(8)))) != 0)
                    {
                        //If number of classes is <= 8, swap color with a green color.
                        hv_CurrentColor.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentColor = hv_Colors.TupleSelect(
                                hv_GoodIdx);
                        }
                        hv_GreenIdx.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_GreenIdx = (new HTuple((new HTuple(hv_ClassNames.TupleLength()
                                )) / 2.0)).TupleFloor();
                        }
                        //Set to pure green.
                        if (hv_Colors == null)
                            hv_Colors = new HTuple();
                        hv_Colors[hv_GoodIdx] = "#00ff00";
                        //Write original color to a green entry.
                        if (hv_Colors == null)
                            hv_Colors = new HTuple();
                        hv_Colors[hv_GreenIdx] = hv_CurrentColor;
                        break;
                    }
                    else if ((int)((new HTuple(hv_GoodIdx.TupleNotEqual(-1))).TupleAnd(
                        new HTuple((new HTuple(hv_ClassNames.TupleLength())).TupleGreater(8)))) != 0)
                    {
                        //If number of classes is larger than 8, set the respective color to green.
                        if (hv_Colors == null)
                            hv_Colors = new HTuple();
                        hv_Colors[hv_GoodIdx] = "#00ff00";
                        break;
                    }
                }

                hv_NumColors.Dispose();
                hv_ColorsRainbow.Dispose();
                hv_ClassNamesGood.Dispose();
                hv_IndexFind.Dispose();
                hv_GoodIdx.Dispose();
                hv_CurrentColor.Dispose();
                hv_GreenIdx.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_NumColors.Dispose();
                hv_ColorsRainbow.Dispose();
                hv_ClassNamesGood.Dispose();
                hv_IndexFind.Dispose();
                hv_GoodIdx.Dispose();
                hv_CurrentColor.Dispose();
                hv_GreenIdx.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Get the image of a sample. 
        public void get_image(out HObject ho_Image, HTuple hv_SampleKeys, HTuple hv_DLSample)
        {


            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Image);
            //
            //This procedure returns the image of a sample.
            //
            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("image"))).TupleNotEqual(-1))) != 0)
            {
                ho_Image.Dispose();
                HOperatorSet.GetDictObject(out ho_Image, hv_DLSample, "image");
            }
            else
            {
                throw new HalconException("Image could not be found in DLSample.");
            }


            return;
        }

        // Chapter: Graphics / Window
        // Short Description: Get the next window that can be used for visualization. 
        public void get_next_window(HTuple hv_Font, HTuple hv_FontSize, HTuple hv_ShowBottomDesc,
            HTuple hv_WidthImage, HTuple hv_HeightImage, HTuple hv_MapColorBarWidth, HTuple hv_ScaleWindows,
            HTuple hv_ThresholdWidth, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict,
            HTuple hv_WindowHandleKey, out HTuple hv_CurrentWindowHandle, out HTuple hv_WindowImageRatioHeight,
            out HTuple hv_PrevWindowCoordinatesOut)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_OpenNewWindow = new HTuple(), hv_WindowHandles = new HTuple();
            HTuple hv_Value = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
            HTuple hv__ = new HTuple(), hv_MarginBottom = new HTuple();
            HTuple hv_WindowImageRatioWidth = new HTuple(), hv_SetPartRow2 = new HTuple();
            HTuple hv_SetPartColumn2 = new HTuple(), hv_MetaInfo = new HTuple();
            // Initialize local and output iconic variables 
            hv_CurrentWindowHandle = new HTuple();
            hv_WindowImageRatioHeight = new HTuple();
            hv_PrevWindowCoordinatesOut = new HTuple();
            try
            {
                //
                //This procedure returns the next window that
                //is used for visualization. If ReuseWindows is true
                //and WindowHandleList is suitable, the window handles
                //that are passed over are used. Else, this procedure
                //opens a new window, either next to the last ones, or
                //in a new row.
                //
                //First, check if the requested window is already available.
                hv_OpenNewWindow.Dispose();
                hv_OpenNewWindow = 0;
                try
                {
                    hv_WindowHandles.Dispose();
                    HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, out hv_WindowHandles);
                    hv_CurrentWindowHandle.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentWindowHandle = hv_WindowHandles.TupleSelect(
                            0);
                    }
                    //Check if window handle is valid.
                    try
                    {
                        hv_Value.Dispose();
                        HOperatorSet.GetWindowParam(hv_CurrentWindowHandle, "flush", out hv_Value);
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException2)
                    {
                        HDevExpDefaultException2.ToHTuple(out hv_Exception);
                        //If there is something wrong with the current window, create a new one.
                        hv_OpenNewWindow.Dispose();
                        hv_OpenNewWindow = 1;
                        HOperatorSet.RemoveDictKey(hv_WindowHandleDict, hv_WindowHandleKey);
                    }
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    hv_OpenNewWindow.Dispose();
                    hv_OpenNewWindow = 1;
                }
                //
                //Get next window.
                if ((int)(hv_OpenNewWindow.TupleNot()) != 0)
                {
                    //
                    //If possible, reuse existing window handles.
                    HDevWindowStack.SetActive(hv_CurrentWindowHandle);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                    }
                    set_display_font(hv_CurrentWindowHandle, hv_FontSize, hv_Font, "true", "false");
                    //
                    //Calculate MarginBottom.
                    if ((int)(hv_ShowBottomDesc) != 0)
                    {
                        hv_Ascent.Dispose(); hv_Descent.Dispose(); hv__.Dispose(); hv__.Dispose();
                        HOperatorSet.GetStringExtents(hv_CurrentWindowHandle, "test_string", out hv_Ascent,
                            out hv_Descent, out hv__, out hv__);
                        hv_MarginBottom.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MarginBottom = ((2 * 12) + hv_Ascent) + hv_Descent;
                        }
                    }
                    else
                    {
                        hv_MarginBottom.Dispose();
                        hv_MarginBottom = 0;
                    }
                    //
                    //Get and set meta information for current window.
                    hv_WindowImageRatioHeight.Dispose(); hv_WindowImageRatioWidth.Dispose(); hv_SetPartRow2.Dispose(); hv_SetPartColumn2.Dispose(); hv_PrevWindowCoordinatesOut.Dispose();
                    update_window_meta_information(hv_CurrentWindowHandle, hv_WidthImage, hv_HeightImage,
                        0, 0, hv_MapColorBarWidth, hv_MarginBottom, out hv_WindowImageRatioHeight,
                        out hv_WindowImageRatioWidth, out hv_SetPartRow2, out hv_SetPartColumn2,
                        out hv_PrevWindowCoordinatesOut);
                    //
                    //Update meta information.
                    hv_MetaInfo.Dispose();
                    HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_window_image_ratio_height",
                            hv_WindowImageRatioHeight);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_window_image_ratio_width",
                            hv_WindowImageRatioWidth);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_set_part_row2",
                            hv_SetPartRow2);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_set_part_column2",
                            hv_SetPartColumn2);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_margin_bottom",
                            hv_MarginBottom);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_map_color_bar_with",
                            hv_MapColorBarWidth);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_window_coordinates",
                            hv_PrevWindowCoordinatesOut);
                    }
                }
                else
                {
                    //
                    //Open a new window.
                    hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatioHeight.Dispose(); hv_PrevWindowCoordinatesOut.Dispose();
                    open_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                        hv_HeightImage, hv_MapColorBarWidth, hv_ScaleWindows, hv_ThresholdWidth,
                        hv_PrevWindowCoordinates, hv_WindowHandleDict, hv_WindowHandleKey, out hv_CurrentWindowHandle,
                        out hv_WindowImageRatioHeight, out hv_PrevWindowCoordinatesOut);
                    HOperatorSet.SetWindowParam(hv_CurrentWindowHandle, "flush", "false");
                }
                //

                hv_OpenNewWindow.Dispose();
                hv_WindowHandles.Dispose();
                hv_Value.Dispose();
                hv_Exception.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv__.Dispose();
                hv_MarginBottom.Dispose();
                hv_WindowImageRatioWidth.Dispose();
                hv_SetPartRow2.Dispose();
                hv_SetPartColumn2.Dispose();
                hv_MetaInfo.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_OpenNewWindow.Dispose();
                hv_WindowHandles.Dispose();
                hv_Value.Dispose();
                hv_Exception.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv__.Dispose();
                hv_MarginBottom.Dispose();
                hv_WindowImageRatioWidth.Dispose();
                hv_SetPartRow2.Dispose();
                hv_SetPartColumn2.Dispose();
                hv_MetaInfo.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Semantic Segmentation
        // Short Description: Get the ground truth segmentation image. 
        public void get_segmentation_image_ground_truth(out HObject ho_SegmentationImagGroundTruth,
            HTuple hv_SampleKeys, HTuple hv_DLSample)
        {


            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_SegmentationImagGroundTruth);
            //
            //This procedure returns the ground truth segmentation image.
            //
            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("segmentation_image"))).TupleNotEqual(
                -1))) != 0)
            {
                ho_SegmentationImagGroundTruth.Dispose();
                HOperatorSet.GetDictObject(out ho_SegmentationImagGroundTruth, hv_DLSample,
                    "segmentation_image");
            }
            else
            {
                throw new HalconException("Ground truth segmentation image could not be found in DLSample.");
            }


            return;
        }

        // Chapter: Deep Learning / Semantic Segmentation
        // Short Description: Get the predicted segmentation result image. 
        public void get_segmentation_image_result(out HObject ho_SegmentationImageResult,
            HTuple hv_ResultKeys, HTuple hv_DLResult)
        {


            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_SegmentationImageResult);
            //
            //This procedure returns the predicted segmentation result image.
            //
            if ((int)(new HTuple(((hv_ResultKeys.TupleFind("segmentation_image"))).TupleNotEqual(
                -1))) != 0)
            {
                ho_SegmentationImageResult.Dispose();
                HOperatorSet.GetDictObject(out ho_SegmentationImageResult, hv_DLResult, "segmentation_image");
            }
            else
            {
                throw new HalconException("Result segmentation data could not be found in DLSample.");
            }


            return;
        }

        // Chapter: Deep Learning / Semantic Segmentation
        // Short Description: Get the weight image of a sample. 
        public void get_weight_image(out HObject ho_ImageWeight, HTuple hv_SampleKeys,
            HTuple hv_DLSample)
        {


            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ImageWeight);
            //
            //This procedure returns the segmentation weight image of a sample.
            //
            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("weight_image"))).TupleNotEqual(
                -1))) != 0)
            {
                ho_ImageWeight.Dispose();
                HOperatorSet.GetDictObject(out ho_ImageWeight, hv_DLSample, "weight_image");
            }
            else
            {
                throw new HalconException("Weight image could not be found in DLSample.");
            }


            return;
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Initialize the dictionary RunningMeasures for the evaluation. 
        public void init_running_evaluation_measures(HTuple hv_EvalParams, out HTuple hv_RunningMeasures)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Valid = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_NumClasses = new HTuple(), hv_EvaluationType = new HTuple();
            HTuple hv_Measures = new HTuple(), hv_ClassIDs = new HTuple();
            HTuple hv_InstanceType = new HTuple(), hv_EvalOrientation = new HTuple();
            HTuple hv_AllocationBlockLength = new HTuple(), hv_IoUThreshs = new HTuple();
            HTuple hv_MaxNumDetections = new HTuple(), hv_AreaRanges = new HTuple();
            HTuple hv_AreaNames = new HTuple(), hv_MinAreas = new HTuple();
            HTuple hv_MaxAreas = new HTuple(), hv_DetailedEvaluation = new HTuple();
            HTuple hv_MaxNumIdx = new HTuple(), hv_MaxNum = new HTuple();
            HTuple hv_CurrentRunningMeasure = new HTuple(), hv_AreaIdx = new HTuple();
            HTuple hv_AreaRunningMeasure = new HTuple(), hv_I = new HTuple();
            HTuple hv_IoURunningMeasure = new HTuple(), hv_ClsIdx = new HTuple();
            HTuple hv_ClassRunningMeasures = new HTuple(), hv_Confidence = new HTuple();
            HTuple hv_IgnoreClassIDs = new HTuple(), hv_CalcConfMatrix = new HTuple();
            HTuple hv_MatrixSize = new HTuple(), hv_PixelConfusionMatrix = new HTuple();
            HTuple hv_MaxId = new HTuple(), hv_ClsIDToClsIdx = new HTuple();
            HTuple hv_TP = new HTuple(), hv_FP = new HTuple(), hv_FN = new HTuple();
            // Initialize local and output iconic variables 
            hv_RunningMeasures = new HTuple();
            try
            {
                //
                //This procedure initializes the dictionary RunningMeasures for evaluation.
                //It uses the evaluation parameters to initialize the running measures accordingly.
                //
                //The structure of RunningMeasures depends on the entry 'evaluate_instances' in the dictionary EvalParams.
                //
                //The dictionary RunningMeasures can be updated based on the per-batch/per-image evaluation results.
                //
                hv_RunningMeasures.Dispose();
                HOperatorSet.CreateDict(out hv_RunningMeasures);
                //Check that the necessary evaluation parameters exist.
                hv_Valid.Dispose(); hv_Exception.Dispose();
                validate_evaluation_param(hv_EvalParams, out hv_Valid, out hv_Exception);
                if ((int)(hv_Valid.TupleNot()) != 0)
                {
                    throw new HalconException(new HTuple("Invalid EvalParams, ") + hv_Exception);
                }
                //
                //Get general evaluation parameters.
                hv_NumClasses.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
                hv_EvaluationType.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "evaluation_type", out hv_EvaluationType);
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                hv_ClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                //
                if ((int)(new HTuple(hv_EvaluationType.TupleEqual("anomaly_detection"))) != 0)
                {
                    //RunningMeasures contains:
                    //- image_ids:          IDs of the images.
                    //- anomaly_label_ids:  Class IDs of ground truth labels.
                    //- anomaly_scores:     Predicted image level anomaly scores.
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_ids", new HTuple());
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "anomaly_label_ids", new HTuple());
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "anomaly_scores", new HTuple());
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("classification"))) != 0)
                {
                    //RunningMeasures contains:
                    //- image_ids:          IDs of the images.
                    //- image_label_ids:    Class IDs of ground truth labels.
                    //- top1_predictions:   Class IDs of the top predicted class.
                    //- topk_predictions:   Class IDs of top-K predicted classes.
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_ids", new HTuple());
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_label_ids", new HTuple());
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "top1_predictions", new HTuple());
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "topk_predictions", new HTuple());
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("detection"))) != 0)
                {
                    //RunningMeasures contains:
                    //For each maximal number of regions (MaxNumDetections):
                    // - For each area range (AreaRanges):
                    //   -- confidence:     Confidence (score) of each result.
                    //   -- num_gt:         Total number of ground truth instances per class.
                    //   -- num_pred:       Total number of predictions per class.
                    //   -- num_gt_ignore:  Number of ignored ground truth instances per class.
                    //   -- for each IoU-threshold:
                    //      --- For each class:
                    //          ---- is_tp:                  TP/FP assignment of result.
                    //          ---- ignore:                 Ignore/Not-Ignore assignment of result.
                    //          ---- abs_orientation_diff (for instance_type 'rectangle2' with measure SoAP):
                    //                                       Absolute orientation difference of the result.
                    //
                    //Check if the orientation difference is to be evaluated.
                    hv_InstanceType.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "instance_type", out hv_InstanceType);
                    hv_EvalOrientation.Dispose();
                    hv_EvalOrientation = 0;
                    if ((int)((new HTuple(hv_InstanceType.TupleEqual("rectangle2"))).TupleAnd(
                        (new HTuple(((hv_Measures.TupleFind("soap"))).TupleNotEqual(-1))).TupleOr(
                        new HTuple(((hv_Measures.TupleFind("all"))).TupleNotEqual(-1))))) != 0)
                    {
                        hv_EvalOrientation.Dispose();
                        hv_EvalOrientation = 1;
                    }
                    //
                    //Calculating the measures confidence, is_tp, ignore, and abs_orientation_diff,
                    //arrays are allocated with -1 in blocks of AllocationBlockLength
                    //(thus, if a block is filled, the next block is allocated).
                    //Otherwise the arrays have to be concatenated which is rather slow.
                    //The actual length of the array is garnered in num_pred.
                    hv_AllocationBlockLength.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "allocation_block_length", out hv_AllocationBlockLength);
                    hv_IoUThreshs.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "iou_threshold", out hv_IoUThreshs);
                    hv_MaxNumDetections.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "max_num_detections", out hv_MaxNumDetections);
                    hv_AreaRanges.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "area_ranges", out hv_AreaRanges);
                    //AreaRanges is a dictionary containing 'name', 'min_area', 'max_area'.
                    hv_AreaNames.Dispose();
                    HOperatorSet.GetDictTuple(hv_AreaRanges, "name", out hv_AreaNames);
                    hv_MinAreas.Dispose();
                    HOperatorSet.GetDictTuple(hv_AreaRanges, "min", out hv_MinAreas);
                    hv_MaxAreas.Dispose();
                    HOperatorSet.GetDictTuple(hv_AreaRanges, "max", out hv_MaxAreas);
                    //Check if a detailed evaluation will be performed.
                    hv_DetailedEvaluation.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "detailed_evaluation", out hv_DetailedEvaluation);
                    //Set a result dictionary for each maximal number of detections and IoU-threshold.
                    for (hv_MaxNumIdx = 0; (int)hv_MaxNumIdx <= (int)((new HTuple(hv_MaxNumDetections.TupleLength()
                        )) - 1); hv_MaxNumIdx = (int)hv_MaxNumIdx + 1)
                    {
                        hv_MaxNum.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MaxNum = hv_MaxNumDetections.TupleSelect(
                                hv_MaxNumIdx);
                        }
                        hv_CurrentRunningMeasure.Dispose();
                        HOperatorSet.CreateDict(out hv_CurrentRunningMeasure);
                        for (hv_AreaIdx = 0; (int)hv_AreaIdx <= (int)((new HTuple(hv_AreaNames.TupleLength()
                            )) - 1); hv_AreaIdx = (int)hv_AreaIdx + 1)
                        {
                            hv_AreaRunningMeasure.Dispose();
                            HOperatorSet.CreateDict(out hv_AreaRunningMeasure);
                            for (hv_I = 0; (int)hv_I <= (int)((new HTuple(hv_IoUThreshs.TupleLength()
                                )) - 1); hv_I = (int)hv_I + 1)
                            {
                                hv_IoURunningMeasure.Dispose();
                                HOperatorSet.CreateDict(out hv_IoURunningMeasure);
                                HTuple end_val84 = hv_NumClasses - 1;
                                HTuple step_val84 = 1;
                                for (hv_ClsIdx = 0; hv_ClsIdx.Continue(end_val84, step_val84); hv_ClsIdx = hv_ClsIdx.TupleAdd(step_val84))
                                {
                                    hv_ClassRunningMeasures.Dispose();
                                    HOperatorSet.CreateDict(out hv_ClassRunningMeasures);
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_tp", HTuple.TupleGenConst(
                                            hv_AllocationBlockLength, -1));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "ignore", HTuple.TupleGenConst(
                                            hv_AllocationBlockLength, -1));
                                    }
                                    if ((int)(hv_EvalOrientation) != 0)
                                    {
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "abs_orientation_diff",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                    }
                                    if ((int)(hv_DetailedEvaluation) != 0)
                                    {
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_fp_class",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_fp_background",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_fp_localization",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_fp_duplicate",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_fp_multiple",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                        if ((int)(hv_EvalOrientation) != 0)
                                        {
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "abs_orientation_diff_class",
                                                    HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                            }
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "abs_orientation_diff_localization",
                                                    HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                            }
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "abs_orientation_diff_duplicate",
                                                    HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                            }
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "abs_orientation_diff_multiple",
                                                    HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                            }
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_IoURunningMeasure, "image_ids_with_false_negatives",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_IoURunningMeasure, "image_ids_with_false_positives",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                        HOperatorSet.SetDictTuple(hv_IoURunningMeasure, "num_image_ids_with_false_negatives",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_IoURunningMeasure, "num_image_ids_with_false_positives",
                                            0);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_IoURunningMeasure, "class_" + (hv_ClassIDs.TupleSelect(
                                            hv_ClsIdx)), hv_ClassRunningMeasures);
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_AreaRunningMeasure, "iou_" + ((("" + (hv_IoUThreshs.TupleSelect(
                                        hv_I)))).TupleRegexpReplace("\\.", "")), hv_IoURunningMeasure);
                                }
                            }
                            hv_Confidence.Dispose();
                            HOperatorSet.CreateDict(out hv_Confidence);
                            HTuple end_val113 = hv_NumClasses - 1;
                            HTuple step_val113 = 1;
                            for (hv_ClsIdx = 0; hv_ClsIdx.Continue(end_val113, step_val113); hv_ClsIdx = hv_ClsIdx.TupleAdd(step_val113))
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_Confidence, "class_" + (hv_ClassIDs.TupleSelect(
                                        hv_ClsIdx)), HTuple.TupleGenConst(hv_AllocationBlockLength, -1.0));
                                }
                            }
                            HOperatorSet.SetDictTuple(hv_AreaRunningMeasure, "confidence", hv_Confidence);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_AreaRunningMeasure, "num_gt", HTuple.TupleGenConst(
                                    hv_NumClasses, 0));
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_AreaRunningMeasure, "num_pred", HTuple.TupleGenConst(
                                    hv_NumClasses, 0));
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_AreaRunningMeasure, "num_gt_ignore", HTuple.TupleGenConst(
                                    hv_NumClasses, 0));
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_CurrentRunningMeasure, "area_" + (hv_AreaNames.TupleSelect(
                                    hv_AreaIdx)), hv_AreaRunningMeasure);
                            }
                        }
                        if ((int)(new HTuple(hv_MaxNum.TupleEqual(-1))) != 0)
                        {
                            hv_MaxNum.Dispose();
                            hv_MaxNum = "all";
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_RunningMeasures, "max_num_detections_" + hv_MaxNum,
                                hv_CurrentRunningMeasure);
                        }
                    }
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("segmentation"))) != 0)
                {
                    //RunningMeasures contains:
                    //if confusion matrix in Measures (slower but more information).
                    // - confusion matrix per pixel.
                    //else:
                    // - TP/FP/FN (pixel numbers per class).
                    //
                    //Incorporate ignore class IDs.
                    hv_IgnoreClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "ignore_class_ids", out hv_IgnoreClassIDs);
                    //
                    //Check if we need to compute/update the confusion matrix.
                    hv_CalcConfMatrix.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CalcConfMatrix = (new HTuple(((hv_Measures.TupleFind(
                            "pixel_confusion_matrix"))).TupleGreater(-1))).TupleOr(new HTuple(((hv_Measures.TupleFind(
                            "all"))).TupleGreater(-1)));
                    }
                    if ((int)(hv_CalcConfMatrix) != 0)
                    {
                        //Define the size of the confusion matrix.
                        hv_MatrixSize.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MatrixSize = hv_NumClasses + (new HTuple((new HTuple(hv_IgnoreClassIDs.TupleLength()
                                )).TupleGreater(0)));
                        }
                        hv_PixelConfusionMatrix.Dispose();
                        HOperatorSet.CreateMatrix(hv_MatrixSize, hv_MatrixSize, 0, out hv_PixelConfusionMatrix);
                        HOperatorSet.SetDictTuple(hv_RunningMeasures, "pixel_confusion_matrix",
                            hv_PixelConfusionMatrix);
                        //
                        //If the class IDs are not running indices from 0 to NumClasses we
                        //define a mapping from class IDs to class indices.
                        if ((int)((new HTuple(hv_ClassIDs.TupleNotEqual(HTuple.TupleGenSequence(
                            0, (new HTuple(hv_ClassIDs.TupleLength())) - 1, 1)))).TupleOr(new HTuple((new HTuple(hv_IgnoreClassIDs.TupleLength()
                            )).TupleGreater(0)))) != 0)
                        {
                            //Get the max ID that can occur.
                            hv_MaxId.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_MaxId = (hv_ClassIDs.TupleMax()
                                    ) + (new HTuple((new HTuple(hv_IgnoreClassIDs.TupleLength())).TupleGreater(
                                    0)));
                            }
                            //Define the basic mapping.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClsIDToClsIdx.Dispose();
                                HOperatorSet.TupleGenConst(hv_MaxId + 1, -1, out hv_ClsIDToClsIdx);
                            }
                            if (hv_ClsIDToClsIdx == null)
                                hv_ClsIDToClsIdx = new HTuple();
                            hv_ClsIDToClsIdx[hv_ClassIDs] = HTuple.TupleGenSequence(0, (new HTuple(hv_ClassIDs.TupleLength()
                                )) - 1, 1);
                            //Map ignore IDs to the next higher one.
                            if (hv_ClsIDToClsIdx == null)
                                hv_ClsIDToClsIdx = new HTuple();
                            hv_ClsIDToClsIdx[hv_IgnoreClassIDs] = (hv_ClsIDToClsIdx.TupleMax()) + 1;
                            //Set the mapping to the evaluation parameters.
                            HOperatorSet.SetDictTuple(hv_EvalParams, "class_id_mapping", hv_ClsIDToClsIdx);
                        }
                    }
                    else
                    {
                        hv_TP.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TP = HTuple.TupleGenConst(
                                hv_NumClasses, 0);
                        }
                        hv_FP.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FP = HTuple.TupleGenConst(
                                hv_NumClasses, 0);
                        }
                        hv_FN.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FN = HTuple.TupleGenConst(
                                hv_NumClasses, 0);
                        }
                        HOperatorSet.SetDictTuple(hv_RunningMeasures, "tp", hv_TP);
                        HOperatorSet.SetDictTuple(hv_RunningMeasures, "fp", hv_FP);
                        HOperatorSet.SetDictTuple(hv_RunningMeasures, "fn", hv_FN);
                    }
                }
                //

                hv_Valid.Dispose();
                hv_Exception.Dispose();
                hv_NumClasses.Dispose();
                hv_EvaluationType.Dispose();
                hv_Measures.Dispose();
                hv_ClassIDs.Dispose();
                hv_InstanceType.Dispose();
                hv_EvalOrientation.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_IoUThreshs.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_MaxNumIdx.Dispose();
                hv_MaxNum.Dispose();
                hv_CurrentRunningMeasure.Dispose();
                hv_AreaIdx.Dispose();
                hv_AreaRunningMeasure.Dispose();
                hv_I.Dispose();
                hv_IoURunningMeasure.Dispose();
                hv_ClsIdx.Dispose();
                hv_ClassRunningMeasures.Dispose();
                hv_Confidence.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_CalcConfMatrix.Dispose();
                hv_MatrixSize.Dispose();
                hv_PixelConfusionMatrix.Dispose();
                hv_MaxId.Dispose();
                hv_ClsIDToClsIdx.Dispose();
                hv_TP.Dispose();
                hv_FP.Dispose();
                hv_FN.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Valid.Dispose();
                hv_Exception.Dispose();
                hv_NumClasses.Dispose();
                hv_EvaluationType.Dispose();
                hv_Measures.Dispose();
                hv_ClassIDs.Dispose();
                hv_InstanceType.Dispose();
                hv_EvalOrientation.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_IoUThreshs.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_MaxNumIdx.Dispose();
                hv_MaxNum.Dispose();
                hv_CurrentRunningMeasure.Dispose();
                hv_AreaIdx.Dispose();
                hv_AreaRunningMeasure.Dispose();
                hv_I.Dispose();
                hv_IoURunningMeasure.Dispose();
                hv_ClsIdx.Dispose();
                hv_ClassRunningMeasures.Dispose();
                hv_Confidence.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_CalcConfMatrix.Dispose();
                hv_MatrixSize.Dispose();
                hv_PixelConfusionMatrix.Dispose();
                hv_MaxId.Dispose();
                hv_ClsIDToClsIdx.Dispose();
                hv_TP.Dispose();
                hv_FP.Dispose();
                hv_FN.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: shuffles the input colors in a deterministic way 
        public void make_neighboring_colors_distinguishable(HTuple hv_ColorsRainbow, out HTuple hv_Colors)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_NumColors = new HTuple(), hv_NumChunks = new HTuple();
            HTuple hv_NumLeftOver = new HTuple(), hv_ColorsPerChunk = new HTuple();
            HTuple hv_StartIdx = new HTuple(), hv_S = new HTuple();
            HTuple hv_EndIdx = new HTuple(), hv_IdxsLeft = new HTuple();
            HTuple hv_IdxsRight = new HTuple();
            // Initialize local and output iconic variables 
            hv_Colors = new HTuple();
            try
            {
                //
                //Shuffle the input colors in a deterministic way
                //to make adjacent colors more distinguishable.
                //Neighboring colors from the input are distributed to every NumChunks
                //position in the output.
                //Depending on the number of colors, increase NumChunks.
                hv_NumColors.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumColors = new HTuple(hv_ColorsRainbow.TupleLength()
                        );
                }
                if ((int)(new HTuple(hv_NumColors.TupleGreaterEqual(8))) != 0)
                {
                    hv_NumChunks.Dispose();
                    hv_NumChunks = 3;
                    if ((int)(new HTuple(hv_NumColors.TupleGreaterEqual(40))) != 0)
                    {
                        hv_NumChunks.Dispose();
                        hv_NumChunks = 6;
                    }
                    else if ((int)(new HTuple(hv_NumColors.TupleGreaterEqual(20))) != 0)
                    {
                        hv_NumChunks.Dispose();
                        hv_NumChunks = 4;
                    }
                    hv_Colors.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Colors = HTuple.TupleGenConst(
                            hv_NumColors, -1);
                    }
                    //Check if the Number of Colors is dividable by NumChunks.
                    hv_NumLeftOver.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumLeftOver = hv_NumColors % hv_NumChunks;
                    }
                    hv_ColorsPerChunk.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ColorsPerChunk = ((hv_NumColors / hv_NumChunks)).TupleInt()
                            ;
                    }
                    hv_StartIdx.Dispose();
                    hv_StartIdx = 0;
                    HTuple end_val19 = hv_NumChunks - 1;
                    HTuple step_val19 = 1;
                    for (hv_S = 0; hv_S.Continue(end_val19, step_val19); hv_S = hv_S.TupleAdd(step_val19))
                    {
                        hv_EndIdx.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_EndIdx = (hv_StartIdx + hv_ColorsPerChunk) - 1;
                        }
                        if ((int)(new HTuple(hv_S.TupleLess(hv_NumLeftOver))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_EndIdx = hv_EndIdx + 1;
                                    hv_EndIdx.Dispose();
                                    hv_EndIdx = ExpTmpLocalVar_EndIdx;
                                }
                            }
                        }
                        hv_IdxsLeft.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_IdxsLeft = HTuple.TupleGenSequence(
                                hv_S, hv_NumColors - 1, hv_NumChunks);
                        }
                        hv_IdxsRight.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_IdxsRight = HTuple.TupleGenSequence(
                                hv_StartIdx, hv_EndIdx, 1);
                        }
                        if (hv_Colors == null)
                            hv_Colors = new HTuple();
                        hv_Colors[HTuple.TupleGenSequence(hv_S, hv_NumColors - 1, hv_NumChunks)] = hv_ColorsRainbow.TupleSelectRange(
                            hv_StartIdx, hv_EndIdx);
                        hv_StartIdx.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_StartIdx = hv_EndIdx + 1;
                        }
                    }
                }
                else
                {
                    hv_Colors.Dispose();
                    hv_Colors = new HTuple(hv_ColorsRainbow);
                }

                hv_NumColors.Dispose();
                hv_NumChunks.Dispose();
                hv_NumLeftOver.Dispose();
                hv_ColorsPerChunk.Dispose();
                hv_StartIdx.Dispose();
                hv_S.Dispose();
                hv_EndIdx.Dispose();
                hv_IdxsLeft.Dispose();
                hv_IdxsRight.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_NumColors.Dispose();
                hv_NumChunks.Dispose();
                hv_NumLeftOver.Dispose();
                hv_ColorsPerChunk.Dispose();
                hv_StartIdx.Dispose();
                hv_S.Dispose();
                hv_EndIdx.Dispose();
                hv_IdxsLeft.Dispose();
                hv_IdxsRight.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Window
        // Short Description: Open a window next to the given WindowHandleFather.  
        public void open_child_window(HTuple hv_WindowHandleFather, HTuple hv_Font, HTuple hv_FontSize,
            HTuple hv_Text, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict,
            HTuple hv_WindowHandleKey, out HTuple hv_WindowHandleChild, out HTuple hv_PrevWindowCoordinatesOut)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_StringWidth = new HTuple(), hv_IndexText = new HTuple();
            HTuple hv__ = new HTuple(), hv_TextWidth = new HTuple();
            HTuple hv_WindowRow = new HTuple(), hv_WindowColumn = new HTuple();
            HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
            HTuple hv_MetaInfo = new HTuple();
            // Initialize local and output iconic variables 
            hv_WindowHandleChild = new HTuple();
            hv_PrevWindowCoordinatesOut = new HTuple();
            try
            {
                //
                //This procedure opens a window next to the given WindowHandleFather.
                //
                //Get the maximum width of the text to be displayed.
                //The width should be at leat 200.
                hv_StringWidth.Dispose();
                hv_StringWidth = 150;
                for (hv_IndexText = 0; (int)hv_IndexText <= (int)((new HTuple(hv_Text.TupleLength()
                    )) - 1); hv_IndexText = (int)hv_IndexText + 1)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv__.Dispose(); hv__.Dispose(); hv_TextWidth.Dispose(); hv__.Dispose();
                        HOperatorSet.GetStringExtents(hv_WindowHandleFather, hv_Text.TupleSelect(
                            hv_IndexText), out hv__, out hv__, out hv_TextWidth, out hv__);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_StringWidth = hv_StringWidth.TupleMax2(
                                hv_TextWidth);
                            hv_StringWidth.Dispose();
                            hv_StringWidth = ExpTmpLocalVar_StringWidth;
                        }
                    }
                }
                //
                //Define window coordinates.
                hv_WindowRow.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowRow = hv_PrevWindowCoordinates.TupleSelect(
                        0);
                }
                hv_WindowColumn.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowColumn = ((hv_PrevWindowCoordinates.TupleSelect(
                        1)) + (hv_PrevWindowCoordinates.TupleSelect(2))) + 5;
                }
                hv_WindowWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowWidth = hv_StringWidth + (2 * 12.0);
                }
                hv_WindowHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowHeight = hv_PrevWindowCoordinates.TupleSelect(
                        3);
                }
                //
                HOperatorSet.SetWindowAttr("background_color", "black");
                HOperatorSet.OpenWindow(hv_WindowRow, hv_WindowColumn, hv_WindowWidth, hv_WindowHeight, 0, "visible", "", out hv_WindowHandleChild);
                HDevWindowStack.Push(hv_WindowHandleChild);
                set_display_font(hv_WindowHandleChild, hv_FontSize, hv_Font, "true", "false");
                //
                //Return the coordinates of the new window.
                hv_PrevWindowCoordinatesOut.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PrevWindowCoordinatesOut = new HTuple();
                    hv_PrevWindowCoordinatesOut = hv_PrevWindowCoordinatesOut.TupleConcat(hv_WindowRow, hv_WindowColumn, hv_WindowWidth, hv_WindowHeight);
                }
                //
                //Set some meta information about the new child window handle.
                hv_MetaInfo.Dispose();
                HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_child_window_coordinates",
                        hv_PrevWindowCoordinatesOut);
                }
                HOperatorSet.SetDictTuple(hv_WindowHandleDict, "meta_information", hv_MetaInfo);
                //

                hv_StringWidth.Dispose();
                hv_IndexText.Dispose();
                hv__.Dispose();
                hv_TextWidth.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowColumn.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_MetaInfo.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_StringWidth.Dispose();
                hv_IndexText.Dispose();
                hv__.Dispose();
                hv_TextWidth.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowColumn.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_MetaInfo.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Window
        // Short Description: Open a new window, either next to the last ones, or in a new row. 
        public void open_next_window(HTuple hv_Font, HTuple hv_FontSize, HTuple hv_ShowBottomDesc,
            HTuple hv_WidthImage, HTuple hv_HeightImage, HTuple hv_MapColorBarWidth, HTuple hv_ScaleWindows,
            HTuple hv_ThresholdWidth, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict,
            HTuple hv_WindowHandleKey, out HTuple hv_WindowHandleNew, out HTuple hv_WindowImageRatioHeight,
            out HTuple hv_PrevWindowCoordinatesOut)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_PrevWindowRow = new HTuple(), hv_PrevWindowColumn = new HTuple();
            HTuple hv_PrevWindowWidth = new HTuple(), hv_PrevWindowHeight = new HTuple();
            HTuple hv_WindowRow = new HTuple(), hv_WindowColumn = new HTuple();
            HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
            HTuple hv__ = new HTuple(), hv_MarginBottom = new HTuple();
            HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
            HTuple hv_WindowImageRatioWidth = new HTuple(), hv_SetPartRow2 = new HTuple();
            HTuple hv_SetPartColumn2 = new HTuple(), hv_MetaInfo = new HTuple();
            // Initialize local and output iconic variables 
            hv_WindowHandleNew = new HTuple();
            hv_WindowImageRatioHeight = new HTuple();
            hv_PrevWindowCoordinatesOut = new HTuple();
            try
            {
                //
                //This procedure opens a new window, either next to
                //the last ones, or in a new row.
                //
                //Get coordinates of previous window.
                hv_PrevWindowRow.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PrevWindowRow = hv_PrevWindowCoordinates.TupleSelect(
                        0);
                }
                hv_PrevWindowColumn.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PrevWindowColumn = hv_PrevWindowCoordinates.TupleSelect(
                        1);
                }
                hv_PrevWindowWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PrevWindowWidth = hv_PrevWindowCoordinates.TupleSelect(
                        2);
                }
                hv_PrevWindowHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PrevWindowHeight = hv_PrevWindowCoordinates.TupleSelect(
                        3);
                }
                //
                if ((int)(new HTuple(((hv_PrevWindowColumn + hv_PrevWindowWidth)).TupleGreater(
                    hv_ThresholdWidth))) != 0)
                {
                    //Open window in new row.
                    hv_WindowRow.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_WindowRow = (hv_PrevWindowRow + hv_PrevWindowHeight) + 55;
                    }
                    hv_WindowColumn.Dispose();
                    hv_WindowColumn = 0;
                }
                else
                {
                    //Open window in same row.
                    hv_WindowRow.Dispose();
                    hv_WindowRow = new HTuple(hv_PrevWindowRow);
                    hv_WindowColumn.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_WindowColumn = hv_PrevWindowColumn + hv_PrevWindowWidth;
                    }
                    if ((int)(new HTuple(hv_WindowColumn.TupleNotEqual(0))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_WindowColumn = hv_WindowColumn + 5;
                                hv_WindowColumn.Dispose();
                                hv_WindowColumn = ExpTmpLocalVar_WindowColumn;
                            }
                        }
                    }
                }
                //
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowHandleNew.Dispose();
                    dev_open_window_fit_size(hv_WindowRow, hv_WindowColumn, hv_WidthImage, hv_HeightImage,
                        (new HTuple(500)).TupleConcat(800) * hv_ScaleWindows, (new HTuple(400)).TupleConcat(
                        600) * hv_ScaleWindows, out hv_WindowHandleNew);
                }
                set_display_font(hv_WindowHandleNew, hv_FontSize, hv_Font, "true", "false");
                //
                //Add MarginBottom and MapColorBarWidth to window.
                if ((int)(hv_ShowBottomDesc) != 0)
                {
                    hv_Ascent.Dispose(); hv_Descent.Dispose(); hv__.Dispose(); hv__.Dispose();
                    HOperatorSet.GetStringExtents(hv_WindowHandleNew, "Test_string", out hv_Ascent,
                        out hv_Descent, out hv__, out hv__);
                    hv_MarginBottom.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MarginBottom = ((2 * 12) + hv_Ascent) + hv_Descent;
                    }
                }
                else
                {
                    hv_MarginBottom.Dispose();
                    hv_MarginBottom = 0;
                }
                hv__.Dispose(); hv__.Dispose(); hv_WindowWidth.Dispose(); hv_WindowHeight.Dispose();
                HOperatorSet.GetWindowExtents(hv_WindowHandleNew, out hv__, out hv__, out hv_WindowWidth,
                    out hv_WindowHeight);
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_WindowRow,
                            hv_WindowColumn, hv_WindowWidth + hv_MapColorBarWidth, hv_WindowHeight + hv_MarginBottom);
                    }
                }
                //
                //Get and set meta information of new window handle.
                hv_WindowImageRatioHeight.Dispose(); hv_WindowImageRatioWidth.Dispose(); hv_SetPartRow2.Dispose(); hv_SetPartColumn2.Dispose(); hv_PrevWindowCoordinatesOut.Dispose();
                update_window_meta_information(hv_WindowHandleNew, hv_WidthImage, hv_HeightImage,
                    hv_WindowRow, hv_WindowColumn, hv_MapColorBarWidth, hv_MarginBottom, out hv_WindowImageRatioHeight,
                    out hv_WindowImageRatioWidth, out hv_SetPartRow2, out hv_SetPartColumn2,
                    out hv_PrevWindowCoordinatesOut);
                //
                //Set window handle and some meta information about the new window handle.
                HOperatorSet.SetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, hv_WindowHandleNew);
                hv_MetaInfo.Dispose();
                HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_window_image_ratio_height",
                        hv_WindowImageRatioHeight);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_window_image_ratio_width",
                        hv_WindowImageRatioWidth);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_set_part_row2",
                        hv_SetPartRow2);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_set_part_column2",
                        hv_SetPartColumn2);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_margin_bottom",
                        hv_MarginBottom);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_map_color_bar_with",
                        hv_MapColorBarWidth);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_window_coordinates",
                        hv_PrevWindowCoordinatesOut);
                }
                HOperatorSet.SetDictTuple(hv_WindowHandleDict, "meta_information", hv_MetaInfo);
                //

                hv_PrevWindowRow.Dispose();
                hv_PrevWindowColumn.Dispose();
                hv_PrevWindowWidth.Dispose();
                hv_PrevWindowHeight.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowColumn.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv__.Dispose();
                hv_MarginBottom.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_WindowImageRatioWidth.Dispose();
                hv_SetPartRow2.Dispose();
                hv_SetPartColumn2.Dispose();
                hv_MetaInfo.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_PrevWindowRow.Dispose();
                hv_PrevWindowColumn.Dispose();
                hv_PrevWindowWidth.Dispose();
                hv_PrevWindowHeight.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowColumn.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv__.Dispose();
                hv_MarginBottom.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_WindowImageRatioWidth.Dispose();
                hv_SetPartRow2.Dispose();
                hv_SetPartColumn2.Dispose();
                hv_MetaInfo.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Read the dictionaries DLSamples from files. 
        public void read_dl_samples(HTuple hv_DLDataset, HTuple hv_SampleIndices, out HTuple hv_DLSampleBatch)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_DatasetSamples = new HTuple(), hv_MinIndex = new HTuple();
            HTuple hv_MaxIndex = new HTuple(), hv_KeyDirExists = new HTuple();
            HTuple hv_DictDir = new HTuple(), hv_DLSamplesProc = new HTuple();
            HTuple hv_ImageIndex = new HTuple(), hv_KeyFileExists = new HTuple();
            HTuple hv_ImageID = new HTuple(), hv_FileNameRelative = new HTuple();
            HTuple hv_FileNameSample = new HTuple(), hv_FileExists = new HTuple();
            HTuple hv_DictPath = new HTuple(), hv_DLSample = new HTuple();
            HTuple hv_Exception = new HTuple();
            // Initialize local and output iconic variables 
            hv_DLSampleBatch = new HTuple();
            try
            {
                //
                //This procedure reads a batch of DLSample dictionaries from disk.
                //The wanted samples are selected from a DLDataset by their indices.
                //The indices of the wanted samples are handed over in SampleIndices.
                //It returns the tuple of read-in dictionaries in DLSampleBatch.
                //
                //Sanity checks of inputs.
                //
                if ((int)(new HTuple((new HTuple(hv_SampleIndices.TupleLength())).TupleLessEqual(
                    0))) != 0)
                {
                    //Check the length of selected indices.
                    throw new HalconException(new HTuple("Invalid length of SelectedIndices: ") + (new HTuple(hv_SampleIndices.TupleLength()
                        )));
                }
                else
                {
                    //Get the samples from the DLDataset.
                    hv_DatasetSamples.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DatasetSamples);
                    //Get min and max value of given indices.
                    hv_MinIndex.Dispose();
                    HOperatorSet.TupleMin(hv_SampleIndices, out hv_MinIndex);
                    hv_MaxIndex.Dispose();
                    HOperatorSet.TupleMax(hv_SampleIndices, out hv_MaxIndex);
                    if ((int)((new HTuple(hv_MinIndex.TupleLess(0))).TupleOr(new HTuple(hv_MaxIndex.TupleGreater(
                        (new HTuple(hv_DatasetSamples.TupleLength())) - 1)))) != 0)
                    {
                        //Check the value range of the provided indices.
                        throw new HalconException("The given SampleIndices are not within the range of available samples in DLDataset.");
                    }
                }
                //
                //Check if the key dlsample_dir is given.
                hv_KeyDirExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLDataset, "key_exists", "dlsample_dir", out hv_KeyDirExists);
                //
                if ((int)(hv_KeyDirExists) != 0)
                {
                    //
                    //Get the dlsample_dir.
                    hv_DictDir.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLDataset, "dlsample_dir", out hv_DictDir);
                    //Get the samples to be processed.
                    hv_DLSamplesProc.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DLSamplesProc = hv_DatasetSamples.TupleSelect(
                            hv_SampleIndices);
                    }
                    //
                    //Initialize DLSampleBatch tuple.
                    hv_DLSampleBatch.Dispose();
                    hv_DLSampleBatch = new HTuple();
                    //
                    //Read in all DLSamples into the batch.
                    for (hv_ImageIndex = 0; (int)hv_ImageIndex <= (int)((new HTuple(hv_SampleIndices.TupleLength()
                        )) - 1); hv_ImageIndex = (int)hv_ImageIndex + 1)
                    {
                        //Check if dlsample key exist.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_KeyFileExists.Dispose();
                            HOperatorSet.GetDictParam(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                                "key_exists", "dlsample_file_name", out hv_KeyFileExists);
                        }
                        //
                        if ((int)(hv_KeyFileExists.TupleNot()) != 0)
                        {
                            //
                            //If the key does not exist, check if a corresponding file exists.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ImageID.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                                    "image_id", out hv_ImageID);
                            }
                            hv_FileNameRelative.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_FileNameRelative = hv_ImageID + "_dlsample.hdict";
                            }
                            hv_FileNameSample.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_FileNameSample = (hv_DictDir + "/") + hv_FileNameRelative;
                            }
                            //
                            hv_FileExists.Dispose();
                            HOperatorSet.FileExists(hv_FileNameSample, out hv_FileExists);
                            if ((int)(hv_FileExists) != 0)
                            {
                                //If it exists, create corresponding key.
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                                        "dlsample_file_name", hv_FileNameRelative);
                                }
                            }
                            else
                            {
                                //If not, throw an error.
                                throw new HalconException("No 'dlsample_file_name' and hdict file available for image ID " + hv_ImageID);
                            }
                            //
                        }
                        //
                        //If dlsample dictionary is available for reading, read it.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_DictPath.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                                "dlsample_file_name", out hv_DictPath);
                        }
                        try
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_DLSample.Dispose();
                                HOperatorSet.ReadDict((hv_DictDir + "/") + hv_DictPath, new HTuple(), new HTuple(),
                                    out hv_DLSample);
                            }
                        }
                        // catch (Exception) 
                        catch (HalconException HDevExpDefaultException1)
                        {
                            HDevExpDefaultException1.ToHTuple(out hv_Exception);
                            throw new HalconException((((("An error has occurred while reading " + hv_DictDir) + "/") + hv_DictPath) + new HTuple(" , HALCON error # ")) + (hv_Exception.TupleSelect(
                                0)));
                        }
                        //Add it to the DLSampleBatch.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_DLSampleBatch = hv_DLSampleBatch.TupleConcat(
                                    hv_DLSample);
                                hv_DLSampleBatch.Dispose();
                                hv_DLSampleBatch = ExpTmpLocalVar_DLSampleBatch;
                            }
                        }
                        //
                    }
                }
                else
                {
                    throw new HalconException("The dataset needs to include the key 'dlsample_dir' for reading a DLSample from file.");
                }


                hv_DatasetSamples.Dispose();
                hv_MinIndex.Dispose();
                hv_MaxIndex.Dispose();
                hv_KeyDirExists.Dispose();
                hv_DictDir.Dispose();
                hv_DLSamplesProc.Dispose();
                hv_ImageIndex.Dispose();
                hv_KeyFileExists.Dispose();
                hv_ImageID.Dispose();
                hv_FileNameRelative.Dispose();
                hv_FileNameSample.Dispose();
                hv_FileExists.Dispose();
                hv_DictPath.Dispose();
                hv_DLSample.Dispose();
                hv_Exception.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_DatasetSamples.Dispose();
                hv_MinIndex.Dispose();
                hv_MaxIndex.Dispose();
                hv_KeyDirExists.Dispose();
                hv_DictDir.Dispose();
                hv_DLSamplesProc.Dispose();
                hv_ImageIndex.Dispose();
                hv_KeyFileExists.Dispose();
                hv_ImageID.Dispose();
                hv_FileNameRelative.Dispose();
                hv_FileNameSample.Dispose();
                hv_FileExists.Dispose();
                hv_DictPath.Dispose();
                hv_DLSample.Dispose();
                hv_Exception.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Filters / Arithmetic
        // Short Description: Scale the gray values of an image from the interval [Min,Max] to [0,255] 
        public void scale_image_range(HObject ho_Image, out HObject ho_ImageScaled, HTuple hv_Min,
            HTuple hv_Max)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_ImageSelected = null, ho_SelectedChannel = null;
            HObject ho_LowerRegion = null, ho_UpperRegion = null, ho_ImageSelectedScaled = null;

            // Local copy input parameter variables 
            HObject ho_Image_COPY_INP_TMP;
            ho_Image_COPY_INP_TMP = new HObject(ho_Image);



            // Local control variables 

            HTuple hv_LowerLimit = new HTuple(), hv_UpperLimit = new HTuple();
            HTuple hv_Mult = new HTuple(), hv_Add = new HTuple(), hv_NumImages = new HTuple();
            HTuple hv_ImageIndex = new HTuple(), hv_Channels = new HTuple();
            HTuple hv_ChannelIndex = new HTuple(), hv_MinGray = new HTuple();
            HTuple hv_MaxGray = new HTuple(), hv_Range = new HTuple();
            HTuple hv_Max_COPY_INP_TMP = new HTuple(hv_Max);
            HTuple hv_Min_COPY_INP_TMP = new HTuple(hv_Min);

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ImageScaled);
            HOperatorSet.GenEmptyObj(out ho_ImageSelected);
            HOperatorSet.GenEmptyObj(out ho_SelectedChannel);
            HOperatorSet.GenEmptyObj(out ho_LowerRegion);
            HOperatorSet.GenEmptyObj(out ho_UpperRegion);
            HOperatorSet.GenEmptyObj(out ho_ImageSelectedScaled);
            try
            {
                //Convenience procedure to scale the gray values of the
                //input image Image from the interval [Min,Max]
                //to the interval [0,255] (default).
                //Gray values < 0 or > 255 (after scaling) are clipped.
                //
                //If the image shall be scaled to an interval different from [0,255],
                //this can be achieved by passing tuples with 2 values [From, To]
                //as Min and Max.
                //Example:
                //scale_image_range(Image:ImageScaled:[100,50],[200,250])
                //maps the gray values of Image from the interval [100,200] to [50,250].
                //All other gray values will be clipped.
                //
                //input parameters:
                //Image: the input image
                //Min: the minimum gray value which will be mapped to 0
                //     If a tuple with two values is given, the first value will
                //     be mapped to the second value.
                //Max: The maximum gray value which will be mapped to 255
                //     If a tuple with two values is given, the first value will
                //     be mapped to the second value.
                //
                //Output parameter:
                //ImageScale: the resulting scaled image.
                //
                if ((int)(new HTuple((new HTuple(hv_Min_COPY_INP_TMP.TupleLength())).TupleEqual(
                    2))) != 0)
                {
                    hv_LowerLimit.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_LowerLimit = hv_Min_COPY_INP_TMP.TupleSelect(
                            1);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Min = hv_Min_COPY_INP_TMP.TupleSelect(
                                0);
                            hv_Min_COPY_INP_TMP.Dispose();
                            hv_Min_COPY_INP_TMP = ExpTmpLocalVar_Min;
                        }
                    }
                }
                else
                {
                    hv_LowerLimit.Dispose();
                    hv_LowerLimit = 0.0;
                }
                if ((int)(new HTuple((new HTuple(hv_Max_COPY_INP_TMP.TupleLength())).TupleEqual(
                    2))) != 0)
                {
                    hv_UpperLimit.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_UpperLimit = hv_Max_COPY_INP_TMP.TupleSelect(
                            1);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Max = hv_Max_COPY_INP_TMP.TupleSelect(
                                0);
                            hv_Max_COPY_INP_TMP.Dispose();
                            hv_Max_COPY_INP_TMP = ExpTmpLocalVar_Max;
                        }
                    }
                }
                else
                {
                    hv_UpperLimit.Dispose();
                    hv_UpperLimit = 255.0;
                }
                //
                //Calculate scaling parameters.
                hv_Mult.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Mult = (((hv_UpperLimit - hv_LowerLimit)).TupleReal()
                        ) / (hv_Max_COPY_INP_TMP - hv_Min_COPY_INP_TMP);
                }
                hv_Add.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Add = ((-hv_Mult) * hv_Min_COPY_INP_TMP) + hv_LowerLimit;
                }
                //
                //Scale image.
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ScaleImage(ho_Image_COPY_INP_TMP, out ExpTmpOutVar_0, hv_Mult,
                        hv_Add);
                    ho_Image_COPY_INP_TMP.Dispose();
                    ho_Image_COPY_INP_TMP = ExpTmpOutVar_0;
                }
                //
                //Clip gray values if necessary.
                //This must be done for each image and channel separately.
                ho_ImageScaled.Dispose();
                HOperatorSet.GenEmptyObj(out ho_ImageScaled);
                hv_NumImages.Dispose();
                HOperatorSet.CountObj(ho_Image_COPY_INP_TMP, out hv_NumImages);
                HTuple end_val49 = hv_NumImages;
                HTuple step_val49 = 1;
                for (hv_ImageIndex = 1; hv_ImageIndex.Continue(end_val49, step_val49); hv_ImageIndex = hv_ImageIndex.TupleAdd(step_val49))
                {
                    ho_ImageSelected.Dispose();
                    HOperatorSet.SelectObj(ho_Image_COPY_INP_TMP, out ho_ImageSelected, hv_ImageIndex);
                    hv_Channels.Dispose();
                    HOperatorSet.CountChannels(ho_ImageSelected, out hv_Channels);
                    HTuple end_val52 = hv_Channels;
                    HTuple step_val52 = 1;
                    for (hv_ChannelIndex = 1; hv_ChannelIndex.Continue(end_val52, step_val52); hv_ChannelIndex = hv_ChannelIndex.TupleAdd(step_val52))
                    {
                        ho_SelectedChannel.Dispose();
                        HOperatorSet.AccessChannel(ho_ImageSelected, out ho_SelectedChannel, hv_ChannelIndex);
                        hv_MinGray.Dispose(); hv_MaxGray.Dispose(); hv_Range.Dispose();
                        HOperatorSet.MinMaxGray(ho_SelectedChannel, ho_SelectedChannel, 0, out hv_MinGray,
                            out hv_MaxGray, out hv_Range);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_LowerRegion.Dispose();
                            HOperatorSet.Threshold(ho_SelectedChannel, out ho_LowerRegion, ((hv_MinGray.TupleConcat(
                                hv_LowerLimit))).TupleMin(), hv_LowerLimit);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_UpperRegion.Dispose();
                            HOperatorSet.Threshold(ho_SelectedChannel, out ho_UpperRegion, hv_UpperLimit,
                                ((hv_UpperLimit.TupleConcat(hv_MaxGray))).TupleMax());
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.PaintRegion(ho_LowerRegion, ho_SelectedChannel, out ExpTmpOutVar_0,
                                hv_LowerLimit, "fill");
                            ho_SelectedChannel.Dispose();
                            ho_SelectedChannel = ExpTmpOutVar_0;
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.PaintRegion(ho_UpperRegion, ho_SelectedChannel, out ExpTmpOutVar_0,
                                hv_UpperLimit, "fill");
                            ho_SelectedChannel.Dispose();
                            ho_SelectedChannel = ExpTmpOutVar_0;
                        }
                        if ((int)(new HTuple(hv_ChannelIndex.TupleEqual(1))) != 0)
                        {
                            ho_ImageSelectedScaled.Dispose();
                            HOperatorSet.CopyObj(ho_SelectedChannel, out ho_ImageSelectedScaled,
                                1, 1);
                        }
                        else
                        {
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.AppendChannel(ho_ImageSelectedScaled, ho_SelectedChannel,
                                    out ExpTmpOutVar_0);
                                ho_ImageSelectedScaled.Dispose();
                                ho_ImageSelectedScaled = ExpTmpOutVar_0;
                            }
                        }
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_ImageScaled, ho_ImageSelectedScaled, out ExpTmpOutVar_0
                            );
                        ho_ImageScaled.Dispose();
                        ho_ImageScaled = ExpTmpOutVar_0;
                    }
                }
                ho_Image_COPY_INP_TMP.Dispose();
                ho_ImageSelected.Dispose();
                ho_SelectedChannel.Dispose();
                ho_LowerRegion.Dispose();
                ho_UpperRegion.Dispose();
                ho_ImageSelectedScaled.Dispose();

                hv_Max_COPY_INP_TMP.Dispose();
                hv_Min_COPY_INP_TMP.Dispose();
                hv_LowerLimit.Dispose();
                hv_UpperLimit.Dispose();
                hv_Mult.Dispose();
                hv_Add.Dispose();
                hv_NumImages.Dispose();
                hv_ImageIndex.Dispose();
                hv_Channels.Dispose();
                hv_ChannelIndex.Dispose();
                hv_MinGray.Dispose();
                hv_MaxGray.Dispose();
                hv_Range.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Image_COPY_INP_TMP.Dispose();
                ho_ImageSelected.Dispose();
                ho_SelectedChannel.Dispose();
                ho_LowerRegion.Dispose();
                ho_UpperRegion.Dispose();
                ho_ImageSelectedScaled.Dispose();

                hv_Max_COPY_INP_TMP.Dispose();
                hv_Min_COPY_INP_TMP.Dispose();
                hv_LowerLimit.Dispose();
                hv_UpperLimit.Dispose();
                hv_Mult.Dispose();
                hv_Add.Dispose();
                hv_NumImages.Dispose();
                hv_ImageIndex.Dispose();
                hv_Channels.Dispose();
                hv_ChannelIndex.Dispose();
                hv_MinGray.Dispose();
                hv_MaxGray.Dispose();
                hv_Range.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Text
        // Short Description: Set font independent of OS 
        public void set_display_font(HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font,
            HTuple hv_Bold, HTuple hv_Slant)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_OS = new HTuple(), hv_Fonts = new HTuple();
            HTuple hv_Style = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_AvailableFonts = new HTuple(), hv_Fdx = new HTuple();
            HTuple hv_Indices = new HTuple();
            HTuple hv_Font_COPY_INP_TMP = new HTuple(hv_Font);
            HTuple hv_Size_COPY_INP_TMP = new HTuple(hv_Size);

            // Initialize local and output iconic variables 
            try
            {
                //This procedure sets the text font of the current window with
                //the specified attributes.
                //
                //Input parameters:
                //WindowHandle: The graphics window for which the font will be set
                //Size: The font size. If Size=-1, the default of 16 is used.
                //Bold: If set to 'true', a bold font is used
                //Slant: If set to 'true', a slanted font is used
                //
                hv_OS.Dispose();
                HOperatorSet.GetSystem("operating_system", out hv_OS);
                if ((int)((new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
                    new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(-1)))) != 0)
                {
                    hv_Size_COPY_INP_TMP.Dispose();
                    hv_Size_COPY_INP_TMP = 16;
                }
                if ((int)(new HTuple(((hv_OS.TupleSubstr(0, 2))).TupleEqual("Win"))) != 0)
                {
                    //Restore previous behaviour
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Size = ((1.13677 * hv_Size_COPY_INP_TMP)).TupleInt()
                                ;
                            hv_Size_COPY_INP_TMP.Dispose();
                            hv_Size_COPY_INP_TMP = ExpTmpLocalVar_Size;
                        }
                    }
                }
                else
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Size = hv_Size_COPY_INP_TMP.TupleInt()
                                ;
                            hv_Size_COPY_INP_TMP.Dispose();
                            hv_Size_COPY_INP_TMP = ExpTmpLocalVar_Size;
                        }
                    }
                }
                if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("Courier"))) != 0)
                {
                    hv_Fonts.Dispose();
                    hv_Fonts = new HTuple();
                    hv_Fonts[0] = "Courier";
                    hv_Fonts[1] = "Courier 10 Pitch";
                    hv_Fonts[2] = "Courier New";
                    hv_Fonts[3] = "CourierNew";
                    hv_Fonts[4] = "Liberation Mono";
                }
                else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("mono"))) != 0)
                {
                    hv_Fonts.Dispose();
                    hv_Fonts = new HTuple();
                    hv_Fonts[0] = "Consolas";
                    hv_Fonts[1] = "Menlo";
                    hv_Fonts[2] = "Courier";
                    hv_Fonts[3] = "Courier 10 Pitch";
                    hv_Fonts[4] = "FreeMono";
                    hv_Fonts[5] = "Liberation Mono";
                }
                else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("sans"))) != 0)
                {
                    hv_Fonts.Dispose();
                    hv_Fonts = new HTuple();
                    hv_Fonts[0] = "Luxi Sans";
                    hv_Fonts[1] = "DejaVu Sans";
                    hv_Fonts[2] = "FreeSans";
                    hv_Fonts[3] = "Arial";
                    hv_Fonts[4] = "Liberation Sans";
                }
                else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("serif"))) != 0)
                {
                    hv_Fonts.Dispose();
                    hv_Fonts = new HTuple();
                    hv_Fonts[0] = "Times New Roman";
                    hv_Fonts[1] = "Luxi Serif";
                    hv_Fonts[2] = "DejaVu Serif";
                    hv_Fonts[3] = "FreeSerif";
                    hv_Fonts[4] = "Utopia";
                    hv_Fonts[5] = "Liberation Serif";
                }
                else
                {
                    hv_Fonts.Dispose();
                    hv_Fonts = new HTuple(hv_Font_COPY_INP_TMP);
                }
                hv_Style.Dispose();
                hv_Style = "";
                if ((int)(new HTuple(hv_Bold.TupleEqual("true"))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Style = hv_Style + "Bold";
                            hv_Style.Dispose();
                            hv_Style = ExpTmpLocalVar_Style;
                        }
                    }
                }
                else if ((int)(new HTuple(hv_Bold.TupleNotEqual("false"))) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "Wrong value of control parameter Bold";
                    throw new HalconException(hv_Exception);
                }
                if ((int)(new HTuple(hv_Slant.TupleEqual("true"))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Style = hv_Style + "Italic";
                            hv_Style.Dispose();
                            hv_Style = ExpTmpLocalVar_Style;
                        }
                    }
                }
                else if ((int)(new HTuple(hv_Slant.TupleNotEqual("false"))) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "Wrong value of control parameter Slant";
                    throw new HalconException(hv_Exception);
                }
                if ((int)(new HTuple(hv_Style.TupleEqual(""))) != 0)
                {
                    hv_Style.Dispose();
                    hv_Style = "Normal";
                }
                hv_AvailableFonts.Dispose();
                HOperatorSet.QueryFont(hv_WindowHandle, out hv_AvailableFonts);
                hv_Font_COPY_INP_TMP.Dispose();
                hv_Font_COPY_INP_TMP = "";
                for (hv_Fdx = 0; (int)hv_Fdx <= (int)((new HTuple(hv_Fonts.TupleLength())) - 1); hv_Fdx = (int)hv_Fdx + 1)
                {
                    hv_Indices.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Indices = hv_AvailableFonts.TupleFind(
                            hv_Fonts.TupleSelect(hv_Fdx));
                    }
                    if ((int)(new HTuple((new HTuple(hv_Indices.TupleLength())).TupleGreater(
                        0))) != 0)
                    {
                        if ((int)(new HTuple(((hv_Indices.TupleSelect(0))).TupleGreaterEqual(0))) != 0)
                        {
                            hv_Font_COPY_INP_TMP.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Font_COPY_INP_TMP = hv_Fonts.TupleSelect(
                                    hv_Fdx);
                            }
                            break;
                        }
                    }
                }
                if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual(""))) != 0)
                {
                    throw new HalconException("Wrong value of control parameter Font");
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_Font = (((hv_Font_COPY_INP_TMP + "-") + hv_Style) + "-") + hv_Size_COPY_INP_TMP;
                        hv_Font_COPY_INP_TMP.Dispose();
                        hv_Font_COPY_INP_TMP = ExpTmpLocalVar_Font;
                    }
                }
                HOperatorSet.SetFont(hv_WindowHandle, hv_Font_COPY_INP_TMP);

                hv_Font_COPY_INP_TMP.Dispose();
                hv_Size_COPY_INP_TMP.Dispose();
                hv_OS.Dispose();
                hv_Fonts.Dispose();
                hv_Style.Dispose();
                hv_Exception.Dispose();
                hv_AvailableFonts.Dispose();
                hv_Fdx.Dispose();
                hv_Indices.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Font_COPY_INP_TMP.Dispose();
                hv_Size_COPY_INP_TMP.Dispose();
                hv_OS.Dispose();
                hv_Fonts.Dispose();
                hv_Style.Dispose();
                hv_Exception.Dispose();
                hv_AvailableFonts.Dispose();
                hv_Fdx.Dispose();
                hv_Indices.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Time
        // Short Description: Create a formatted string of a time span. 
        public void timespan_string(HTuple hv_TotalSeconds, HTuple hv_Format, out HTuple hv_TimeString)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Seconds = new HTuple(), hv_TotalMinutes = new HTuple();
            HTuple hv_Minutes = new HTuple(), hv_TotalHours = new HTuple();
            HTuple hv_Hours = new HTuple(), hv_Days = new HTuple();
            HTuple hv_TotalSeconds_COPY_INP_TMP = new HTuple(hv_TotalSeconds);

            // Initialize local and output iconic variables 
            hv_TimeString = new HTuple();
            try
            {
                //
                //This procedure creates a readable representation of a time span
                //given the elapsed time in seconds.
                //
                //Ensure that the input is an integer.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_TotalSeconds = hv_TotalSeconds_COPY_INP_TMP.TupleInt()
                            ;
                        hv_TotalSeconds_COPY_INP_TMP.Dispose();
                        hv_TotalSeconds_COPY_INP_TMP = ExpTmpLocalVar_TotalSeconds;
                    }
                }
                //
                hv_Seconds.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Seconds = hv_TotalSeconds_COPY_INP_TMP % 60;
                }
                //
                hv_TotalMinutes.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TotalMinutes = hv_TotalSeconds_COPY_INP_TMP / 60;
                }
                hv_Minutes.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Minutes = hv_TotalMinutes % 60;
                }
                //
                hv_TotalHours.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TotalHours = hv_TotalSeconds_COPY_INP_TMP / 3600;
                }
                hv_Hours.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Hours = hv_TotalHours % 24;
                }
                //
                hv_Days.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Days = hv_TotalSeconds_COPY_INP_TMP / 86400;
                }
                //
                if ((int)(new HTuple(hv_Format.TupleEqual("auto"))) != 0)
                {
                    //Print the highest non-zero unit and all remaining sub-units.
                    if ((int)(new HTuple(hv_Days.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (((((((hv_Days.TupleString(
                                "d")) + "d ") + (hv_Hours.TupleString("d"))) + "h ") + (hv_Minutes.TupleString(
                                "d"))) + "m ") + (hv_Seconds.TupleString("d"))) + "s";
                        }
                    }
                    else if ((int)(new HTuple(hv_Hours.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (((((hv_Hours.TupleString(
                                "d")) + "h ") + (hv_Minutes.TupleString("d"))) + "m ") + (hv_Seconds.TupleString(
                                "d"))) + "s";
                        }
                    }
                    else if ((int)(new HTuple(hv_Minutes.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (((hv_Minutes.TupleString(
                                "d")) + "m ") + (hv_Seconds.TupleString("d"))) + "s";
                        }
                    }
                    else
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (hv_Seconds.TupleString(
                                "d")) + "s";
                        }
                    }
                }
                else if ((int)(new HTuple(hv_Format.TupleEqual("top1"))) != 0)
                {
                    //Print the highest non-zero unit.
                    if ((int)(new HTuple(hv_Days.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (hv_Days.TupleString(
                                "d")) + "d";
                        }
                    }
                    else if ((int)(new HTuple(hv_Hours.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (hv_Hours.TupleString(
                                "d")) + "h";
                        }
                    }
                    else if ((int)(new HTuple(hv_Minutes.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (hv_Minutes.TupleString(
                                "d")) + "m";
                        }
                    }
                    else
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (hv_Seconds.TupleString(
                                "d")) + "s";
                        }
                    }
                }
                else if ((int)(new HTuple(hv_Format.TupleEqual("top2"))) != 0)
                {
                    //Print the highest non-zero unit and the following sub-unit.
                    if ((int)(new HTuple(hv_Days.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (((hv_Days.TupleString(
                                "d")) + "d ") + (hv_Hours.TupleString("d"))) + "h";
                        }
                    }
                    else if ((int)(new HTuple(hv_Hours.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (((hv_Hours.TupleString(
                                "d")) + "h ") + (hv_Minutes.TupleString("d"))) + "m";
                        }
                    }
                    else if ((int)(new HTuple(hv_Minutes.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (((hv_Minutes.TupleString(
                                "d")) + "m ") + (hv_Seconds.TupleString("d"))) + "s";
                        }
                    }
                    else
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (hv_Seconds.TupleString(
                                "d")) + "s";
                        }
                    }
                }
                else if ((int)(new HTuple(hv_Format.TupleEqual("dhms"))) != 0)
                {
                    //Print a Days-Hours-Minutes-Seconds string.
                    hv_TimeString.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TimeString = (((((((hv_Days.TupleString(
                            "d")) + "d ") + (hv_Hours.TupleString("d"))) + "h ") + (hv_Minutes.TupleString(
                            "d"))) + "m ") + (hv_Seconds.TupleString("d"))) + "s";
                    }
                }
                else if ((int)(new HTuple(hv_Format.TupleEqual("hms"))) != 0)
                {
                    //Print a Hours-Minutes-Seconds string, where hours can be >= 24.
                    hv_TimeString.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TimeString = (((((hv_TotalHours.TupleString(
                            "d")) + "h ") + (hv_Minutes.TupleString("d"))) + "m ") + (hv_Seconds.TupleString(
                            "d"))) + "s";
                    }
                }
                else
                {
                    throw new HalconException("Unknown format string.");
                }
                //

                hv_TotalSeconds_COPY_INP_TMP.Dispose();
                hv_Seconds.Dispose();
                hv_TotalMinutes.Dispose();
                hv_Minutes.Dispose();
                hv_TotalHours.Dispose();
                hv_Hours.Dispose();
                hv_Days.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_TotalSeconds_COPY_INP_TMP.Dispose();
                hv_Seconds.Dispose();
                hv_TotalMinutes.Dispose();
                hv_Minutes.Dispose();
                hv_TotalHours.Dispose();
                hv_Hours.Dispose();
                hv_Days.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Tuple / Element Order
        // Short Description: Sort the elements of a tuple randomly. 
        public void tuple_shuffle(HTuple hv_Tuple, out HTuple hv_Shuffled)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShuffleIndices = new HTuple();
            // Initialize local and output iconic variables 
            hv_Shuffled = new HTuple();
            try
            {
                //This procedure sorts the input tuple randomly.
                //
                if ((int)(new HTuple((new HTuple(hv_Tuple.TupleLength())).TupleGreater(0))) != 0)
                {
                    //Create a tuple of random numbers,
                    //sort this tuple, and return the indices
                    //of this sorted tuple.
                    hv_ShuffleIndices.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ShuffleIndices = (HTuple.TupleRand(
                            new HTuple(hv_Tuple.TupleLength()))).TupleSortIndex();
                    }
                    //Assign the elements of Tuple
                    //to these random positions.
                    hv_Shuffled.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Shuffled = hv_Tuple.TupleSelect(
                            hv_ShuffleIndices);
                    }
                }
                else
                {
                    //If the input tuple is empty,
                    //an empty tuple should be returned.
                    hv_Shuffled.Dispose();
                    hv_Shuffled = new HTuple();
                }

                hv_ShuffleIndices.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShuffleIndices.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Update RunningMeasures by evaluating Samples and corresponding Results. 
        public void update_running_evaluation_measures(HTuple hv_Samples, HTuple hv_Results,
            HTuple hv_EvalParams, HTuple hv_RunningMeasures)
        {



            // Local control variables 

            HTuple hv_EvaluationType = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure updates the running measures depending on the evaluation type.
                hv_EvaluationType.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "evaluation_type", out hv_EvaluationType);
                if ((int)(new HTuple(hv_EvaluationType.TupleEqual("anomaly_detection"))) != 0)
                {
                    update_running_image_anomaly_measures(hv_Samples, hv_Results, hv_EvalParams,
                        hv_RunningMeasures);
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("classification"))) != 0)
                {
                    update_running_image_classification_measures(hv_Samples, hv_Results, hv_EvalParams,
                        hv_RunningMeasures);
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("detection"))) != 0)
                {
                    update_running_instance_measures(hv_Samples, hv_Results, hv_EvalParams, hv_RunningMeasures);
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("segmentation"))) != 0)
                {
                    update_running_pixel_measures(hv_Samples, hv_Results, hv_EvalParams, hv_RunningMeasures);
                }
                //

                hv_EvaluationType.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_EvaluationType.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection
        // Short Description: Update running measures for an image anomaly detection evaluation. 
        public void update_running_image_anomaly_measures(HTuple hv_Samples, HTuple hv_Results,
            HTuple hv_EvalParams, HTuple hv_RunningMeasures)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ImageIDs = new HTuple(), hv_AnomalyLabelIDs = new HTuple();
            HTuple hv_AnomalyScores = new HTuple(), hv_SampleIndex = new HTuple();
            HTuple hv_Sample = new HTuple(), hv_ImageID = new HTuple();
            HTuple hv_AnomalyLabelID = new HTuple(), hv_Result = new HTuple();
            HTuple hv_AnomalyScore = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure updates the RunningMeasures for an evaluation for anomaly detection.
                //
                //These measures are stored in the dictionary RunningMeasures and
                //updated by incorporating the Results the model obtained for the Samples.
                //
                //
                //Get image ids.
                hv_ImageIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "image_ids", out hv_ImageIDs);
                //Get anomaly label ids.
                hv_AnomalyLabelIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "anomaly_label_ids", out hv_AnomalyLabelIDs);
                //Get anomaly scores.
                hv_AnomalyScores.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "anomaly_scores", out hv_AnomalyScores);
                //
                //Loop over all samples and update running measures accordingly.
                for (hv_SampleIndex = 0; (int)hv_SampleIndex <= (int)((new HTuple(hv_Samples.TupleLength()
                    )) - 1); hv_SampleIndex = (int)hv_SampleIndex + 1)
                {
                    hv_Sample.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Sample = hv_Samples.TupleSelect(
                            hv_SampleIndex);
                    }
                    hv_ImageID.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "image_id", out hv_ImageID);
                    hv_AnomalyLabelID.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "anomaly_label_id", out hv_AnomalyLabelID);
                    hv_Result.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Result = hv_Results.TupleSelect(
                            hv_SampleIndex);
                    }
                    hv_AnomalyScore.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "anomaly_score", out hv_AnomalyScore);
                    //
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ImageIDs = hv_ImageIDs.TupleConcat(
                                hv_ImageID);
                            hv_ImageIDs.Dispose();
                            hv_ImageIDs = ExpTmpLocalVar_ImageIDs;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_AnomalyLabelIDs = hv_AnomalyLabelIDs.TupleConcat(
                                hv_AnomalyLabelID);
                            hv_AnomalyLabelIDs.Dispose();
                            hv_AnomalyLabelIDs = ExpTmpLocalVar_AnomalyLabelIDs;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_AnomalyScores = hv_AnomalyScores.TupleConcat(
                                hv_AnomalyScore);
                            hv_AnomalyScores.Dispose();
                            hv_AnomalyScores = ExpTmpLocalVar_AnomalyScores;
                        }
                    }
                }
                //
                //Set image ids in running measures.
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_ids", hv_ImageIDs);
                //Set anomaly label ids in running measures.
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "anomaly_label_ids", hv_AnomalyLabelIDs);
                //Set anomaly scores in running measures.
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "anomaly_scores", hv_AnomalyScores);
                //

                hv_ImageIDs.Dispose();
                hv_AnomalyLabelIDs.Dispose();
                hv_AnomalyScores.Dispose();
                hv_SampleIndex.Dispose();
                hv_Sample.Dispose();
                hv_ImageID.Dispose();
                hv_AnomalyLabelID.Dispose();
                hv_Result.Dispose();
                hv_AnomalyScore.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ImageIDs.Dispose();
                hv_AnomalyLabelIDs.Dispose();
                hv_AnomalyScores.Dispose();
                hv_SampleIndex.Dispose();
                hv_Sample.Dispose();
                hv_ImageID.Dispose();
                hv_AnomalyLabelID.Dispose();
                hv_Result.Dispose();
                hv_AnomalyScore.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Update running measures for an image classification evaluation. 
        public void update_running_image_classification_measures(HTuple hv_Samples, HTuple hv_Results,
            HTuple hv_EvalParams, HTuple hv_RunningMeasures)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_RegExpTopKError = new HTuple(), hv_Measures = new HTuple();
            HTuple hv_K = new HTuple(), hv_M = new HTuple(), hv_ComputeTopKError = new HTuple();
            HTuple hv_ImageIDs = new HTuple(), hv_ImageLabelIDs = new HTuple();
            HTuple hv_Top1Prediction = new HTuple(), hv_TopKPredictionDicts = new HTuple();
            HTuple hv_Index = new HTuple(), hv_Sample = new HTuple();
            HTuple hv_ImageID = new HTuple(), hv_ImageLabelID = new HTuple();
            HTuple hv_Result = new HTuple(), hv_PredictedClassIDs = new HTuple();
            HTuple hv_TopKPrediction = new HTuple(), hv_TopKPredictionDict = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure updates the RunningMeasures for an evaluation for classification.
                //
                //To avoid memory, only save first K predictions per sample.
                hv_RegExpTopKError.Dispose();
                hv_RegExpTopKError = "top([0-9]+)_error";
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                hv_K.Dispose();
                hv_K = 1;
                for (hv_M = 0; (int)hv_M <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_M = (int)hv_M + 1)
                {
                    hv_ComputeTopKError.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ComputeTopKError = ((hv_Measures.TupleSelect(
                            hv_M))).TupleRegexpTest(hv_RegExpTopKError);
                    }
                    if ((int)(hv_ComputeTopKError) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_K = hv_K.TupleMax2(
                                    ((((hv_Measures.TupleSelect(hv_M))).TupleRegexpMatch(hv_RegExpTopKError))).TupleNumber()
                                    );
                                hv_K.Dispose();
                                hv_K = ExpTmpLocalVar_K;
                            }
                        }
                    }
                }
                //
                //Extend tuples in RunningMeasures with new results.
                hv_ImageIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "image_ids", out hv_ImageIDs);
                hv_ImageLabelIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "image_label_ids", out hv_ImageLabelIDs);
                hv_Top1Prediction.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "top1_predictions", out hv_Top1Prediction);
                hv_TopKPredictionDicts.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "topk_predictions", out hv_TopKPredictionDicts);
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Samples.TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
                {
                    hv_Sample.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Sample = hv_Samples.TupleSelect(
                            hv_Index);
                    }
                    hv_ImageID.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "image_id", out hv_ImageID);
                    hv_ImageLabelID.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "image_label_id", out hv_ImageLabelID);
                    hv_Result.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Result = hv_Results.TupleSelect(
                            hv_Index);
                    }
                    hv_PredictedClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "classification_class_ids", out hv_PredictedClassIDs);
                    hv_TopKPrediction.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TopKPrediction = hv_PredictedClassIDs.TupleSelectRange(
                            0, hv_K - 1);
                    }
                    hv_TopKPredictionDict.Dispose();
                    HOperatorSet.CreateDict(out hv_TopKPredictionDict);
                    HOperatorSet.SetDictTuple(hv_TopKPredictionDict, "predictions", hv_TopKPrediction);
                    //
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ImageIDs = hv_ImageIDs.TupleConcat(
                                hv_ImageID);
                            hv_ImageIDs.Dispose();
                            hv_ImageIDs = ExpTmpLocalVar_ImageIDs;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ImageLabelIDs = hv_ImageLabelIDs.TupleConcat(
                                hv_ImageLabelID);
                            hv_ImageLabelIDs.Dispose();
                            hv_ImageLabelIDs = ExpTmpLocalVar_ImageLabelIDs;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Top1Prediction = hv_Top1Prediction.TupleConcat(
                                hv_TopKPrediction.TupleSelect(0));
                            hv_Top1Prediction.Dispose();
                            hv_Top1Prediction = ExpTmpLocalVar_Top1Prediction;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_TopKPredictionDicts = hv_TopKPredictionDicts.TupleConcat(
                                hv_TopKPredictionDict);
                            hv_TopKPredictionDicts.Dispose();
                            hv_TopKPredictionDicts = ExpTmpLocalVar_TopKPredictionDicts;
                        }
                    }
                }
                //
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_ids", hv_ImageIDs);
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_label_ids", hv_ImageLabelIDs);
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "top1_predictions", hv_Top1Prediction);
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "topk_predictions", hv_TopKPredictionDicts);
                //

                hv_RegExpTopKError.Dispose();
                hv_Measures.Dispose();
                hv_K.Dispose();
                hv_M.Dispose();
                hv_ComputeTopKError.Dispose();
                hv_ImageIDs.Dispose();
                hv_ImageLabelIDs.Dispose();
                hv_Top1Prediction.Dispose();
                hv_TopKPredictionDicts.Dispose();
                hv_Index.Dispose();
                hv_Sample.Dispose();
                hv_ImageID.Dispose();
                hv_ImageLabelID.Dispose();
                hv_Result.Dispose();
                hv_PredictedClassIDs.Dispose();
                hv_TopKPrediction.Dispose();
                hv_TopKPredictionDict.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_RegExpTopKError.Dispose();
                hv_Measures.Dispose();
                hv_K.Dispose();
                hv_M.Dispose();
                hv_ComputeTopKError.Dispose();
                hv_ImageIDs.Dispose();
                hv_ImageLabelIDs.Dispose();
                hv_Top1Prediction.Dispose();
                hv_TopKPredictionDicts.Dispose();
                hv_Index.Dispose();
                hv_Sample.Dispose();
                hv_ImageID.Dispose();
                hv_ImageLabelID.Dispose();
                hv_Result.Dispose();
                hv_PredictedClassIDs.Dispose();
                hv_TopKPrediction.Dispose();
                hv_TopKPredictionDict.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Update running measures for an instance-based evaluation. 
        public void update_running_instance_measures(HTuple hv_Samples, HTuple hv_Results,
            HTuple hv_EvalParams, HTuple hv_RunningMeasures)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_MaxNumDetections = new HTuple();
            HTuple hv_AreaRanges = new HTuple(), hv_IoUThresholds = new HTuple();
            HTuple hv_InstanceType = new HTuple(), hv_ClassIDs = new HTuple();
            HTuple hv_NumClasses = new HTuple(), hv_Measures = new HTuple();
            HTuple hv_AreaNames = new HTuple(), hv_MinAreas = new HTuple();
            HTuple hv_MaxAreas = new HTuple(), hv_NumAreaRanges = new HTuple();
            HTuple hv_AllocationBlockLength = new HTuple(), hv_DetailedEvaluation = new HTuple();
            HTuple hv_KeyExists = new HTuple(), hv_ClassIDToClassIdx = new HTuple();
            HTuple hv_EvaluateOrientation = new HTuple(), hv_SIdx = new HTuple();
            HTuple hv_CurrentSample = new HTuple(), hv_CurrentResult = new HTuple();
            HTuple hv_GtClassIDs = new HTuple(), hv_ResClassIDs = new HTuple();
            HTuple hv_NumGT = new HTuple(), hv_NumRes = new HTuple();
            HTuple hv_Confidences = new HTuple(), hv_ResSortIndices = new HTuple();
            HTuple hv_GtAreas = new HTuple(), hv_ResAreas = new HTuple();
            HTuple hv_IoUs = new HTuple(), hv_GtPhis = new HTuple();
            HTuple hv_ResPhis = new HTuple(), hv_MDIdx = new HTuple();
            HTuple hv_MaxNum = new HTuple(), hv_MaxNumStr = new HTuple();
            HTuple hv_CurrentRunningMeasures = new HTuple(), hv_AreaIdx = new HTuple();
            HTuple hv_MinArea = new HTuple(), hv_MaxArea = new HTuple();
            HTuple hv_AreaName = new HTuple(), hv_AreaRunningMeasures = new HTuple();
            HTuple hv_GtIgnore = new HTuple(), hv_GtIgnoreInds = new HTuple();
            HTuple hv_PerClassNumGt = new HTuple(), hv_PerClassNumPred = new HTuple();
            HTuple hv_PerClassConfidences = new HTuple(), hv_PerClassNumGtIgnore = new HTuple();
            HTuple hv_SampleHasFP = new HTuple(), hv_SampleHasFN = new HTuple();
            HTuple hv_ClsIdx = new HTuple(), hv_CurrentClassID = new HTuple();
            HTuple hv_CurrentGtIdxs = new HTuple(), hv_CurrentNumGt = new HTuple();
            HTuple hv_CurrentGtIgnore = new HTuple(), hv_CurrentNumGtIgnore = new HTuple();
            HTuple hv_CurrentNumGtNoIgnore = new HTuple(), hv_CurrentResIdxs = new HTuple();
            HTuple hv_CurrentNumRes = new HTuple(), hv_CurrentResAreas = new HTuple();
            HTuple hv_OldNumPred = new HTuple(), hv_CurrentClassConfidences = new HTuple();
            HTuple hv_GtSortIdx = new HTuple(), hv_CurrentResPhis = new HTuple();
            HTuple hv_CurrentGtPhis = new HTuple(), hv_ITIdx = new HTuple();
            HTuple hv_GtMatched = new HTuple(), hv_ResMatched = new HTuple();
            HTuple hv_ResAbsOrientationDiff = new HTuple(), hv_ResIgnore = new HTuple();
            HTuple hv_ResIdx = new HTuple(), hv_CurrentIoU = new HTuple();
            HTuple hv_MatchIdx = new HTuple(), hv_GtIdx = new HTuple();
            HTuple hv_AreaIgnore = new HTuple(), hv_PerIoUMeasure = new HTuple();
            HTuple hv_PerClassMeasures = new HTuple(), hv_CurrentIsTP = new HTuple();
            HTuple hv_CurrentIgnore = new HTuple(), hv_CurrentAbsOrientationDiff = new HTuple();
            HTuple hv_GtMatchedNoIgnore = new HTuple(), hv_ResIsFPClass = new HTuple();
            HTuple hv_ResIsFPBackground = new HTuple(), hv_ResIsFPLocalization = new HTuple();
            HTuple hv_ResIsFPDuplicate = new HTuple(), hv_ResIsFPMultiple = new HTuple();
            HTuple hv_ResAbsOrientationDiffClass = new HTuple(), hv_ResAbsOrientationDiffLocalization = new HTuple();
            HTuple hv_ResAbsOrientationDiffDuplicate = new HTuple();
            HTuple hv_ResAbsOrientationDiffMultiple = new HTuple();
            HTuple hv_FPResIdxsThisClass = new HTuple(), hv_FPResIdxsAllResults = new HTuple();
            HTuple hv_GTIdxsNotToIgnore = new HTuple(), hv_MaxIoU = new HTuple();
            HTuple hv_IoUsWithGT = new HTuple(), hv_MaxIdx = new HTuple();
            HTuple hv_GTClassIDMaxIoU = new HTuple(), hv_AbsOrientationDiff = new HTuple();
            HTuple hv_IsFPClass = new HTuple(), hv_IsFPBackground = new HTuple();
            HTuple hv_IsFPLocalization = new HTuple(), hv_IsFPDuplicate = new HTuple();
            HTuple hv_IsFPMultiple = new HTuple(), hv_AbsOrientationDiffMultiple = new HTuple();
            HTuple hv_AbsOrientationDiffDuplicate = new HTuple(), hv_AbsOrientationDiffLocalization = new HTuple();
            HTuple hv_AbsOrientationDiffClass = new HTuple(), hv_CurrentImageID = new HTuple();
            HTuple hv_ImageIDsWithFN = new HTuple(), hv_NumImageIDsWithFN = new HTuple();
            HTuple hv_ImageIDsWithFP = new HTuple(), hv_NumImageIDsWithFP = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure updates the RunningMeasures
                //for an instance-based evaluation for detection.
                //These measures are stored in the dictionary RunningMeasures and
                //updated by incorporating the Results the model obtained for the Samples.
                //
                dev_update_off();
                //Get the necessary evaluation parameters.
                hv_MaxNumDetections.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "max_num_detections", out hv_MaxNumDetections);
                hv_AreaRanges.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "area_ranges", out hv_AreaRanges);
                hv_IoUThresholds.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "iou_threshold", out hv_IoUThresholds);
                hv_InstanceType.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "instance_type", out hv_InstanceType);
                hv_ClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                hv_NumClasses.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                //
                //Get the area parameters: name, min, and max.
                hv_AreaNames.Dispose();
                HOperatorSet.GetDictTuple(hv_AreaRanges, "name", out hv_AreaNames);
                hv_MinAreas.Dispose();
                HOperatorSet.GetDictTuple(hv_AreaRanges, "min", out hv_MinAreas);
                hv_MaxAreas.Dispose();
                HOperatorSet.GetDictTuple(hv_AreaRanges, "max", out hv_MaxAreas);
                hv_NumAreaRanges.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumAreaRanges = (new HTuple(hv_AreaNames.TupleLength()
                        )) - 1;
                }
                //
                //Get the allocation length for extending tuples.
                hv_AllocationBlockLength.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "allocation_block_length", out hv_AllocationBlockLength);
                //
                //Check if a detailed evaluation should be done.
                hv_DetailedEvaluation.Dispose();
                hv_DetailedEvaluation = 0;
                hv_KeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "detailed_evaluation",
                    out hv_KeyExists);
                if ((int)(hv_KeyExists.TupleSelect(0)) != 0)
                {
                    hv_DetailedEvaluation.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "detailed_evaluation", out hv_DetailedEvaluation);
                }
                if ((int)(hv_DetailedEvaluation) != 0)
                {
                    //We need a mapping from class IDs to class indices
                    hv_ClassIDToClassIdx.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassIDToClassIdx = HTuple.TupleGenConst(
                            (hv_ClassIDs.TupleMax()) + 1, -1);
                    }
                    if (hv_ClassIDToClassIdx == null)
                        hv_ClassIDToClassIdx = new HTuple();
                    hv_ClassIDToClassIdx[hv_ClassIDs] = HTuple.TupleGenSequence(0, hv_NumClasses - 1, 1);
                }
                //
                //Check if the orientation is to be evaluated.
                hv_EvaluateOrientation.Dispose();
                hv_EvaluateOrientation = 0;
                if ((int)((new HTuple(hv_InstanceType.TupleEqual("rectangle2"))).TupleAnd((new HTuple(((hv_Measures.TupleFind(
                    "soap"))).TupleNotEqual(-1))).TupleOr(new HTuple(((hv_Measures.TupleFind(
                    "all"))).TupleNotEqual(-1))))) != 0)
                {
                    hv_EvaluateOrientation.Dispose();
                    hv_EvaluateOrientation = 1;
                }
                //
                //Go through samples.
                for (hv_SIdx = 0; (int)hv_SIdx <= (int)((new HTuple(hv_Samples.TupleLength())) - 1); hv_SIdx = (int)hv_SIdx + 1)
                {
                    //
                    hv_CurrentSample.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentSample = hv_Samples.TupleSelect(
                            hv_SIdx);
                    }
                    hv_CurrentResult.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentResult = hv_Results.TupleSelect(
                            hv_SIdx);
                    }
                    //
                    //* Get classes.
                    hv_GtClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_CurrentSample, "bbox_label_id", out hv_GtClassIDs);
                    hv_ResClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_CurrentResult, "bbox_class_id", out hv_ResClassIDs);
                    hv_NumGT.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumGT = new HTuple(hv_GtClassIDs.TupleLength()
                            );
                    }
                    hv_NumRes.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumRes = new HTuple(hv_ResClassIDs.TupleLength()
                            );
                    }
                    //
                    //* Get result confidences and sort them in descending order.
                    hv_Confidences.Dispose();
                    HOperatorSet.GetDictTuple(hv_CurrentResult, "bbox_confidence", out hv_Confidences);
                    hv_ResSortIndices.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ResSortIndices = ((-hv_Confidences)).TupleSortIndex()
                            ;
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Confidences = hv_Confidences.TupleSelect(
                                hv_ResSortIndices);
                            hv_Confidences.Dispose();
                            hv_Confidences = ExpTmpLocalVar_Confidences;
                        }
                    }
                    //Sort the result class IDs.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResClassIDs = hv_ResClassIDs.TupleSelect(
                                hv_ResSortIndices);
                            hv_ResClassIDs.Dispose();
                            hv_ResClassIDs = ExpTmpLocalVar_ResClassIDs;
                        }
                    }
                    //
                    //Compute the IoUs of the instances.
                    hv_GtAreas.Dispose(); hv_ResAreas.Dispose(); hv_IoUs.Dispose();
                    area_iou(hv_CurrentSample, hv_CurrentResult, hv_InstanceType, hv_ResSortIndices,
                        out hv_GtAreas, out hv_ResAreas, out hv_IoUs);
                    //
                    if ((int)(hv_EvaluateOrientation) != 0)
                    {
                        hv_GtPhis.Dispose();
                        HOperatorSet.GetDictTuple(hv_CurrentSample, "bbox_phi", out hv_GtPhis);
                        hv_ResPhis.Dispose();
                        HOperatorSet.GetDictTuple(hv_CurrentResult, "bbox_phi", out hv_ResPhis);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_ResPhis = hv_ResPhis.TupleSelect(
                                    hv_ResSortIndices);
                                hv_ResPhis.Dispose();
                                hv_ResPhis = ExpTmpLocalVar_ResPhis;
                            }
                        }
                    }
                    //Loop over the maximal number of detections.
                    for (hv_MDIdx = 0; (int)hv_MDIdx <= (int)((new HTuple(hv_MaxNumDetections.TupleLength()
                        )) - 1); hv_MDIdx = (int)hv_MDIdx + 1)
                    {
                        hv_MaxNum.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MaxNum = hv_MaxNumDetections.TupleSelect(
                                hv_MDIdx);
                        }
                        hv_MaxNumStr.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MaxNumStr = "" + hv_MaxNum;
                        }
                        if ((int)(new HTuple(hv_MaxNum.TupleEqual(-1))) != 0)
                        {
                            hv_MaxNumStr.Dispose();
                            hv_MaxNumStr = "all";
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentRunningMeasures.Dispose();
                            HOperatorSet.GetDictTuple(hv_RunningMeasures, "max_num_detections_" + hv_MaxNumStr,
                                out hv_CurrentRunningMeasures);
                        }
                        //
                        //Loop over the area ranges.
                        for (hv_AreaIdx = 0; (int)hv_AreaIdx <= (int)((new HTuple(hv_AreaNames.TupleLength()
                            )) - 1); hv_AreaIdx = (int)hv_AreaIdx + 1)
                        {
                            //
                            //Get information about the current area range.
                            hv_MinArea.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_MinArea = hv_MinAreas.TupleSelect(
                                    hv_AreaIdx);
                            }
                            hv_MaxArea.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_MaxArea = hv_MaxAreas.TupleSelect(
                                    hv_AreaIdx);
                            }
                            hv_AreaName.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_AreaName = hv_AreaNames.TupleSelect(
                                    hv_AreaIdx);
                            }
                            //
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_AreaRunningMeasures.Dispose();
                                HOperatorSet.GetDictTuple(hv_CurrentRunningMeasures, "area_" + hv_AreaName,
                                    out hv_AreaRunningMeasures);
                            }
                            //
                            //Set ignore-flag for ground truth instances.
                            hv_GtIgnore.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_GtIgnore = HTuple.TupleGenConst(
                                    hv_NumGT, 0);
                            }
                            //
                            //Ignore ground truth instances with area outside the area range.
                            if ((int)(new HTuple(hv_NumGT.TupleGreater(0))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_GtIgnoreInds.Dispose();
                                    HOperatorSet.TupleFind(((hv_GtAreas.TupleLessElem(hv_MinArea))).TupleOr(
                                        hv_GtAreas.TupleGreaterElem(hv_MaxArea)), 1, out hv_GtIgnoreInds);
                                }
                                if ((int)(new HTuple(hv_GtIgnoreInds.TupleGreater(-1))) != 0)
                                {
                                    if (hv_GtIgnore == null)
                                        hv_GtIgnore = new HTuple();
                                    hv_GtIgnore[hv_GtIgnoreInds] = 1;
                                }
                            }
                            //
                            hv_PerClassNumGt.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_gt", out hv_PerClassNumGt);
                            hv_PerClassNumPred.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_pred", out hv_PerClassNumPred);
                            hv_PerClassConfidences.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "confidence", out hv_PerClassConfidences);
                            hv_PerClassNumGtIgnore.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_gt_ignore", out hv_PerClassNumGtIgnore);
                            //
                            if ((int)(hv_DetailedEvaluation) != 0)
                            {
                                //Store if a sample has at least one false positive or false negative (for each IoU threshold).
                                hv_SampleHasFP.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_SampleHasFP = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_SampleHasFN.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_SampleHasFN = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                            }
                            //
                            //Loop over the classes.
                            HTuple end_val112 = hv_NumClasses - 1;
                            HTuple step_val112 = 1;
                            for (hv_ClsIdx = 0; hv_ClsIdx.Continue(end_val112, step_val112); hv_ClsIdx = hv_ClsIdx.TupleAdd(step_val112))
                            {
                                hv_CurrentClassID.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentClassID = hv_ClassIDs.TupleSelect(
                                        hv_ClsIdx);
                                }
                                //
                                //Get the ground truth for this class.
                                hv_CurrentGtIdxs.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentGtIdxs = hv_GtClassIDs.TupleFind(
                                        hv_CurrentClassID);
                                }
                                if ((int)(new HTuple(hv_CurrentGtIdxs.TupleEqual(-1))) != 0)
                                {
                                    hv_CurrentGtIdxs.Dispose();
                                    hv_CurrentGtIdxs = new HTuple();
                                }
                                hv_CurrentNumGt.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentNumGt = new HTuple(hv_CurrentGtIdxs.TupleLength()
                                        );
                                }
                                //
                                //Get ground truth ignore for this class.
                                hv_CurrentGtIgnore.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentGtIgnore = hv_GtIgnore.TupleSelect(
                                        hv_CurrentGtIdxs);
                                }
                                if ((int)(new HTuple((new HTuple(hv_CurrentGtIgnore.TupleLength())).TupleEqual(
                                    0))) != 0)
                                {
                                    hv_CurrentNumGtIgnore.Dispose();
                                    hv_CurrentNumGtIgnore = 0;
                                }
                                else
                                {
                                    hv_CurrentNumGtIgnore.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_CurrentNumGtIgnore = hv_CurrentGtIgnore.TupleSum()
                                            ;
                                    }
                                }
                                //
                                //Number of gt for this class and without ignore.
                                hv_CurrentNumGtNoIgnore.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentNumGtNoIgnore = hv_CurrentNumGt - hv_CurrentNumGtIgnore;
                                }
                                //
                                //Get results for this class.
                                hv_CurrentResIdxs.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentResIdxs = hv_ResClassIDs.TupleFind(
                                        hv_CurrentClassID);
                                }
                                if ((int)(new HTuple(hv_CurrentResIdxs.TupleEqual(-1))) != 0)
                                {
                                    hv_CurrentResIdxs.Dispose();
                                    hv_CurrentResIdxs = new HTuple();
                                }
                                hv_CurrentNumRes.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentNumRes = hv_MaxNum.TupleMin2(
                                        new HTuple(hv_CurrentResIdxs.TupleLength()));
                                }
                                //MaxNum -1 corresponds to taking all results.
                                if ((int)(new HTuple(hv_MaxNum.TupleEqual(-1))) != 0)
                                {
                                    hv_CurrentNumRes.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_CurrentNumRes = new HTuple(hv_CurrentResIdxs.TupleLength()
                                            );
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_CurrentResIdxs = hv_CurrentResIdxs.TupleSelectRange(
                                            0, hv_CurrentNumRes - 1);
                                        hv_CurrentResIdxs.Dispose();
                                        hv_CurrentResIdxs = ExpTmpLocalVar_CurrentResIdxs;
                                    }
                                }
                                //
                                //Get areas of the current results.
                                hv_CurrentResAreas.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentResAreas = hv_ResAreas.TupleSelect(
                                        hv_CurrentResIdxs);
                                }
                                //
                                //Update the confidences, num_gt and num_pred for this class.
                                hv_OldNumPred.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_OldNumPred = hv_PerClassNumPred.TupleSelect(
                                        hv_ClsIdx);
                                }
                                if (hv_PerClassNumGt == null)
                                    hv_PerClassNumGt = new HTuple();
                                hv_PerClassNumGt[hv_ClsIdx] = (hv_PerClassNumGt.TupleSelect(hv_ClsIdx)) + hv_CurrentNumGt;
                                if (hv_PerClassNumGtIgnore == null)
                                    hv_PerClassNumGtIgnore = new HTuple();
                                hv_PerClassNumGtIgnore[hv_ClsIdx] = (hv_PerClassNumGtIgnore.TupleSelect(
                                    hv_ClsIdx)) + hv_CurrentNumGtIgnore;
                                if (hv_PerClassNumPred == null)
                                    hv_PerClassNumPred = new HTuple();
                                hv_PerClassNumPred[hv_ClsIdx] = (hv_PerClassNumPred.TupleSelect(hv_ClsIdx)) + hv_CurrentNumRes;
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentClassConfidences.Dispose();
                                    HOperatorSet.GetDictTuple(hv_PerClassConfidences, "class_" + (hv_ClassIDs.TupleSelect(
                                        hv_ClsIdx)), out hv_CurrentClassConfidences);
                                }
                                //Confidences are allocated in blocks of AllocationBlockLength. Therefore, we have to check
                                //if the allocated block is long enough, otherwise allocate a new block.
                                if ((int)(new HTuple(((hv_PerClassNumPred.TupleSelect(hv_ClsIdx))).TupleGreater(
                                    new HTuple(hv_CurrentClassConfidences.TupleLength())))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_CurrentClassConfidences = hv_CurrentClassConfidences.TupleConcat(
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                            hv_CurrentClassConfidences.Dispose();
                                            hv_CurrentClassConfidences = ExpTmpLocalVar_CurrentClassConfidences;
                                        }
                                    }
                                }
                                if (hv_CurrentClassConfidences == null)
                                    hv_CurrentClassConfidences = new HTuple();
                                hv_CurrentClassConfidences[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                    hv_ClsIdx)) - 1, 1)] = hv_Confidences.TupleSelect(hv_CurrentResIdxs);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_PerClassConfidences, "class_" + (hv_ClassIDs.TupleSelect(
                                        hv_ClsIdx)), hv_CurrentClassConfidences);
                                }
                                //
                                //Sort the ground truth: Non-ignored instances first.
                                hv_GtSortIdx.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_GtSortIdx = hv_CurrentGtIgnore.TupleSortIndex()
                                        ;
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_CurrentGtIgnore = hv_CurrentGtIgnore.TupleSelect(
                                            hv_GtSortIdx);
                                        hv_CurrentGtIgnore.Dispose();
                                        hv_CurrentGtIgnore = ExpTmpLocalVar_CurrentGtIgnore;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_CurrentGtIdxs = hv_CurrentGtIdxs.TupleSelect(
                                            hv_GtSortIdx);
                                        hv_CurrentGtIdxs.Dispose();
                                        hv_CurrentGtIdxs = ExpTmpLocalVar_CurrentGtIdxs;
                                    }
                                }
                                //
                                //Get orientations of result and ground truth instances.
                                if ((int)(hv_EvaluateOrientation) != 0)
                                {
                                    hv_CurrentResPhis.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_CurrentResPhis = hv_ResPhis.TupleSelect(
                                            hv_CurrentResIdxs);
                                    }
                                    hv_CurrentGtPhis.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_CurrentGtPhis = hv_GtPhis.TupleSelect(
                                            hv_CurrentGtIdxs);
                                    }
                                }
                                //
                                if ((int)(new HTuple(hv_CurrentNumRes.TupleGreater(0))) != 0)
                                {
                                    //Loop over IoU thresholds.
                                    for (hv_ITIdx = 0; (int)hv_ITIdx <= (int)((new HTuple(hv_IoUThresholds.TupleLength()
                                        )) - 1); hv_ITIdx = (int)hv_ITIdx + 1)
                                    {
                                        //We check which ground truth and
                                        //result instance can be matched.
                                        hv_GtMatched.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_GtMatched = HTuple.TupleGenConst(
                                                hv_CurrentNumGt, 0);
                                        }
                                        hv_ResMatched.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_ResMatched = HTuple.TupleGenConst(
                                                hv_CurrentNumRes, 0);
                                        }
                                        //
                                        if ((int)(hv_EvaluateOrientation) != 0)
                                        {
                                            //Initialize the absolute orientation difference to -1.
                                            hv_ResAbsOrientationDiff.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ResAbsOrientationDiff = HTuple.TupleGenConst(
                                                    hv_CurrentNumRes, -1);
                                            }
                                        }
                                        //Store which detections should be ignored.
                                        hv_ResIgnore.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_ResIgnore = HTuple.TupleGenConst(
                                                hv_CurrentNumRes, 0);
                                        }
                                        HTuple end_val187 = hv_CurrentNumRes - 1;
                                        HTuple step_val187 = 1;
                                        for (hv_ResIdx = 0; hv_ResIdx.Continue(end_val187, step_val187); hv_ResIdx = hv_ResIdx.TupleAdd(step_val187))
                                        {
                                            //Set the currently best achieved IoU to the IoU threshold and
                                            //initialize the matching index.
                                            hv_CurrentIoU.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_CurrentIoU = ((hv_IoUThresholds.TupleSelect(
                                                    hv_ITIdx))).TupleMin2(1 - 1.0e-10);
                                            }
                                            hv_MatchIdx.Dispose();
                                            hv_MatchIdx = -1;
                                            //Loop over ground truth.
                                            HTuple end_val193 = hv_CurrentNumGt - 1;
                                            HTuple step_val193 = 1;
                                            for (hv_GtIdx = 0; hv_GtIdx.Continue(end_val193, step_val193); hv_GtIdx = hv_GtIdx.TupleAdd(step_val193))
                                            {
                                                //Continue if this ground truth has already been matched.
                                                if ((int)(hv_GtMatched.TupleSelect(hv_GtIdx)) != 0)
                                                {
                                                    continue;
                                                }
                                                //Stop if matched with non-ignored ground truth and current ground truth is on ignore.
                                                if ((int)(new HTuple(hv_MatchIdx.TupleGreater(-1))) != 0)
                                                {
                                                    if ((int)((new HTuple(((hv_CurrentGtIgnore.TupleSelect(hv_MatchIdx))).TupleEqual(
                                                        0))).TupleAnd(new HTuple(((hv_CurrentGtIgnore.TupleSelect(
                                                        hv_GtIdx))).TupleEqual(1)))) != 0)
                                                    {
                                                        break;
                                                    }
                                                }
                                                //Continue if IoU is not better than a previous match.
                                                if ((int)(new HTuple(((hv_IoUs.TupleSelect(((hv_CurrentGtIdxs.TupleSelect(
                                                    hv_GtIdx)) * hv_NumRes) + (hv_CurrentResIdxs.TupleSelect(hv_ResIdx))))).TupleLess(
                                                    hv_CurrentIoU))) != 0)
                                                {
                                                    continue;
                                                }
                                                //We got a new best match, store it.
                                                hv_CurrentIoU.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_CurrentIoU = hv_IoUs.TupleSelect(
                                                        ((hv_CurrentGtIdxs.TupleSelect(hv_GtIdx)) * hv_NumRes) + (hv_CurrentResIdxs.TupleSelect(
                                                        hv_ResIdx)));
                                                }
                                                hv_MatchIdx.Dispose();
                                                hv_MatchIdx = new HTuple(hv_GtIdx);
                                            }
                                            //If a match has been made we store it for both ground truth and result.
                                            if ((int)(new HTuple(hv_MatchIdx.TupleNotEqual(-1))) != 0)
                                            {
                                                //In COCO they use the IDs of GT and Res, we just use 1
                                                //to indicate the matching, but don't store which one has been matched.
                                                if (hv_ResMatched == null)
                                                    hv_ResMatched = new HTuple();
                                                hv_ResMatched[hv_ResIdx] = 1;
                                                if (hv_GtMatched == null)
                                                    hv_GtMatched = new HTuple();
                                                hv_GtMatched[hv_MatchIdx] = 1;
                                                if (hv_ResIgnore == null)
                                                    hv_ResIgnore = new HTuple();
                                                hv_ResIgnore[hv_ResIdx] = hv_CurrentGtIgnore.TupleSelect(hv_MatchIdx);
                                                //
                                                if ((int)(hv_EvaluateOrientation) != 0)
                                                {
                                                    //Set the absolute orientation difference.
                                                    if (hv_ResAbsOrientationDiff == null)
                                                        hv_ResAbsOrientationDiff = new HTuple();
                                                    hv_ResAbsOrientationDiff[hv_ResIdx] = (((hv_CurrentResPhis.TupleSelect(
                                                        hv_ResIdx)) - (hv_CurrentGtPhis.TupleSelect(hv_MatchIdx)))).TupleAbs()
                                                        ;
                                                    if ((int)(new HTuple(((hv_ResAbsOrientationDiff.TupleSelect(
                                                        hv_ResIdx))).TupleGreater((new HTuple(180)).TupleRad()
                                                        ))) != 0)
                                                    {
                                                        if (hv_ResAbsOrientationDiff == null)
                                                            hv_ResAbsOrientationDiff = new HTuple();
                                                        hv_ResAbsOrientationDiff[hv_ResIdx] = ((new HTuple(360)).TupleRad()
                                                            ) - (hv_ResAbsOrientationDiff.TupleSelect(hv_ResIdx));
                                                    }
                                                }
                                            }
                                        }
                                        //Ignore the unmatched results that are outside of the current area range.
                                        hv_AreaIgnore.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_AreaIgnore = ((hv_CurrentResAreas.TupleLessElem(
                                                hv_MinArea))).TupleOr(hv_CurrentResAreas.TupleGreaterElem(hv_MaxArea));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_ResIgnore = (new HTuple(((hv_ResMatched.TupleEqualElem(
                                                    -1))).TupleAnd(hv_AreaIgnore.TupleEqualElem(1)))).TupleOr(hv_ResIgnore);
                                                hv_ResIgnore.Dispose();
                                                hv_ResIgnore = ExpTmpLocalVar_ResIgnore;
                                            }
                                        }
                                        //True positives are the matched results.
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_PerIoUMeasure.Dispose();
                                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                                hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUMeasure);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_PerClassMeasures.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "class_" + (hv_ClassIDs.TupleSelect(
                                                hv_ClsIdx)), out hv_PerClassMeasures);
                                        }
                                        hv_CurrentIsTP.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_tp", out hv_CurrentIsTP);
                                        //As for confidences, check if we have to allocate a new block.
                                        if ((int)(new HTuple(((hv_PerClassNumPred.TupleSelect(hv_ClsIdx))).TupleGreater(
                                            new HTuple(hv_CurrentIsTP.TupleLength())))) != 0)
                                        {
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                {
                                                    HTuple
                                                      ExpTmpLocalVar_CurrentIsTP = hv_CurrentIsTP.TupleConcat(
                                                        HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                    hv_CurrentIsTP.Dispose();
                                                    hv_CurrentIsTP = ExpTmpLocalVar_CurrentIsTP;
                                                }
                                            }
                                        }
                                        if (hv_CurrentIsTP == null)
                                            hv_CurrentIsTP = new HTuple();
                                        hv_CurrentIsTP[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                            hv_ClsIdx)) - 1, 1)] = hv_ResMatched;
                                        HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_tp", hv_CurrentIsTP);
                                        //Set the ignored results.
                                        hv_CurrentIgnore.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerClassMeasures, "ignore", out hv_CurrentIgnore);
                                        if ((int)(new HTuple(((hv_PerClassNumPred.TupleSelect(hv_ClsIdx))).TupleGreater(
                                            new HTuple(hv_CurrentIgnore.TupleLength())))) != 0)
                                        {
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                {
                                                    HTuple
                                                      ExpTmpLocalVar_CurrentIgnore = hv_CurrentIgnore.TupleConcat(
                                                        HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                    hv_CurrentIgnore.Dispose();
                                                    hv_CurrentIgnore = ExpTmpLocalVar_CurrentIgnore;
                                                }
                                            }
                                        }
                                        if (hv_CurrentIgnore == null)
                                            hv_CurrentIgnore = new HTuple();
                                        hv_CurrentIgnore[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                            hv_ClsIdx)) - 1, 1)] = hv_ResIgnore;
                                        HOperatorSet.SetDictTuple(hv_PerClassMeasures, "ignore", hv_CurrentIgnore);
                                        //Set the absolute orientation difference.
                                        if ((int)(hv_EvaluateOrientation) != 0)
                                        {
                                            hv_CurrentAbsOrientationDiff.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerClassMeasures, "abs_orientation_diff",
                                                out hv_CurrentAbsOrientationDiff);
                                            if ((int)(new HTuple(((hv_PerClassNumPred.TupleSelect(hv_ClsIdx))).TupleGreater(
                                                new HTuple(hv_CurrentAbsOrientationDiff.TupleLength())))) != 0)
                                            {
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_CurrentAbsOrientationDiff = hv_CurrentAbsOrientationDiff.TupleConcat(
                                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                        hv_CurrentAbsOrientationDiff.Dispose();
                                                        hv_CurrentAbsOrientationDiff = ExpTmpLocalVar_CurrentAbsOrientationDiff;
                                                    }
                                                }
                                            }
                                            if (hv_CurrentAbsOrientationDiff == null)
                                                hv_CurrentAbsOrientationDiff = new HTuple();
                                            hv_CurrentAbsOrientationDiff[HTuple.TupleGenSequence(hv_OldNumPred,
                                                (hv_PerClassNumPred.TupleSelect(hv_ClsIdx)) - 1, 1)] = hv_ResAbsOrientationDiff;
                                            HOperatorSet.SetDictTuple(hv_PerClassMeasures, "abs_orientation_diff",
                                                hv_CurrentAbsOrientationDiff);
                                        }
                                        //
                                        //Beginning of detailed evaluation processing (optional).
                                        //
                                        if ((int)(hv_DetailedEvaluation) != 0)
                                        {
                                            //Check if there have been false negatives.
                                            if ((int)(new HTuple(hv_CurrentNumGtNoIgnore.TupleGreater(0))) != 0)
                                            {
                                                hv_GtMatchedNoIgnore.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_GtMatchedNoIgnore = hv_GtMatched.TupleAnd(
                                                        hv_CurrentGtIgnore.TupleNot());
                                                }
                                                if ((int)(new HTuple(((hv_GtMatchedNoIgnore.TupleSum())).TupleLess(
                                                    hv_CurrentNumGtNoIgnore))) != 0)
                                                {
                                                    if (hv_SampleHasFN == null)
                                                        hv_SampleHasFN = new HTuple();
                                                    hv_SampleHasFN[hv_ITIdx] = 1;
                                                }
                                            }
                                            //
                                            //Initialize the detailed running measures.
                                            hv_ResIsFPClass.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ResIsFPClass = HTuple.TupleGenConst(
                                                    hv_CurrentNumRes, -1);
                                            }
                                            hv_ResIsFPBackground.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ResIsFPBackground = HTuple.TupleGenConst(
                                                    hv_CurrentNumRes, 0);
                                            }
                                            hv_ResIsFPLocalization.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ResIsFPLocalization = HTuple.TupleGenConst(
                                                    hv_CurrentNumRes, 0);
                                            }
                                            hv_ResIsFPDuplicate.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ResIsFPDuplicate = HTuple.TupleGenConst(
                                                    hv_CurrentNumRes, 0);
                                            }
                                            hv_ResIsFPMultiple.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ResIsFPMultiple = HTuple.TupleGenConst(
                                                    hv_CurrentNumRes, 0);
                                            }
                                            //
                                            //Initialize detailed running measures for orientation difference.
                                            if ((int)(hv_EvaluateOrientation) != 0)
                                            {
                                                hv_ResAbsOrientationDiffClass.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_ResAbsOrientationDiffClass = HTuple.TupleGenConst(
                                                        hv_CurrentNumRes, -1);
                                                }
                                                hv_ResAbsOrientationDiffLocalization.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_ResAbsOrientationDiffLocalization = HTuple.TupleGenConst(
                                                        hv_CurrentNumRes, -1);
                                                }
                                                hv_ResAbsOrientationDiffDuplicate.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_ResAbsOrientationDiffDuplicate = HTuple.TupleGenConst(
                                                        hv_CurrentNumRes, -1);
                                                }
                                                hv_ResAbsOrientationDiffMultiple.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_ResAbsOrientationDiffMultiple = HTuple.TupleGenConst(
                                                        hv_CurrentNumRes, -1);
                                                }
                                            }
                                            //Check if there have been false positives.
                                            if ((int)(new HTuple(((hv_ResMatched.TupleSum())).TupleLess(hv_CurrentNumRes))) != 0)
                                            {
                                                if (hv_SampleHasFP == null)
                                                    hv_SampleHasFP = new HTuple();
                                                hv_SampleHasFP[hv_ITIdx] = 1;
                                                //
                                                //For each false positive, find out what was the reason for being false positive:
                                                hv_FPResIdxsThisClass.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_FPResIdxsThisClass = hv_ResMatched.TupleFind(
                                                        0);
                                                }
                                                hv_FPResIdxsAllResults.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_FPResIdxsAllResults = hv_CurrentResIdxs.TupleSelect(
                                                        hv_FPResIdxsThisClass);
                                                }
                                                hv_GTIdxsNotToIgnore.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_GTIdxsNotToIgnore = hv_GtIgnore.TupleFind(
                                                        0);
                                                }
                                                for (hv_ResIdx = 0; (int)hv_ResIdx <= (int)((new HTuple(hv_FPResIdxsThisClass.TupleLength()
                                                    )) - 1); hv_ResIdx = (int)hv_ResIdx + 1)
                                                {
                                                    if ((int)(((hv_ResIgnore.TupleSelect(hv_FPResIdxsThisClass.TupleSelect(
                                                        hv_ResIdx)))).TupleNot()) != 0)
                                                    {
                                                        if ((int)((new HTuple((new HTuple(hv_GTIdxsNotToIgnore.TupleLength()
                                                            )).TupleEqual(0))).TupleOr(new HTuple(hv_GTIdxsNotToIgnore.TupleEqual(
                                                            -1)))) != 0)
                                                        {
                                                            //No GT instances or all GT instances are ignored.
                                                            //Thus, any detection is a background detection
                                                            hv_MaxIoU.Dispose();
                                                            hv_MaxIoU = 0.0;
                                                        }
                                                        else
                                                        {
                                                            //We have GT instances to consider.
                                                            hv_IoUsWithGT.Dispose();
                                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                            {
                                                                hv_IoUsWithGT = hv_IoUs.TupleSelect(
                                                                    (hv_GTIdxsNotToIgnore * hv_NumRes) + (hv_FPResIdxsAllResults.TupleSelect(
                                                                    hv_ResIdx)));
                                                            }
                                                            hv_MaxIoU.Dispose();
                                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                            {
                                                                hv_MaxIoU = hv_IoUsWithGT.TupleMax()
                                                                    ;
                                                            }
                                                            //It is enough to look for the first occurrence because the IoUs to ground truth should be different.
                                                            hv_MaxIdx.Dispose();
                                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                            {
                                                                hv_MaxIdx = hv_IoUsWithGT.TupleFindFirst(
                                                                    hv_MaxIoU);
                                                            }
                                                            hv_GTClassIDMaxIoU.Dispose();
                                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                            {
                                                                hv_GTClassIDMaxIoU = hv_GtClassIDs.TupleSelect(
                                                                    hv_GTIdxsNotToIgnore.TupleSelect(hv_MaxIdx));
                                                            }
                                                        }
                                                        if ((int)(hv_EvaluateOrientation.TupleAnd(new HTuple(hv_MaxIoU.TupleGreater(
                                                            0.0)))) != 0)
                                                        {
                                                            //Calculate the absolute orientation difference to the GT instance with maximal IoU.
                                                            hv_AbsOrientationDiff.Dispose();
                                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                            {
                                                                hv_AbsOrientationDiff = (((hv_ResPhis.TupleSelect(
                                                                    hv_FPResIdxsAllResults.TupleSelect(hv_ResIdx))) - (hv_GtPhis.TupleSelect(
                                                                    hv_GTIdxsNotToIgnore.TupleSelect(hv_MaxIdx))))).TupleAbs()
                                                                    ;
                                                            }
                                                            if ((int)(new HTuple(hv_AbsOrientationDiff.TupleGreater(
                                                                (new HTuple(180)).TupleRad()))) != 0)
                                                            {
                                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                                {
                                                                    {
                                                                        HTuple
                                                                          ExpTmpLocalVar_AbsOrientationDiff = ((new HTuple(360)).TupleRad()
                                                                            ) - hv_AbsOrientationDiff;
                                                                        hv_AbsOrientationDiff.Dispose();
                                                                        hv_AbsOrientationDiff = ExpTmpLocalVar_AbsOrientationDiff;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        //Determine false positive type.
                                                        if ((int)(new HTuple(hv_MaxIoU.TupleEqual(0.0))) != 0)
                                                        {
                                                            //Background detection. This detection does not overlap to any ground truth (that is not ignored).
                                                            if (hv_ResIsFPBackground == null)
                                                                hv_ResIsFPBackground = new HTuple();
                                                            hv_ResIsFPBackground[hv_FPResIdxsThisClass.TupleSelect(
                                                                hv_ResIdx)] = 1;
                                                        }
                                                        else if ((int)((new HTuple(hv_MaxIoU.TupleGreaterEqual(
                                                            hv_IoUThresholds.TupleSelect(hv_ITIdx)))).TupleAnd(
                                                            new HTuple(hv_CurrentClassID.TupleNotEqual(hv_GTClassIDMaxIoU)))) != 0)
                                                        {
                                                            //False class.
                                                            //Note that this does not necessarily mean that this detection
                                                            //would be a true positive if the class was changed. It could still be a duplicate.
                                                            if (hv_ResIsFPClass == null)
                                                                hv_ResIsFPClass = new HTuple();
                                                            hv_ResIsFPClass[hv_FPResIdxsThisClass.TupleSelect(hv_ResIdx)] = hv_ClassIDToClassIdx.TupleSelect(
                                                                hv_GTClassIDMaxIoU);
                                                            //Store the absolute orientation difference.
                                                            if ((int)(hv_EvaluateOrientation) != 0)
                                                            {
                                                                if (hv_ResAbsOrientationDiffClass == null)
                                                                    hv_ResAbsOrientationDiffClass = new HTuple();
                                                                hv_ResAbsOrientationDiffClass[hv_FPResIdxsThisClass.TupleSelect(
                                                                    hv_ResIdx)] = hv_AbsOrientationDiff;
                                                            }
                                                        }
                                                        else if ((int)((new HTuple(hv_MaxIoU.TupleGreaterEqual(
                                                            hv_IoUThresholds.TupleSelect(hv_ITIdx)))).TupleAnd(
                                                            new HTuple(hv_CurrentClassID.TupleEqual(hv_GTClassIDMaxIoU)))) != 0)
                                                        {
                                                            //Duplicate detection. There must exist another detection with a higher confidence with the same ground truth.
                                                            if (hv_ResIsFPDuplicate == null)
                                                                hv_ResIsFPDuplicate = new HTuple();
                                                            hv_ResIsFPDuplicate[hv_FPResIdxsThisClass.TupleSelect(
                                                                hv_ResIdx)] = 1;
                                                            //Store the absolute orientation difference.
                                                            if ((int)(hv_EvaluateOrientation) != 0)
                                                            {
                                                                if (hv_ResAbsOrientationDiffDuplicate == null)
                                                                    hv_ResAbsOrientationDiffDuplicate = new HTuple();
                                                                hv_ResAbsOrientationDiffDuplicate[hv_FPResIdxsThisClass.TupleSelect(
                                                                    hv_ResIdx)] = hv_AbsOrientationDiff;
                                                            }
                                                        }
                                                        else if ((int)((new HTuple(hv_MaxIoU.TupleLess(
                                                            hv_IoUThresholds.TupleSelect(hv_ITIdx)))).TupleAnd(
                                                            new HTuple(hv_CurrentClassID.TupleEqual(hv_GTClassIDMaxIoU)))) != 0)
                                                        {
                                                            //Bad localization. Class is correct, but the IoU is too low.
                                                            if (hv_ResIsFPLocalization == null)
                                                                hv_ResIsFPLocalization = new HTuple();
                                                            hv_ResIsFPLocalization[hv_FPResIdxsThisClass.TupleSelect(
                                                                hv_ResIdx)] = 1;
                                                            //Store the absolute orientation difference.
                                                            if ((int)(hv_EvaluateOrientation) != 0)
                                                            {
                                                                if (hv_ResAbsOrientationDiffLocalization == null)
                                                                    hv_ResAbsOrientationDiffLocalization = new HTuple();
                                                                hv_ResAbsOrientationDiffLocalization[hv_FPResIdxsThisClass.TupleSelect(
                                                                    hv_ResIdx)] = hv_AbsOrientationDiff;
                                                            }
                                                        }
                                                        else if ((int)((new HTuple(hv_MaxIoU.TupleLess(
                                                            hv_IoUThresholds.TupleSelect(hv_ITIdx)))).TupleAnd(
                                                            new HTuple(hv_CurrentClassID.TupleNotEqual(hv_GTClassIDMaxIoU)))) != 0)
                                                        {
                                                            //Wrong class and bad localization.
                                                            if (hv_ResIsFPMultiple == null)
                                                                hv_ResIsFPMultiple = new HTuple();
                                                            hv_ResIsFPMultiple[hv_FPResIdxsThisClass.TupleSelect(
                                                                hv_ResIdx)] = 1;
                                                            //Store the absolute orientation difference.
                                                            if ((int)(hv_EvaluateOrientation) != 0)
                                                            {
                                                                if (hv_ResAbsOrientationDiffMultiple == null)
                                                                    hv_ResAbsOrientationDiffMultiple = new HTuple();
                                                                hv_ResAbsOrientationDiffMultiple[hv_FPResIdxsThisClass.TupleSelect(
                                                                    hv_ResIdx)] = hv_AbsOrientationDiff;
                                                            }
                                                        }
                                                        else
                                                        {
                                                            //This case should never occur.
                                                            throw new HalconException("Fatal error during detailed evaluation.");
                                                        }
                                                    }
                                                }
                                            }
                                            //
                                            //Overwrite the detailed running measures.
                                            hv_IsFPClass.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_fp_class",
                                                out hv_IsFPClass);
                                            hv_IsFPBackground.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_fp_background",
                                                out hv_IsFPBackground);
                                            hv_IsFPLocalization.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_fp_localization",
                                                out hv_IsFPLocalization);
                                            hv_IsFPDuplicate.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_fp_duplicate",
                                                out hv_IsFPDuplicate);
                                            hv_IsFPMultiple.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_fp_multiple",
                                                out hv_IsFPMultiple);
                                            if ((int)(hv_EvaluateOrientation) != 0)
                                            {
                                                hv_AbsOrientationDiffMultiple.Dispose();
                                                HOperatorSet.GetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_multiple",
                                                    out hv_AbsOrientationDiffMultiple);
                                                hv_AbsOrientationDiffDuplicate.Dispose();
                                                HOperatorSet.GetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_duplicate",
                                                    out hv_AbsOrientationDiffDuplicate);
                                                hv_AbsOrientationDiffLocalization.Dispose();
                                                HOperatorSet.GetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_localization",
                                                    out hv_AbsOrientationDiffLocalization);
                                                hv_AbsOrientationDiffClass.Dispose();
                                                HOperatorSet.GetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_class",
                                                    out hv_AbsOrientationDiffClass);
                                            }
                                            //Allocate new blocks if necessary (all have the same length).
                                            if ((int)(new HTuple(((hv_PerClassNumPred.TupleSelect(hv_ClsIdx))).TupleGreater(
                                                new HTuple(hv_IsFPClass.TupleLength())))) != 0)
                                            {
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_IsFPClass = hv_IsFPClass.TupleConcat(
                                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                        hv_IsFPClass.Dispose();
                                                        hv_IsFPClass = ExpTmpLocalVar_IsFPClass;
                                                    }
                                                }
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_IsFPBackground = hv_IsFPBackground.TupleConcat(
                                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                        hv_IsFPBackground.Dispose();
                                                        hv_IsFPBackground = ExpTmpLocalVar_IsFPBackground;
                                                    }
                                                }
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_IsFPLocalization = hv_IsFPLocalization.TupleConcat(
                                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                        hv_IsFPLocalization.Dispose();
                                                        hv_IsFPLocalization = ExpTmpLocalVar_IsFPLocalization;
                                                    }
                                                }
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_IsFPDuplicate = hv_IsFPDuplicate.TupleConcat(
                                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                        hv_IsFPDuplicate.Dispose();
                                                        hv_IsFPDuplicate = ExpTmpLocalVar_IsFPDuplicate;
                                                    }
                                                }
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_IsFPMultiple = hv_IsFPMultiple.TupleConcat(
                                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                        hv_IsFPMultiple.Dispose();
                                                        hv_IsFPMultiple = ExpTmpLocalVar_IsFPMultiple;
                                                    }
                                                }
                                                if ((int)(hv_EvaluateOrientation) != 0)
                                                {
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        {
                                                            HTuple
                                                              ExpTmpLocalVar_AbsOrientationDiffMultiple = hv_AbsOrientationDiffMultiple.TupleConcat(
                                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                            hv_AbsOrientationDiffMultiple.Dispose();
                                                            hv_AbsOrientationDiffMultiple = ExpTmpLocalVar_AbsOrientationDiffMultiple;
                                                        }
                                                    }
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        {
                                                            HTuple
                                                              ExpTmpLocalVar_AbsOrientationDiffDuplicate = hv_AbsOrientationDiffDuplicate.TupleConcat(
                                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                            hv_AbsOrientationDiffDuplicate.Dispose();
                                                            hv_AbsOrientationDiffDuplicate = ExpTmpLocalVar_AbsOrientationDiffDuplicate;
                                                        }
                                                    }
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        {
                                                            HTuple
                                                              ExpTmpLocalVar_AbsOrientationDiffLocalization = hv_AbsOrientationDiffLocalization.TupleConcat(
                                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                            hv_AbsOrientationDiffLocalization.Dispose();
                                                            hv_AbsOrientationDiffLocalization = ExpTmpLocalVar_AbsOrientationDiffLocalization;
                                                        }
                                                    }
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        {
                                                            HTuple
                                                              ExpTmpLocalVar_AbsOrientationDiffClass = hv_AbsOrientationDiffClass.TupleConcat(
                                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                            hv_AbsOrientationDiffClass.Dispose();
                                                            hv_AbsOrientationDiffClass = ExpTmpLocalVar_AbsOrientationDiffClass;
                                                        }
                                                    }
                                                }
                                            }
                                            if (hv_IsFPClass == null)
                                                hv_IsFPClass = new HTuple();
                                            hv_IsFPClass[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                                hv_ClsIdx)) - 1, 1)] = hv_ResIsFPClass;
                                            if (hv_IsFPBackground == null)
                                                hv_IsFPBackground = new HTuple();
                                            hv_IsFPBackground[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                                hv_ClsIdx)) - 1, 1)] = hv_ResIsFPBackground;
                                            if (hv_IsFPLocalization == null)
                                                hv_IsFPLocalization = new HTuple();
                                            hv_IsFPLocalization[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                                hv_ClsIdx)) - 1, 1)] = hv_ResIsFPLocalization;
                                            if (hv_IsFPDuplicate == null)
                                                hv_IsFPDuplicate = new HTuple();
                                            hv_IsFPDuplicate[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                                hv_ClsIdx)) - 1, 1)] = hv_ResIsFPDuplicate;
                                            if (hv_IsFPMultiple == null)
                                                hv_IsFPMultiple = new HTuple();
                                            hv_IsFPMultiple[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                                hv_ClsIdx)) - 1, 1)] = hv_ResIsFPMultiple;
                                            if ((int)(hv_EvaluateOrientation) != 0)
                                            {
                                                if (hv_AbsOrientationDiffMultiple == null)
                                                    hv_AbsOrientationDiffMultiple = new HTuple();
                                                hv_AbsOrientationDiffMultiple[HTuple.TupleGenSequence(hv_OldNumPred,
                                                    (hv_PerClassNumPred.TupleSelect(hv_ClsIdx)) - 1, 1)] = hv_ResAbsOrientationDiffMultiple;
                                                if (hv_AbsOrientationDiffDuplicate == null)
                                                    hv_AbsOrientationDiffDuplicate = new HTuple();
                                                hv_AbsOrientationDiffDuplicate[HTuple.TupleGenSequence(hv_OldNumPred,
                                                    (hv_PerClassNumPred.TupleSelect(hv_ClsIdx)) - 1, 1)] = hv_ResAbsOrientationDiffDuplicate;
                                                if (hv_AbsOrientationDiffLocalization == null)
                                                    hv_AbsOrientationDiffLocalization = new HTuple();
                                                hv_AbsOrientationDiffLocalization[HTuple.TupleGenSequence(hv_OldNumPred,
                                                    (hv_PerClassNumPred.TupleSelect(hv_ClsIdx)) - 1, 1)] = hv_ResAbsOrientationDiffLocalization;
                                                if (hv_AbsOrientationDiffClass == null)
                                                    hv_AbsOrientationDiffClass = new HTuple();
                                                hv_AbsOrientationDiffClass[HTuple.TupleGenSequence(hv_OldNumPred,
                                                    (hv_PerClassNumPred.TupleSelect(hv_ClsIdx)) - 1, 1)] = hv_ResAbsOrientationDiffClass;
                                            }
                                            HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_fp_class",
                                                hv_IsFPClass);
                                            HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_fp_background",
                                                hv_IsFPBackground);
                                            HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_fp_localization",
                                                hv_IsFPLocalization);
                                            HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_fp_duplicate",
                                                hv_IsFPDuplicate);
                                            HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_fp_multiple",
                                                hv_IsFPMultiple);
                                            if ((int)(hv_EvaluateOrientation) != 0)
                                            {
                                                HOperatorSet.SetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_multiple",
                                                    hv_AbsOrientationDiffMultiple);
                                                HOperatorSet.SetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_duplicate",
                                                    hv_AbsOrientationDiffDuplicate);
                                                HOperatorSet.SetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_localization",
                                                    hv_AbsOrientationDiffLocalization);
                                                HOperatorSet.SetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_class",
                                                    hv_AbsOrientationDiffClass);
                                            }
                                        }
                                        //
                                        //End of detailed evaluation processing.
                                        //
                                    }
                                }
                                else
                                {
                                    if ((int)(hv_DetailedEvaluation.TupleAnd(new HTuple(hv_CurrentNumGtNoIgnore.TupleGreater(
                                        0)))) != 0)
                                    {
                                        //There are false negatives for this class.
                                        //Loop over IoU thresholds.
                                        for (hv_ITIdx = 0; (int)hv_ITIdx <= (int)((new HTuple(hv_IoUThresholds.TupleLength()
                                            )) - 1); hv_ITIdx = (int)hv_ITIdx + 1)
                                        {
                                            if (hv_SampleHasFN == null)
                                                hv_SampleHasFN = new HTuple();
                                            hv_SampleHasFN[hv_ITIdx] = 1;
                                        }
                                    }
                                }
                            }
                            //Update the confidences, num_gt and num_pred.
                            HOperatorSet.SetDictTuple(hv_AreaRunningMeasures, "num_gt", hv_PerClassNumGt);
                            HOperatorSet.SetDictTuple(hv_AreaRunningMeasures, "num_pred", hv_PerClassNumPred);
                            HOperatorSet.SetDictTuple(hv_AreaRunningMeasures, "confidence", hv_PerClassConfidences);
                            HOperatorSet.SetDictTuple(hv_AreaRunningMeasures, "num_gt_ignore", hv_PerClassNumGtIgnore);
                            //
                            if ((int)(hv_DetailedEvaluation) != 0)
                            {
                                //Set values that are calculated over all classes (for each IoU threshold).
                                for (hv_ITIdx = 0; (int)hv_ITIdx <= (int)((new HTuple(hv_IoUThresholds.TupleLength()
                                    )) - 1); hv_ITIdx = (int)hv_ITIdx + 1)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUMeasure.Dispose();
                                        HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                            hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUMeasure);
                                    }
                                    //Set image IDs with false negatives
                                    if ((int)(hv_SampleHasFN.TupleSelect(hv_ITIdx)) != 0)
                                    {
                                        hv_CurrentImageID.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentSample, "image_id", out hv_CurrentImageID);
                                        hv_ImageIDsWithFN.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_negatives",
                                            out hv_ImageIDsWithFN);
                                        hv_NumImageIDsWithFN.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_negatives",
                                            out hv_NumImageIDsWithFN);
                                        //Allocate a new block if necessary.
                                        if ((int)(new HTuple(((hv_NumImageIDsWithFN + 1)).TupleGreater(new HTuple(hv_ImageIDsWithFN.TupleLength()
                                            )))) != 0)
                                        {
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                {
                                                    HTuple
                                                      ExpTmpLocalVar_ImageIDsWithFN = hv_ImageIDsWithFN.TupleConcat(
                                                        HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                    hv_ImageIDsWithFN.Dispose();
                                                    hv_ImageIDsWithFN = ExpTmpLocalVar_ImageIDsWithFN;
                                                }
                                            }
                                        }
                                        if (hv_ImageIDsWithFN == null)
                                            hv_ImageIDsWithFN = new HTuple();
                                        hv_ImageIDsWithFN[hv_NumImageIDsWithFN] = hv_CurrentImageID;
                                        HOperatorSet.SetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_negatives",
                                            hv_ImageIDsWithFN);
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_negatives",
                                                hv_NumImageIDsWithFN + 1);
                                        }
                                    }
                                    if ((int)(hv_SampleHasFP.TupleSelect(hv_ITIdx)) != 0)
                                    {
                                        hv_CurrentImageID.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentSample, "image_id", out hv_CurrentImageID);
                                        hv_ImageIDsWithFP.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_positives",
                                            out hv_ImageIDsWithFP);
                                        hv_NumImageIDsWithFP.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_positives",
                                            out hv_NumImageIDsWithFP);
                                        //Allocate a new block if necessary.
                                        if ((int)(new HTuple(((hv_NumImageIDsWithFP + 1)).TupleGreater(new HTuple(hv_ImageIDsWithFP.TupleLength()
                                            )))) != 0)
                                        {
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                {
                                                    HTuple
                                                      ExpTmpLocalVar_ImageIDsWithFP = hv_ImageIDsWithFP.TupleConcat(
                                                        HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                    hv_ImageIDsWithFP.Dispose();
                                                    hv_ImageIDsWithFP = ExpTmpLocalVar_ImageIDsWithFP;
                                                }
                                            }
                                        }
                                        if (hv_ImageIDsWithFP == null)
                                            hv_ImageIDsWithFP = new HTuple();
                                        hv_ImageIDsWithFP[hv_NumImageIDsWithFP] = hv_CurrentImageID;
                                        HOperatorSet.SetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_positives",
                                            hv_ImageIDsWithFP);
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_positives",
                                                hv_NumImageIDsWithFP + 1);
                                        }
                                    }
                                }
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_CurrentRunningMeasures, "area_" + hv_AreaName,
                                hv_AreaRunningMeasures);
                        }
                    }
                }
                //

                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_IoUThresholds.Dispose();
                hv_InstanceType.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClasses.Dispose();
                hv_Measures.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_NumAreaRanges.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_KeyExists.Dispose();
                hv_ClassIDToClassIdx.Dispose();
                hv_EvaluateOrientation.Dispose();
                hv_SIdx.Dispose();
                hv_CurrentSample.Dispose();
                hv_CurrentResult.Dispose();
                hv_GtClassIDs.Dispose();
                hv_ResClassIDs.Dispose();
                hv_NumGT.Dispose();
                hv_NumRes.Dispose();
                hv_Confidences.Dispose();
                hv_ResSortIndices.Dispose();
                hv_GtAreas.Dispose();
                hv_ResAreas.Dispose();
                hv_IoUs.Dispose();
                hv_GtPhis.Dispose();
                hv_ResPhis.Dispose();
                hv_MDIdx.Dispose();
                hv_MaxNum.Dispose();
                hv_MaxNumStr.Dispose();
                hv_CurrentRunningMeasures.Dispose();
                hv_AreaIdx.Dispose();
                hv_MinArea.Dispose();
                hv_MaxArea.Dispose();
                hv_AreaName.Dispose();
                hv_AreaRunningMeasures.Dispose();
                hv_GtIgnore.Dispose();
                hv_GtIgnoreInds.Dispose();
                hv_PerClassNumGt.Dispose();
                hv_PerClassNumPred.Dispose();
                hv_PerClassConfidences.Dispose();
                hv_PerClassNumGtIgnore.Dispose();
                hv_SampleHasFP.Dispose();
                hv_SampleHasFN.Dispose();
                hv_ClsIdx.Dispose();
                hv_CurrentClassID.Dispose();
                hv_CurrentGtIdxs.Dispose();
                hv_CurrentNumGt.Dispose();
                hv_CurrentGtIgnore.Dispose();
                hv_CurrentNumGtIgnore.Dispose();
                hv_CurrentNumGtNoIgnore.Dispose();
                hv_CurrentResIdxs.Dispose();
                hv_CurrentNumRes.Dispose();
                hv_CurrentResAreas.Dispose();
                hv_OldNumPred.Dispose();
                hv_CurrentClassConfidences.Dispose();
                hv_GtSortIdx.Dispose();
                hv_CurrentResPhis.Dispose();
                hv_CurrentGtPhis.Dispose();
                hv_ITIdx.Dispose();
                hv_GtMatched.Dispose();
                hv_ResMatched.Dispose();
                hv_ResAbsOrientationDiff.Dispose();
                hv_ResIgnore.Dispose();
                hv_ResIdx.Dispose();
                hv_CurrentIoU.Dispose();
                hv_MatchIdx.Dispose();
                hv_GtIdx.Dispose();
                hv_AreaIgnore.Dispose();
                hv_PerIoUMeasure.Dispose();
                hv_PerClassMeasures.Dispose();
                hv_CurrentIsTP.Dispose();
                hv_CurrentIgnore.Dispose();
                hv_CurrentAbsOrientationDiff.Dispose();
                hv_GtMatchedNoIgnore.Dispose();
                hv_ResIsFPClass.Dispose();
                hv_ResIsFPBackground.Dispose();
                hv_ResIsFPLocalization.Dispose();
                hv_ResIsFPDuplicate.Dispose();
                hv_ResIsFPMultiple.Dispose();
                hv_ResAbsOrientationDiffClass.Dispose();
                hv_ResAbsOrientationDiffLocalization.Dispose();
                hv_ResAbsOrientationDiffDuplicate.Dispose();
                hv_ResAbsOrientationDiffMultiple.Dispose();
                hv_FPResIdxsThisClass.Dispose();
                hv_FPResIdxsAllResults.Dispose();
                hv_GTIdxsNotToIgnore.Dispose();
                hv_MaxIoU.Dispose();
                hv_IoUsWithGT.Dispose();
                hv_MaxIdx.Dispose();
                hv_GTClassIDMaxIoU.Dispose();
                hv_AbsOrientationDiff.Dispose();
                hv_IsFPClass.Dispose();
                hv_IsFPBackground.Dispose();
                hv_IsFPLocalization.Dispose();
                hv_IsFPDuplicate.Dispose();
                hv_IsFPMultiple.Dispose();
                hv_AbsOrientationDiffMultiple.Dispose();
                hv_AbsOrientationDiffDuplicate.Dispose();
                hv_AbsOrientationDiffLocalization.Dispose();
                hv_AbsOrientationDiffClass.Dispose();
                hv_CurrentImageID.Dispose();
                hv_ImageIDsWithFN.Dispose();
                hv_NumImageIDsWithFN.Dispose();
                hv_ImageIDsWithFP.Dispose();
                hv_NumImageIDsWithFP.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_IoUThresholds.Dispose();
                hv_InstanceType.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClasses.Dispose();
                hv_Measures.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_NumAreaRanges.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_KeyExists.Dispose();
                hv_ClassIDToClassIdx.Dispose();
                hv_EvaluateOrientation.Dispose();
                hv_SIdx.Dispose();
                hv_CurrentSample.Dispose();
                hv_CurrentResult.Dispose();
                hv_GtClassIDs.Dispose();
                hv_ResClassIDs.Dispose();
                hv_NumGT.Dispose();
                hv_NumRes.Dispose();
                hv_Confidences.Dispose();
                hv_ResSortIndices.Dispose();
                hv_GtAreas.Dispose();
                hv_ResAreas.Dispose();
                hv_IoUs.Dispose();
                hv_GtPhis.Dispose();
                hv_ResPhis.Dispose();
                hv_MDIdx.Dispose();
                hv_MaxNum.Dispose();
                hv_MaxNumStr.Dispose();
                hv_CurrentRunningMeasures.Dispose();
                hv_AreaIdx.Dispose();
                hv_MinArea.Dispose();
                hv_MaxArea.Dispose();
                hv_AreaName.Dispose();
                hv_AreaRunningMeasures.Dispose();
                hv_GtIgnore.Dispose();
                hv_GtIgnoreInds.Dispose();
                hv_PerClassNumGt.Dispose();
                hv_PerClassNumPred.Dispose();
                hv_PerClassConfidences.Dispose();
                hv_PerClassNumGtIgnore.Dispose();
                hv_SampleHasFP.Dispose();
                hv_SampleHasFN.Dispose();
                hv_ClsIdx.Dispose();
                hv_CurrentClassID.Dispose();
                hv_CurrentGtIdxs.Dispose();
                hv_CurrentNumGt.Dispose();
                hv_CurrentGtIgnore.Dispose();
                hv_CurrentNumGtIgnore.Dispose();
                hv_CurrentNumGtNoIgnore.Dispose();
                hv_CurrentResIdxs.Dispose();
                hv_CurrentNumRes.Dispose();
                hv_CurrentResAreas.Dispose();
                hv_OldNumPred.Dispose();
                hv_CurrentClassConfidences.Dispose();
                hv_GtSortIdx.Dispose();
                hv_CurrentResPhis.Dispose();
                hv_CurrentGtPhis.Dispose();
                hv_ITIdx.Dispose();
                hv_GtMatched.Dispose();
                hv_ResMatched.Dispose();
                hv_ResAbsOrientationDiff.Dispose();
                hv_ResIgnore.Dispose();
                hv_ResIdx.Dispose();
                hv_CurrentIoU.Dispose();
                hv_MatchIdx.Dispose();
                hv_GtIdx.Dispose();
                hv_AreaIgnore.Dispose();
                hv_PerIoUMeasure.Dispose();
                hv_PerClassMeasures.Dispose();
                hv_CurrentIsTP.Dispose();
                hv_CurrentIgnore.Dispose();
                hv_CurrentAbsOrientationDiff.Dispose();
                hv_GtMatchedNoIgnore.Dispose();
                hv_ResIsFPClass.Dispose();
                hv_ResIsFPBackground.Dispose();
                hv_ResIsFPLocalization.Dispose();
                hv_ResIsFPDuplicate.Dispose();
                hv_ResIsFPMultiple.Dispose();
                hv_ResAbsOrientationDiffClass.Dispose();
                hv_ResAbsOrientationDiffLocalization.Dispose();
                hv_ResAbsOrientationDiffDuplicate.Dispose();
                hv_ResAbsOrientationDiffMultiple.Dispose();
                hv_FPResIdxsThisClass.Dispose();
                hv_FPResIdxsAllResults.Dispose();
                hv_GTIdxsNotToIgnore.Dispose();
                hv_MaxIoU.Dispose();
                hv_IoUsWithGT.Dispose();
                hv_MaxIdx.Dispose();
                hv_GTClassIDMaxIoU.Dispose();
                hv_AbsOrientationDiff.Dispose();
                hv_IsFPClass.Dispose();
                hv_IsFPBackground.Dispose();
                hv_IsFPLocalization.Dispose();
                hv_IsFPDuplicate.Dispose();
                hv_IsFPMultiple.Dispose();
                hv_AbsOrientationDiffMultiple.Dispose();
                hv_AbsOrientationDiffDuplicate.Dispose();
                hv_AbsOrientationDiffLocalization.Dispose();
                hv_AbsOrientationDiffClass.Dispose();
                hv_CurrentImageID.Dispose();
                hv_ImageIDsWithFN.Dispose();
                hv_NumImageIDsWithFN.Dispose();
                hv_ImageIDsWithFP.Dispose();
                hv_NumImageIDsWithFP.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Update running measures for a pixel-based evaluation. 
        public void update_running_pixel_measures(HTuple hv_Samples, HTuple hv_Results,
            HTuple hv_EvalParams, HTuple hv_RunningMeasures)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Annot = null, ho_Result = null, ho_ClsIgnore = null;
            HObject ho_ClsIgnoreTmp = null, ho_ClsAnnot = null, ho_ClsResult = null;
            HObject ho_TPReg = null, ho_FPReg = null, ho_FNReg = null;

            // Local control variables 

            HTuple hv_ClassIDs = new HTuple(), hv_IgnoreClassIDs = new HTuple();
            HTuple hv_Measures = new HTuple(), hv_CalcConfMatrix = new HTuple();
            HTuple hv_NumClasses = new HTuple(), hv_MaxId = new HTuple();
            HTuple hv_ConfMatrix = new HTuple(), hv_MapClassIDs = new HTuple();
            HTuple hv_ClsIdToClsIdx = new HTuple(), hv_TP = new HTuple();
            HTuple hv_FP = new HTuple(), hv_FN = new HTuple(), hv_SampleIndex = new HTuple();
            HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
            HTuple hv_AnnotVals = new HTuple(), hv_ResultVals = new HTuple();
            HTuple hv_ConfTuple = new HTuple(), hv_ConfHist = new HTuple();
            HTuple hv_BinSize = new HTuple(), hv_ConfMatrixTmp = new HTuple();
            HTuple hv_IgnoreIndex = new HTuple(), hv_ClsIndex = new HTuple();
            HTuple hv_ClsId = new HTuple(), hv_ClsTP = new HTuple();
            HTuple hv_ClsFP = new HTuple(), hv_ClsFN = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Annot);
            HOperatorSet.GenEmptyObj(out ho_Result);
            HOperatorSet.GenEmptyObj(out ho_ClsIgnore);
            HOperatorSet.GenEmptyObj(out ho_ClsIgnoreTmp);
            HOperatorSet.GenEmptyObj(out ho_ClsAnnot);
            HOperatorSet.GenEmptyObj(out ho_ClsResult);
            HOperatorSet.GenEmptyObj(out ho_TPReg);
            HOperatorSet.GenEmptyObj(out ho_FPReg);
            HOperatorSet.GenEmptyObj(out ho_FNReg);
            try
            {
                //
                //This procedure updates the RunningMeasures
                //for a pixel-based evaluation for segmentation.
                //These measures are stored in the dictionary RunningMeasures and
                //updated by incorporating the Results the model obtained for the Samples.
                //
                //Get the class IDs.
                hv_ClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                //Get the ignore class IDs.
                hv_IgnoreClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "ignore_class_ids", out hv_IgnoreClassIDs);
                //Check if we need to compute/update the confusion matrix.
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                hv_CalcConfMatrix.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_CalcConfMatrix = (new HTuple(((hv_Measures.TupleFind(
                        "pixel_confusion_matrix"))).TupleGreater(-1))).TupleOr(new HTuple(((hv_Measures.TupleFind(
                        "all"))).TupleGreater(-1)));
                }
                //Get the number of classes.
                hv_NumClasses.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
                //Get the maximum class ID plus a possible ignore-class.
                hv_MaxId.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_MaxId = (hv_ClassIDs.TupleMax()
                        ) + (new HTuple((new HTuple(hv_IgnoreClassIDs.TupleLength())).TupleGreater(
                        0)));
                }
                //
                if ((int)(hv_CalcConfMatrix) != 0)
                {
                    //Get the current confusion matrix.
                    hv_ConfMatrix.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "pixel_confusion_matrix", out hv_ConfMatrix);
                    //Check if we need to map the class IDs.
                    hv_MapClassIDs.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "class_id_mapping",
                        out hv_MapClassIDs);
                    if ((int)(hv_MapClassIDs) != 0)
                    {
                        hv_ClsIdToClsIdx.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "class_id_mapping", out hv_ClsIdToClsIdx);
                        hv_NumClasses.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_NumClasses = (hv_ClsIdToClsIdx.TupleMax()
                                ) + 1;
                        }
                    }
                }
                else
                {
                    //Get the tuples for TP/FP/FN
                    hv_TP.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "tp", out hv_TP);
                    hv_FP.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "fp", out hv_FP);
                    hv_FN.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "fn", out hv_FN);
                }
                //
                //Loop over images, i.e. sample dicts.
                for (hv_SampleIndex = 0; (int)hv_SampleIndex <= (int)((new HTuple(hv_Samples.TupleLength()
                    )) - 1); hv_SampleIndex = (int)hv_SampleIndex + 1)
                {
                    //Get annotation.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_Annot.Dispose();
                        HOperatorSet.GetDictObject(out ho_Annot, hv_Samples.TupleSelect(hv_SampleIndex),
                            "segmentation_image");
                    }
                    //Get result.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_Result.Dispose();
                        HOperatorSet.GetDictObject(out ho_Result, hv_Results.TupleSelect(hv_SampleIndex),
                            "segmentation_image");
                    }
                    //
                    //Update the measures.
                    if ((int)(hv_CalcConfMatrix) != 0)
                    {
                        //Get the ground truth and predicted class IDs of all pixels.
                        hv_Rows.Dispose(); hv_Columns.Dispose();
                        HOperatorSet.GetRegionPoints(ho_Annot, out hv_Rows, out hv_Columns);
                        hv_AnnotVals.Dispose();
                        HOperatorSet.GetGrayval(ho_Annot, hv_Rows, hv_Columns, out hv_AnnotVals);
                        hv_ResultVals.Dispose();
                        HOperatorSet.GetGrayval(ho_Result, hv_Rows, hv_Columns, out hv_ResultVals);
                        //Map the class IDs to class indices.
                        if ((int)(hv_MapClassIDs) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_AnnotVals = hv_ClsIdToClsIdx.TupleSelect(
                                        hv_AnnotVals);
                                    hv_AnnotVals.Dispose();
                                    hv_AnnotVals = ExpTmpLocalVar_AnnotVals;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ResultVals = hv_ClsIdToClsIdx.TupleSelect(
                                        hv_ResultVals);
                                    hv_ResultVals.Dispose();
                                    hv_ResultVals = ExpTmpLocalVar_ResultVals;
                                }
                            }
                        }
                        //The ground truth and predicted IDs are accumulated
                        //such that each confusion pair (class_i <-> class_j) gets a unique value.
                        hv_ConfTuple.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ConfTuple = (hv_NumClasses * hv_AnnotVals) + hv_ResultVals;
                        }
                        //Compute the histogram of this confusion tuple.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ConfHist.Dispose(); hv_BinSize.Dispose();
                            HOperatorSet.TupleHistoRange(hv_ConfTuple, 0, (hv_NumClasses * hv_NumClasses) - 1,
                                hv_NumClasses * hv_NumClasses, out hv_ConfHist, out hv_BinSize);
                        }
                        hv_ConfMatrixTmp.Dispose();
                        HOperatorSet.CreateMatrix(hv_NumClasses, hv_NumClasses, hv_ConfHist, out hv_ConfMatrixTmp);
                        {
                            HTuple ExpTmpOutVar_0;
                            HOperatorSet.TransposeMatrix(hv_ConfMatrixTmp, out ExpTmpOutVar_0);
                            hv_ConfMatrixTmp.Dispose();
                            hv_ConfMatrixTmp = ExpTmpOutVar_0;
                        }
                        {
                            HTuple ExpTmpOutVar_0;
                            HOperatorSet.AddMatrix(hv_ConfMatrix, hv_ConfMatrixTmp, out ExpTmpOutVar_0);
                            hv_ConfMatrix.Dispose();
                            hv_ConfMatrix = ExpTmpOutVar_0;
                        }
                    }
                    else
                    {
                        //Get the ignore region.
                        ho_ClsIgnore.Dispose();
                        HOperatorSet.GenEmptyRegion(out ho_ClsIgnore);
                        for (hv_IgnoreIndex = 0; (int)hv_IgnoreIndex <= (int)((new HTuple(hv_IgnoreClassIDs.TupleLength()
                            )) - 1); hv_IgnoreIndex = (int)hv_IgnoreIndex + 1)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_ClsIgnoreTmp.Dispose();
                                HOperatorSet.Threshold(ho_Annot, out ho_ClsIgnoreTmp, hv_IgnoreClassIDs.TupleSelect(
                                    hv_IgnoreIndex), hv_IgnoreClassIDs.TupleSelect(hv_IgnoreIndex));
                            }
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.Union2(ho_ClsIgnore, ho_ClsIgnoreTmp, out ExpTmpOutVar_0
                                    );
                                ho_ClsIgnore.Dispose();
                                ho_ClsIgnore = ExpTmpOutVar_0;
                            }
                        }
                        //
                        //Go through model classes.
                        for (hv_ClsIndex = 0; (int)hv_ClsIndex <= (int)((new HTuple(hv_ClassIDs.TupleLength()
                            )) - 1); hv_ClsIndex = (int)hv_ClsIndex + 1)
                        {
                            hv_ClsId.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClsId = hv_ClassIDs.TupleSelect(
                                    hv_ClsIndex);
                            }
                            //Get the annotated region for this class.
                            ho_ClsAnnot.Dispose();
                            HOperatorSet.Threshold(ho_Annot, out ho_ClsAnnot, hv_ClsId, hv_ClsId);
                            //Get the result region for this class.
                            ho_ClsResult.Dispose();
                            HOperatorSet.Threshold(ho_Result, out ho_ClsResult, hv_ClsId, hv_ClsId);
                            //The pixels in the ignore region should not be considered.
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.Difference(ho_ClsResult, ho_ClsIgnore, out ExpTmpOutVar_0
                                    );
                                ho_ClsResult.Dispose();
                                ho_ClsResult = ExpTmpOutVar_0;
                            }
                            //Get TP/FP/FN.
                            ho_TPReg.Dispose();
                            HOperatorSet.Intersection(ho_ClsAnnot, ho_ClsResult, out ho_TPReg);
                            ho_FPReg.Dispose();
                            HOperatorSet.Difference(ho_ClsResult, ho_ClsAnnot, out ho_FPReg);
                            //We define false negatives as pixels that have been labeled as this class,
                            //but not been correctly predicted.
                            ho_FNReg.Dispose();
                            HOperatorSet.Difference(ho_ClsAnnot, ho_ClsResult, out ho_FNReg);
                            //Get corresponding pixel numbers and update.
                            hv_ClsTP.Dispose();
                            HOperatorSet.RegionFeatures(ho_TPReg, "area", out hv_ClsTP);
                            hv_ClsFP.Dispose();
                            HOperatorSet.RegionFeatures(ho_FPReg, "area", out hv_ClsFP);
                            hv_ClsFN.Dispose();
                            HOperatorSet.RegionFeatures(ho_FNReg, "area", out hv_ClsFN);
                            if (hv_TP == null)
                                hv_TP = new HTuple();
                            hv_TP[hv_ClsIndex] = (hv_TP.TupleSelect(hv_ClsIndex)) + hv_ClsTP;
                            if (hv_FP == null)
                                hv_FP = new HTuple();
                            hv_FP[hv_ClsIndex] = (hv_FP.TupleSelect(hv_ClsIndex)) + hv_ClsFP;
                            if (hv_FN == null)
                                hv_FN = new HTuple();
                            hv_FN[hv_ClsIndex] = (hv_FN.TupleSelect(hv_ClsIndex)) + hv_ClsFN;
                        }
                    }
                }
                //
                //Update running measures.
                if ((int)(hv_CalcConfMatrix) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "pixel_confusion_matrix", hv_ConfMatrix);
                }
                else
                {
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "tp", hv_TP);
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "fp", hv_FP);
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "fn", hv_FN);
                }
                //
                ho_Annot.Dispose();
                ho_Result.Dispose();
                ho_ClsIgnore.Dispose();
                ho_ClsIgnoreTmp.Dispose();
                ho_ClsAnnot.Dispose();
                ho_ClsResult.Dispose();
                ho_TPReg.Dispose();
                ho_FPReg.Dispose();
                ho_FNReg.Dispose();

                hv_ClassIDs.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_Measures.Dispose();
                hv_CalcConfMatrix.Dispose();
                hv_NumClasses.Dispose();
                hv_MaxId.Dispose();
                hv_ConfMatrix.Dispose();
                hv_MapClassIDs.Dispose();
                hv_ClsIdToClsIdx.Dispose();
                hv_TP.Dispose();
                hv_FP.Dispose();
                hv_FN.Dispose();
                hv_SampleIndex.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_AnnotVals.Dispose();
                hv_ResultVals.Dispose();
                hv_ConfTuple.Dispose();
                hv_ConfHist.Dispose();
                hv_BinSize.Dispose();
                hv_ConfMatrixTmp.Dispose();
                hv_IgnoreIndex.Dispose();
                hv_ClsIndex.Dispose();
                hv_ClsId.Dispose();
                hv_ClsTP.Dispose();
                hv_ClsFP.Dispose();
                hv_ClsFN.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Annot.Dispose();
                ho_Result.Dispose();
                ho_ClsIgnore.Dispose();
                ho_ClsIgnoreTmp.Dispose();
                ho_ClsAnnot.Dispose();
                ho_ClsResult.Dispose();
                ho_TPReg.Dispose();
                ho_FPReg.Dispose();
                ho_FNReg.Dispose();

                hv_ClassIDs.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_Measures.Dispose();
                hv_CalcConfMatrix.Dispose();
                hv_NumClasses.Dispose();
                hv_MaxId.Dispose();
                hv_ConfMatrix.Dispose();
                hv_MapClassIDs.Dispose();
                hv_ClsIdToClsIdx.Dispose();
                hv_TP.Dispose();
                hv_FP.Dispose();
                hv_FN.Dispose();
                hv_SampleIndex.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_AnnotVals.Dispose();
                hv_ResultVals.Dispose();
                hv_ConfTuple.Dispose();
                hv_ConfHist.Dispose();
                hv_BinSize.Dispose();
                hv_ConfMatrixTmp.Dispose();
                hv_IgnoreIndex.Dispose();
                hv_ClsIndex.Dispose();
                hv_ClsId.Dispose();
                hv_ClsTP.Dispose();
                hv_ClsFP.Dispose();
                hv_ClsFN.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Window
        // Short Description: This procedure sets and returns meta information to display images correctly. 
        public void update_window_meta_information(HTuple hv_WindowHandle, HTuple hv_WidthImage,
            HTuple hv_HeightImage, HTuple hv_WindowRow1, HTuple hv_WindowColumn1, HTuple hv_MapColorBarWidth,
            HTuple hv_MarginBottom, out HTuple hv_WindowImageRatioHeight, out HTuple hv_WindowImageRatioWidth,
            out HTuple hv_SetPartRow2, out HTuple hv_SetPartColumn2, out HTuple hv_PrevWindowCoordinatesOut)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv__ = new HTuple(), hv_WindowWidth = new HTuple();
            HTuple hv_WindowHeight = new HTuple(), hv_WindowRow2 = new HTuple();
            HTuple hv_WindowColumn2 = new HTuple(), hv_WindowRatio = new HTuple();
            HTuple hv_ImageRow2 = new HTuple(), hv_ImageColumn2 = new HTuple();
            HTuple hv_ImageRatio = new HTuple(), hv_ImageWindowRatioHeight = new HTuple();
            HTuple hv_ImageRow2InWindow = new HTuple(), hv_ImageCol2InWindow = new HTuple();
            // Initialize local and output iconic variables 
            hv_WindowImageRatioHeight = new HTuple();
            hv_WindowImageRatioWidth = new HTuple();
            hv_SetPartRow2 = new HTuple();
            hv_SetPartColumn2 = new HTuple();
            hv_PrevWindowCoordinatesOut = new HTuple();
            try
            {
                //
                //This procedure sets and returns meta information to display images correctly.
                //
                //Set part for the image to be displayed later and adapt window size (+ MarginBottom + MapColorBarWidth).
                hv__.Dispose(); hv__.Dispose(); hv_WindowWidth.Dispose(); hv_WindowHeight.Dispose();
                HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv__, out hv__, out hv_WindowWidth,
                    out hv_WindowHeight);
                hv_WindowImageRatioHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowImageRatioHeight = hv_WindowHeight / (hv_HeightImage * 1.0);
                }
                hv_WindowImageRatioWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowImageRatioWidth = hv_WindowWidth / (hv_WidthImage * 1.0);
                }
                //
                //Set window part such that image is displayed undistorted.
                hv_WindowRow2.Dispose();
                hv_WindowRow2 = new HTuple(hv_WindowHeight);
                hv_WindowColumn2.Dispose();
                hv_WindowColumn2 = new HTuple(hv_WindowWidth);
                hv_WindowRatio.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowRatio = hv_WindowColumn2 / (hv_WindowRow2 * 1.0);
                }
                //
                hv_ImageRow2.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ImageRow2 = hv_HeightImage + (hv_MarginBottom / hv_WindowImageRatioHeight);
                }
                hv_ImageColumn2.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ImageColumn2 = hv_WidthImage + (hv_MapColorBarWidth / hv_WindowImageRatioWidth);
                }
                hv_ImageRatio.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ImageRatio = hv_ImageColumn2 / (hv_ImageRow2 * 1.0);
                }
                if ((int)(new HTuple(hv_ImageRatio.TupleGreater(hv_WindowRatio))) != 0)
                {
                    //
                    //Extend image until right window border.
                    hv_SetPartColumn2.Dispose();
                    hv_SetPartColumn2 = new HTuple(hv_ImageColumn2);
                    hv_ImageWindowRatioHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageWindowRatioHeight = hv_ImageColumn2 / (hv_WindowColumn2 * 1.0);
                    }
                    hv_ImageRow2InWindow.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageRow2InWindow = hv_ImageRow2 / hv_ImageWindowRatioHeight;
                    }
                    hv_SetPartRow2.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SetPartRow2 = hv_ImageRow2 + ((hv_WindowRow2 - hv_ImageRow2InWindow) / hv_WindowImageRatioWidth);
                    }
                }
                else
                {
                    //
                    //Extend image until bottom of window.
                    hv_SetPartRow2.Dispose();
                    hv_SetPartRow2 = new HTuple(hv_ImageRow2);
                    hv_ImageWindowRatioHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageWindowRatioHeight = hv_ImageRow2 / (hv_WindowRow2 * 1.0);
                    }
                    hv_ImageCol2InWindow.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageCol2InWindow = hv_ImageColumn2 / hv_ImageWindowRatioHeight;
                    }
                    hv_SetPartColumn2.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SetPartColumn2 = hv_ImageColumn2 + ((hv_WindowColumn2 - hv_ImageCol2InWindow) / hv_WindowImageRatioHeight);
                    }
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_SetPartRow2, hv_SetPartColumn2);
                }
                //
                //Return the coordinates of the new window.
                hv_PrevWindowCoordinatesOut.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PrevWindowCoordinatesOut = new HTuple();
                    hv_PrevWindowCoordinatesOut = hv_PrevWindowCoordinatesOut.TupleConcat(hv_WindowRow1, hv_WindowColumn1, hv_WindowWidth, hv_WindowHeight);
                }
                //

                hv__.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_WindowRow2.Dispose();
                hv_WindowColumn2.Dispose();
                hv_WindowRatio.Dispose();
                hv_ImageRow2.Dispose();
                hv_ImageColumn2.Dispose();
                hv_ImageRatio.Dispose();
                hv_ImageWindowRatioHeight.Dispose();
                hv_ImageRow2InWindow.Dispose();
                hv_ImageCol2InWindow.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv__.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_WindowRow2.Dispose();
                hv_WindowColumn2.Dispose();
                hv_WindowRatio.Dispose();
                hv_ImageRow2.Dispose();
                hv_ImageColumn2.Dispose();
                hv_ImageRatio.Dispose();
                hv_ImageWindowRatioHeight.Dispose();
                hv_ImageRow2InWindow.Dispose();
                hv_ImageCol2InWindow.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Check that all given entries in EvalParams are valid. 
        public void validate_evaluation_param(HTuple hv_EvalParams, out HTuple hv_Valid,
            out HTuple hv_Exception)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ClassIDsExist = new HTuple(), hv_ClassIDs = new HTuple();
            HTuple hv_NumClassesExist = new HTuple(), hv_NumClasses = new HTuple();
            HTuple hv_EvalInstancesExists = new HTuple(), hv_EvaluationTypeExists = new HTuple();
            HTuple hv_EvaluationType = new HTuple(), hv_Indices = new HTuple();
            HTuple hv_MeasuresExists = new HTuple(), hv_Measures = new HTuple();
            HTuple hv_ValidMeasures = new HTuple(), hv_Ks = new HTuple();
            HTuple hv_KeysExist = new HTuple(), hv_ClassNames = new HTuple();
            HTuple hv_ClassesToEvaluate = new HTuple(), hv_ClassIDsToEvaluate = new HTuple();
            HTuple hv_IouThreshExists = new HTuple(), hv_IouThresholds = new HTuple();
            HTuple hv_MaxNumDetectionsExists = new HTuple(), hv_MaxNumDetections = new HTuple();
            HTuple hv_AreaRangesExist = new HTuple(), hv_AreaRanges = new HTuple();
            HTuple hv_AreaKeysExist = new HTuple(), hv_AreaNames = new HTuple();
            HTuple hv_MinAreas = new HTuple(), hv_MaxAreas = new HTuple();
            HTuple hv_InstanceTypeExists = new HTuple(), hv_InstanceType = new HTuple();
            HTuple hv_ValidInstanceTypes = new HTuple(), hv_AllocationBlockLengthExists = new HTuple();
            HTuple hv_AllocationBlockLength = new HTuple(), hv_DetailedEvaluationExists = new HTuple();
            HTuple hv_DetailedEvaluation = new HTuple(), hv_IgnoreClassIDsExist = new HTuple();
            HTuple hv_ValidMeasuresString = new HTuple(), hv_Idx = new HTuple();
            HTuple hv_ValidMeasure = new HTuple();
            // Initialize local and output iconic variables 
            hv_Valid = new HTuple();
            hv_Exception = new HTuple();
            try
            {
                //
                //This procedure checks if the dictionary EvalParams
                //contains all necessary parameters and if they are valid (type, range, ...).
                //
                hv_Valid.Dispose();
                hv_Valid = 0;
                hv_Exception.Dispose();
                hv_Exception = "";
                //Check class IDs.
                hv_ClassIDsExist.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "class_ids", out hv_ClassIDsExist);
                if ((int)(hv_ClassIDsExist.TupleNot()) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "The evaluation parameters need a key-value pair for 'class_ids'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();

                    return;
                }
                else
                {
                    hv_ClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                    if ((int)(new HTuple((new HTuple(hv_ClassIDs.TupleLength())).TupleLess(1))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'class_ids' should have at least length 1";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    if ((int)(new HTuple(((hv_ClassIDs.TupleIsIntElem())).TupleNotEqual(HTuple.TupleGenConst(
                        new HTuple(hv_ClassIDs.TupleLength()), 1)))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'class_ids' should be of type int";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    if ((int)(new HTuple(((((hv_ClassIDs.TupleLessElem(0))).TupleFind(1))).TupleGreater(
                        -1))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'class_ids' should be positive or zero";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                }
                //Check the entry num_classes.
                hv_NumClassesExist.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "num_classes", out hv_NumClassesExist);
                if ((int)(hv_NumClassesExist.TupleNot()) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "The evaluation parameters need a key-value pair for 'num_classes'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();

                    return;
                }
                else
                {
                    hv_NumClasses.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
                    if ((int)(new HTuple((new HTuple(hv_NumClasses.TupleLength())).TupleNotEqual(
                        1))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'num_classes' should have length 1";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    if ((int)(new HTuple(((hv_NumClasses.TupleType())).TupleNotEqual((new HTuple((new HTuple(1)).TupleInt()
                        )).TupleType()))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'num_classes' should be of type int";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    if ((int)(new HTuple(hv_NumClasses.TupleLess(1))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'num_classes' should be at least 1";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                }
                //Check that num_classes is equal to |class_ids|.
                if ((int)(new HTuple(hv_NumClasses.TupleNotEqual(new HTuple(hv_ClassIDs.TupleLength()
                    )))) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "'num_classes' has to be set to the number of 'class_ids'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();

                    return;
                }
                //Check the entry 'evaluate_instances'.
                hv_EvalInstancesExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "evaluate_instances",
                    out hv_EvalInstancesExists);
                if ((int)(hv_EvalInstancesExists.TupleNot()) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "The evaluation parameters need a key-value pair for 'evaluate_instances'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();

                    return;
                }
                //Check the entry 'evaluation_type'.
                hv_EvaluationTypeExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "evaluation_type", out hv_EvaluationTypeExists);
                if ((int)(hv_EvaluationTypeExists.TupleNot()) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "The evaluation parameters need a key-value pair for 'evaluation_type'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();

                    return;
                }
                else
                {
                    hv_EvaluationType.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "evaluation_type", out hv_EvaluationType);
                    hv_Indices.Dispose();
                    HOperatorSet.TupleFind((((new HTuple("anomaly_detection")).TupleConcat("classification")).TupleConcat(
                        "segmentation")).TupleConcat("detection"), hv_EvaluationType, out hv_Indices);
                    if ((int)((new HTuple(hv_Indices.TupleEqual(-1))).TupleOr(new HTuple(hv_Indices.TupleEqual(
                        new HTuple())))) != 0)
                    {
                        hv_Exception.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Exception = "Invalid entry for 'evaluation_type': " + hv_EvaluationType;
                        }

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                }
                //Check the entry 'measures'.
                hv_MeasuresExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "measures", out hv_MeasuresExists);
                if ((int)(hv_MeasuresExists.TupleNot()) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "The evaluation parameters need a key-value pair for 'measures'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();

                    return;
                }
                else
                {
                    hv_Measures.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                    if ((int)(new HTuple((new HTuple(hv_Measures.TupleLength())).TupleEqual(0))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'measures' should contain at least one entry";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                }
                //Check evaluation type specific entries of EvalParams.
                hv_EvaluationType.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "evaluation_type", out hv_EvaluationType);
                if ((int)(new HTuple(hv_EvaluationType.TupleEqual("anomaly_detection"))) != 0)
                {
                    //
                    //Check for correct number of classes.
                    if ((int)(new HTuple((new HTuple(hv_ClassIDs.TupleLength())).TupleNotEqual(
                        2))) != 0)
                    {
                        throw new HalconException("The number of classes must be 2 for model type anomaly detection.");
                    }
                    //
                    //Currently only the anomaly score histogram is evaluated
                    hv_ValidMeasures.Dispose();
                    hv_ValidMeasures = "anomaly_score_histogram";
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("classification"))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Ks.Dispose();
                        HOperatorSet.TupleGenSequence(1, new HTuple(hv_ClassIDs.TupleLength()), 1,
                            out hv_Ks);
                    }
                    hv_ValidMeasures.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ValidMeasures = ("top" + hv_Ks) + "_error";
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ValidMeasures = hv_ValidMeasures.TupleConcat(
                                ((((new HTuple("precision")).TupleConcat("recall")).TupleConcat("f_score")).TupleConcat(
                                "absolute_confusion_matrix")).TupleConcat("relative_confusion_matrix"));
                            hv_ValidMeasures.Dispose();
                            hv_ValidMeasures = ExpTmpLocalVar_ValidMeasures;
                        }
                    }
                    //
                    //Check if not both of the two options to specify the evaluated classes are chosen.
                    hv_KeysExist.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", (new HTuple("class_names_to_evaluate")).TupleConcat(
                        "class_ids_to_evaluate"), out hv_KeysExist);
                    if ((int)(new HTuple(((hv_KeysExist.TupleSum())).TupleEqual(2))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "No more than one option of 'class_names_to_evaluate' and 'class_ids_to_evaluate' is allowed";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    if ((int)(hv_KeysExist.TupleSelect(0)) != 0)
                    {
                        hv_ClassNames.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "class_names", out hv_ClassNames);
                        hv_ClassesToEvaluate.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "class_names_to_evaluate", out hv_ClassesToEvaluate);
                        if ((int)(new HTuple(((hv_ClassesToEvaluate.TupleDifference(hv_ClassNames.TupleConcat(
                            "global")))).TupleNotEqual(new HTuple()))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "Invalid entry in 'class_names_to_evaluate'";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                    if ((int)(hv_KeysExist.TupleSelect(1)) != 0)
                    {
                        hv_ClassIDs.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                        hv_ClassIDsToEvaluate.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids_to_evaluate", out hv_ClassIDsToEvaluate);
                        if ((int)(new HTuple(((hv_ClassIDsToEvaluate.TupleDifference(hv_ClassIDs.TupleConcat(
                            "global")))).TupleNotEqual(new HTuple()))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "Invalid entry in 'class_ids_to_evaluate'";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("detection"))) != 0)
                {
                    //Instance-based evaluation.
                    //Add instance measures.
                    hv_ValidMeasures.Dispose();
                    hv_ValidMeasures = new HTuple();
                    hv_ValidMeasures[0] = "all";
                    hv_ValidMeasures[1] = "mean_ap";
                    //
                    //Check if the entry 'iou_threshold' is present.
                    hv_IouThreshExists.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "iou_threshold", out hv_IouThreshExists);
                    if ((int)(hv_IouThreshExists.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "The evaluation parameters need a key-value pair for 'iou_threshold'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    else
                    {
                        hv_IouThresholds.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "iou_threshold", out hv_IouThresholds);
                        //Check the length of 'iou_threshold'.
                        if ((int)(new HTuple((new HTuple(hv_IouThresholds.TupleLength())).TupleLess(
                            1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'iou_threshold' is empty";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        if ((int)(new HTuple(((hv_IouThresholds.TupleIsRealElem())).TupleNotEqual(
                            HTuple.TupleGenConst(new HTuple(hv_IouThresholds.TupleLength()), 1)))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'iou_threshold' should be of type real";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check if the IoU thresholds are within (0.0, 1.0).
                        if ((int)((new HTuple(((hv_IouThresholds.TupleMin())).TupleLessEqual(0.0))).TupleOr(
                            new HTuple(((hv_IouThresholds.TupleMax())).TupleGreaterEqual(1.0)))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = new HTuple("Invalid 'iou_threshold', not in range (0.0, 1.0)");

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                    //
                    //Check if the entry 'max_num_detections' is present.
                    hv_MaxNumDetectionsExists.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "max_num_detections",
                        out hv_MaxNumDetectionsExists);
                    if ((int)(hv_MaxNumDetectionsExists.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "The evaluation parameters need a key-value pair for 'max_num_detections'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    else
                    {
                        hv_MaxNumDetections.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "max_num_detections", out hv_MaxNumDetections);
                        //Check the length of 'max_num_detections'.
                        if ((int)(new HTuple((new HTuple(hv_MaxNumDetections.TupleLength())).TupleLess(
                            1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'max_num_detections' is empty";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        if ((int)(new HTuple(((hv_MaxNumDetections.TupleIsIntElem())).TupleNotEqual(
                            HTuple.TupleGenConst(new HTuple(hv_MaxNumDetections.TupleLength()),
                            1)))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'max_num_detections' should be of type int";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check if 'max_num_detections' is -1 (to use all detections) or positive.
                        if ((int)((new HTuple(((hv_MaxNumDetections.TupleMin())).TupleLess(-1))).TupleOr(
                            new HTuple(((hv_MaxNumDetections.TupleFind(0))).TupleGreater(-1)))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'max_num_detections' should be -1 or positive";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                    //
                    //Check if the entry 'area_ranges' is present.
                    hv_AreaRangesExist.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "area_ranges", out hv_AreaRangesExist);
                    if ((int)(hv_AreaRangesExist.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "The evaluation parameters need a key-value pair for 'area_ranges'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    else
                    {
                        //Check if the entry 'area_ranges' is a dict.
                        hv_AreaRanges.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "area_ranges", out hv_AreaRanges);
                        if ((int)(new HTuple(((hv_AreaRanges.TupleSemType())).TupleNotEqual("dict"))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges' must be a dict";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check that the necessary keys exist.
                        hv_AreaKeysExist.Dispose();
                        HOperatorSet.GetDictParam(hv_AreaRanges, "key_exists", ((new HTuple("name")).TupleConcat(
                            "min")).TupleConcat("max"), out hv_AreaKeysExist);
                        if ((int)(((hv_AreaKeysExist.TupleSelect(0))).TupleNot()) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges' need a key-value pair for 'name'";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        if ((int)(((hv_AreaKeysExist.TupleSelect(1))).TupleNot()) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges' need a key-value pair for 'min'";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        if ((int)(((hv_AreaKeysExist.TupleSelect(2))).TupleNot()) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges' need a key-value pair for 'max'";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check the lengths of the area keys.
                        hv_AreaNames.Dispose();
                        HOperatorSet.GetDictTuple(hv_AreaRanges, "name", out hv_AreaNames);
                        if ((int)(new HTuple((new HTuple(hv_AreaNames.TupleLength())).TupleLess(
                            1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges': 'name' is empty";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        hv_MinAreas.Dispose();
                        HOperatorSet.GetDictTuple(hv_AreaRanges, "min", out hv_MinAreas);
                        if ((int)(new HTuple((new HTuple(hv_MinAreas.TupleLength())).TupleLess(
                            1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges': 'min' is empty";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        hv_MaxAreas.Dispose();
                        HOperatorSet.GetDictTuple(hv_AreaRanges, "max", out hv_MaxAreas);
                        if ((int)(new HTuple((new HTuple(hv_MaxAreas.TupleLength())).TupleLess(
                            1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges': 'max' is empty";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        if ((int)((new HTuple((new HTuple(hv_AreaNames.TupleLength())).TupleNotEqual(
                            new HTuple(hv_MinAreas.TupleLength())))).TupleOr(new HTuple((new HTuple(hv_AreaNames.TupleLength()
                            )).TupleNotEqual(new HTuple(hv_MaxAreas.TupleLength()))))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = new HTuple("'area_ranges': 'name', 'min' and 'max' must have the same length");

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check values of min, max.
                        if ((int)(new HTuple(((((hv_MinAreas.TupleGreaterEqualElem(hv_MaxAreas))).TupleFind(
                            1))).TupleGreater(-1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges': 'min' must be elementwise smaller than 'max'";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                    //
                    //Check if instance-type is valid.
                    hv_InstanceTypeExists.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "instance_type", out hv_InstanceTypeExists);
                    if ((int)(hv_InstanceTypeExists.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "The evaluation parameters need a key-value pair for 'instance_type'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    else
                    {
                        hv_InstanceType.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "instance_type", out hv_InstanceType);
                        hv_ValidInstanceTypes.Dispose();
                        hv_ValidInstanceTypes = new HTuple();
                        hv_ValidInstanceTypes[0] = "rectangle1";
                        hv_ValidInstanceTypes[1] = "rectangle2";
                        if ((int)(new HTuple(((hv_ValidInstanceTypes.TupleFind(hv_InstanceType))).TupleEqual(
                            -1))) != 0)
                        {
                            hv_Exception.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Exception = ("Invalid instance type '" + hv_InstanceType) + "'";
                            }

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                    //
                    //Check if the entry 'allocation_block_length' is present and valid.
                    hv_AllocationBlockLengthExists.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "allocation_block_length",
                        out hv_AllocationBlockLengthExists);
                    if ((int)(hv_AllocationBlockLengthExists.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "The evaluation parameters need a key-value pair for 'allocation_block_length'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    else
                    {
                        hv_AllocationBlockLength.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "allocation_block_length", out hv_AllocationBlockLength);
                        //Check the length of 'allocation_block_length'.
                        if ((int)(new HTuple((new HTuple(hv_AllocationBlockLength.TupleLength()
                            )).TupleNotEqual(1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'allocation_block_length' should have length 1";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check the type of 'allocation_block_length'.
                        if ((int)(new HTuple(((hv_AllocationBlockLength.TupleType())).TupleNotEqual(
                            (new HTuple((new HTuple(0)).TupleInt())).TupleType()))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'allocation_block_length' should be of type int";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check if 'allocation_block_length' is larger than zero.
                        if ((int)(new HTuple(hv_AllocationBlockLength.TupleLess(1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'allocation_block_length' should be positive";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                    //
                    //Check if the entry 'detailed_evaluation' is valid if present.
                    hv_DetailedEvaluationExists.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "detailed_evaluation",
                        out hv_DetailedEvaluationExists);
                    if ((int)(hv_DetailedEvaluationExists.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "The evaluation parameters need a key-value pair for 'detailed_evaluation'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    else
                    {
                        hv_DetailedEvaluation.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "detailed_evaluation", out hv_DetailedEvaluation);
                        //Check the length of 'detailed_evaluation'.
                        if ((int)(new HTuple((new HTuple(hv_DetailedEvaluation.TupleLength())).TupleNotEqual(
                            1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'detailed_evaluation' should have length 1";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check the type of 'detailed_evaluation'.
                        if ((int)(new HTuple(((hv_DetailedEvaluation.TupleType())).TupleNotEqual(
                            (new HTuple(1)).TupleType()))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'detailed_evaluation' should be of type int";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check if 'detailed_evaluation' is larger than zero.
                        if ((int)((new HTuple(hv_DetailedEvaluation.TupleNotEqual(0))).TupleAnd(
                            new HTuple(hv_DetailedEvaluation.TupleNotEqual(1)))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'detailed_evaluation' should be zero or one";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                    //
                    //Add valid measure 'soap' if instance_type is 'rectangle2'.
                    if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_ValidMeasures = hv_ValidMeasures.TupleConcat(
                                    "soap");
                                hv_ValidMeasures.Dispose();
                                hv_ValidMeasures = ExpTmpLocalVar_ValidMeasures;
                            }
                        }
                    }
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("segmentation"))) != 0)
                {
                    //Pixel-based evaluation.
                    hv_ValidMeasures.Dispose();
                    hv_ValidMeasures = new HTuple();
                    hv_ValidMeasures[0] = "all";
                    hv_ValidMeasures[1] = "pixel_accuracy";
                    hv_ValidMeasures[2] = "mean_accuracy";
                    hv_ValidMeasures[3] = "mean_iou";
                    hv_ValidMeasures[4] = "class_iou";
                    hv_ValidMeasures[5] = "class_pixel_accuracy";
                    hv_ValidMeasures[6] = "pixel_confusion_matrix";
                    hv_ValidMeasures[7] = "frequency_weighted_iou";
                    //
                    //Check if the entry 'ignore_class_ids' exists.
                    hv_IgnoreClassIDsExist.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "ignore_class_ids",
                        out hv_IgnoreClassIDsExist);
                    if ((int)(hv_IgnoreClassIDsExist.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "The evaluation parameters need a key-value pair for 'ignore_class_ids'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                }
                else
                {
                    hv_Exception.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Exception = "Unknown evaluation_type: " + hv_EvaluationType;
                    }

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();

                    return;
                }
                //Check measures.
                hv_ValidMeasuresString.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ValidMeasuresString = HTuple.TupleGenConst(
                        ((new HTuple(hv_ValidMeasures.TupleLength())) * 2) - 1, new HTuple("','"));
                }
                if (hv_ValidMeasuresString == null)
                    hv_ValidMeasuresString = new HTuple();
                hv_ValidMeasuresString[HTuple.TupleGenSequence(0, (new HTuple(hv_ValidMeasuresString.TupleLength()
                    )) - 1, 2)] = hv_ValidMeasures;
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_ValidMeasuresString = hv_ValidMeasuresString.TupleSum()
                            ;
                        hv_ValidMeasuresString.Dispose();
                        hv_ValidMeasuresString = ExpTmpLocalVar_ValidMeasuresString;
                    }
                }
                for (hv_Idx = 0; (int)hv_Idx <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_Idx = (int)hv_Idx + 1)
                {
                    hv_ValidMeasure.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ValidMeasure = ((hv_ValidMeasures.TupleFind(
                            hv_Measures.TupleSelect(hv_Idx)))).TupleGreaterElem(-1);
                    }
                    if ((int)(hv_ValidMeasure.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Exception = ((("Invalid measure '" + (hv_Measures.TupleSelect(
                                hv_Idx))) + new HTuple("', choose one of ['")) + hv_ValidMeasuresString) + "']";
                        }

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                }
                //
                //Done with checks.
                hv_Valid.Dispose();
                hv_Valid = 1;

                hv_ClassIDsExist.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClassesExist.Dispose();
                hv_NumClasses.Dispose();
                hv_EvalInstancesExists.Dispose();
                hv_EvaluationTypeExists.Dispose();
                hv_EvaluationType.Dispose();
                hv_Indices.Dispose();
                hv_MeasuresExists.Dispose();
                hv_Measures.Dispose();
                hv_ValidMeasures.Dispose();
                hv_Ks.Dispose();
                hv_KeysExist.Dispose();
                hv_ClassNames.Dispose();
                hv_ClassesToEvaluate.Dispose();
                hv_ClassIDsToEvaluate.Dispose();
                hv_IouThreshExists.Dispose();
                hv_IouThresholds.Dispose();
                hv_MaxNumDetectionsExists.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRangesExist.Dispose();
                hv_AreaRanges.Dispose();
                hv_AreaKeysExist.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_InstanceTypeExists.Dispose();
                hv_InstanceType.Dispose();
                hv_ValidInstanceTypes.Dispose();
                hv_AllocationBlockLengthExists.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_DetailedEvaluationExists.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_IgnoreClassIDsExist.Dispose();
                hv_ValidMeasuresString.Dispose();
                hv_Idx.Dispose();
                hv_ValidMeasure.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ClassIDsExist.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClassesExist.Dispose();
                hv_NumClasses.Dispose();
                hv_EvalInstancesExists.Dispose();
                hv_EvaluationTypeExists.Dispose();
                hv_EvaluationType.Dispose();
                hv_Indices.Dispose();
                hv_MeasuresExists.Dispose();
                hv_Measures.Dispose();
                hv_ValidMeasures.Dispose();
                hv_Ks.Dispose();
                hv_KeysExist.Dispose();
                hv_ClassNames.Dispose();
                hv_ClassesToEvaluate.Dispose();
                hv_ClassIDsToEvaluate.Dispose();
                hv_IouThreshExists.Dispose();
                hv_IouThresholds.Dispose();
                hv_MaxNumDetectionsExists.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRangesExist.Dispose();
                hv_AreaRanges.Dispose();
                hv_AreaKeysExist.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_InstanceTypeExists.Dispose();
                hv_InstanceType.Dispose();
                hv_ValidInstanceTypes.Dispose();
                hv_AllocationBlockLengthExists.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_DetailedEvaluationExists.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_IgnoreClassIDsExist.Dispose();
                hv_ValidMeasuresString.Dispose();
                hv_Idx.Dispose();
                hv_ValidMeasure.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Local procedures 
        public void check_data_availability(HTuple hv_ExampleDataDir, HTuple hv_DLDatasetFileName,
            HTuple hv_TrainedModelFileName, HTuple hv_UsePretrainedModel)
        {



            // Local control variables 

            HTuple hv_FileExists = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure checks the availability of all files required to run the
                //evaluation example.
                //
                hv_FileExists.Dispose();
                HOperatorSet.FileExists(hv_ExampleDataDir, out hv_FileExists);
                if ((int)(hv_FileExists.TupleNot()) != 0)
                {
                    throw new HalconException(hv_ExampleDataDir + " does not exist. Please run part 1 of example series.");
                }
                //
                hv_FileExists.Dispose();
                HOperatorSet.FileExists(hv_DLDatasetFileName, out hv_FileExists);
                if ((int)(hv_FileExists.TupleNot()) != 0)
                {
                    throw new HalconException(hv_DLDatasetFileName + " does not exist. Please run part 1 of example series.");
                }
                //
                hv_FileExists.Dispose();
                HOperatorSet.FileExists(hv_TrainedModelFileName, out hv_FileExists);
                if ((int)(hv_FileExists.TupleNot()) != 0)
                {
                    if ((int)(hv_UsePretrainedModel) != 0)
                    {
                        throw new HalconException(hv_TrainedModelFileName + " does not exist. Please run the HALCON Deep Learning installer.");
                    }
                    else
                    {
                        throw new HalconException(hv_TrainedModelFileName + " does not exist. Please run part 2 of example series.");
                    }
                }
                //

                hv_FileExists.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_FileExists.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void create_tiny_example_dataset_with_result(out HTuple hv_DLDataset, out HTuple hv_DLResult)
        {


            // Local iconic variables 

            // Local control variables 

            HTuple hv_ExampleDir = new HTuple(), hv_DLSamples = new HTuple();
            HTuple hv_DLSample = new HTuple();
            // Initialize local and output iconic variables 
            hv_DLDataset = new HTuple();
            hv_DLResult = new HTuple();
            try
            {
                //This procedure creates a tiny dataset out of the pill bag dataset.
                //
                hv_ExampleDir.Dispose();
                HOperatorSet.GetSystem("example_dir", out hv_ExampleDir);
                //Create DLDataset
                hv_DLDataset.Dispose();
                HOperatorSet.CreateDict(out hv_DLDataset);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_DLDataset, "image_dir", hv_ExampleDir + "/images");
                }
                HOperatorSet.SetDictTuple(hv_DLDataset, "class_ids", (((((((((new HTuple(1)).TupleConcat(
                    2)).TupleConcat(3)).TupleConcat(4)).TupleConcat(5)).TupleConcat(6)).TupleConcat(
                    7)).TupleConcat(8)).TupleConcat(9)).TupleConcat(10));
                HOperatorSet.SetDictTuple(hv_DLDataset, "class_names", (((((((((new HTuple("Omega-3")).TupleConcat(
                    "KMW")).TupleConcat("Stomach tablet")).TupleConcat("Ginko")).TupleConcat(
                    "Ginseng")).TupleConcat("Glucosamin")).TupleConcat("Cognivia")).TupleConcat(
                    "Capsularum I")).TupleConcat("Iron tablet")).TupleConcat("Vitamin-B"));
                //Create Samples
                hv_DLSamples.Dispose();
                hv_DLSamples = new HTuple();
                hv_DLSample.Dispose();
                HOperatorSet.CreateDict(out hv_DLSample);
                HOperatorSet.SetDictTuple(hv_DLSample, "image_id", 36);
                HOperatorSet.SetDictTuple(hv_DLSample, "image_file_name", "pill_bag/pill_bag_036.png");
                HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row1", (((((((new HTuple(177)).TupleConcat(
                    242)).TupleConcat(247)).TupleConcat(240)).TupleConcat(453)).TupleConcat(
                    127)).TupleConcat(465)).TupleConcat(372));
                HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col1", (((((((new HTuple(692)).TupleConcat(
                    362)).TupleConcat(455)).TupleConcat(894)).TupleConcat(436)).TupleConcat(
                    915)).TupleConcat(826)).TupleConcat(535));
                HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row2", (((((((new HTuple(287)).TupleConcat(
                    376)).TupleConcat(458)).TupleConcat(322)).TupleConcat(554)).TupleConcat(
                    244)).TupleConcat(561)).TupleConcat(456));
                HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col2", (((((((new HTuple(933)).TupleConcat(
                    493)).TupleConcat(580)).TupleConcat(978)).TupleConcat(672)).TupleConcat(
                    1033)).TupleConcat(1037)).TupleConcat(618));
                HOperatorSet.SetDictTuple(hv_DLSample, "bbox_label_id", (((((((new HTuple(1)).TupleConcat(
                    3)).TupleConcat(4)).TupleConcat(5)).TupleConcat(6)).TupleConcat(7)).TupleConcat(
                    8)).TupleConcat(9));
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_DLSamples = hv_DLSamples.TupleConcat(
                            hv_DLSample);
                        hv_DLSamples.Dispose();
                        hv_DLSamples = ExpTmpLocalVar_DLSamples;
                    }
                }
                //
                HOperatorSet.SetDictTuple(hv_DLDataset, "samples", hv_DLSamples);
                //
                //Create a fake result
                hv_DLResult.Dispose();
                HOperatorSet.CreateDict(out hv_DLResult);
                HOperatorSet.SetDictTuple(hv_DLResult, "bbox_row1", (((((((((((new HTuple(183)).TupleConcat(
                    245)).TupleConcat(240)).TupleConcat(241)).TupleConcat(445)).TupleConcat(
                    120)).TupleConcat(372)).TupleConcat(619)).TupleConcat(116)).TupleConcat(
                    461)).TupleConcat(253)).TupleConcat(139));
                HOperatorSet.SetDictTuple(hv_DLResult, "bbox_col1", (((((((((((new HTuple(692)).TupleConcat(
                    368)).TupleConcat(461)).TupleConcat(892)).TupleConcat(434)).TupleConcat(
                    919)).TupleConcat(534)).TupleConcat(765)).TupleConcat(648)).TupleConcat(
                    448)).TupleConcat(368)).TupleConcat(977));
                HOperatorSet.SetDictTuple(hv_DLResult, "bbox_row2", (((((((((((new HTuple(287)).TupleConcat(
                    380)).TupleConcat(451)).TupleConcat(305)).TupleConcat(554)).TupleConcat(
                    241)).TupleConcat(452)).TupleConcat(723)).TupleConcat(216)).TupleConcat(
                    569)).TupleConcat(394)).TupleConcat(177));
                HOperatorSet.SetDictTuple(hv_DLResult, "bbox_col2", (((((((((((new HTuple(940)).TupleConcat(
                    491)).TupleConcat(581)).TupleConcat(968)).TupleConcat(675)).TupleConcat(
                    1023)).TupleConcat(621)).TupleConcat(1005)).TupleConcat(898)).TupleConcat(
                    669)).TupleConcat(498)).TupleConcat(1010));
                HOperatorSet.SetDictTuple(hv_DLResult, "bbox_class_id", (((((((((((new HTuple(1)).TupleConcat(
                    3)).TupleConcat(4)).TupleConcat(9)).TupleConcat(6)).TupleConcat(7)).TupleConcat(
                    9)).TupleConcat(6)).TupleConcat(1)).TupleConcat(1)).TupleConcat(3)).TupleConcat(
                    9));
                HOperatorSet.SetDictTuple(hv_DLResult, "bbox_confidence", (((((((((((new HTuple(0.99871)).TupleConcat(
                    1.0)).TupleConcat(0.71677)).TupleConcat(0.97492)).TupleConcat(0.96392)).TupleConcat(
                    0.81231)).TupleConcat(0.99123)).TupleConcat(0.61978)).TupleConcat(0.65315)).TupleConcat(
                    0.70765)).TupleConcat(0.63381)).TupleConcat(0.7241));
                //
                //For easy retrieval we store the type of detections
                HOperatorSet.SetDictTuple(hv_DLResult, "bbox_detection_type", (((((((((((new HTuple("tp")).TupleConcat(
                    "tp")).TupleConcat("tp")).TupleConcat("fp_class")).TupleConcat("tp")).TupleConcat(
                    "tp")).TupleConcat("tp")).TupleConcat("fp_bg")).TupleConcat("fp_loc")).TupleConcat(
                    "fp_class")).TupleConcat("fp_dup")).TupleConcat("fp_mult"));

                hv_ExampleDir.Dispose();
                hv_DLSamples.Dispose();
                hv_DLSample.Dispose();

                return;

                hv_ExampleDir.Dispose();
                hv_DLSamples.Dispose();
                hv_DLSample.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ExampleDir.Dispose();
                hv_DLSamples.Dispose();
                hv_DLSample.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_close_example_windows(HTuple hv_ExampleInternals)
        {



            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_Keys = new HTuple(), hv_Index = new HTuple();
            HTuple hv_WindowHandle = new HTuple(), hv_Exception = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure closes all example windows.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_Keys.Dispose();
                    hv_Index.Dispose();
                    hv_WindowHandle.Dispose();
                    hv_Exception.Dispose();

                    return;
                }
                //
                hv_Keys.Dispose();
                HOperatorSet.GetDictParam(hv_ExampleInternals, "keys", new HTuple(), out hv_Keys);
                for (hv_Index = 0; (int)hv_Index <= (int)(new HTuple(hv_Keys.TupleLength())); hv_Index = (int)hv_Index + 1)
                {
                    try
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_WindowHandle.Dispose();
                            HOperatorSet.GetDictTuple(hv_ExampleInternals, hv_Keys.TupleSelect(hv_Index),
                                out hv_WindowHandle);
                        }
                        HDevWindowStack.SetActive(hv_WindowHandle);
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                        }
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException1)
                    {
                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    }
                }
                //

                hv_ShowExampleScreens.Dispose();
                hv_Keys.Dispose();
                hv_Index.Dispose();
                hv_WindowHandle.Dispose();
                hv_Exception.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_Keys.Dispose();
                hv_Index.Dispose();
                hv_WindowHandle.Dispose();
                hv_Exception.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_ap_matrix(HTuple hv_Matrix, HTuple hv_ColumnNames, HTuple hv_RowNames,
            HTuple hv_WindowHandle, HTuple hv_GenParam)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_NumRows = new HTuple(), hv_NumColumns = new HTuple();
            HTuple hv_DisplayColumnWidth = new HTuple(), hv_DisplayColor = new HTuple();
            HTuple hv_IdxsNoDisplay = new HTuple(), hv_AxisTitles = new HTuple();
            HTuple hv_ValueColors = new HTuple(), hv_NumberFormat = new HTuple();
            HTuple hv_Title = new HTuple(), hv_AxisColor = new HTuple();
            HTuple hv_WindowRow = new HTuple(), hv_WindowColumn = new HTuple();
            HTuple hv_GenParamKeys = new HTuple(), hv_KeyExists = new HTuple();
            HTuple hv_ValueTmp = new HTuple(), hv_ColStringWidths = new HTuple();
            HTuple hv_AllNames = new HTuple(), hv_MaxStringWidth = new HTuple();
            HTuple hv_StringIndex = new HTuple(), hv_String = new HTuple();
            HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
            HTuple hv_StringWidth = new HTuple(), hv_StringHeight = new HTuple();
            HTuple hv_RowStart = new HTuple(), hv_RowDistance = new HTuple();
            HTuple hv_RowEnd = new HTuple(), hv_ColumnStart = new HTuple();
            HTuple hv_ColumnOffset = new HTuple(), hv_ColumnEnd = new HTuple();
            HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
            HTuple hv_WidthLimit = new HTuple(), hv_HeightLimit = new HTuple();
            HTuple hv_TextRow = new HTuple(), hv_TextColumn = new HTuple();
            HTuple hv_RowStartTmp = new HTuple(), hv_ColumnDistance = new HTuple();
            HTuple hv_Index = new HTuple(), hv_TitleAscent = new HTuple();
            HTuple hv_TitleDescent = new HTuple(), hv_TitleWidth = new HTuple();
            HTuple hv_TitleHeight = new HTuple(), hv_AxisTitleRowX = new HTuple();
            HTuple hv_MatrixText = new HTuple(), hv_IdxsDisplay = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //Display a matrix in a window.
                //
                //GenParam (all are optional):
                //  - display_column_width: Either 'equal' or 'minimal'. For 'equal', all columns have the same width
                //                          that equals the width of the longest row or column-name.
                //  - display_color:        If true, the values will be displayed with the colors that are given by
                //                          'value_colors'.
                //                          Else, all values are displayed in white.
                //  - idxs_no_display:      Indices of the matrix that should not be displayed. The indices should be
                //                          given in row-major order, according to get_full_matrix. If not given or if
                //                          set to an empty tuple, all matrix values are displayed.
                //  - axis_titles:          Titles for the matrix x- and y-axis that are displayed at the top-right
                //                          and bottom-left of the matrix, respectively. Should be a tuple of length
                //                          two or an empty tuple if no axis titles should be displayed.
                //  - value_colors:         Tuple containing the hex color-string for each value of the matrix. If a
                //                          single value is given, this color is used for all values, else it must have
                //                          the length of the number of values in the matrix. Is ignored if
                //                          display_color is false.
                //  - number_format:        Format of the numbers when they are converted to strings for display.
                //                          Default: 2.0f
                //  - title:                Title of the displayed matrix, if given shown in the top-left.
                //  - row_col_names_color:  Color of column and row names. Default: 'light gray'
                //
                //
                //Get the matrix dimensions.
                hv_NumRows.Dispose(); hv_NumColumns.Dispose();
                HOperatorSet.GetSizeMatrix(hv_Matrix, out hv_NumRows, out hv_NumColumns);
                //Set defaults params.
                hv_DisplayColumnWidth.Dispose();
                hv_DisplayColumnWidth = "equal";
                hv_DisplayColor.Dispose();
                hv_DisplayColor = 0;
                hv_IdxsNoDisplay.Dispose();
                hv_IdxsNoDisplay = new HTuple();
                hv_AxisTitles.Dispose();
                hv_AxisTitles = new HTuple();
                hv_ValueColors.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ValueColors = HTuple.TupleGenConst(
                        hv_NumRows * hv_NumColumns, "white");
                }
                hv_NumberFormat.Dispose();
                hv_NumberFormat = "2.0f";
                hv_Title.Dispose();
                hv_Title = new HTuple();
                hv_AxisColor.Dispose();
                hv_AxisColor = "light gray";
                hv_WindowRow.Dispose();
                hv_WindowRow = 0;
                hv_WindowColumn.Dispose();
                hv_WindowColumn = 0;
                //Get parameters and overwrite
                hv_GenParamKeys.Dispose();
                hv_GenParamKeys = new HTuple();
                hv_GenParamKeys[0] = "display_column_width";
                hv_GenParamKeys[1] = "display_color";
                hv_GenParamKeys[2] = "idxs_no_display";
                hv_GenParamKeys[3] = "axis_titles";
                hv_GenParamKeys[4] = "value_colors";
                hv_GenParamKeys[5] = "number_format";
                hv_GenParamKeys[6] = "title";
                hv_GenParamKeys[7] = "row_col_names_color";
                hv_GenParamKeys[8] = "window_row";
                hv_GenParamKeys[9] = "window_column";
                if ((int)(new HTuple((new HTuple(hv_GenParam.TupleLength())).TupleGreater(0))) != 0)
                {
                    hv_KeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "key_exists", hv_GenParamKeys, out hv_KeyExists);
                    //DisplayColumnWidth.
                    if ((int)(hv_KeyExists.TupleSelect(0)) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "display_column_width", out hv_ValueTmp);
                        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
                            1))).TupleOr(new HTuple((new HTuple(((new HTuple("equal")).TupleConcat(
                            "minimal")).TupleFind(hv_ValueTmp))).TupleEqual(-1)))) != 0)
                        {
                            throw new HalconException("Invalid value for 'display_column_width'");
                        }
                        else
                        {
                            hv_DisplayColumnWidth.Dispose();
                            hv_DisplayColumnWidth = new HTuple(hv_ValueTmp);
                        }
                    }
                    //DisplayColor.
                    if ((int)(hv_KeyExists.TupleSelect(1)) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "display_color", out hv_ValueTmp);
                        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
                            1))).TupleOr(new HTuple((new HTuple(((new HTuple(1)).TupleConcat(0)).TupleFind(
                            hv_ValueTmp))).TupleEqual(-1)))) != 0)
                        {
                            throw new HalconException("Invalid value for 'display_color'");
                        }
                        else
                        {
                            hv_DisplayColor.Dispose();
                            hv_DisplayColor = new HTuple(hv_ValueTmp);
                        }
                    }
                    //ValueIdxsNoDisplay.
                    if ((int)(hv_KeyExists.TupleSelect(2)) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "idxs_no_display", out hv_ValueTmp);
                        if ((int)(new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleGreater(
                            0))) != 0)
                        {
                            if ((int)((new HTuple((new HTuple((new HTuple(((hv_ValueTmp.TupleMin()
                                )).TupleLess(0))).TupleOr(new HTuple(((hv_ValueTmp.TupleMax())).TupleGreater(
                                (hv_NumRows * hv_NumColumns) - 1))))).TupleOr(((hv_ValueTmp.TupleIsInt()
                                )).TupleNot()))).TupleOr(new HTuple((new HTuple(hv_ValueTmp.TupleLength()
                                )).TupleGreater(hv_NumRows * hv_NumColumns)))) != 0)
                            {
                                throw new HalconException("Invalid value for 'idxs_no_display'");
                            }
                        }
                        hv_IdxsNoDisplay.Dispose();
                        hv_IdxsNoDisplay = new HTuple(hv_ValueTmp);
                    }
                    //AxisTitles.
                    if ((int)(hv_KeyExists.TupleSelect(3)) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "axis_titles", out hv_ValueTmp);
                        if ((int)(new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleGreater(
                            0))) != 0)
                        {
                            if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleGreater(
                                2))).TupleOr(new HTuple(((hv_ValueTmp.TupleIsStringElem())).TupleNotEqual(
                                HTuple.TupleGenConst(new HTuple(hv_ValueTmp.TupleLength()), 1))))) != 0)
                            {
                                throw new HalconException("Invalid value for 'axis_titles'");
                            }
                        }
                        hv_AxisTitles.Dispose();
                        hv_AxisTitles = new HTuple(hv_ValueTmp);
                    }
                    //ValueColors.
                    if ((int)(((hv_KeyExists.TupleSelect(4))).TupleAnd(hv_DisplayColor)) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "value_colors", out hv_ValueTmp);
                        if ((int)(new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleGreater(
                            0))) != 0)
                        {
                            if ((int)((new HTuple((new HTuple((new HTuple(hv_ValueTmp.TupleLength()
                                )).TupleNotEqual(hv_NumColumns * hv_NumRows))).TupleAnd(new HTuple((new HTuple(hv_ValueTmp.TupleLength()
                                )).TupleNotEqual(1))))).TupleOr(((hv_ValueTmp.TupleIsString())).TupleNot()
                                )) != 0)
                            {
                                throw new HalconException("Invalid value for 'value_colors'");
                            }
                            if ((int)(new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleEqual(
                                1))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_ValueTmp = HTuple.TupleGenConst(
                                            hv_NumRows * hv_NumColumns, hv_ValueTmp);
                                        hv_ValueTmp.Dispose();
                                        hv_ValueTmp = ExpTmpLocalVar_ValueTmp;
                                    }
                                }
                            }
                        }
                        hv_ValueColors.Dispose();
                        hv_ValueColors = new HTuple(hv_ValueTmp);
                    }
                    //NumberFormat.
                    if ((int)(hv_KeyExists.TupleSelect(5)) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "number_format", out hv_ValueTmp);
                        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
                            1))).TupleOr(((hv_ValueTmp.TupleIsString())).TupleNot())) != 0)
                        {
                            throw new HalconException("Invalid value for 'number_format'");
                        }
                        else
                        {
                            hv_NumberFormat.Dispose();
                            hv_NumberFormat = new HTuple(hv_ValueTmp);
                        }
                    }
                    //Title.
                    if ((int)(hv_KeyExists.TupleSelect(6)) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "title", out hv_ValueTmp);
                        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
                            1))).TupleOr(((hv_ValueTmp.TupleIsString())).TupleNot())) != 0)
                        {
                            throw new HalconException("Invalid value for 'title'");
                        }
                        else
                        {
                            hv_Title.Dispose();
                            hv_Title = new HTuple(hv_ValueTmp);
                        }
                    }
                    //Color of column and row names.
                    if ((int)(hv_KeyExists.TupleSelect(7)) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "row_col_names_color", out hv_ValueTmp);
                        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
                            1))).TupleOr(((hv_ValueTmp.TupleIsString())).TupleNot())) != 0)
                        {
                            throw new HalconException("Invalid value for 'row_col_names_color'");
                        }
                        else
                        {
                            hv_AxisColor.Dispose();
                            hv_AxisColor = new HTuple(hv_ValueTmp);
                        }
                    }
                    //Position of the window
                    if ((int)(hv_KeyExists.TupleSelect(8)) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "window_row", out hv_ValueTmp);
                        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
                            1))).TupleOr(new HTuple(hv_ValueTmp.TupleLess(0)))) != 0)
                        {
                            throw new HalconException("Invalid value for 'window_row'");
                        }
                        else
                        {
                            hv_WindowRow.Dispose();
                            hv_WindowRow = new HTuple(hv_ValueTmp);
                        }
                    }
                    if ((int)(hv_KeyExists.TupleSelect(9)) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "window_column", out hv_ValueTmp);
                        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
                            1))).TupleOr(new HTuple(hv_ValueTmp.TupleLess(0)))) != 0)
                        {
                            throw new HalconException("Invalid value for 'window_column'");
                        }
                        else
                        {
                            hv_WindowColumn.Dispose();
                            hv_WindowColumn = new HTuple(hv_ValueTmp);
                        }
                    }
                }
                //
                //
                //Calculate the width of row and column-name-strings.
                hv_ColStringWidths.Dispose();
                hv_ColStringWidths = new HTuple();
                hv_AllNames.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_AllNames = new HTuple();
                    hv_AllNames = hv_AllNames.TupleConcat(hv_ColumnNames, hv_RowNames);
                }
                hv_MaxStringWidth.Dispose();
                hv_MaxStringWidth = 0;
                for (hv_StringIndex = 0; (int)hv_StringIndex <= (int)((new HTuple(hv_AllNames.TupleLength()
                    )) - 1); hv_StringIndex = (int)hv_StringIndex + 1)
                {
                    hv_String.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_String = hv_AllNames.TupleSelect(
                            hv_StringIndex);
                    }
                    hv_Ascent.Dispose(); hv_Descent.Dispose(); hv_StringWidth.Dispose(); hv_StringHeight.Dispose();
                    HOperatorSet.GetStringExtents(hv_WindowHandle, hv_String, out hv_Ascent,
                        out hv_Descent, out hv_StringWidth, out hv_StringHeight);
                    if ((int)(new HTuple(hv_StringIndex.TupleLess(new HTuple(hv_ColumnNames.TupleLength()
                        )))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_ColStringWidths = hv_ColStringWidths.TupleConcat(
                                    hv_StringWidth);
                                hv_ColStringWidths.Dispose();
                                hv_ColStringWidths = ExpTmpLocalVar_ColStringWidths;
                            }
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_MaxStringWidth = hv_MaxStringWidth.TupleMax2(
                                hv_StringWidth);
                            hv_MaxStringWidth.Dispose();
                            hv_MaxStringWidth = ExpTmpLocalVar_MaxStringWidth;
                        }
                    }
                }
                //The columns should have a minimum width for 4 characters.
                hv_Ascent.Dispose(); hv_Descent.Dispose(); hv_StringWidth.Dispose(); hv_StringHeight.Dispose();
                HOperatorSet.GetStringExtents(hv_WindowHandle, "test", out hv_Ascent, out hv_Descent,
                    out hv_StringWidth, out hv_StringHeight);
                //Update the maximum string width.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_MaxStringWidth = hv_MaxStringWidth.TupleMax2(
                            hv_StringWidth);
                        hv_MaxStringWidth.Dispose();
                        hv_MaxStringWidth = ExpTmpLocalVar_MaxStringWidth;
                    }
                }
                //
                //Set params for nice display, e.g. distances from window border and row- and column-offsets.
                hv_RowStart.Dispose();
                hv_RowStart = 80;
                hv_RowDistance.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RowDistance = hv_StringHeight + 10;
                }
                hv_RowEnd.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RowEnd = hv_StringHeight * 7;
                }
                hv_ColumnStart.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ColumnStart = 50 + hv_MaxStringWidth;
                }
                hv_ColumnOffset.Dispose();
                hv_ColumnOffset = 30;
                hv_ColumnEnd.Dispose();
                hv_ColumnEnd = new HTuple(hv_ColumnOffset);
                //
                //Adapt the window size to fit the confusion matrix.
                if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("minimal"))) != 0)
                {
                    //Every column of the confusion matrix is as narrow as possible
                    //based to the respective string widths.
                    hv_Width.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Width = (((hv_ColStringWidths.TupleSum()
                            ) + (hv_ColumnOffset * hv_NumColumns)) + hv_ColumnStart) + hv_ColumnEnd;
                    }
                }
                else if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("equal"))) != 0)
                {
                    //Every column of the confusion matrix should have the same width.
                    //based on the maximum string width.
                    hv_Width.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Width = (((hv_MaxStringWidth + hv_ColumnOffset) * hv_NumColumns) + hv_ColumnStart) + hv_ColumnEnd;
                    }
                }
                hv_Height.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Height = ((hv_RowDistance * hv_NumRows) + hv_RowStart) + hv_RowEnd;
                }
                HDevWindowStack.SetActive(hv_WindowHandle);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                }
                //
                //Set reasonable limits for graphics window (adapt if necessary).
                hv_WidthLimit.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WidthLimit = new HTuple();
                    hv_WidthLimit[0] = 450;
                    hv_WidthLimit = hv_WidthLimit.TupleConcat(hv_Width);
                }
                hv_HeightLimit.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HeightLimit = new HTuple();
                    hv_HeightLimit[0] = 250;
                    hv_HeightLimit = hv_HeightLimit.TupleConcat(hv_Height);
                }
                dev_resize_window_fit_size(hv_WindowRow, hv_WindowColumn, hv_Width, hv_Height,
                    hv_WidthLimit, hv_HeightLimit);
                //
                //
                //Calculate row and column coordinates for display of values.
                hv_TextRow.Dispose();
                hv_TextRow = new HTuple();
                hv_TextColumn.Dispose();
                hv_TextColumn = new HTuple();
                hv_RowStartTmp.Dispose();
                hv_RowStartTmp = 0;
                hv_ColumnDistance.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ColumnDistance = new HTuple();
                    hv_ColumnDistance[0] = 0;
                    hv_ColumnDistance = hv_ColumnDistance.TupleConcat((((hv_ColStringWidths.TupleSelectRange(
                        0, hv_NumColumns - 2)) + hv_ColumnOffset)).TupleCumul());
                }
                if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("equal"))) != 0)
                {
                    hv_ColumnDistance.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ColumnDistance = HTuple.TupleGenSequence(
                            0, hv_NumColumns - 1, 1) * (hv_MaxStringWidth + hv_ColumnOffset);
                    }
                }
                HTuple end_val192 = hv_NumRows - 1;
                HTuple step_val192 = 1;
                for (hv_Index = 0; hv_Index.Continue(end_val192, step_val192); hv_Index = hv_Index.TupleAdd(step_val192))
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_TextRow = hv_TextRow.TupleConcat(
                                HTuple.TupleGenConst(hv_NumColumns, hv_RowStartTmp));
                            hv_TextRow.Dispose();
                            hv_TextRow = ExpTmpLocalVar_TextRow;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_RowStartTmp = hv_RowStartTmp + hv_RowDistance;
                            hv_RowStartTmp.Dispose();
                            hv_RowStartTmp = ExpTmpLocalVar_RowStartTmp;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_TextColumn = hv_TextColumn.TupleConcat(
                                hv_ColumnDistance);
                            hv_TextColumn.Dispose();
                            hv_TextColumn = ExpTmpLocalVar_TextColumn;
                        }
                    }
                }
                //Display the confusion matrix with a margin from the top and left.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_TextColumn = hv_TextColumn + hv_ColumnStart;
                        hv_TextColumn.Dispose();
                        hv_TextColumn = ExpTmpLocalVar_TextColumn;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_TextRow = hv_TextRow + hv_RowStart;
                        hv_TextRow.Dispose();
                        hv_TextRow = ExpTmpLocalVar_TextRow;
                    }
                }
                //
                //Display axis titles.
                if ((int)(new HTuple((new HTuple(hv_AxisTitles.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    if ((int)(new HTuple((new HTuple(hv_Title.TupleLength())).TupleGreater(0))) != 0)
                    {
                        hv_TitleAscent.Dispose(); hv_TitleDescent.Dispose(); hv_TitleWidth.Dispose(); hv_TitleHeight.Dispose();
                        HOperatorSet.GetStringExtents(hv_WindowHandle, hv_Title, out hv_TitleAscent,
                            out hv_TitleDescent, out hv_TitleWidth, out hv_TitleHeight);
                        hv_AxisTitleRowX.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_AxisTitleRowX = 2 * (hv_TitleHeight.TupleCeil()
                                );
                        }
                    }
                    else
                    {
                        hv_AxisTitleRowX.Dispose();
                        hv_AxisTitleRowX = "top";
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_AxisTitles.TupleSelect(
                                0), "window", hv_AxisTitleRowX, "right", "black", "box", "false");
                        }
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_AxisTitles.TupleSelect(
                                1), "window", "bottom", "left", "black", "box", "false");
                        }
                    }
                }
                //
                //Display title.
                if ((int)(new HTuple((new HTuple(hv_Title.TupleLength())).TupleGreater(0))) != 0)
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Title, "window",
                            "top", "left", "black", "box", "false");
                    }
                }
                //
                //Display row names.
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_RowNames, "window",
                            hv_TextRow.TupleSelect(HTuple.TupleGenSequence(0, hv_NumColumns * (hv_NumRows - 1),
                            hv_NumColumns)), HTuple.TupleGenConst(hv_NumRows, ((hv_TextColumn.TupleSelect(
                            0)) - hv_MaxStringWidth) - hv_ColumnOffset), hv_AxisColor, "box", "false");
                    }
                }
                //
                //Display column names.
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ColumnNames, "window",
                            HTuple.TupleGenConst(hv_NumColumns, (hv_TextRow.TupleSelect(0)) - hv_RowDistance),
                            hv_TextColumn.TupleSelectRange(0, hv_NumColumns - 1), hv_AxisColor, "box",
                            "false");
                    }
                }
                //
                //
                //Align the numbers right.
                hv_MatrixText.Dispose();
                HOperatorSet.GetFullMatrix(hv_Matrix, out hv_MatrixText);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_MatrixText = hv_MatrixText.TupleString(
                            hv_NumberFormat);
                        hv_MatrixText.Dispose();
                        hv_MatrixText = ExpTmpLocalVar_MatrixText;
                    }
                }
                //
                //
                //Handle no-display indices.
                hv_IdxsDisplay.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_IdxsDisplay = (HTuple.TupleGenSequence(
                        0, (new HTuple(hv_MatrixText.TupleLength())) - 1, 1)).TupleDifference(hv_IdxsNoDisplay);
                }
                //
                //Display confusion matrix.
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_MatrixText.TupleSelect(
                            hv_IdxsDisplay), "window", hv_TextRow.TupleSelect(hv_IdxsDisplay), hv_TextColumn.TupleSelect(
                            hv_IdxsDisplay), hv_ValueColors.TupleSelect(hv_IdxsDisplay), "box", "false");
                    }
                }

                hv_NumRows.Dispose();
                hv_NumColumns.Dispose();
                hv_DisplayColumnWidth.Dispose();
                hv_DisplayColor.Dispose();
                hv_IdxsNoDisplay.Dispose();
                hv_AxisTitles.Dispose();
                hv_ValueColors.Dispose();
                hv_NumberFormat.Dispose();
                hv_Title.Dispose();
                hv_AxisColor.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowColumn.Dispose();
                hv_GenParamKeys.Dispose();
                hv_KeyExists.Dispose();
                hv_ValueTmp.Dispose();
                hv_ColStringWidths.Dispose();
                hv_AllNames.Dispose();
                hv_MaxStringWidth.Dispose();
                hv_StringIndex.Dispose();
                hv_String.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_StringWidth.Dispose();
                hv_StringHeight.Dispose();
                hv_RowStart.Dispose();
                hv_RowDistance.Dispose();
                hv_RowEnd.Dispose();
                hv_ColumnStart.Dispose();
                hv_ColumnOffset.Dispose();
                hv_ColumnEnd.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_WidthLimit.Dispose();
                hv_HeightLimit.Dispose();
                hv_TextRow.Dispose();
                hv_TextColumn.Dispose();
                hv_RowStartTmp.Dispose();
                hv_ColumnDistance.Dispose();
                hv_Index.Dispose();
                hv_TitleAscent.Dispose();
                hv_TitleDescent.Dispose();
                hv_TitleWidth.Dispose();
                hv_TitleHeight.Dispose();
                hv_AxisTitleRowX.Dispose();
                hv_MatrixText.Dispose();
                hv_IdxsDisplay.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_NumRows.Dispose();
                hv_NumColumns.Dispose();
                hv_DisplayColumnWidth.Dispose();
                hv_DisplayColor.Dispose();
                hv_IdxsNoDisplay.Dispose();
                hv_AxisTitles.Dispose();
                hv_ValueColors.Dispose();
                hv_NumberFormat.Dispose();
                hv_Title.Dispose();
                hv_AxisColor.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowColumn.Dispose();
                hv_GenParamKeys.Dispose();
                hv_KeyExists.Dispose();
                hv_ValueTmp.Dispose();
                hv_ColStringWidths.Dispose();
                hv_AllNames.Dispose();
                hv_MaxStringWidth.Dispose();
                hv_StringIndex.Dispose();
                hv_String.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_StringWidth.Dispose();
                hv_StringHeight.Dispose();
                hv_RowStart.Dispose();
                hv_RowDistance.Dispose();
                hv_RowEnd.Dispose();
                hv_ColumnStart.Dispose();
                hv_ColumnOffset.Dispose();
                hv_ColumnEnd.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_WidthLimit.Dispose();
                hv_HeightLimit.Dispose();
                hv_TextRow.Dispose();
                hv_TextColumn.Dispose();
                hv_RowStartTmp.Dispose();
                hv_ColumnDistance.Dispose();
                hv_Index.Dispose();
                hv_TitleAscent.Dispose();
                hv_TitleDescent.Dispose();
                hv_TitleWidth.Dispose();
                hv_TitleHeight.Dispose();
                hv_AxisTitleRowX.Dispose();
                hv_MatrixText.Dispose();
                hv_IdxsDisplay.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_end_of_program(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure closes all example windows.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_Text.Dispose();

                    return;
                }
                //Reopen text window
                dev_display_example_init_text_window(hv_ExampleInternals);
                //
                //Display explanatory text.
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                //
                hv_Text.Dispose();
                hv_Text = new HTuple("Now, the third part 'Evaluation of the trained model' of the workflow");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "for DL object detection is finished.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "The model has been evaluated and the results have been inspected.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("If the performance of the model satisfies the requirements,");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "it can now be applied to new images.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("To see the DL object detection inference process, please run");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "'detect_pills_deep_learning_4_infer.hdev'.";
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Please open the next example.",
                        "window", "bottom", "right", "black", new HTuple(), new HTuple());
                }

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Short Description: Add dict of window handles to close in next call to dev_display_example_reset_window 
        public void dev_display_example_add_window_handles_to_close(HTuple hv_ExampleInternals,
            HTuple hv_WindowHandleDict)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_WindowHandlesToClose = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_Keys = new HTuple();
            HTuple hv_IndexKeys = new HTuple(), hv_WindowHandle = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure saves window handles, which are going to be closed by
                //dev_display_example_reset_window
                //
                hv_WindowHandlesToClose.Dispose();
                hv_WindowHandlesToClose = new HTuple();
                try
                {
                    hv_WindowHandlesToClose.Dispose();
                    HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_handles_to_close",
                        out hv_WindowHandlesToClose);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                }
                hv_Keys.Dispose();
                HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_Keys);
                for (hv_IndexKeys = 0; (int)hv_IndexKeys <= (int)((new HTuple(hv_Keys.TupleLength()
                    )) - 1); hv_IndexKeys = (int)hv_IndexKeys + 1)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_WindowHandle.Dispose();
                        HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_Keys.TupleSelect(hv_IndexKeys),
                            out hv_WindowHandle);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_WindowHandlesToClose = hv_WindowHandlesToClose.TupleConcat(
                                hv_WindowHandle);
                            hv_WindowHandlesToClose.Dispose();
                            hv_WindowHandlesToClose = ExpTmpLocalVar_WindowHandlesToClose;
                        }
                    }
                }
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_handles_to_close", hv_WindowHandlesToClose);

                hv_WindowHandlesToClose.Dispose();
                hv_Exception.Dispose();
                hv_Keys.Dispose();
                hv_IndexKeys.Dispose();
                hv_WindowHandle.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_WindowHandlesToClose.Dispose();
                hv_Exception.Dispose();
                hv_Keys.Dispose();
                hv_IndexKeys.Dispose();
                hv_WindowHandle.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_example_init_text_window(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_WindowWidthText = new HTuple(), hv_WindowHeightText = new HTuple();
            HTuple hv_WindowBGColor = new HTuple(), hv_WindowHandleText = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                hv_WindowWidthText.Dispose();
                hv_WindowWidthText = 800;
                hv_WindowHeightText.Dispose();
                hv_WindowHeightText = 300;
                hv_WindowBGColor.Dispose();
                hv_WindowBGColor = "gray";
                HOperatorSet.SetWindowAttr("background_color", hv_WindowBGColor);
                HOperatorSet.OpenWindow(0, 0, hv_WindowWidthText, hv_WindowHeightText, 0, "visible", "", out hv_WindowHandleText);
                HDevWindowStack.Push(hv_WindowHandleText);
                set_display_font(hv_WindowHandleText, 16, "mono", "true", "false");
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_text", hv_WindowHandleText);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_text_width", hv_WindowWidthText);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_text_height", hv_WindowHeightText);

                hv_WindowWidthText.Dispose();
                hv_WindowHeightText.Dispose();
                hv_WindowBGColor.Dispose();
                hv_WindowHandleText.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_WindowWidthText.Dispose();
                hv_WindowHeightText.Dispose();
                hv_WindowBGColor.Dispose();
                hv_WindowHandleText.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_example_reset_windows(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_WindowHandlesToClose = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_I = new HTuple();
            HTuple hv_WindowHandleKeys = new HTuple(), hv_Index = new HTuple();
            HTuple hv_WindowImagesNeeded = new HTuple(), hv_WindowHandleImages = new HTuple();
            HTuple hv_WindowLegendNeeded = new HTuple(), hv_WindowHandleLegend = new HTuple();
            HTuple hv_ClearWindows = new HTuple(), hv_ClearAllWindows = new HTuple();
            HTuple hv_ClearImageWindow = new HTuple(), hv_ClearLegendWindow = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_ClearTextWindow = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure resets the graphics windows.
                //
                //Close any windows that are listed in key 'window_handles_to_close'.
                try
                {
                    hv_WindowHandlesToClose.Dispose();
                    HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_handles_to_close",
                        out hv_WindowHandlesToClose);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    hv_WindowHandlesToClose.Dispose();
                    hv_WindowHandlesToClose = new HTuple();
                }
                for (hv_I = 0; (int)hv_I <= (int)((new HTuple(hv_WindowHandlesToClose.TupleLength()
                    )) - 1); hv_I = (int)hv_I + 1)
                {
                    HDevWindowStack.SetActive(hv_WindowHandlesToClose.TupleSelect(
                        hv_I));
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                    }
                }
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_handles_to_close", new HTuple());
                //
                //Open image window if needed
                hv_WindowHandleKeys.Dispose();
                HOperatorSet.GetDictParam(hv_ExampleInternals, "keys", new HTuple(), out hv_WindowHandleKeys);
                hv_Index.Dispose();
                HOperatorSet.TupleFind(hv_WindowHandleKeys, "window_images", out hv_Index);
                hv_WindowImagesNeeded.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_needed", out hv_WindowImagesNeeded);
                if ((int)(hv_WindowImagesNeeded.TupleAnd(new HTuple(hv_Index.TupleEqual(-1)))) != 0)
                {
                    //Open new window for images
                    dev_open_example_image_window(hv_ExampleInternals);
                }
                else if ((int)((new HTuple(hv_WindowImagesNeeded.TupleNot())).TupleAnd(
                    new HTuple(hv_Index.TupleNotEqual(-1)))) != 0)
                {
                    //Window for images exists but is not needed -> close it
                    hv_WindowHandleImages.Dispose();
                    HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images", out hv_WindowHandleImages);
                    HDevWindowStack.SetActive(hv_WindowHandleImages);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                    }
                    //Delete key
                    HOperatorSet.RemoveDictKey(hv_ExampleInternals, "window_images");
                }
                //
                //Open legend window if needed
                hv_WindowHandleKeys.Dispose();
                HOperatorSet.GetDictParam(hv_ExampleInternals, "keys", new HTuple(), out hv_WindowHandleKeys);
                hv_Index.Dispose();
                HOperatorSet.TupleFind(hv_WindowHandleKeys, "window_legend", out hv_Index);
                hv_WindowLegendNeeded.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_legend_needed", out hv_WindowLegendNeeded);
                if ((int)(hv_WindowLegendNeeded.TupleAnd(new HTuple(hv_Index.TupleEqual(-1)))) != 0)
                {
                    //Open new window for legend
                    dev_open_example_legend_window(hv_ExampleInternals, 280);
                }
                else if ((int)((new HTuple(hv_WindowLegendNeeded.TupleNot())).TupleAnd(
                    new HTuple(hv_Index.TupleNotEqual(-1)))) != 0)
                {
                    //Window for legend exists but is not needed -> close it
                    hv_WindowHandleLegend.Dispose();
                    HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_legend", out hv_WindowHandleLegend);
                    HDevWindowStack.SetActive(hv_WindowHandleLegend);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                    }
                    //Delete key
                    HOperatorSet.RemoveDictKey(hv_ExampleInternals, "window_legend");
                }
                //
                hv_ClearWindows.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "clear_windows", out hv_ClearWindows);
                hv_ClearAllWindows.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ClearAllWindows = hv_ClearWindows.TupleFind(
                        "all");
                }
                if ((int)((new HTuple(hv_ClearAllWindows.TupleLength())).TupleAnd(new HTuple(hv_ClearAllWindows.TupleGreater(
                    -1)))) != 0)
                {
                    hv_ClearAllWindows.Dispose();
                    hv_ClearAllWindows = 1;
                }
                else
                {
                    hv_ClearAllWindows.Dispose();
                    hv_ClearAllWindows = 0;
                }
                //
                //Set the correct area (part) of the image window.
                try
                {
                    hv_WindowHandleImages.Dispose();
                    HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_image", out hv_WindowHandleImages);
                    hv_ClearImageWindow.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClearImageWindow = hv_ClearWindows.TupleFind(
                            hv_WindowHandleImages);
                    }
                    if ((int)(hv_ClearAllWindows.TupleOr((new HTuple(hv_ClearImageWindow.TupleLength()
                        )).TupleAnd(new HTuple(hv_ClearImageWindow.TupleGreater(-1))))) != 0)
                    {
                        HDevWindowStack.SetActive(hv_WindowHandleImages);
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetPart(HDevWindowStack.GetActive(), 1, 1, -1, -1);
                        }
                    }
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                }
                //
                //Set the correct area (part) of the legend window.
                try
                {
                    hv_WindowHandleLegend.Dispose();
                    HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_legend", out hv_WindowHandleLegend);
                    hv_ClearLegendWindow.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClearLegendWindow = hv_ClearWindows.TupleFind(
                            hv_WindowHandleLegend);
                    }
                    if ((int)(hv_ClearAllWindows.TupleOr((new HTuple(hv_ClearLegendWindow.TupleLength()
                        )).TupleAnd(new HTuple(hv_ClearLegendWindow.TupleGreater(-1))))) != 0)
                    {
                        HDevWindowStack.SetActive(hv_WindowHandleLegend);
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetPart(HDevWindowStack.GetActive(), 1, 1, -1, -1);
                        }
                    }
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                }
                //
                try
                {
                    hv_WindowHandleText.Dispose();
                    HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                    hv_ClearTextWindow.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClearTextWindow = hv_ClearWindows.TupleFind(
                            hv_WindowHandleText);
                    }
                    if ((int)(hv_ClearAllWindows.TupleOr((new HTuple(hv_ClearTextWindow.TupleLength()
                        )).TupleAnd(new HTuple(hv_ClearTextWindow.TupleGreater(-1))))) != 0)
                    {
                        HDevWindowStack.SetActive(hv_WindowHandleText);
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                        }
                    }
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                }

                hv_WindowHandlesToClose.Dispose();
                hv_Exception.Dispose();
                hv_I.Dispose();
                hv_WindowHandleKeys.Dispose();
                hv_Index.Dispose();
                hv_WindowImagesNeeded.Dispose();
                hv_WindowHandleImages.Dispose();
                hv_WindowLegendNeeded.Dispose();
                hv_WindowHandleLegend.Dispose();
                hv_ClearWindows.Dispose();
                hv_ClearAllWindows.Dispose();
                hv_ClearImageWindow.Dispose();
                hv_ClearLegendWindow.Dispose();
                hv_WindowHandleText.Dispose();
                hv_ClearTextWindow.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_WindowHandlesToClose.Dispose();
                hv_Exception.Dispose();
                hv_I.Dispose();
                hv_WindowHandleKeys.Dispose();
                hv_Index.Dispose();
                hv_WindowImagesNeeded.Dispose();
                hv_WindowHandleImages.Dispose();
                hv_WindowLegendNeeded.Dispose();
                hv_WindowHandleLegend.Dispose();
                hv_ClearWindows.Dispose();
                hv_ClearAllWindows.Dispose();
                hv_ClearImageWindow.Dispose();
                hv_ClearLegendWindow.Dispose();
                hv_WindowHandleText.Dispose();
                hv_ClearTextWindow.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_explain_area_ranges(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure displays an explanation of the parameter \'area_ranges\'.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_Text.Dispose();

                    return;
                }
                //
                //Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                dev_display_example_reset_windows(hv_ExampleInternals);
                //
                //Display the overview on the different example parts.
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                //
                hv_Text.Dispose();
                hv_Text = "Parameter 'area_ranges'";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "This parameter allows to evaluate specific area ranges separately.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "It is useful if you have objects of very different sizes and";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "want to evaluate the performance of the model for the different";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "sizes separately.";
                //
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", new HTuple(), new HTuple());
                }
                //

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_explain_detailed_evaluation_part_1(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
            HTuple hv_WindowHandleDict = new HTuple(), hv_ExampleEvaluationResults = new HTuple();
            HTuple hv_ExampleEvaluationParams = new HTuple(), hv_Height = new HTuple();
            HTuple hv_GenParams = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure displays the precision for an example evaluation.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_Text.Dispose();
                    hv_WindowHandleDict.Dispose();
                    hv_ExampleEvaluationResults.Dispose();
                    hv_ExampleEvaluationParams.Dispose();
                    hv_Height.Dispose();
                    hv_GenParams.Dispose();

                    return;
                }
                //
                //Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                dev_display_example_reset_windows(hv_ExampleInternals);
                //
                //Display the overview on the different example parts.
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                //
                hv_Text.Dispose();
                hv_Text = "Detailed Evaluation: Precision";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "If 'evaluate_dl_model' was called with 'detailed_evaluation'";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("enabled, the procedure");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "'dev_display_detection_detailed_evaluation' allows to inspect";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "the results.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("Below, pie charts of the precision (true positive rate) and the");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "false positive rates are shown over all classes and for each class";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "separately for an example evaluation result.";
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", new HTuple(), new HTuple());
                }
                //
                hv_WindowHandleDict.Dispose();
                HOperatorSet.CreateDict(out hv_WindowHandleDict);
                hv_ExampleEvaluationResults.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "example_evaluation_results",
                    out hv_ExampleEvaluationResults);
                hv_ExampleEvaluationParams.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "example_evaluation_params",
                    out hv_ExampleEvaluationParams);
                hv_Height.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text_height", out hv_Height);
                hv_GenParams.Dispose();
                HOperatorSet.CreateDict(out hv_GenParams);
                HOperatorSet.SetDictTuple(hv_GenParams, "display_mode", "pie_charts_precision");
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_GenParams, "window_row", hv_Height + 55);
                }
                dev_display_detection_detailed_evaluation(hv_ExampleEvaluationResults, hv_ExampleEvaluationParams,
                    hv_GenParams, hv_WindowHandleDict);
                //
                dev_display_example_add_window_handles_to_close(hv_ExampleInternals, hv_WindowHandleDict);

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();
                hv_WindowHandleDict.Dispose();
                hv_ExampleEvaluationResults.Dispose();
                hv_ExampleEvaluationParams.Dispose();
                hv_Height.Dispose();
                hv_GenParams.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();
                hv_WindowHandleDict.Dispose();
                hv_ExampleEvaluationResults.Dispose();
                hv_ExampleEvaluationParams.Dispose();
                hv_Height.Dispose();
                hv_GenParams.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_explain_detailed_evaluation_part_2(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
            HTuple hv_WindowHandleDict = new HTuple(), hv_ExampleEvaluationResults = new HTuple();
            HTuple hv_ExampleEvaluationParams = new HTuple(), hv_Height = new HTuple();
            HTuple hv_GenParams = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure displays the recall for an example evaluation.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_Text.Dispose();
                    hv_WindowHandleDict.Dispose();
                    hv_ExampleEvaluationResults.Dispose();
                    hv_ExampleEvaluationParams.Dispose();
                    hv_Height.Dispose();
                    hv_GenParams.Dispose();

                    return;
                }
                //
                //Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                dev_display_example_reset_windows(hv_ExampleInternals);
                //
                //Display the overview on the different example parts.
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                //
                hv_Text.Dispose();
                hv_Text = "Detailed Evaluation: Recall";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("Depending on the values of the parameter 'display_mode',");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "more results can be displayed.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("Below 'display_mode' is set to 'pie_charts_recall', which");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "gives information on the recall and the false negative rate.";
                //
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", new HTuple(), new HTuple());
                }
                //
                hv_WindowHandleDict.Dispose();
                HOperatorSet.CreateDict(out hv_WindowHandleDict);
                hv_ExampleEvaluationResults.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "example_evaluation_results",
                    out hv_ExampleEvaluationResults);
                hv_ExampleEvaluationParams.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "example_evaluation_params",
                    out hv_ExampleEvaluationParams);
                hv_Height.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text_height", out hv_Height);
                hv_GenParams.Dispose();
                HOperatorSet.CreateDict(out hv_GenParams);
                HOperatorSet.SetDictTuple(hv_GenParams, "display_mode", "pie_charts_recall");
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_GenParams, "window_row", hv_Height + 55);
                }
                dev_display_detection_detailed_evaluation(hv_ExampleEvaluationResults, hv_ExampleEvaluationParams,
                    hv_GenParams, hv_WindowHandleDict);
                //
                dev_display_example_add_window_handles_to_close(hv_ExampleInternals, hv_WindowHandleDict);

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();
                hv_WindowHandleDict.Dispose();
                hv_ExampleEvaluationResults.Dispose();
                hv_ExampleEvaluationParams.Dispose();
                hv_Height.Dispose();
                hv_GenParams.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();
                hv_WindowHandleDict.Dispose();
                hv_ExampleEvaluationResults.Dispose();
                hv_ExampleEvaluationParams.Dispose();
                hv_Height.Dispose();
                hv_GenParams.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_explain_detailed_evaluation_part_3(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
            HTuple hv_WindowHandleDict = new HTuple(), hv_ExampleEvaluationResults = new HTuple();
            HTuple hv_ExampleEvaluationParams = new HTuple(), hv_Height = new HTuple();
            HTuple hv_GenParams = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure displays the confusion matrix for an example evaluation.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_Text.Dispose();
                    hv_WindowHandleDict.Dispose();
                    hv_ExampleEvaluationResults.Dispose();
                    hv_ExampleEvaluationParams.Dispose();
                    hv_Height.Dispose();
                    hv_GenParams.Dispose();

                    return;
                }
                //
                //Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                dev_display_example_reset_windows(hv_ExampleInternals);
                //
                //Display the overview on the different example parts.
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                //
                hv_Text.Dispose();
                hv_Text = "Detailed Evaluation: Confusion Matrix";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "The confusion matrix summarizes the pie chart diagrams seen on the";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "two previous screens in one matrix. It can be obtained by setting";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "'display_mode' to 'absolute_confusion_matrix' or";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "'relative_confusion_matrix'.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("Below, the confusion matrix with the absolute numbers is shown for");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "our example evaluation.";
                //
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", new HTuple(), new HTuple());
                }
                //
                hv_WindowHandleDict.Dispose();
                HOperatorSet.CreateDict(out hv_WindowHandleDict);
                hv_ExampleEvaluationResults.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "example_evaluation_results",
                    out hv_ExampleEvaluationResults);
                hv_ExampleEvaluationParams.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "example_evaluation_params",
                    out hv_ExampleEvaluationParams);
                hv_Height.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text_height", out hv_Height);
                hv_GenParams.Dispose();
                HOperatorSet.CreateDict(out hv_GenParams);
                HOperatorSet.SetDictTuple(hv_GenParams, "display_mode", "absolute_confusion_matrix");
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_GenParams, "window_row", hv_Height + 55);
                }
                dev_display_detection_detailed_evaluation(hv_ExampleEvaluationResults, hv_ExampleEvaluationParams,
                    hv_GenParams, hv_WindowHandleDict);
                //
                dev_display_example_add_window_handles_to_close(hv_ExampleInternals, hv_WindowHandleDict);

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();
                hv_WindowHandleDict.Dispose();
                hv_ExampleEvaluationResults.Dispose();
                hv_ExampleEvaluationParams.Dispose();
                hv_Height.Dispose();
                hv_GenParams.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();
                hv_WindowHandleDict.Dispose();
                hv_ExampleEvaluationResults.Dispose();
                hv_ExampleEvaluationParams.Dispose();
                hv_Height.Dispose();
                hv_GenParams.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_explain_detection_scenarios_common(HTuple hv_ExampleInternals,
            HTuple hv_Text, HTuple hv_TitleImage, HTuple hv_DetectionKey, HTuple hv_DetectionValue)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_WindowHandleImages = new HTuple();
            HTuple hv_WindowHandleLegend = new HTuple(), hv_WindowHandleDict = new HTuple();
            HTuple hv_GenParamValue = new HTuple(), hv_WindowImageColumn1 = new HTuple();
            HTuple hv_WindowImageRow1 = new HTuple(), hv_WindowImageWidth = new HTuple();
            HTuple hv_WindowImageHeight = new HTuple(), hv_Row = new HTuple();
            HTuple hv_Column = new HTuple(), hv_Width = new HTuple();
            HTuple hv_Height = new HTuple(), hv_DLDataset = new HTuple();
            HTuple hv_DLResult = new HTuple(), hv_DLSample = new HTuple();
            HTuple hv_DLResultSelected = new HTuple(), hv_GenParam = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_WindowHandleImages.Dispose();
                    hv_WindowHandleLegend.Dispose();
                    hv_WindowHandleDict.Dispose();
                    hv_GenParamValue.Dispose();
                    hv_WindowImageColumn1.Dispose();
                    hv_WindowImageRow1.Dispose();
                    hv_WindowImageWidth.Dispose();
                    hv_WindowImageHeight.Dispose();
                    hv_Row.Dispose();
                    hv_Column.Dispose();
                    hv_Width.Dispose();
                    hv_Height.Dispose();
                    hv_DLDataset.Dispose();
                    hv_DLResult.Dispose();
                    hv_DLSample.Dispose();
                    hv_DLResultSelected.Dispose();
                    hv_GenParam.Dispose();

                    return;
                }
                //
                //Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 1);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 1);
                dev_display_example_reset_windows(hv_ExampleInternals);
                //
                //Display explanatory text.
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", new HTuple(), new HTuple());
                }
                //
                //Display example images,
                hv_WindowHandleImages.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images", out hv_WindowHandleImages);
                //
                //Display a temporary legend.
                hv_WindowHandleLegend.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_legend", out hv_WindowHandleLegend);
                //
                hv_WindowHandleDict.Dispose();
                HOperatorSet.CreateDict(out hv_WindowHandleDict);
                hv_GenParamValue.Dispose();
                HOperatorSet.GetDictParam(hv_ExampleInternals, "keys", new HTuple(), out hv_GenParamValue);
                //To display the Text at the bottom of the image such that the image is undistorted,
                //change size of windows.
                hv_WindowImageColumn1.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_x", out hv_WindowImageColumn1);
                hv_WindowImageRow1.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_y", out hv_WindowImageRow1);
                hv_WindowImageWidth.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_width", out hv_WindowImageWidth);
                hv_WindowImageHeight.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_height", out hv_WindowImageHeight);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_WindowImageHeight = hv_WindowImageHeight + 39.88;
                        hv_WindowImageHeight.Dispose();
                        hv_WindowImageHeight = ExpTmpLocalVar_WindowImageHeight;
                    }
                }
                HDevWindowStack.SetActive(hv_WindowHandleImages);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_WindowImageRow1,
                        hv_WindowImageColumn1, hv_WindowImageWidth, hv_WindowImageHeight);
                }
                //Same for legend window
                hv_Row.Dispose(); hv_Column.Dispose(); hv_Width.Dispose(); hv_Height.Dispose();
                HOperatorSet.GetWindowExtents(hv_WindowHandleLegend, out hv_Row, out hv_Column,
                    out hv_Width, out hv_Height);
                HDevWindowStack.SetActive(hv_WindowHandleLegend);
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_WindowImageRow1,
                            (hv_WindowImageColumn1 + hv_WindowImageWidth) + 5, 290, hv_WindowImageHeight);
                    }
                }
                HDevWindowStack.SetActive(hv_WindowHandleImages);
                //
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_WindowHandleDict, "bbox_both", hv_WindowHandleImages.TupleConcat(
                        hv_WindowHandleLegend));
                }
                //
                //Display the sample contained in tiny dataset.
                hv_DLDataset.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "example_dl_dataset", out hv_DLDataset);
                hv_DLResult.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "example_dl_result", out hv_DLResult);
                //
                hv_DLSample.Dispose();
                gen_dl_samples(hv_DLDataset, 0, "detection", new HTuple(), out hv_DLSample);
                if ((int)((new HTuple(hv_DetectionKey.TupleEqual("bbox_detection_type"))).TupleAnd(
                    new HTuple(hv_DetectionValue.TupleEqual("all")))) != 0)
                {
                    hv_DLResultSelected.Dispose();
                    hv_DLResultSelected = new HTuple(hv_DLResult);
                }
                else
                {
                    hv_DLResultSelected.Dispose();
                    select_dl_results(hv_DLResult, hv_DetectionKey, hv_DetectionValue, out hv_DLResultSelected);
                }
                hv_GenParam.Dispose();
                HOperatorSet.CreateDict(out hv_GenParam);
                HOperatorSet.SetDictTuple(hv_GenParam, "bbox_display_confidence", 0);
                dev_display_dl_data(hv_DLSample, hv_DLResultSelected, hv_DLDataset, "bbox_both",
                    hv_GenParam, hv_WindowHandleDict);
                //
                HDevWindowStack.SetActive(hv_WindowHandleImages);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_TitleImage, "window",
                        "top", "left", "black", new HTuple(), new HTuple());
                }
                HDevWindowStack.SetActive(hv_WindowHandleText);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", new HTuple(), new HTuple());
                }
                HDevWindowStack.SetActive(hv_WindowHandleLegend);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", new HTuple(), new HTuple());
                }

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_WindowHandleImages.Dispose();
                hv_WindowHandleLegend.Dispose();
                hv_WindowHandleDict.Dispose();
                hv_GenParamValue.Dispose();
                hv_WindowImageColumn1.Dispose();
                hv_WindowImageRow1.Dispose();
                hv_WindowImageWidth.Dispose();
                hv_WindowImageHeight.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_DLDataset.Dispose();
                hv_DLResult.Dispose();
                hv_DLSample.Dispose();
                hv_DLResultSelected.Dispose();
                hv_GenParam.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_WindowHandleImages.Dispose();
                hv_WindowHandleLegend.Dispose();
                hv_WindowHandleDict.Dispose();
                hv_GenParamValue.Dispose();
                hv_WindowImageColumn1.Dispose();
                hv_WindowImageRow1.Dispose();
                hv_WindowImageWidth.Dispose();
                hv_WindowImageHeight.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_DLDataset.Dispose();
                hv_DLResult.Dispose();
                hv_DLSample.Dispose();
                hv_DLResultSelected.Dispose();
                hv_GenParam.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_explain_detection_scenarios_part_1(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Text = new HTuple(), hv_DetectionValue = new HTuple();
            HTuple hv_DetectionKey = new HTuple(), hv_TitleImage = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure displays the explanation of detection scenarios.
                //
                //Explanatory text
                hv_Text.Dispose();
                hv_Text = "Detailed Evaluation";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("If 'evaluate_dl_model' is called with 'detailed_evaluation' enabled,");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "the detections for each class are analyzed in detail in addition to the";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "specified measures.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("We will explain the meaning of true positives, false positives, and false");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "negatives in the context of object detection with the help of the example";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("below. Note, that ground truth objects are displayed with transparent");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("rectangles, and predictions with their bounding boxes. This example is");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "artificially created to demonstrate all possible detection scenarios.";
                //
                //Detection type
                hv_DetectionValue.Dispose();
                hv_DetectionValue = "all";
                hv_DetectionKey.Dispose();
                hv_DetectionKey = "bbox_detection_type";
                hv_TitleImage.Dispose();
                hv_TitleImage = "Output of 'apply_dl_model'";
                //
                //Display text and results
                dev_display_screen_explain_detection_scenarios_common(hv_ExampleInternals,
                    hv_Text, hv_TitleImage, hv_DetectionKey, hv_DetectionValue);

                hv_Text.Dispose();
                hv_DetectionValue.Dispose();
                hv_DetectionKey.Dispose();
                hv_TitleImage.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Text.Dispose();
                hv_DetectionValue.Dispose();
                hv_DetectionKey.Dispose();
                hv_TitleImage.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_explain_detection_scenarios_part_2(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Text = new HTuple(), hv_DetectionValue = new HTuple();
            HTuple hv_DetectionKey = new HTuple(), hv_TitleImage = new HTuple();
            HTuple hv_WindowHandleText = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure displays the explanation of detection scenarios.
                //
                //Explanatory text
                hv_Text.Dispose();
                hv_Text = "True Positive Detection (TP)";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "A true positive is a detection where the IoU of the predicted rectangle";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "and the ground truth rectangle is larger than the required minimum IoU";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "and the predicted class is correct.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "Below we see all true positive detections.";
                //
                //Detection type
                hv_DetectionValue.Dispose();
                hv_DetectionValue = "tp";
                hv_DetectionKey.Dispose();
                hv_DetectionKey = "bbox_detection_type";
                hv_TitleImage.Dispose();
                hv_TitleImage = "True Positives (TP)";
                //
                //Display text and results
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "clear_windows", hv_WindowHandleText);
                dev_display_screen_explain_detection_scenarios_common(hv_ExampleInternals,
                    hv_Text, hv_TitleImage, hv_DetectionKey, hv_DetectionValue);

                hv_Text.Dispose();
                hv_DetectionValue.Dispose();
                hv_DetectionKey.Dispose();
                hv_TitleImage.Dispose();
                hv_WindowHandleText.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Text.Dispose();
                hv_DetectionValue.Dispose();
                hv_DetectionKey.Dispose();
                hv_TitleImage.Dispose();
                hv_WindowHandleText.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_explain_detection_scenarios_part_3(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Text = new HTuple(), hv_DetectionValue = new HTuple();
            HTuple hv_DetectionKey = new HTuple(), hv_TitleImage = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure displays the explanation of detection scenarios.
                //
                //Explanatory text.
                hv_Text.Dispose();
                hv_Text = "False Positive on Background (FP bg)";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "A false positive is considered to be on the background if the IoU of";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("the predicted rectangle with all ground truth rectangles is zero, i.e.");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "it has no overlap with any of the ground truth boxes.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "Below we see all false positive background detections.";
                //
                //Detection type
                hv_DetectionValue.Dispose();
                hv_DetectionValue = "fp_bg";
                hv_DetectionKey.Dispose();
                hv_DetectionKey = "bbox_detection_type";
                hv_TitleImage.Dispose();
                hv_TitleImage = "False Positives on Background (FP bg)";
                //
                //Display text and results
                dev_display_screen_explain_detection_scenarios_common(hv_ExampleInternals,
                    hv_Text, hv_TitleImage, hv_DetectionKey, hv_DetectionValue);

                hv_Text.Dispose();
                hv_DetectionValue.Dispose();
                hv_DetectionKey.Dispose();
                hv_TitleImage.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Text.Dispose();
                hv_DetectionValue.Dispose();
                hv_DetectionKey.Dispose();
                hv_TitleImage.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_explain_detection_scenarios_part_4(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Text = new HTuple(), hv_DetectionValue = new HTuple();
            HTuple hv_DetectionKey = new HTuple(), hv_TitleImage = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure displays the explanation of detection scenarios.
                //
                //Explanatory text.
                hv_Text.Dispose();
                hv_Text = "False Positives due to Misclassification (FP class)";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "A detection is considered as misclassified if the IoU of the";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "predicted rectangle is larger than the required minimum IoU of";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "a ground truth box but the predicted class is wrong.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "Below we see all false positive misclassified detections.";
                //
                //Detection type
                hv_DetectionValue.Dispose();
                hv_DetectionValue = "fp_class";
                hv_DetectionKey.Dispose();
                hv_DetectionKey = "bbox_detection_type";
                hv_TitleImage.Dispose();
                hv_TitleImage = "False Positives due to Misclassification (FP class)";
                //
                //Display text and results
                dev_display_screen_explain_detection_scenarios_common(hv_ExampleInternals,
                    hv_Text, hv_TitleImage, hv_DetectionKey, hv_DetectionValue);

                hv_Text.Dispose();
                hv_DetectionValue.Dispose();
                hv_DetectionKey.Dispose();
                hv_TitleImage.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Text.Dispose();
                hv_DetectionValue.Dispose();
                hv_DetectionKey.Dispose();
                hv_TitleImage.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_explain_detection_scenarios_part_5(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Text = new HTuple(), hv_DetectionValue = new HTuple();
            HTuple hv_DetectionKey = new HTuple(), hv_TitleImage = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure displays the first part of the explanation of true positive detections.
                //
                //Explanatory text.
                hv_Text.Dispose();
                hv_Text = "False Positive due to Wrong Location (FP loc)";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "A location of a prediction is considered to be wrong if the IoU is";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("non-zero and below the minimum IoU, and the predicted class matches");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "the ground truth.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "Below we see all false positive detections with a wrong location.";
                //
                //Detection type
                hv_DetectionValue.Dispose();
                hv_DetectionValue = "fp_loc";
                hv_DetectionKey.Dispose();
                hv_DetectionKey = "bbox_detection_type";
                hv_TitleImage.Dispose();
                hv_TitleImage = "False Positive due to Wrong Location (FP loc)";
                //
                //Display text and results
                dev_display_screen_explain_detection_scenarios_common(hv_ExampleInternals,
                    hv_Text, hv_TitleImage, hv_DetectionKey, hv_DetectionValue);

                hv_Text.Dispose();
                hv_DetectionValue.Dispose();
                hv_DetectionKey.Dispose();
                hv_TitleImage.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Text.Dispose();
                hv_DetectionValue.Dispose();
                hv_DetectionKey.Dispose();
                hv_TitleImage.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_explain_detection_scenarios_part_6(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Text = new HTuple(), hv_DetectionValue = new HTuple();
            HTuple hv_DetectionKey = new HTuple(), hv_TitleImage = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure displays the explanation of detection scenarios.
                //
                //Explanatory text.
                hv_Text.Dispose();
                hv_Text = "False Positive due to Duplicate Detections (FP dup)";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "A false positive is considered to be a duplicate if the IoU is higher than";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "the minimum IoU but there exists another detection of the same class";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "which has a higher score.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "Below we see all false positive duplicate detections.";
                //
                //Detection type
                hv_DetectionValue.Dispose();
                hv_DetectionValue = new HTuple();
                hv_DetectionValue[0] = "fp_dup";
                hv_DetectionValue[1] = 3;
                hv_DetectionKey.Dispose();
                hv_DetectionKey = new HTuple();
                hv_DetectionKey[0] = "bbox_detection_type";
                hv_DetectionKey[1] = "bbox_class_id";
                hv_TitleImage.Dispose();
                hv_TitleImage = "False Positive due to Duplicate Detections (FP dup)";
                //
                //Display text and results
                dev_display_screen_explain_detection_scenarios_common(hv_ExampleInternals,
                    hv_Text, hv_TitleImage, hv_DetectionKey, hv_DetectionValue);

                hv_Text.Dispose();
                hv_DetectionValue.Dispose();
                hv_DetectionKey.Dispose();
                hv_TitleImage.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Text.Dispose();
                hv_DetectionValue.Dispose();
                hv_DetectionKey.Dispose();
                hv_TitleImage.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_explain_detection_scenarios_part_7(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Text = new HTuple(), hv_DetectionValue = new HTuple();
            HTuple hv_DetectionKey = new HTuple(), hv_TitleImage = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure displays the explanation of detection scenarios.
                //
                //Explanatory text.
                hv_Text.Dispose();
                hv_Text = "False Positive due to Location and Class (FP mult)";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "A false positive can also occur due to multiple reasons. In this case";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("the IoU is smaller than the required minimum IoU, i.e. the location is");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("wrong, and at the same time the predicted class is wrong.");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "Below we see all false positives of this kind.";
                //
                //Detection type
                hv_DetectionValue.Dispose();
                hv_DetectionValue = "fp_mult";
                hv_DetectionKey.Dispose();
                hv_DetectionKey = "bbox_detection_type";
                hv_TitleImage.Dispose();
                hv_TitleImage = "False Positive due to Location and Class (FP mult)";
                //
                //Display text and results
                dev_display_screen_explain_detection_scenarios_common(hv_ExampleInternals,
                    hv_Text, hv_TitleImage, hv_DetectionKey, hv_DetectionValue);

                hv_Text.Dispose();
                hv_DetectionValue.Dispose();
                hv_DetectionKey.Dispose();
                hv_TitleImage.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Text.Dispose();
                hv_DetectionValue.Dispose();
                hv_DetectionKey.Dispose();
                hv_TitleImage.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_explain_detection_scenarios_part_8(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Text = new HTuple(), hv_DetectionValue = new HTuple();
            HTuple hv_DetectionKey = new HTuple(), hv_TitleImage = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure displays the explanation of detection scenarios.
                //
                //Explanatory text.
                hv_Text.Dispose();
                hv_Text = "False Negative";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("A false negative occurs, if there is no true positive detection for");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "a given ground truth object.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("Below, we have false negatives for the classes with 'class_id' = 5");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("and 'class_id' = 8, as there are ground truth objects for these");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("classes, but no true positive predictions.");
                //
                //Detection type
                hv_DetectionValue.Dispose();
                hv_DetectionValue = "all";
                hv_DetectionKey.Dispose();
                hv_DetectionKey = "bbox_detection_type";
                hv_TitleImage.Dispose();
                hv_TitleImage = "False Negative (FN)";
                //
                //Display text and results
                dev_display_screen_explain_detection_scenarios_common(hv_ExampleInternals,
                    hv_Text, hv_TitleImage, hv_DetectionKey, hv_DetectionValue);

                hv_Text.Dispose();
                hv_DetectionValue.Dispose();
                hv_DetectionKey.Dispose();
                hv_TitleImage.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Text.Dispose();
                hv_DetectionValue.Dispose();
                hv_DetectionKey.Dispose();
                hv_TitleImage.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_explain_evaluation(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleImages = new HTuple(), hv_WindowHandleText = new HTuple();
            HTuple hv_Text = new HTuple(), hv_ExampleEvaluationResults = new HTuple();
            HTuple hv_ExampleEvaluationParams = new HTuple(), hv_EvaluationResultsArea = new HTuple();
            HTuple hv_EvaluationResultsIoU = new HTuple(), hv_EvaluationResultsIoUKeys = new HTuple();
            HTuple hv_IoUKeys = new HTuple(), hv_ClassKeys = new HTuple();
            HTuple hv_KeyIndex = new HTuple(), hv_EvaluationResultsIoU0 = new HTuple();
            HTuple hv_MatrixID = new HTuple(), hv_ColIndex = new HTuple();
            HTuple hv_IoUClassAP = new HTuple(), hv_RowIndex = new HTuple();
            HTuple hv_ClassAP = new HTuple(), hv_MeanIoUAP = new HTuple();
            HTuple hv_MeanAP = new HTuple(), hv_GenParam = new HTuple();
            HTuple hv_TextWindowHeight = new HTuple(), hv_Colors = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure displays shows the result of an example evaluation.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleImages.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_Text.Dispose();
                    hv_ExampleEvaluationResults.Dispose();
                    hv_ExampleEvaluationParams.Dispose();
                    hv_EvaluationResultsArea.Dispose();
                    hv_EvaluationResultsIoU.Dispose();
                    hv_EvaluationResultsIoUKeys.Dispose();
                    hv_IoUKeys.Dispose();
                    hv_ClassKeys.Dispose();
                    hv_KeyIndex.Dispose();
                    hv_EvaluationResultsIoU0.Dispose();
                    hv_MatrixID.Dispose();
                    hv_ColIndex.Dispose();
                    hv_IoUClassAP.Dispose();
                    hv_RowIndex.Dispose();
                    hv_ClassAP.Dispose();
                    hv_MeanIoUAP.Dispose();
                    hv_MeanAP.Dispose();
                    hv_GenParam.Dispose();
                    hv_TextWindowHeight.Dispose();
                    hv_Colors.Dispose();

                    return;
                }
                //
                //Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 1);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                dev_display_example_reset_windows(hv_ExampleInternals);
                hv_WindowHandleImages.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images", out hv_WindowHandleImages);
                //
                //Display the overview on the different example parts.
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                //
                hv_Text.Dispose();
                hv_Text = "Evaluation Results";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "The result of an evaluation is returned in the dict EvaluationResult.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "Below you see the main results for an example evaluation with three IoU";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "thresholds. For each class and each IoU value the average precision (AP)";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "was calculated as area under the precision-recall curve. In the last row";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("the mean AP over all classes, the 'mean_class_ap', is displayed. The last");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "column shows the mean AP over the IoU thresholds for each class";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("('mean_iou_ap'). The 'mean_ap' is the mean of these mean values, and");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "summarizes the evaluation results with a single value.";
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", new HTuple(), new HTuple());
                }
                //
                hv_ExampleEvaluationResults.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "example_evaluation_results",
                    out hv_ExampleEvaluationResults);
                hv_ExampleEvaluationParams.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "example_evaluation_params",
                    out hv_ExampleEvaluationParams);
                //
                //Select the results of interest
                hv_EvaluationResultsArea.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleEvaluationResults, "max_num_detections_all",
                    out hv_EvaluationResultsArea);
                hv_EvaluationResultsIoU.Dispose();
                HOperatorSet.GetDictTuple(hv_EvaluationResultsArea, "area_all", out hv_EvaluationResultsIoU);
                hv_EvaluationResultsIoUKeys.Dispose();
                HOperatorSet.GetDictParam(hv_EvaluationResultsIoU, "keys", new HTuple(), out hv_EvaluationResultsIoUKeys);
                //
                hv_IoUKeys.Dispose();
                hv_IoUKeys = new HTuple();
                hv_ClassKeys.Dispose();
                hv_ClassKeys = new HTuple();
                for (hv_KeyIndex = 0; (int)hv_KeyIndex <= (int)((new HTuple(hv_EvaluationResultsIoUKeys.TupleLength()
                    )) - 1); hv_KeyIndex = (int)hv_KeyIndex + 1)
                {
                    if ((int)(new HTuple(((hv_EvaluationResultsIoUKeys.TupleSelect(hv_KeyIndex))).TupleRegexpTest(
                        "ap_iou_.*"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_IoUKeys = hv_IoUKeys.TupleConcat(
                                    hv_EvaluationResultsIoUKeys.TupleSelect(hv_KeyIndex));
                                hv_IoUKeys.Dispose();
                                hv_IoUKeys = ExpTmpLocalVar_IoUKeys;
                            }
                        }
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_EvaluationResultsIoU0.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvaluationResultsIoU, hv_IoUKeys.TupleSelect(0),
                        out hv_EvaluationResultsIoU0);
                }
                hv_ClassKeys.Dispose();
                HOperatorSet.GetDictParam(hv_EvaluationResultsIoU0, "keys", new HTuple(), out hv_ClassKeys);
                //
                //Create and fill AP matrix
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_MatrixID.Dispose();
                    HOperatorSet.CreateMatrix(new HTuple(hv_ClassKeys.TupleLength()), (new HTuple(hv_IoUKeys.TupleLength()
                        )) + 1, 0.0, out hv_MatrixID);
                }
                for (hv_ColIndex = 0; (int)hv_ColIndex <= (int)((new HTuple(hv_IoUKeys.TupleLength()
                    )) - 1); hv_ColIndex = (int)hv_ColIndex + 1)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_IoUClassAP.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvaluationResultsIoU, hv_IoUKeys.TupleSelect(
                            hv_ColIndex), out hv_IoUClassAP);
                    }
                    for (hv_RowIndex = 0; (int)hv_RowIndex <= (int)((new HTuple(hv_ClassKeys.TupleLength()
                        )) - 1); hv_RowIndex = (int)hv_RowIndex + 1)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClassAP.Dispose();
                            HOperatorSet.GetDictTuple(hv_IoUClassAP, hv_ClassKeys.TupleSelect(hv_RowIndex),
                                out hv_ClassAP);
                        }
                        HOperatorSet.SetValueMatrix(hv_MatrixID, hv_RowIndex, hv_ColIndex, hv_ClassAP);
                    }
                }
                //
                //Add mean IoU AP column
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_IoUKeys = hv_IoUKeys.TupleConcat(
                            "mean_iou_ap");
                        hv_IoUKeys.Dispose();
                        hv_IoUKeys = ExpTmpLocalVar_IoUKeys;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_MeanIoUAP.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvaluationResultsIoU, hv_IoUKeys.TupleSelect((new HTuple(hv_IoUKeys.TupleLength()
                        )) - 1), out hv_MeanIoUAP);
                }
                for (hv_RowIndex = 0; (int)hv_RowIndex <= (int)((new HTuple(hv_ClassKeys.TupleLength()
                    )) - 2); hv_RowIndex = (int)hv_RowIndex + 1)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassAP.Dispose();
                        HOperatorSet.GetDictTuple(hv_MeanIoUAP, hv_ClassKeys.TupleSelect(hv_RowIndex),
                            out hv_ClassAP);
                    }
                    HOperatorSet.SetValueMatrix(hv_MatrixID, hv_RowIndex, hv_ColIndex, hv_ClassAP);
                }
                //
                //Add mean IoU
                hv_MeanAP.Dispose();
                HOperatorSet.GetDictTuple(hv_EvaluationResultsIoU, "mean_ap", out hv_MeanAP);
                HOperatorSet.SetValueMatrix(hv_MatrixID, hv_RowIndex, hv_ColIndex, hv_MeanAP);
                //
                //Display AP matrix
                hv_GenParam.Dispose();
                HOperatorSet.CreateDict(out hv_GenParam);
                HOperatorSet.SetDictTuple(hv_GenParam, "number_format", "1.2f");
                hv_TextWindowHeight.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text_height", out hv_TextWindowHeight);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_GenParam, "window_row", hv_TextWindowHeight + 55);
                }
                HOperatorSet.SetDictTuple(hv_GenParam, "title", "Evaluation Results: Class and Mean AP");
                HOperatorSet.SetDictTuple(hv_GenParam, "row_col_names_color", "black");
                HOperatorSet.SetDictTuple(hv_GenParam, "axis_titles", (new HTuple("IoU thresholds")).TupleConcat(
                    "Classes"));
                HOperatorSet.SetDictTuple(hv_GenParam, "display_color", 1);
                hv_Colors.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Colors = HTuple.TupleGenConst(
                        (new HTuple(hv_IoUKeys.TupleLength())) * (new HTuple(hv_ClassKeys.TupleLength()
                        )), "navy");
                }
                if (hv_Colors == null)
                    hv_Colors = new HTuple();
                hv_Colors[(new HTuple(hv_Colors.TupleLength())) - 1] = "forest green";
                HOperatorSet.SetDictTuple(hv_GenParam, "value_colors", hv_Colors);
                dev_display_ap_matrix(hv_MatrixID, hv_IoUKeys, hv_ClassKeys, hv_WindowHandleImages,
                    hv_GenParam);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "mean_ap", "window", "bottom",
                        "right", "forest green", "box", "false");
                }
                //

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleImages.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();
                hv_ExampleEvaluationResults.Dispose();
                hv_ExampleEvaluationParams.Dispose();
                hv_EvaluationResultsArea.Dispose();
                hv_EvaluationResultsIoU.Dispose();
                hv_EvaluationResultsIoUKeys.Dispose();
                hv_IoUKeys.Dispose();
                hv_ClassKeys.Dispose();
                hv_KeyIndex.Dispose();
                hv_EvaluationResultsIoU0.Dispose();
                hv_MatrixID.Dispose();
                hv_ColIndex.Dispose();
                hv_IoUClassAP.Dispose();
                hv_RowIndex.Dispose();
                hv_ClassAP.Dispose();
                hv_MeanIoUAP.Dispose();
                hv_MeanAP.Dispose();
                hv_GenParam.Dispose();
                hv_TextWindowHeight.Dispose();
                hv_Colors.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleImages.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();
                hv_ExampleEvaluationResults.Dispose();
                hv_ExampleEvaluationParams.Dispose();
                hv_EvaluationResultsArea.Dispose();
                hv_EvaluationResultsIoU.Dispose();
                hv_EvaluationResultsIoUKeys.Dispose();
                hv_IoUKeys.Dispose();
                hv_ClassKeys.Dispose();
                hv_KeyIndex.Dispose();
                hv_EvaluationResultsIoU0.Dispose();
                hv_MatrixID.Dispose();
                hv_ColIndex.Dispose();
                hv_IoUClassAP.Dispose();
                hv_RowIndex.Dispose();
                hv_ClassAP.Dispose();
                hv_MeanIoUAP.Dispose();
                hv_MeanAP.Dispose();
                hv_GenParam.Dispose();
                hv_TextWindowHeight.Dispose();
                hv_Colors.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_explain_iou_threshold(HTuple hv_ExampleInternals)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Background, ho_RectanglesGT, ho_RectangleGT;
            HObject ho_RectanglesPrediction, ho_RectanglePrediction;
            HObject ho_Intersection = null, ho_Union = null, ho_IoUImage;
            HObject ho_ImageBottom, ho_Images, ho_TiledImage;

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_TextWindowHeight = new HTuple(), hv_TextWindowWidth = new HTuple();
            HTuple hv_Height = new HTuple(), hv_WindowHandleImages = new HTuple();
            HTuple hv_ColorGT = new HTuple(), hv_ColorPrediction = new HTuple();
            HTuple hv_NumRectangles = new HTuple(), hv_RectangleIndex = new HTuple();
            HTuple hv_AreaUnion = new HTuple(), hv__ = new HTuple();
            HTuple hv_AreaIntersection = new HTuple(), hv_Row = new HTuple();
            HTuple hv_Column = new HTuple(), hv_IoU = new HTuple();
            HTuple hv_IoUString = new HTuple(), hv_Ascent = new HTuple();
            HTuple hv_Descent = new HTuple(), hv_IoUStringWidth = new HTuple();
            HTuple hv_IoUStringHeight = new HTuple(), hv_WindowHandleLegend = new HTuple();
            HTuple hv_IoUWidth = new HTuple(), hv_IoUHeight = new HTuple();
            HTuple hv_Crop = new HTuple(), hv_TextIoU = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_ExampleEvaluationParams = new HTuple();
            HTuple hv_IoUThreshold = new HTuple(), hv_IoUThresholdString = new HTuple();
            HTuple hv_ExampleEvaluationResults = new HTuple(), hv_Text = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Background);
            HOperatorSet.GenEmptyObj(out ho_RectanglesGT);
            HOperatorSet.GenEmptyObj(out ho_RectangleGT);
            HOperatorSet.GenEmptyObj(out ho_RectanglesPrediction);
            HOperatorSet.GenEmptyObj(out ho_RectanglePrediction);
            HOperatorSet.GenEmptyObj(out ho_Intersection);
            HOperatorSet.GenEmptyObj(out ho_Union);
            HOperatorSet.GenEmptyObj(out ho_IoUImage);
            HOperatorSet.GenEmptyObj(out ho_ImageBottom);
            HOperatorSet.GenEmptyObj(out ho_Images);
            HOperatorSet.GenEmptyObj(out ho_TiledImage);
            try
            {
                //This procedure displays an explanation of the parameter 'iou_threshold'.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {
                    ho_Background.Dispose();
                    ho_RectanglesGT.Dispose();
                    ho_RectangleGT.Dispose();
                    ho_RectanglesPrediction.Dispose();
                    ho_RectanglePrediction.Dispose();
                    ho_Intersection.Dispose();
                    ho_Union.Dispose();
                    ho_IoUImage.Dispose();
                    ho_ImageBottom.Dispose();
                    ho_Images.Dispose();
                    ho_TiledImage.Dispose();

                    hv_ShowExampleScreens.Dispose();
                    hv_TextWindowHeight.Dispose();
                    hv_TextWindowWidth.Dispose();
                    hv_Height.Dispose();
                    hv_WindowHandleImages.Dispose();
                    hv_ColorGT.Dispose();
                    hv_ColorPrediction.Dispose();
                    hv_NumRectangles.Dispose();
                    hv_RectangleIndex.Dispose();
                    hv_AreaUnion.Dispose();
                    hv__.Dispose();
                    hv_AreaIntersection.Dispose();
                    hv_Row.Dispose();
                    hv_Column.Dispose();
                    hv_IoU.Dispose();
                    hv_IoUString.Dispose();
                    hv_Ascent.Dispose();
                    hv_Descent.Dispose();
                    hv_IoUStringWidth.Dispose();
                    hv_IoUStringHeight.Dispose();
                    hv_WindowHandleLegend.Dispose();
                    hv_IoUWidth.Dispose();
                    hv_IoUHeight.Dispose();
                    hv_Crop.Dispose();
                    hv_TextIoU.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_ExampleEvaluationParams.Dispose();
                    hv_IoUThreshold.Dispose();
                    hv_IoUThresholdString.Dispose();
                    hv_ExampleEvaluationResults.Dispose();
                    hv_Text.Dispose();

                    return;
                }
                //
                //Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 1);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 1);
                dev_display_example_reset_windows(hv_ExampleInternals);
                //
                hv_TextWindowHeight.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text_height", out hv_TextWindowHeight);
                hv_TextWindowWidth.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text_width", out hv_TextWindowWidth);
                hv_Height.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Height = hv_TextWindowHeight + 20;
                }
                //
                //Display example IoU values.
                hv_WindowHandleImages.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images", out hv_WindowHandleImages);
                HDevWindowStack.SetActive(hv_WindowHandleImages);
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_TextWindowHeight + 55,
                            0, hv_TextWindowWidth, hv_Height);
                    }
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                }
                ho_Background.Dispose();
                HOperatorSet.GenImageConst(out ho_Background, "byte", hv_TextWindowWidth, hv_Height);
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.PaintRegion(ho_Background, ho_Background, out ExpTmpOutVar_0,
                        255, "fill");
                    ho_Background.Dispose();
                    ho_Background = ExpTmpOutVar_0;
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispObj(ho_Background, HDevWindowStack.GetActive());
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 3);
                }
                hv_ColorGT.Dispose();
                hv_ColorGT = "#ff781aff";
                hv_ColorPrediction.Dispose();
                hv_ColorPrediction = "#48c2ffff";
                //
                ho_RectanglesGT.Dispose();
                HOperatorSet.GenEmptyObj(out ho_RectanglesGT);
                ho_RectangleGT.Dispose();
                HOperatorSet.GenRectangle1(out ho_RectangleGT, 25, 570, 100, 735);
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_RectanglesGT, ho_RectangleGT, out ExpTmpOutVar_0);
                    ho_RectanglesGT.Dispose();
                    ho_RectanglesGT = ExpTmpOutVar_0;
                }
                ho_RectangleGT.Dispose();
                HOperatorSet.GenRectangle1(out ho_RectangleGT, 180, 60, 255, 225);
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_RectanglesGT, ho_RectangleGT, out ExpTmpOutVar_0);
                    ho_RectanglesGT.Dispose();
                    ho_RectanglesGT = ExpTmpOutVar_0;
                }
                ho_RectangleGT.Dispose();
                HOperatorSet.GenRectangle1(out ho_RectangleGT, 100, 300, 175, 465);
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_RectanglesGT, ho_RectangleGT, out ExpTmpOutVar_0);
                    ho_RectanglesGT.Dispose();
                    ho_RectanglesGT = ExpTmpOutVar_0;
                }
                //
                ho_RectanglesPrediction.Dispose();
                HOperatorSet.GenEmptyObj(out ho_RectanglesPrediction);
                ho_RectanglePrediction.Dispose();
                HOperatorSet.GenRectangle1(out ho_RectanglePrediction, 20, 565, 105, 730);
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_RectanglesPrediction, ho_RectanglePrediction, out ExpTmpOutVar_0
                        );
                    ho_RectanglesPrediction.Dispose();
                    ho_RectanglesPrediction = ExpTmpOutVar_0;
                }
                ho_RectanglePrediction.Dispose();
                HOperatorSet.GenRectangle1(out ho_RectanglePrediction, 220, 30, 300, 190);
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_RectanglesPrediction, ho_RectanglePrediction, out ExpTmpOutVar_0
                        );
                    ho_RectanglesPrediction.Dispose();
                    ho_RectanglesPrediction = ExpTmpOutVar_0;
                }
                ho_RectanglePrediction.Dispose();
                HOperatorSet.GenRectangle1(out ho_RectanglePrediction, 80, 315, 160, 480);
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_RectanglesPrediction, ho_RectanglePrediction, out ExpTmpOutVar_0
                        );
                    ho_RectanglesPrediction.Dispose();
                    ho_RectanglesPrediction = ExpTmpOutVar_0;
                }
                //
                hv_NumRectangles.Dispose();
                HOperatorSet.CountObj(ho_RectanglesPrediction, out hv_NumRectangles);
                HTuple end_val46 = hv_NumRectangles;
                HTuple step_val46 = 1;
                for (hv_RectangleIndex = 1; hv_RectangleIndex.Continue(end_val46, step_val46); hv_RectangleIndex = hv_RectangleIndex.TupleAdd(step_val46))
                {
                    ho_RectangleGT.Dispose();
                    HOperatorSet.SelectObj(ho_RectanglesGT, out ho_RectangleGT, hv_RectangleIndex);
                    ho_RectanglePrediction.Dispose();
                    HOperatorSet.SelectObj(ho_RectanglesPrediction, out ho_RectanglePrediction,
                        hv_RectangleIndex);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_ColorGT);
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_RectangleGT, HDevWindowStack.GetActive());
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_ColorPrediction);
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_RectanglePrediction, HDevWindowStack.GetActive()
                            );
                    }
                    ho_Intersection.Dispose();
                    HOperatorSet.Intersection(ho_RectangleGT, ho_RectanglePrediction, out ho_Intersection
                        );
                    ho_Union.Dispose();
                    HOperatorSet.Union2(ho_RectangleGT, ho_RectanglePrediction, out ho_Union);
                    hv_AreaUnion.Dispose(); hv__.Dispose(); hv__.Dispose();
                    HOperatorSet.AreaCenter(ho_Union, out hv_AreaUnion, out hv__, out hv__);
                    hv_AreaIntersection.Dispose(); hv_Row.Dispose(); hv_Column.Dispose();
                    HOperatorSet.AreaCenter(ho_Intersection, out hv_AreaIntersection, out hv_Row,
                        out hv_Column);
                    hv_IoU.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_IoU = hv_AreaIntersection / (hv_AreaUnion.TupleReal()
                            );
                    }
                    hv_IoUString.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_IoUString = "IoU = " + (hv_IoU.TupleString(
                            ".2f"));
                    }
                    hv_Ascent.Dispose(); hv_Descent.Dispose(); hv_IoUStringWidth.Dispose(); hv_IoUStringHeight.Dispose();
                    HOperatorSet.GetStringExtents(hv_WindowHandleImages, hv_IoUString, out hv_Ascent,
                        out hv_Descent, out hv_IoUStringWidth, out hv_IoUStringHeight);
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_IoUString, "image",
                                hv_Row - hv_IoUStringHeight, hv_Column - (hv_IoUStringWidth / 2), "black",
                                new HTuple(), new HTuple());
                        }
                    }
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Example IoU values",
                        "window", "top", "left", "black", new HTuple(), new HTuple());
                }
                //
                //Display graphical IoU formula.
                hv_WindowHandleLegend.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_legend", out hv_WindowHandleLegend);
                HDevWindowStack.SetActive(hv_WindowHandleLegend);
                hv_TextWindowHeight.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text_height", out hv_TextWindowHeight);
                hv_Height.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Height = hv_TextWindowHeight + 20;
                }
                ho_IoUImage.Dispose();
                HOperatorSet.ReadImage(out ho_IoUImage, "dl_explanation/evaluation_det_iou");
                hv_IoUWidth.Dispose(); hv_IoUHeight.Dispose();
                HOperatorSet.GetImageSize(ho_IoUImage, out hv_IoUWidth, out hv_IoUHeight);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_ImageBottom.Dispose();
                    HOperatorSet.GenImageConst(out ho_ImageBottom, "byte", hv_IoUWidth, hv_Height - hv_IoUHeight);
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.PaintRegion(ho_ImageBottom, ho_ImageBottom, out ExpTmpOutVar_0,
                        255, "fill");
                    ho_ImageBottom.Dispose();
                    ho_ImageBottom = ExpTmpOutVar_0;
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.Compose3(ho_ImageBottom, ho_ImageBottom, ho_ImageBottom, out ExpTmpOutVar_0
                        );
                    ho_ImageBottom.Dispose();
                    ho_ImageBottom = ExpTmpOutVar_0;
                }
                ho_Images.Dispose();
                HOperatorSet.ConcatObj(ho_IoUImage, ho_ImageBottom, out ho_Images);
                hv_Crop.Dispose();
                hv_Crop = new HTuple();
                hv_Crop[0] = -1;
                hv_Crop[1] = -1;
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_TiledImage.Dispose();
                    HOperatorSet.TileImagesOffset(ho_Images, out ho_TiledImage, (new HTuple(0)).TupleConcat(
                        hv_IoUHeight), (new HTuple(0)).TupleConcat(0), hv_Crop, hv_Crop, hv_Crop,
                        hv_Crop, hv_IoUWidth, hv_Height);
                }
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_TextWindowHeight + 55,
                            hv_TextWindowWidth + 6, hv_IoUWidth, hv_Height);
                    }
                }
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_Height - 1, hv_IoUWidth - 1);
                    }
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispObj(ho_TiledImage, HDevWindowStack.GetActive());
                }
                hv_TextIoU.Dispose();
                hv_TextIoU = "Intersection over union (IoU)";
                if (hv_TextIoU == null)
                    hv_TextIoU = new HTuple();
                hv_TextIoU[new HTuple(hv_TextIoU.TupleLength())] = "ground truth";
                if (hv_TextIoU == null)
                    hv_TextIoU = new HTuple();
                hv_TextIoU[new HTuple(hv_TextIoU.TupleLength())] = "prediction";
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_TextIoU, "window",
                        "bottom", "center", ((new HTuple("black")).TupleConcat("#ff781aff")).TupleConcat(
                        "#48c2ffff"), new HTuple(), new HTuple());
                }
                //
                //Display the explanation.
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                //
                hv_ExampleEvaluationParams.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "example_evaluation_params",
                    out hv_ExampleEvaluationParams);
                hv_IoUThreshold.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleEvaluationParams, "iou_threshold", out hv_IoUThreshold);
                hv_IoUThresholdString.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_IoUThresholdString = "[" + (((hv_IoUThreshold.TupleSelect(
                        0))).TupleString(".2f"));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_IoUThresholdString = (hv_IoUThresholdString + new HTuple(", ")) + (((hv_IoUThreshold.TupleSelect(
                            1))).TupleString(".2f"));
                        hv_IoUThresholdString.Dispose();
                        hv_IoUThresholdString = ExpTmpLocalVar_IoUThresholdString;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_IoUThresholdString = ((hv_IoUThresholdString + new HTuple(",..., ")) + (((hv_IoUThreshold.TupleSelect(
                            (new HTuple(hv_IoUThreshold.TupleLength())) - 1))).TupleString(".2f"))) + "]";
                        hv_IoUThresholdString.Dispose();
                        hv_IoUThresholdString = ExpTmpLocalVar_IoUThresholdString;
                    }
                }
                hv_ExampleEvaluationResults.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "example_evaluation_results",
                    out hv_ExampleEvaluationResults);

                hv_Text.Dispose();
                hv_Text = "IoU Thresholds";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "The parameter 'iou_threshold' specifies the thresholds on the";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "intersection over union (IoU) used during evaluation. The IoU";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("quantifies, how precise a detection matches a ground truth");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "object (see below). An exact match results in an IoU = 1.0.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "As default the evaluation is performed for the thresholds";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = ("'iou_threshold' = " + hv_IoUThresholdString) + ". For each of these IoU";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "thresholds the measure 'mean_ap' and the average precision for each";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "class are calculated as area under the precision-recall curve. These";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "measures are additionally computed as average over all respective values";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "per IoU threshold.";
                HDevWindowStack.SetActive(hv_WindowHandleText);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", new HTuple(), new HTuple());
                }
                //
                ho_Background.Dispose();
                ho_RectanglesGT.Dispose();
                ho_RectangleGT.Dispose();
                ho_RectanglesPrediction.Dispose();
                ho_RectanglePrediction.Dispose();
                ho_Intersection.Dispose();
                ho_Union.Dispose();
                ho_IoUImage.Dispose();
                ho_ImageBottom.Dispose();
                ho_Images.Dispose();
                ho_TiledImage.Dispose();

                hv_ShowExampleScreens.Dispose();
                hv_TextWindowHeight.Dispose();
                hv_TextWindowWidth.Dispose();
                hv_Height.Dispose();
                hv_WindowHandleImages.Dispose();
                hv_ColorGT.Dispose();
                hv_ColorPrediction.Dispose();
                hv_NumRectangles.Dispose();
                hv_RectangleIndex.Dispose();
                hv_AreaUnion.Dispose();
                hv__.Dispose();
                hv_AreaIntersection.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();
                hv_IoU.Dispose();
                hv_IoUString.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_IoUStringWidth.Dispose();
                hv_IoUStringHeight.Dispose();
                hv_WindowHandleLegend.Dispose();
                hv_IoUWidth.Dispose();
                hv_IoUHeight.Dispose();
                hv_Crop.Dispose();
                hv_TextIoU.Dispose();
                hv_WindowHandleText.Dispose();
                hv_ExampleEvaluationParams.Dispose();
                hv_IoUThreshold.Dispose();
                hv_IoUThresholdString.Dispose();
                hv_ExampleEvaluationResults.Dispose();
                hv_Text.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Background.Dispose();
                ho_RectanglesGT.Dispose();
                ho_RectangleGT.Dispose();
                ho_RectanglesPrediction.Dispose();
                ho_RectanglePrediction.Dispose();
                ho_Intersection.Dispose();
                ho_Union.Dispose();
                ho_IoUImage.Dispose();
                ho_ImageBottom.Dispose();
                ho_Images.Dispose();
                ho_TiledImage.Dispose();

                hv_ShowExampleScreens.Dispose();
                hv_TextWindowHeight.Dispose();
                hv_TextWindowWidth.Dispose();
                hv_Height.Dispose();
                hv_WindowHandleImages.Dispose();
                hv_ColorGT.Dispose();
                hv_ColorPrediction.Dispose();
                hv_NumRectangles.Dispose();
                hv_RectangleIndex.Dispose();
                hv_AreaUnion.Dispose();
                hv__.Dispose();
                hv_AreaIntersection.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();
                hv_IoU.Dispose();
                hv_IoUString.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_IoUStringWidth.Dispose();
                hv_IoUStringHeight.Dispose();
                hv_WindowHandleLegend.Dispose();
                hv_IoUWidth.Dispose();
                hv_IoUHeight.Dispose();
                hv_Crop.Dispose();
                hv_TextIoU.Dispose();
                hv_WindowHandleText.Dispose();
                hv_ExampleEvaluationParams.Dispose();
                hv_IoUThreshold.Dispose();
                hv_IoUThresholdString.Dispose();
                hv_ExampleEvaluationResults.Dispose();
                hv_Text.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_explain_max_num_detections(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure displays an explanation of the parameter 'max_num_detections'.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_Text.Dispose();

                    return;
                }
                //
                //Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                dev_display_example_reset_windows(hv_ExampleInternals);
                //
                //Display the overview on the different example parts.
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                //
                hv_Text.Dispose();
                hv_Text = "Parameter 'max_num_detections'";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "This parameter allows to restrict the number of results considered during";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "evaluation. Starting from the result with the highest confidence only";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "'max_num_detections' results per class are considered.";
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", new HTuple(), new HTuple());
                }
                //

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_explain_measures(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure explains the parameter 'measure' of the procedure 'evaluate_dl_model'.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_Text.Dispose();

                    return;
                }
                //
                //Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                dev_display_example_reset_windows(hv_ExampleInternals);
                //
                //Display the overview on the different example parts.
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                //
                hv_Text.Dispose();
                hv_Text = "Evaluation Measures";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "'evaluate_dl_model' evaluates the performance of a model with respect to";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "one or more measures. In the case of object detection the mean average";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("precision, the 'mean_ap', is used.");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "The 'mean_ap' is useful to summarize the performance of the detection";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("model, e.g. during training or for a high-level comparison of different");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "models. It is selected via the parameter 'measures'.";
                //
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", new HTuple(), new HTuple());
                }
                //

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_introduction_evaluation(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure explains the evaluation of an object detection model.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_Text.Dispose();

                    return;
                }
                //
                //Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                dev_display_example_reset_windows(hv_ExampleInternals);
                //
                //Display the overview on the different example parts.
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                //
                hv_Text.Dispose();
                hv_Text = "Evaluation of an Object Detection Model";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("For the evaluation of an object detection model on a dataset, we use");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "the procedure 'evaluate_dl_model'. This procedure is used during training";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "to evaluate the current performance of the model on the validation data";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "with respect to the measure 'mean_ap'. After training the evaluation is";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "useful to finetune the model parameters for non-maximum suppression";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("('min_confidence', 'max_num_detections', 'max_overlap',");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("'max_overlap_class_agnostic'), and to compare the performance of");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "different models.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "On the following screen we will explain the available measures.";
                //
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", new HTuple(), new HTuple());
                }
                //

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_introduction_part_1(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure displays an overview on the different example parts.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_Text.Dispose();

                    return;
                }
                //
                //Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                dev_display_example_reset_windows(hv_ExampleInternals);
                //
                //Display the overview on the different example parts.
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);

                hv_Text.Dispose();
                hv_Text = new HTuple("This example is part of a series of examples, which summarize ");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "the workflow for DL object detection. It uses the MVTec pill bag dataset.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "The four parts are: ";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "1. Creation of the model and dataset preprocessing.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "2. Training of the model.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "3. Evaluation of the trained model.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "4. Inference on new images.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "This example covers part 3: 'Evaluation of the trained model'.";
                //
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", new HTuple(), new HTuple());
                }
                //

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_introduction_part_2(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_UsePretrainedModel = new HTuple(), hv_ExampleDataDir = new HTuple();
            HTuple hv_TrainedModelFileName = new HTuple(), hv_DLDatasetFileName = new HTuple();
            HTuple hv_ExampleDataDirExists = new HTuple(), hv_DatasetExists = new HTuple();
            HTuple hv_ModelExists = new HTuple(), hv_WindowHandleText = new HTuple();
            HTuple hv_ExceptionText = new HTuple(), hv_NumMissing = new HTuple();
            HTuple hv_MissingInstaller = new HTuple(), hv_Text = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure displays a short introduction to this example.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_UsePretrainedModel.Dispose();
                    hv_ExampleDataDir.Dispose();
                    hv_TrainedModelFileName.Dispose();
                    hv_DLDatasetFileName.Dispose();
                    hv_ExampleDataDirExists.Dispose();
                    hv_DatasetExists.Dispose();
                    hv_ModelExists.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_ExceptionText.Dispose();
                    hv_NumMissing.Dispose();
                    hv_MissingInstaller.Dispose();
                    hv_Text.Dispose();

                    return;
                }
                //
                //Check if all required files exist.
                hv_UsePretrainedModel.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "use_pretrained_model", out hv_UsePretrainedModel);
                hv_ExampleDataDir.Dispose();
                hv_ExampleDataDir = "detect_pills_data";
                //
                //Path to finetuned model to evaluate.
                if ((int)(hv_UsePretrainedModel) != 0)
                {
                    //Use the pretrained model shipping with HALCON.
                    hv_TrainedModelFileName.Dispose();
                    hv_TrainedModelFileName = "detect_pills.hdl";
                }
                else
                {
                    //File name of the finetuned object detection model.
                    hv_TrainedModelFileName.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TrainedModelFileName = hv_ExampleDataDir + "/best_dl_model_detection.hdl";
                    }
                }
                //
                //Path to DL dataset.
                hv_DLDatasetFileName.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_DLDatasetFileName = hv_ExampleDataDir + "/dldataset_pill_bag_512x320/dl_dataset.hdict";
                }
                hv_ExampleDataDirExists.Dispose();
                HOperatorSet.FileExists(hv_ExampleDataDir, out hv_ExampleDataDirExists);
                hv_DatasetExists.Dispose();
                HOperatorSet.FileExists(hv_DLDatasetFileName, out hv_DatasetExists);
                hv_ModelExists.Dispose();
                HOperatorSet.FileExists(hv_TrainedModelFileName, out hv_ModelExists);
                if ((int)((new HTuple((new HTuple(hv_ExampleDataDirExists.TupleNot())).TupleOr(
                    hv_DatasetExists.TupleNot()))).TupleOr(hv_ModelExists.TupleNot())) != 0)
                {
                    //Reset the open windows for a clean display.
                    HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
                    HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                    dev_display_example_reset_windows(hv_ExampleInternals);
                    //
                    hv_WindowHandleText.Dispose();
                    HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                    HDevWindowStack.SetActive(hv_WindowHandleText);
                    //
                    hv_ExceptionText.Dispose();
                    hv_ExceptionText = "To run this example you need the output of:";
                    hv_NumMissing.Dispose();
                    hv_NumMissing = 0;
                    hv_MissingInstaller.Dispose();
                    hv_MissingInstaller = 0;
                    if ((int)((new HTuple(hv_ExampleDataDirExists.TupleNot())).TupleOr(hv_DatasetExists.TupleNot()
                        )) != 0)
                    {
                        if (hv_ExceptionText == null)
                            hv_ExceptionText = new HTuple();
                        hv_ExceptionText[new HTuple(hv_ExceptionText.TupleLength())] = " - 'detect_pills_deep_learning_1_prepare.hdev'";
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_NumMissing = hv_NumMissing + 1;
                                hv_NumMissing.Dispose();
                                hv_NumMissing = ExpTmpLocalVar_NumMissing;
                            }
                        }
                    }
                    if ((int)(hv_ModelExists.TupleNot()) != 0)
                    {
                        if ((int)(hv_UsePretrainedModel.TupleNot()) != 0)
                        {
                            if (hv_ExceptionText == null)
                                hv_ExceptionText = new HTuple();
                            hv_ExceptionText[new HTuple(hv_ExceptionText.TupleLength())] = " - 'detect_pills_deep_learning_2_train.hdev'";
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_NumMissing = hv_NumMissing + 1;
                                    hv_NumMissing.Dispose();
                                    hv_NumMissing = ExpTmpLocalVar_NumMissing;
                                }
                            }
                        }
                        else
                        {
                            if (hv_ExceptionText == null)
                                hv_ExceptionText = new HTuple();
                            hv_ExceptionText[new HTuple(hv_ExceptionText.TupleLength())] = new HTuple(" - Deep learning installer, see Installation Guide.");
                            hv_MissingInstaller.Dispose();
                            hv_MissingInstaller = 1;
                        }
                    }
                    if (hv_ExceptionText == null)
                        hv_ExceptionText = new HTuple();
                    hv_ExceptionText[new HTuple(hv_ExceptionText.TupleLength())] = "";
                    if ((int)(hv_MissingInstaller.TupleNot()) != 0)
                    {
                        if ((int)(new HTuple(hv_NumMissing.TupleEqual(1))) != 0)
                        {
                            if (hv_ExceptionText == null)
                                hv_ExceptionText = new HTuple();
                            hv_ExceptionText[new HTuple(hv_ExceptionText.TupleLength())] = "Please run this example first.";
                        }
                        else
                        {
                            if (hv_ExceptionText == null)
                                hv_ExceptionText = new HTuple();
                            hv_ExceptionText[new HTuple(hv_ExceptionText.TupleLength())] = "Please run these examples first.";
                        }
                        if ((int)(hv_ModelExists.TupleNot()) != 0)
                        {
                            if (hv_ExceptionText == null)
                                hv_ExceptionText = new HTuple();
                            hv_ExceptionText[HTuple.TupleGenSequence(new HTuple(hv_ExceptionText.TupleLength()
                                ), (new HTuple(hv_ExceptionText.TupleLength())) + 2, 1)] = ((new HTuple("Alternatively, you can set 'UsePretrainedModel := true' ")).TupleConcat(
                                "at the top of the example script to use an already trained")).TupleConcat(
                                "model shipped with the HALCON installation.");
                        }
                    }
                    //Display warning.
                    set_display_font(hv_WindowHandleText, 20, "mono", "true", "false");
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ExceptionText, "window",
                            "top", "left", "red", "box", "true");
                    }
                    set_display_font(hv_WindowHandleText, 16, "mono", "true", "false");

                    hv_ShowExampleScreens.Dispose();
                    hv_UsePretrainedModel.Dispose();
                    hv_ExampleDataDir.Dispose();
                    hv_TrainedModelFileName.Dispose();
                    hv_DLDatasetFileName.Dispose();
                    hv_ExampleDataDirExists.Dispose();
                    hv_DatasetExists.Dispose();
                    hv_ModelExists.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_ExceptionText.Dispose();
                    hv_NumMissing.Dispose();
                    hv_MissingInstaller.Dispose();
                    hv_Text.Dispose();

                    return;
                }
                //
                //Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                dev_display_example_reset_windows(hv_ExampleInternals);
                //
                //Display explanatory text.
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                //
                hv_Text.Dispose();
                hv_Text = "Evaluation of the Trained Model";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "We will explain how to evaluate an object detection model and the most";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "important aspects thereof.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", "box", "true");
                }

                hv_ShowExampleScreens.Dispose();
                hv_UsePretrainedModel.Dispose();
                hv_ExampleDataDir.Dispose();
                hv_TrainedModelFileName.Dispose();
                hv_DLDatasetFileName.Dispose();
                hv_ExampleDataDirExists.Dispose();
                hv_DatasetExists.Dispose();
                hv_ModelExists.Dispose();
                hv_WindowHandleText.Dispose();
                hv_ExceptionText.Dispose();
                hv_NumMissing.Dispose();
                hv_MissingInstaller.Dispose();
                hv_Text.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_UsePretrainedModel.Dispose();
                hv_ExampleDataDir.Dispose();
                hv_TrainedModelFileName.Dispose();
                hv_DLDatasetFileName.Dispose();
                hv_ExampleDataDirExists.Dispose();
                hv_DatasetExists.Dispose();
                hv_ModelExists.Dispose();
                hv_WindowHandleText.Dispose();
                hv_ExceptionText.Dispose();
                hv_NumMissing.Dispose();
                hv_MissingInstaller.Dispose();
                hv_Text.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_run_program(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_UsePretrainedModel = new HTuple();
            HTuple hv_Text = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure shows a final text before starting with preprocessing.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_UsePretrainedModel.Dispose();
                    hv_Text.Dispose();

                    return;
                }
                //
                //Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                dev_display_example_reset_windows(hv_ExampleInternals);
                //
                //Display the explanatory text.
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                //
                hv_UsePretrainedModel.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "use_pretrained_model", out hv_UsePretrainedModel);
                if ((int)(hv_UsePretrainedModel) != 0)
                {
                    hv_Text.Dispose();
                    hv_Text = "We will now evaluate the retrained model shipped with HALCON.";
                }
                else
                {
                    hv_Text.Dispose();
                    hv_Text = "We will now evaluate the retrained model from example part 2";
                    if (hv_Text == null)
                        hv_Text = new HTuple();
                    hv_Text[new HTuple(hv_Text.TupleLength())] = "'detect_pills_deep_learning_2_train.hdev'.";
                }
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("First, we display a number of randomly selected detections.");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("Second, we will perform a detailed evaluation using");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "'evaluate_dl_model' and display the results.";
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", new HTuple(), new HTuple());
                }
                //

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_UsePretrainedModel.Dispose();
                hv_Text.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_UsePretrainedModel.Dispose();
                hv_Text.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_example_init(HTuple hv_ShowExampleScreens, HTuple hv_UsePretrainedModel,
            out HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_DLDataset = new HTuple(), hv_DLResult = new HTuple();
            HTuple hv_ExampleEvaluationResults = new HTuple(), hv_ModelType = new HTuple();
            HTuple hv_ModelClassIDs = new HTuple(), hv_ExampleEvaluationParams = new HTuple();
            // Initialize local and output iconic variables 
            hv_ExampleInternals = new HTuple();
            try
            {
                //This procedure initializes the graphic windows that are used for explanations during the example.
                //
                //A dict that will be used/adapted by other example procedures.
                hv_ExampleInternals.Dispose();
                HOperatorSet.CreateDict(out hv_ExampleInternals);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "show_example_screens", hv_ShowExampleScreens);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "use_pretrained_model", hv_UsePretrainedModel);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                }
                //
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_DLDataset.Dispose();
                    hv_DLResult.Dispose();
                    hv_ExampleEvaluationResults.Dispose();
                    hv_ModelType.Dispose();
                    hv_ModelClassIDs.Dispose();
                    hv_ExampleEvaluationParams.Dispose();

                    return;
                }
                //
                dev_display_example_init_text_window(hv_ExampleInternals);
                //
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                //
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "clear_windows", "all");
                //
                //Read a tiny dataset with a single sample from the pill bag dataset.
                hv_DLDataset.Dispose(); hv_DLResult.Dispose();
                create_tiny_example_dataset_with_result(out hv_DLDataset, out hv_DLResult);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "example_dl_dataset", hv_DLDataset);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "example_dl_result", hv_DLResult);
                //
                //Create example evaluation results and parameters
                hv_ExampleEvaluationResults.Dispose();
                HOperatorSet.ReadDict("detect_pills_deep_learning_3_evaluate_result.hdict",
                    new HTuple(), new HTuple(), out hv_ExampleEvaluationResults);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "example_evaluation_results",
                    hv_ExampleEvaluationResults);
                //
                hv_ModelType.Dispose();
                hv_ModelType = "detection";
                hv_ModelClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_DLDataset, "class_ids", out hv_ModelClassIDs);
                hv_ExampleEvaluationParams.Dispose();
                create_evaluation_default_param(hv_ModelType, hv_ModelClassIDs, out hv_ExampleEvaluationParams);
                HOperatorSet.SetDictTuple(hv_ExampleEvaluationParams, "detailed_evaluation",
                    1);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "example_evaluation_params",
                    hv_ExampleEvaluationParams);

                hv_DLDataset.Dispose();
                hv_DLResult.Dispose();
                hv_ExampleEvaluationResults.Dispose();
                hv_ModelType.Dispose();
                hv_ModelClassIDs.Dispose();
                hv_ExampleEvaluationParams.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_DLDataset.Dispose();
                hv_DLResult.Dispose();
                hv_ExampleEvaluationResults.Dispose();
                hv_ModelType.Dispose();
                hv_ModelClassIDs.Dispose();
                hv_ExampleEvaluationParams.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_open_example_image_window(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_WindowWidthText = new HTuple(), hv_WindowHeightText = new HTuple();
            HTuple hv_WindowWidthImage = new HTuple(), hv_WindowHeightImages = new HTuple();
            HTuple hv_WindowBGColor = new HTuple(), hv_WindowYImages = new HTuple();
            HTuple hv_WindowXImages = new HTuple(), hv_WindowHandleImages = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure initializes the graphic windows that are used to display example images.
                //
                hv_WindowWidthText.Dispose();
                hv_WindowWidthText = 800;
                hv_WindowHeightText.Dispose();
                hv_WindowHeightText = 300;
                hv_WindowWidthImage.Dispose();
                hv_WindowWidthImage = 800;
                hv_WindowHeightImages.Dispose();
                hv_WindowHeightImages = 500;
                hv_WindowBGColor.Dispose();
                hv_WindowBGColor = "gray";

                hv_WindowYImages.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowYImages = hv_WindowHeightText + 60;
                }
                hv_WindowXImages.Dispose();
                hv_WindowXImages = 0;
                HOperatorSet.SetWindowAttr("background_color", hv_WindowBGColor);
                HOperatorSet.OpenWindow(hv_WindowYImages, hv_WindowXImages, hv_WindowWidthImage, hv_WindowHeightImages, 0, "visible", "", out hv_WindowHandleImages);
                HDevWindowStack.Push(hv_WindowHandleImages);
                set_display_font(hv_WindowHandleImages, 16, "mono", "true", "false");
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images", hv_WindowHandleImages);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_width", hv_WindowWidthImage);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_height", hv_WindowHeightImages);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_x", hv_WindowXImages);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_y", hv_WindowYImages);

                hv_WindowWidthText.Dispose();
                hv_WindowHeightText.Dispose();
                hv_WindowWidthImage.Dispose();
                hv_WindowHeightImages.Dispose();
                hv_WindowBGColor.Dispose();
                hv_WindowYImages.Dispose();
                hv_WindowXImages.Dispose();
                hv_WindowHandleImages.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_WindowWidthText.Dispose();
                hv_WindowHeightText.Dispose();
                hv_WindowWidthImage.Dispose();
                hv_WindowHeightImages.Dispose();
                hv_WindowBGColor.Dispose();
                hv_WindowYImages.Dispose();
                hv_WindowXImages.Dispose();
                hv_WindowHandleImages.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_open_example_legend_window(HTuple hv_ExampleInternals, HTuple hv_WindowWidth)
        {



            // Local control variables 

            HTuple hv_WindowImagesHeight = new HTuple();
            HTuple hv_WindowImagesWidth = new HTuple(), hv_WindowImagesX = new HTuple();
            HTuple hv_WindowImagesY = new HTuple(), hv_WindowHandleLegend = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure initializes the graphic windows that are used to display a legend.
                //
                hv_WindowImagesHeight.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_height", out hv_WindowImagesHeight);
                hv_WindowImagesWidth.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_width", out hv_WindowImagesWidth);
                hv_WindowImagesX.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_x", out hv_WindowImagesX);
                hv_WindowImagesY.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_y", out hv_WindowImagesY);
                HOperatorSet.SetWindowAttr("background_color", "black");
                HOperatorSet.OpenWindow(hv_WindowImagesY, (hv_WindowImagesX + hv_WindowImagesWidth) + 5, hv_WindowWidth, hv_WindowImagesHeight, 0, "visible", "", out hv_WindowHandleLegend);
                HDevWindowStack.Push(hv_WindowHandleLegend);
                set_display_font(hv_WindowHandleLegend, 14, "mono", "true", "false");
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend", hv_WindowHandleLegend);

                hv_WindowImagesHeight.Dispose();
                hv_WindowImagesWidth.Dispose();
                hv_WindowImagesX.Dispose();
                hv_WindowImagesY.Dispose();
                hv_WindowHandleLegend.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_WindowImagesHeight.Dispose();
                hv_WindowImagesWidth.Dispose();
                hv_WindowImagesX.Dispose();
                hv_WindowImagesY.Dispose();
                hv_WindowHandleLegend.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Short Description: Retrieve all entries of a dict Dict where Key matches Value and return the result as new dict DictOut . 
        public void select_dl_results(HTuple hv_Dict, HTuple hv_Keys, HTuple hv_Values,
            out HTuple hv_DictOut)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_KeyType = new HTuple(), hv_ValuesKey = new HTuple();
            HTuple hv_NumValues = new HTuple(), hv_SelectedIndices = new HTuple();
            HTuple hv_Index = new HTuple(), hv_DictKeys = new HTuple();
            HTuple hv_DictDataTypes = new HTuple(), hv_Tuple = new HTuple();
            // Initialize local and output iconic variables 
            hv_DictOut = new HTuple();
            try
            {
                //This procedure allows to retrieve entries of a dict, where
                //a number keys matches specific values.
                //
                //Check supported key types.
                hv_KeyType.Dispose();
                HOperatorSet.GetDictParam(hv_Dict, "key_data_type", hv_Keys, out hv_KeyType);
                if ((int)(new HTuple(hv_KeyType.TupleNotEqual(HTuple.TupleGenConst(new HTuple(hv_Keys.TupleLength()
                    ), "tuple")))) != 0)
                {
                    throw new HalconException("Only 'tuple' type keys are supported.");
                }
                //
                //Create a copy of the dict containing only the the entries that
                //match a the value.
                //
                //Select all entries that match one or more key-value pairs
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ValuesKey.Dispose();
                    HOperatorSet.GetDictTuple(hv_Dict, hv_Keys.TupleSelect(0), out hv_ValuesKey);
                }
                hv_NumValues.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumValues = new HTuple(hv_ValuesKey.TupleLength()
                        );
                }
                hv_SelectedIndices.Dispose();
                hv_SelectedIndices = new HTuple();
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Keys.TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ValuesKey.Dispose();
                        HOperatorSet.GetDictTuple(hv_Dict, hv_Keys.TupleSelect(hv_Index), out hv_ValuesKey);
                    }
                    if ((int)(new HTuple((new HTuple(hv_ValuesKey.TupleLength())).TupleEqual(
                        hv_NumValues))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_SelectedIndices = hv_SelectedIndices.TupleConcat(
                                    hv_ValuesKey.TupleFind(hv_Values.TupleSelect(hv_Index)));
                                hv_SelectedIndices.Dispose();
                                hv_SelectedIndices = ExpTmpLocalVar_SelectedIndices;
                            }
                        }
                    }
                    else
                    {
                        throw new HalconException("All keys should contain the same number of values or one value.");
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_SelectedIndices = hv_SelectedIndices.TupleUniq()
                            ;
                        hv_SelectedIndices.Dispose();
                        hv_SelectedIndices = ExpTmpLocalVar_SelectedIndices;
                    }
                }
                //
                hv_DictKeys.Dispose();
                HOperatorSet.GetDictParam(hv_Dict, "keys", new HTuple(), out hv_DictKeys);
                hv_DictDataTypes.Dispose();
                HOperatorSet.GetDictParam(hv_Dict, "key_data_type", hv_DictKeys, out hv_DictDataTypes);
                hv_DictOut.Dispose();
                HOperatorSet.CreateDict(out hv_DictOut);
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_DictKeys.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    if ((int)(new HTuple(((hv_DictDataTypes.TupleSelect(hv_Index))).TupleEqual(
                        "tuple"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Tuple.Dispose();
                            HOperatorSet.GetDictTuple(hv_Dict, hv_DictKeys.TupleSelect(hv_Index), out hv_Tuple);
                        }
                        if ((int)(new HTuple((new HTuple(hv_Tuple.TupleLength())).TupleEqual(hv_NumValues))) != 0)
                        {
                            if ((int)((new HTuple((new HTuple(hv_SelectedIndices.TupleLength())).TupleGreater(
                                0))).TupleAnd(new HTuple(hv_SelectedIndices.TupleNotEqual(-1)))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_DictOut, hv_DictKeys.TupleSelect(hv_Index),
                                        hv_Tuple.TupleSelect(hv_SelectedIndices));
                                }
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_DictOut, hv_DictKeys.TupleSelect(hv_Index),
                                        new HTuple());
                                }
                            }
                        }
                        else
                        {
                            throw new HalconException("All keys should contain the same number of values or one value.");
                        }
                    }
                    else
                    {
                        throw new HalconException("Only 'tuple' data type is supported.");
                    }
                }

                hv_KeyType.Dispose();
                hv_ValuesKey.Dispose();
                hv_NumValues.Dispose();
                hv_SelectedIndices.Dispose();
                hv_Index.Dispose();
                hv_DictKeys.Dispose();
                hv_DictDataTypes.Dispose();
                hv_Tuple.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_KeyType.Dispose();
                hv_ValuesKey.Dispose();
                hv_NumValues.Dispose();
                hv_SelectedIndices.Dispose();
                hv_Index.Dispose();
                hv_DictKeys.Dispose();
                hv_DictDataTypes.Dispose();
                hv_Tuple.Dispose();

                throw HDevExpDefaultException;
            }
        }


    }
}
