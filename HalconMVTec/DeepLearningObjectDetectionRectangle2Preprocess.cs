using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using HalconDotNet;
using System.Windows.Forms;

namespace HalconMVTec
{
   public class DeepLearningObjectDetectionRectangle2Preprocess
    {
        // Local control variables
        HTuple hv_ModelFileName = new HTuple();//选择的网络模型(例如:"pretrained_dl_classifier_compact.hdl";"pretrained_dl_classifier_enhanced.hdl")
        HTuple hv_PreprocessModelFileName = new HTuple();//保存预处理后的网络模型文件的路径(例如:preprocess_dl_model_detection.hdl)
        HTuple hv_PreprocessResultDirectoryPath = new HTuple();//存储预处理结果-sample文件夹 及 hdict文件的上一级文件夹路径(包含文件夹名)
        HTuple hv_PreprocessResultFileName = new HTuple();//预处理结果文件名(以".hdict"为后缀,例如:dl_preprocess_dataset.hdict)
        HTuple hv_PreprocessResultParameterFileName = new HTuple();//预处理结果-参数的文件名(以".hdict"为后缀,例如:dl_preprocess_param.hdict)

        HTuple hv_LableDataSetFilePath = new HTuple();//读取的标注文件全路径(包含此文件名以".hdict"为后缀)

        HTuple hv_TrainingPercent = new HTuple();//训练集百分比
        HTuple hv_ValidationPercent = new HTuple();//验证集百分比
        HTuple hv_ImageWidth = new HTuple();//图片宽度(像素值)
        HTuple hv_ImageHeight = new HTuple();//图片高度(像素值)
        HTuple hv_ImageNumChannels = new HTuple();//图片通道数
        HTuple hv_RandomSeed = new HTuple();//随机种子
        HTuple hv_NormalizationType = new HTuple();
        HTuple hv_DomainHandling = new HTuple();
        //与水平矩形不同处
        HTuple hv_ClassIdsNoOrientation = new HTuple();//无方向的类别ID

        HTuple hv_ClassIDs = new HTuple();
        HTuple hv_NumClasses = new HTuple();
        HTuple hv_Capacity = new HTuple();
        //HTuple hv_DLDataset = new HTuple();
        HTuple hv_DLModelHandle = new HTuple();
        HTuple hv_DataDirectory = new HTuple();
        HTuple hv_DLDetectionModelParam = new HTuple();
        HTuple hv_DLModelDetectionParam = new HTuple();
        HTuple hv_MinLevel = new HTuple();
        HTuple hv_MaxLevel = new HTuple();
        HTuple hv_AnchorNumSubscales = new HTuple();
        HTuple hv_AnchorAspectRatios = new HTuple();


        HTuple hv_DictHandle = new HTuple();
        //HTuple hv_FileExists = new HTuple();
        HTuple hv_DLPreprocessParam = new HTuple();
        HTuple hv_GenParam = new HTuple();
        HTuple hv_DLDatasetFileName = new HTuple();
        //HTuple hv_DatasetSamples = new HTuple();
        //HTuple hv_SampleIndices = new HTuple();
        //HTuple hv_ShuffledIndices = new HTuple();
        //HTuple hv_DLSampleBatchDisplay = new HTuple();
        //HTuple hv_WindowHandleDict = new HTuple();
        //HTuple hv_Index = new HTuple();
        //HTuple hv_Text = new HTuple();

        //ADD FOR DISPLAY
        public HWindowControl hv_HWindowControl = new HWindowControl();//显示用窗口控件
        int loopCount = 0;//当前处理图片计数
        int imageCount = 0;//需要预处理的图片计数
        HTuple hv_Progress_ForDisplay = new HTuple();//存储要显示的信息

        #region DeepLearningObjectDetectionRectangle2Preprocess(构造函数里对预处理参数初始化)
        //构造函数里对预处理参数初始化
        public DeepLearningObjectDetectionRectangle2Preprocess()
        {
            //预加载网络模型
            hv_ModelFileName = "pretrained_dl_classifier_compact.hdl";

            //In order to get a reproducible split we set a random seed.
            //This means that re-running the script results in the same split of DLDataset.
            hv_RandomSeed = 42;

            //Percentages for splitting the dataset.
            hv_TrainingPercent = 70;
            hv_ValidationPercent = 15;

            //Image dimensions the images are rescaled to during preprocessing.
            hv_ImageWidth = 512;
            hv_ImageHeight = 384;
            hv_ImageNumChannels = 3;

            //Further parameters for image preprocessing.
            hv_NormalizationType = "none";
            hv_DomainHandling = "full_domain";

            hv_Capacity = "medium";
        }
        #endregion

        #region PreprocessAction(预处理开始)
        //与水平矩形不同处
        public void PreprocessAction(string modelFileName, string preprocessModelFileName, string lableDataSetFilePath, string preprocessResultDirectoryPath, string preprocessResultFileName, string preprocessResultParameterFileName, int imageWidth, int imageHeight, int imageNumChannels, int trainingPercent, int validationPercent, int randomSeed, int[] classIdsNoOrientation)
        {
            try
            {
                hv_ModelFileName = modelFileName;
                hv_PreprocessModelFileName = preprocessModelFileName;
                hv_LableDataSetFilePath = lableDataSetFilePath;
                hv_PreprocessResultDirectoryPath = preprocessResultDirectoryPath;
                hv_PreprocessResultParameterFileName = preprocessResultParameterFileName;
                hv_PreprocessResultFileName = preprocessResultFileName;
                hv_ImageWidth = imageWidth;
                hv_ImageHeight = imageHeight;
                hv_ImageNumChannels = imageNumChannels;
                hv_TrainingPercent = trainingPercent;
                hv_ValidationPercent = validationPercent;
                hv_RandomSeed = randomSeed;
                //与水平矩形不同处
                hv_ClassIdsNoOrientation = null;
                if (classIdsNoOrientation.Length > 0)
                    hv_ClassIdsNoOrientation = classIdsNoOrientation;
                //读取标注数据集并分割为训练集,验证集,测试集 
                LabelDataSetSplit();

                HOperatorSet.CreateDict(out hv_GenParam);
                HOperatorSet.SetDictTuple(hv_GenParam, "split", "train");

                //19.11++ k-measn聚类 ->  MinLevel/MaxLevel/AnchorNumSubscales/AnchorAspectRatios
                hv_DLDetectionModelParam.Dispose();
                determine_dl_model_detection_param(hv_DictHandle, hv_ImageWidth, hv_ImageHeight, hv_GenParam, out hv_DLDetectionModelParam);

                //Get the generated model parameters.

                HOperatorSet.GetDictTuple(hv_DLDetectionModelParam, "min_level", out hv_MinLevel);

                HOperatorSet.GetDictTuple(hv_DLDetectionModelParam, "max_level", out hv_MaxLevel);

                HOperatorSet.GetDictTuple(hv_DLDetectionModelParam, "anchor_num_subscales", out hv_AnchorNumSubscales);

                HOperatorSet.GetDictTuple(hv_DLDetectionModelParam, "anchor_aspect_ratios", out hv_AnchorAspectRatios);

                //MaxLevel要和模型的level匹配
                HOperatorSet.CreateDict(out hv_DLModelDetectionParam);
                HOperatorSet.SetDictTuple(hv_DLModelDetectionParam, "image_width", hv_ImageWidth);
                HOperatorSet.SetDictTuple(hv_DLModelDetectionParam, "image_height", hv_ImageHeight);
                HOperatorSet.SetDictTuple(hv_DLModelDetectionParam, "image_num_channels", hv_ImageNumChannels);
                HOperatorSet.SetDictTuple(hv_DLModelDetectionParam, "min_level", hv_MinLevel);
                HOperatorSet.SetDictTuple(hv_DLModelDetectionParam, "max_level", hv_MaxLevel);
                HOperatorSet.SetDictTuple(hv_DLModelDetectionParam, "anchor_num_subscales", hv_AnchorNumSubscales);
                HOperatorSet.SetDictTuple(hv_DLModelDetectionParam, "anchor_aspect_ratios", hv_AnchorAspectRatios);
                HOperatorSet.SetDictTuple(hv_DLModelDetectionParam, "capacity", hv_Capacity);

                //与水平矩形不同处
                //设置模型为rectangle2
                //For a better understanding of the parameters concerning the instance_type 'rectangle2'
                //we set them explicitly in the following lines.
                HOperatorSet.SetDictTuple(hv_DLModelDetectionParam, "instance_type", "rectangle2");
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_DLModelDetectionParam, "anchor_angles", ((((((new HTuple(-120)).TupleConcat(-60)).TupleConcat(0)).TupleConcat(60)).TupleConcat(120)).TupleConcat(180)).TupleRad());                      
                }
                HOperatorSet.SetDictTuple(hv_DLModelDetectionParam, "ignore_direction", "false");
                //与水平矩形不同处
                if (hv_ClassIdsNoOrientation != null)
                    HOperatorSet.SetDictTuple(hv_DLModelDetectionParam, "class_ids_no_orientation", hv_ClassIdsNoOrientation);

                //获得NumClasses
                HOperatorSet.GetDictTuple(hv_DictHandle, "class_ids", out hv_ClassIDs);
                HOperatorSet.TupleLength(hv_ClassIDs, out hv_NumClasses);
                HOperatorSet.SetDictTuple(hv_DLModelDetectionParam, "class_ids", hv_ClassIDs);

                //迁移学习-> 在网络模型基础上继续学习
                //创建模型（包含锚点信息）k-means
                HOperatorSet.CreateDlModelDetection(hv_ModelFileName, hv_NumClasses, hv_DLModelDetectionParam, out hv_DLModelHandle);

                //预处理模型数据
                create_dl_preprocess_param_from_model(hv_DLModelHandle, hv_NormalizationType, hv_DomainHandling, new HTuple(), new HTuple(), new HTuple(), out hv_DLPreprocessParam);

                //Preprocess the dataset. This might take a few seconds.
                HOperatorSet.CreateDict(out hv_GenParam);
                HOperatorSet.SetDictTuple(hv_GenParam, "overwrite_files", 1);

                //开始预处理
                preprocess_dl_dataset(hv_DictHandle, hv_PreprocessResultDirectoryPath, hv_DLPreprocessParam, hv_GenParam, out hv_DLDatasetFileName);

                //Store preprocess params separately in order to use it e.g. during inference.
                //存储预处理结果-参数,以便在推理过程中使用它
                HOperatorSet.WriteDict(hv_DLPreprocessParam, hv_PreprocessResultDirectoryPath + @"\" + hv_PreprocessResultParameterFileName, new HTuple(), new HTuple());

                //保存预处理后的网络模型
                HOperatorSet.WriteDlModel(hv_DLModelHandle, hv_PreprocessModelFileName);


                ////数据显示问题
                //hv_DatasetSamples.Dispose();
                //HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DatasetSamples);
                //hv_SampleIndices.Dispose();
                //find_dl_samples(hv_DatasetSamples, "split", "train", "match", out hv_SampleIndices);
                //hv_ShuffledIndices.Dispose();
                //tuple_shuffle(hv_SampleIndices, out hv_ShuffledIndices);
                //using (HDevDisposeHelper dh = new HDevDisposeHelper())
                //{
                //    hv_DLSampleBatchDisplay.Dispose();
                //    read_dl_samples(hv_DLDataset, hv_ShuffledIndices.TupleSelectRange(0, 9), out hv_DLSampleBatchDisplay);
                //}

                ////Set parameters for dev_display_dl_data.
                //hv_WindowHandleDict.Dispose();
                //HOperatorSet.CreateDict(out hv_WindowHandleDict);
                //hv_GenParam.Dispose();
                //HOperatorSet.CreateDict(out hv_GenParam);
                //HOperatorSet.SetDictTuple(hv_GenParam, "scale_windows", 1.2);
                ////
                ////Display the samples in DLSampleBatchDisplay.
                //for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_DLSampleBatchDisplay.TupleLength()
                //    )) - 1); hv_Index = (int)hv_Index + 1)
                //{
                //    //
                //    //Loop over samples in DLSampleBatchDisplay.
                //    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                //    {
                //        dev_display_dl_data(hv_DLSampleBatchDisplay.TupleSelect(hv_Index), new HTuple(),
                //            hv_DLDataset, "bbox_ground_truth", hv_GenParam, hv_WindowHandleDict);
                //    }
                //    hv_WindowHandles.Dispose();
                //    HOperatorSet.GetDictTuple(hv_WindowHandleDict, "bbox_ground_truth", out hv_WindowHandles);
                //    //
                //    //Add explanatory text.
                //    HDevWindowStack.SetActive(hv_WindowHandles.TupleSelect(
                //        0));
                //    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                //    {
                //        ho_Image.Dispose();
                //        HOperatorSet.GetDictObject(out ho_Image, hv_DLSampleBatchDisplay.TupleSelect(
                //            hv_Index), "image");
                //    }
                //    hv_ImageWidth.Dispose(); hv_ImageHeight.Dispose();
                //    HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
                //    if (HDevWindowStack.IsOpen())
                //    {
                //        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                //        {
                //            HOperatorSet.DispText(HDevWindowStack.GetActive(), (("New image size after preprocessing: " + hv_ImageWidth) + " x ") + hv_ImageHeight,
                //                "window", "bottom", "right", "black", new HTuple(), new HTuple());
                //        }
                //    }
                //    //
                //    HDevWindowStack.SetActive(hv_WindowHandles.TupleSelect(
                //        1));
                //    if (HDevWindowStack.IsOpen())
                //    {
                //        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                //            "window", "bottom", "right", "black", new HTuple(), new HTuple());
                //    }
                //    // stop(...); only in hdevelop
                //}

                ////Close windows that have been used for visualization.
                //dev_close_window_dict(hv_WindowHandleDict);

            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ModelFileName.Dispose();
                hv_NumClasses.Dispose();
                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_ImageNumChannels.Dispose();
                hv_Capacity.Dispose();
                hv_TrainingPercent.Dispose();
                hv_ValidationPercent.Dispose();


                hv_DataDirectory.Dispose();


                hv_GenParam.Dispose();
                hv_DLDetectionModelParam.Dispose();
                hv_MinLevel.Dispose();
                hv_MaxLevel.Dispose();
                hv_AnchorNumSubscales.Dispose();
                hv_AnchorAspectRatios.Dispose();
                hv_DLModelDetectionParam.Dispose();
                hv_ClassIDs.Dispose();
                hv_DLModelHandle.Dispose();
                hv_DLPreprocessParam.Dispose();


                //hv_WindowHandles.Dispose();


                MessageBox.Show(HDevExpDefaultException.ToString());
                //throw HDevExpDefaultException;
            }


            hv_ModelFileName.Dispose();
            hv_NumClasses.Dispose();
            hv_ImageWidth.Dispose();
            hv_ImageHeight.Dispose();
            hv_ImageNumChannels.Dispose();
            hv_Capacity.Dispose();
            hv_TrainingPercent.Dispose();
            hv_ValidationPercent.Dispose();


            hv_DataDirectory.Dispose();


            hv_GenParam.Dispose();
            hv_DLDetectionModelParam.Dispose();
            hv_MinLevel.Dispose();
            hv_MaxLevel.Dispose();
            hv_AnchorNumSubscales.Dispose();
            hv_AnchorAspectRatios.Dispose();
            hv_DLModelDetectionParam.Dispose();
            hv_ClassIDs.Dispose();
            hv_DLModelHandle.Dispose();
            hv_DLPreprocessParam.Dispose();


            //hv_WindowHandles.Dispose();

        }
        #endregion

        #region LabelDataSetSplit(读取标注数据集并分割为训练集,验证集,测试集)
        //Read the labeled data and split it into train, validation and test
        //读取标注数据集并分割为训练集,验证集,测试集 
        public void LabelDataSetSplit()
        {
            //Set the random seed.
            HOperatorSet.SetSystem("seed_rand", hv_RandomSeed);

            //Read the dataset with the procedure read_dl_dataset_classification.
            //Alternatively, you can read a DLDataset dictionary
            //as created by e.g., the MVTec Deep Learning Tool using read_dict().
            HOperatorSet.ReadDict(hv_LableDataSetFilePath, new HTuple(), new HTuple(), out hv_DictHandle);

            HTuple hv_ImageFormat = "png";
            DeepLearningObjectDetectionRectangle2DataAugmentation newDeepLearningObjectDetectionRectangle2DataAugmentation = new DeepLearningObjectDetectionRectangle2DataAugmentation();
            newDeepLearningObjectDetectionRectangle2DataAugmentation.DLObjectDetectionRectangle2DataAugmentationAction(hv_DictHandle, hv_ImageFormat, 255, hv_HWindowControl.HalconWindow, 12, out hv_DictHandle);

            //Generate the split.
            split_dl_dataset(hv_DictHandle, hv_TrainingPercent, hv_ValidationPercent, new HTuple());
        }
        #endregion


  // Procedures 
  // External procedures 
  public void add_colormap_to_image (HObject ho_GrayValueImage, HObject ho_Image, 
      out HObject ho_ColoredImage, HTuple hv_HeatmapColorScheme)
  {

    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_RGBValueImage, ho_Channels, ho_ChannelsScaled;
    HObject ho_Channel=null, ho_ChannelScaled=null, ho_ChannelScaledByte=null;
    HObject ho_ImageByte, ho_ImageByteR=null, ho_ImageByteG=null;
    HObject ho_ImageByteB=null;

    // Local copy input parameter variables 
    HObject ho_GrayValueImage_COPY_INP_TMP;
    ho_GrayValueImage_COPY_INP_TMP = new HObject(ho_GrayValueImage);



    // Local control variables 

    HTuple hv_Type = new HTuple(), hv_NumChannels = new HTuple();
    HTuple hv_ChannelIndex = new HTuple(), hv_ChannelMin = new HTuple();
    HTuple hv_ChannelMax = new HTuple(), hv__ = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ColoredImage);
    HOperatorSet.GenEmptyObj(out ho_RGBValueImage);
    HOperatorSet.GenEmptyObj(out ho_Channels);
    HOperatorSet.GenEmptyObj(out ho_ChannelsScaled);
    HOperatorSet.GenEmptyObj(out ho_Channel);
    HOperatorSet.GenEmptyObj(out ho_ChannelScaled);
    HOperatorSet.GenEmptyObj(out ho_ChannelScaledByte);
    HOperatorSet.GenEmptyObj(out ho_ImageByte);
    HOperatorSet.GenEmptyObj(out ho_ImageByteR);
    HOperatorSet.GenEmptyObj(out ho_ImageByteG);
    HOperatorSet.GenEmptyObj(out ho_ImageByteB);
    try
    {
      //
      //This procedure adds a gray-value image to a RGB image with a chosen colormap.
      //
      hv_Type.Dispose();
      HOperatorSet.GetImageType(ho_GrayValueImage_COPY_INP_TMP, out hv_Type);
      //The image LUT needs a byte image. Rescale real images.
      if ((int)(new HTuple(hv_Type.TupleEqual("real"))) != 0)
      {
        {
        HObject ExpTmpOutVar_0;
        scale_image_range(ho_GrayValueImage_COPY_INP_TMP, out ExpTmpOutVar_0, 0, 
            1);
        ho_GrayValueImage_COPY_INP_TMP.Dispose();
        ho_GrayValueImage_COPY_INP_TMP = ExpTmpOutVar_0;
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConvertImageType(ho_GrayValueImage_COPY_INP_TMP, out ExpTmpOutVar_0, 
            "byte");
        ho_GrayValueImage_COPY_INP_TMP.Dispose();
        ho_GrayValueImage_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      else if ((int)(new HTuple(hv_Type.TupleNotEqual("byte"))) != 0)
      {
        throw new HalconException(new HTuple("For this transformation, a byte or real image is needed!"));
      }
      //
      //Apply the chosen color scheme on the gray value.
      ho_RGBValueImage.Dispose();
      apply_colorscheme_on_gray_value_image(ho_GrayValueImage_COPY_INP_TMP, out ho_RGBValueImage, 
          hv_HeatmapColorScheme);
      //
      //Convert input image to byte image for visualization.
      ho_Channels.Dispose();
      HOperatorSet.ImageToChannels(ho_Image, out ho_Channels);
      hv_NumChannels.Dispose();
      HOperatorSet.CountChannels(ho_Image, out hv_NumChannels);
      ho_ChannelsScaled.Dispose();
      HOperatorSet.GenEmptyObj(out ho_ChannelsScaled);
      HTuple end_val19 = hv_NumChannels;
      HTuple step_val19 = 1;
      for (hv_ChannelIndex=1; hv_ChannelIndex.Continue(end_val19, step_val19); hv_ChannelIndex = hv_ChannelIndex.TupleAdd(step_val19))
      {
        ho_Channel.Dispose();
        HOperatorSet.SelectObj(ho_Channels, out ho_Channel, hv_ChannelIndex);
        hv_ChannelMin.Dispose();hv_ChannelMax.Dispose();hv__.Dispose();
        HOperatorSet.MinMaxGray(ho_Channel, ho_Channel, 0, out hv_ChannelMin, out hv_ChannelMax, 
            out hv__);
        ho_ChannelScaled.Dispose();
        scale_image_range(ho_Channel, out ho_ChannelScaled, hv_ChannelMin, hv_ChannelMax);
        ho_ChannelScaledByte.Dispose();
        HOperatorSet.ConvertImageType(ho_ChannelScaled, out ho_ChannelScaledByte, 
            "byte");
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConcatObj(ho_ChannelsScaled, ho_ChannelScaledByte, out ExpTmpOutVar_0
            );
        ho_ChannelsScaled.Dispose();
        ho_ChannelsScaled = ExpTmpOutVar_0;
        }
      }
      ho_ImageByte.Dispose();
      HOperatorSet.ChannelsToImage(ho_ChannelsScaled, out ho_ImageByte);
      //
      //Note that ImageByte needs to have the same number of channels as
      //RGBValueImage to display colormap image correctly.
      hv_NumChannels.Dispose();
      HOperatorSet.CountChannels(ho_ImageByte, out hv_NumChannels);
      if ((int)(new HTuple(hv_NumChannels.TupleNotEqual(3))) != 0)
      {
        //Just take the first channel and use this to generate
        //an image with 3 channels for visualization.
        ho_ImageByteR.Dispose();
        HOperatorSet.AccessChannel(ho_ImageByte, out ho_ImageByteR, 1);
        ho_ImageByteG.Dispose();
        HOperatorSet.CopyImage(ho_ImageByteR, out ho_ImageByteG);
        ho_ImageByteB.Dispose();
        HOperatorSet.CopyImage(ho_ImageByteR, out ho_ImageByteB);
        ho_ImageByte.Dispose();
        HOperatorSet.Compose3(ho_ImageByteR, ho_ImageByteG, ho_ImageByteB, out ho_ImageByte
            );
      }
      //
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.AddImage(ho_ImageByte, ho_RGBValueImage, out ExpTmpOutVar_0, 0.5, 
          0);
      ho_RGBValueImage.Dispose();
      ho_RGBValueImage = ExpTmpOutVar_0;
      }
      ho_ColoredImage.Dispose();
      ho_ColoredImage = new HObject(ho_RGBValueImage);
      //
      ho_GrayValueImage_COPY_INP_TMP.Dispose();
      ho_RGBValueImage.Dispose();
      ho_Channels.Dispose();
      ho_ChannelsScaled.Dispose();
      ho_Channel.Dispose();
      ho_ChannelScaled.Dispose();
      ho_ChannelScaledByte.Dispose();
      ho_ImageByte.Dispose();
      ho_ImageByteR.Dispose();
      ho_ImageByteG.Dispose();
      ho_ImageByteB.Dispose();

      hv_Type.Dispose();
      hv_NumChannels.Dispose();
      hv_ChannelIndex.Dispose();
      hv_ChannelMin.Dispose();
      hv_ChannelMax.Dispose();
      hv__.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_GrayValueImage_COPY_INP_TMP.Dispose();
      ho_RGBValueImage.Dispose();
      ho_Channels.Dispose();
      ho_ChannelsScaled.Dispose();
      ho_Channel.Dispose();
      ho_ChannelScaled.Dispose();
      ho_ChannelScaledByte.Dispose();
      ho_ImageByte.Dispose();
      ho_ImageByteR.Dispose();
      ho_ImageByteG.Dispose();
      ho_ImageByteB.Dispose();

      hv_Type.Dispose();
      hv_NumChannels.Dispose();
      hv_ChannelIndex.Dispose();
      hv_ChannelMin.Dispose();
      hv_ChannelMax.Dispose();
      hv__.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Object Detection
  // Short Description: This procedure collects data concerning the shape of the ground truth bounding boxes provided in DLDataset. 
  public void analyze_dl_dataset_detection (HTuple hv_DLDataset, HTuple hv_InstanceType, 
      HTuple hv_ImageWidthRaw, HTuple hv_ImageHeightRaw, HTuple hv_ImageWidthTarget, 
      HTuple hv_ImageHeightTarget, HTuple hv_DomainHandling, HTuple hv_PreprocessedPath, 
      HTuple hv_DatasetSplit, out HTuple hv_Areas, out HTuple hv_AspectRatios, out HTuple hv_Angles)
  {



    // Local iconic variables 

    HObject ho_Image=null, ho_Domain=null;

    // Local control variables 

    HTuple hv_Rows1 = new HTuple(), hv_Cols1 = new HTuple();
    HTuple hv_Rows2 = new HTuple(), hv_Cols2 = new HTuple();
    HTuple hv_Lengths1 = new HTuple(), hv_Lengths2 = new HTuple();
    HTuple hv_Phis = new HTuple(), hv_Preprocessed = new HTuple();
    HTuple hv_FactorWidth = new HTuple(), hv_FactorHeight = new HTuple();
    HTuple hv_DLSamples = new HTuple(), hv_ImageDir = new HTuple();
    HTuple hv_SampleIndices = new HTuple(), hv_IterationIndex = new HTuple();
    HTuple hv_DLSampleCurrent = new HTuple(), hv_SampleIndex = new HTuple();
    HTuple hv_KeyFileExists = new HTuple(), hv_FileNameRelative = new HTuple();
    HTuple hv_FileNameSample = new HTuple(), hv_ImageID = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_ImageName = new HTuple();
    HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
    HTuple hv_RowDomain1 = new HTuple(), hv_ColumnDomain1 = new HTuple();
    HTuple hv_RowDomain2 = new HTuple(), hv_ColumnDomain2 = new HTuple();
    HTuple hv_WidthDomain = new HTuple(), hv_HeightDomain = new HTuple();
    HTuple hv_Row1 = new HTuple(), hv_Col1 = new HTuple();
    HTuple hv_Row2 = new HTuple(), hv_Col2 = new HTuple();
    HTuple hv_BoxMask = new HTuple(), hv_Row = new HTuple();
    HTuple hv_Col = new HTuple(), hv_Length1 = new HTuple();
    HTuple hv_Length2 = new HTuple(), hv_Phi = new HTuple();
    HTuple hv_NewRow = new HTuple(), hv_NewCol = new HTuple();
    HTuple hv_NewLength1 = new HTuple(), hv_NewLength2 = new HTuple();
    HTuple hv_NewPhi = new HTuple(), hv_Heights = new HTuple();
    HTuple hv_Widths = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    HOperatorSet.GenEmptyObj(out ho_Domain);
    hv_Areas = new HTuple();
    hv_AspectRatios = new HTuple();
    hv_Angles = new HTuple();
    try
    {
      //This procedure creates various data collections from the given DLDataset
      //for DL Object Detection which are
      //- the areas of the ground truth bounding boxes
      //- the aspect ratios of the ground truth bounding boxes
      //- the orientations of the ground truth bounding boxes for rectangle2 object detection.
      //
      //Output data tuples.
      hv_Areas.Dispose();
      hv_Areas = new HTuple();
      hv_AspectRatios.Dispose();
      hv_AspectRatios = new HTuple();
      hv_Angles.Dispose();
      hv_Angles = new HTuple();
      //
      //Bounding box parameters for rectangle1.
      hv_Rows1.Dispose();
      hv_Rows1 = new HTuple();
      hv_Cols1.Dispose();
      hv_Cols1 = new HTuple();
      hv_Rows2.Dispose();
      hv_Rows2 = new HTuple();
      hv_Cols2.Dispose();
      hv_Cols2 = new HTuple();
      //Bounding box parameters for rectangle2.
      hv_Lengths1.Dispose();
      hv_Lengths1 = new HTuple();
      hv_Lengths2.Dispose();
      hv_Lengths2 = new HTuple();
      hv_Phis.Dispose();
      hv_Phis = new HTuple();
      //
      //Check whether the input dataset is already preprocessed.
      hv_Preprocessed.Dispose();
      hv_Preprocessed = 0;
      if ((int)(new HTuple(hv_PreprocessedPath.TupleNotEqual(""))) != 0)
      {
        hv_Preprocessed.Dispose();
        hv_Preprocessed = 1;
      }
      else
      {
        //Otherwise, check whether the necessary preprocessing parameters are provided.
        if ((int)((new HTuple(hv_ImageWidthTarget.TupleEqual(new HTuple()))).TupleOr(
            new HTuple(hv_ImageHeightTarget.TupleEqual(new HTuple())))) != 0)
        {
          throw new HalconException("Please enter values for the target image width and height.");
        }
        else if ((int)((new HTuple(hv_ImageWidthTarget.TupleLess(1))).TupleOr(
            new HTuple(hv_ImageHeightTarget.TupleLess(1)))) != 0)
        {
          throw new HalconException("Please enter valid values for the target image width and height.");
        }
        //In case the original images are of the same size (specified by the input
        //parameters), the scaling factors can be calculated here.
        if ((int)((new HTuple(hv_ImageWidthRaw.TupleNotEqual(new HTuple()))).TupleAnd(
            new HTuple(hv_ImageHeightRaw.TupleNotEqual(new HTuple())))) != 0)
        {
          hv_FactorWidth.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_FactorWidth = (hv_ImageWidthTarget.TupleReal()
              )/hv_ImageWidthRaw;
          }
          hv_FactorHeight.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_FactorHeight = (hv_ImageHeightTarget.TupleReal()
              )/hv_ImageHeightRaw;
          }
        }
      }
      //
      //Get the samples in the dataset.
      hv_DLSamples.Dispose();
      HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLSamples);
      hv_ImageDir.Dispose();
      HOperatorSet.GetDictTuple(hv_DLDataset, "image_dir", out hv_ImageDir);
      //
      //Get the relevant sample indices.
      hv_SampleIndices.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_SampleIndices = HTuple.TupleGenSequence(
          0,(new HTuple(hv_DLSamples.TupleLength()))-1,1);
      }
      if ((int)(new HTuple(hv_DatasetSplit.TupleNotEqual("all"))) != 0)
      {
        hv_SampleIndices.Dispose();
        find_dl_samples(hv_DLSamples, "split", hv_DatasetSplit, "match", out hv_SampleIndices);
        if ((int)(new HTuple((new HTuple(hv_SampleIndices.TupleLength())).TupleEqual(
            0))) != 0)
        {
          throw new HalconException(("No samples found for the specified dataset split: "+hv_DatasetSplit)+".");
        }
      }
      //
      //Iterate over the samples and store information on the ground truth
      //bounding boxes.
      for (hv_IterationIndex=0; (int)hv_IterationIndex<=(int)((new HTuple(hv_SampleIndices.TupleLength()
          ))-1); hv_IterationIndex = (int)hv_IterationIndex + 1)
      {
        hv_DLSampleCurrent.Dispose();
        hv_DLSampleCurrent = new HTuple();
        hv_SampleIndex.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SampleIndex = hv_SampleIndices.TupleSelect(
            hv_IterationIndex);
        }
        if ((int)(hv_Preprocessed) != 0)
        {
          //Check whether the file name key of the preprocessed samples is available.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_KeyFileExists.Dispose();
          HOperatorSet.GetDictParam(hv_DLSamples.TupleSelect(hv_SampleIndex), "key_exists", 
              "dlsample_file_name", out hv_KeyFileExists);
          }
          if ((int)(hv_KeyFileExists) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_FileNameRelative.Dispose();
            HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_SampleIndex), "dlsample_file_name", 
                out hv_FileNameRelative);
            }
            hv_FileNameSample.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_FileNameSample = (hv_PreprocessedPath+"/")+hv_FileNameRelative;
            }
          }
          else
          {
            //If the key does not exist, check if a corresponding file exists.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ImageID.Dispose();
            HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_SampleIndex), "image_id", 
                out hv_ImageID);
            }
            hv_FileNameRelative.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_FileNameRelative = hv_ImageID+"_dlsample.hdict";
            }
            hv_FileNameSample.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_FileNameSample = (hv_PreprocessedPath+"/")+hv_FileNameRelative;
            }
          }
          //Read the dictionary of the preprocessed sample.
          try
          {
            hv_DLSampleCurrent.Dispose();
            HOperatorSet.ReadDict(hv_FileNameSample, new HTuple(), new HTuple(), 
                out hv_DLSampleCurrent);
          }
          // catch (Exception) 
          catch (HalconException HDevExpDefaultException1)
          {
            HDevExpDefaultException1.ToHTuple(out hv_Exception);
            throw new HalconException((("An error has occurred while reading "+hv_FileNameSample)+new HTuple(" , HALCON error # "))+(hv_Exception.TupleSelect(
                0)));
          }
          //Set the scaling factors to 1 since the samples are already preprocessed.
          hv_FactorWidth.Dispose();
          hv_FactorWidth = 1.0;
          hv_FactorHeight.Dispose();
          hv_FactorHeight = 1.0;
        }
        else
        {
          //In case the samples are not preprocessed, we need to scale them according
          //to the target image sizes as well as perform domain handling if necessary.
          hv_DLSampleCurrent.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_DLSampleCurrent = hv_DLSamples.TupleSelect(
              hv_SampleIndex);
          }
          //The images need to be read in case the raw sizes are not provided or
          //the domain should be cropped.
          if ((int)((new HTuple((new HTuple(hv_ImageWidthRaw.TupleEqual(new HTuple()))).TupleOr(
              new HTuple(hv_ImageHeightRaw.TupleEqual(new HTuple()))))).TupleOr(new HTuple(hv_DomainHandling.TupleEqual(
              "crop_domain")))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ImageName.Dispose();
            HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_SampleIndex), "image_file_name", 
                out hv_ImageName);
            }
            try
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              ho_Image.Dispose();
              HOperatorSet.ReadImage(out ho_Image, (hv_ImageDir+"/")+hv_ImageName);
              }
            }
            // catch (Exception) 
            catch (HalconException HDevExpDefaultException1)
            {
              HDevExpDefaultException1.ToHTuple(out hv_Exception);
              throw new HalconException(((("Error while reading image "+hv_ImageDir)+"/")+hv_ImageName)+".");
            }
          }
          //In case the original images have variable sizes, the image
          //sizes need to be read in order to calculate the scaling factors.
          if ((int)((new HTuple(hv_ImageWidthRaw.TupleEqual(new HTuple()))).TupleOr(
              new HTuple(hv_ImageHeightRaw.TupleEqual(new HTuple())))) != 0)
          {
            //Read the image.
            hv_Width.Dispose();hv_Height.Dispose();
            HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
            //Get the object sizes after preprocessing.
            hv_FactorWidth.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_FactorWidth = (hv_ImageWidthTarget.TupleReal()
                )/hv_Width;
            }
            hv_FactorHeight.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_FactorHeight = (hv_ImageHeightTarget.TupleReal()
                )/hv_Height;
            }
          }
          //Get the domain borders if the domain should be cropped.
          if ((int)(new HTuple(hv_DomainHandling.TupleEqual("crop_domain"))) != 0)
          {
            //Get domain.
            ho_Domain.Dispose();
            HOperatorSet.GetDomain(ho_Image, out ho_Domain);
            //Set the size of the raw image to the domain extensions.
            hv_RowDomain1.Dispose();hv_ColumnDomain1.Dispose();hv_RowDomain2.Dispose();hv_ColumnDomain2.Dispose();
            HOperatorSet.SmallestRectangle1(ho_Domain, out hv_RowDomain1, out hv_ColumnDomain1, 
                out hv_RowDomain2, out hv_ColumnDomain2);
            //Get the object sizes after preprocessing.
            hv_WidthDomain.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WidthDomain = (hv_ColumnDomain2-hv_ColumnDomain1)+1;
            }
            hv_HeightDomain.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_HeightDomain = (hv_RowDomain2-hv_RowDomain1)+1;
            }
            hv_FactorWidth.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_FactorWidth = (hv_ImageWidthTarget.TupleReal()
                )/hv_WidthDomain;
            }
            hv_FactorHeight.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_FactorHeight = (hv_ImageHeightTarget.TupleReal()
                )/hv_HeightDomain;
            }
          }
        }
        //
        //Collect ground truth information for instance type rectangle1.
        if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
        {
          //Get the sample bounding boxes.
          try
          {
            hv_Row1.Dispose();
            HOperatorSet.GetDictTuple(hv_DLSampleCurrent, "bbox_row1", out hv_Row1);
            hv_Col1.Dispose();
            HOperatorSet.GetDictTuple(hv_DLSampleCurrent, "bbox_col1", out hv_Col1);
            hv_Row2.Dispose();
            HOperatorSet.GetDictTuple(hv_DLSampleCurrent, "bbox_row2", out hv_Row2);
            hv_Col2.Dispose();
            HOperatorSet.GetDictTuple(hv_DLSampleCurrent, "bbox_col2", out hv_Col2);
          }
          // catch (Exception) 
          catch (HalconException HDevExpDefaultException1)
          {
            HDevExpDefaultException1.ToHTuple(out hv_Exception);
            throw new HalconException("Bounding box label missing for rectangle1 object detection.");
          }
          //Crop the bounding boxes if necessary.
          if ((int)((new HTuple(hv_Preprocessed.TupleNot())).TupleAnd(new HTuple(hv_DomainHandling.TupleEqual(
              "crop_domain")))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_Row1 = hv_Row1.TupleMax2(
                hv_RowDomain1-.5);
            hv_Row1.Dispose();
            hv_Row1 = ExpTmpLocalVar_Row1;
            }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_Col1 = hv_Col1.TupleMax2(
                hv_ColumnDomain1-.5);
            hv_Col1.Dispose();
            hv_Col1 = ExpTmpLocalVar_Col1;
            }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_Row2 = hv_Row2.TupleMin2(
                hv_RowDomain2+.5);
            hv_Row2.Dispose();
            hv_Row2 = ExpTmpLocalVar_Row2;
            }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_Col2 = hv_Col2.TupleMin2(
                hv_ColumnDomain2+.5);
            hv_Col2.Dispose();
            hv_Col2 = ExpTmpLocalVar_Col2;
            }
            }
            //Remove empty boxes resulted from the clipping.
            hv_BoxMask.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_BoxMask = ((hv_Row1.TupleLessElem(
                hv_Row2))).TupleAnd(hv_Col1.TupleLessElem(hv_Col2));
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_Row1 = (hv_Row1.TupleSelectMask(
                hv_BoxMask))-hv_RowDomain1;
            hv_Row1.Dispose();
            hv_Row1 = ExpTmpLocalVar_Row1;
            }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_Row2 = (hv_Row2.TupleSelectMask(
                hv_BoxMask))-hv_RowDomain1;
            hv_Row2.Dispose();
            hv_Row2 = ExpTmpLocalVar_Row2;
            }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_Col1 = (hv_Col1.TupleSelectMask(
                hv_BoxMask))-hv_ColumnDomain1;
            hv_Col1.Dispose();
            hv_Col1 = ExpTmpLocalVar_Col1;
            }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_Col2 = (hv_Col2.TupleSelectMask(
                hv_BoxMask))-hv_ColumnDomain1;
            hv_Col2.Dispose();
            hv_Col2 = ExpTmpLocalVar_Col2;
            }
            }
          }
          //Collect the scaled bounding box data.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_Rows1 = hv_Rows1.TupleConcat(
              hv_Row1*hv_FactorHeight);
          hv_Rows1.Dispose();
          hv_Rows1 = ExpTmpLocalVar_Rows1;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_Rows2 = hv_Rows2.TupleConcat(
              hv_Row2*hv_FactorHeight);
          hv_Rows2.Dispose();
          hv_Rows2 = ExpTmpLocalVar_Rows2;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_Cols1 = hv_Cols1.TupleConcat(
              hv_Col1*hv_FactorWidth);
          hv_Cols1.Dispose();
          hv_Cols1 = ExpTmpLocalVar_Cols1;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_Cols2 = hv_Cols2.TupleConcat(
              hv_Col2*hv_FactorWidth);
          hv_Cols2.Dispose();
          hv_Cols2 = ExpTmpLocalVar_Cols2;
          }
          }
          //Collect ground truth information for instance type rectangle2.
        }
        else if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
        {
          //Get the sample bounding boxes.
          try
          {
            hv_Row.Dispose();
            HOperatorSet.GetDictTuple(hv_DLSampleCurrent, "bbox_row", out hv_Row);
            hv_Col.Dispose();
            HOperatorSet.GetDictTuple(hv_DLSampleCurrent, "bbox_col", out hv_Col);
            hv_Length1.Dispose();
            HOperatorSet.GetDictTuple(hv_DLSampleCurrent, "bbox_length1", out hv_Length1);
            hv_Length2.Dispose();
            HOperatorSet.GetDictTuple(hv_DLSampleCurrent, "bbox_length2", out hv_Length2);
            hv_Phi.Dispose();
            HOperatorSet.GetDictTuple(hv_DLSampleCurrent, "bbox_phi", out hv_Phi);
          }
          // catch (Exception) 
          catch (HalconException HDevExpDefaultException1)
          {
            HDevExpDefaultException1.ToHTuple(out hv_Exception);
            throw new HalconException("Bounding box label missing for rectangle2 object detection.");
          }
          //Crop the bounding boxes by removing boxes with centers outside
          //of the domain.
          if ((int)((new HTuple(hv_Preprocessed.TupleNot())).TupleAnd(new HTuple(hv_DomainHandling.TupleEqual(
              "crop_domain")))) != 0)
          {
            hv_BoxMask.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_BoxMask = (new HTuple((new HTuple(((hv_Row.TupleGreaterEqualElem(
                hv_RowDomain1))).TupleAnd(hv_Col.TupleGreaterEqualElem(hv_ColumnDomain1)))).TupleAnd(
                hv_Row.TupleLessElem(hv_RowDomain2)))).TupleAnd(hv_Col.TupleLessElem(
                hv_ColumnDomain2));
            }
            //Store the bounding boxes after the clipping.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_Row = (hv_Row.TupleSelectMask(
                hv_BoxMask))-hv_RowDomain1;
            hv_Row.Dispose();
            hv_Row = ExpTmpLocalVar_Row;
            }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_Col = (hv_Col.TupleSelectMask(
                hv_BoxMask))-hv_ColumnDomain1;
            hv_Col.Dispose();
            hv_Col = ExpTmpLocalVar_Col;
            }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_Length1 = hv_Length1.TupleSelectMask(
                hv_BoxMask);
            hv_Length1.Dispose();
            hv_Length1 = ExpTmpLocalVar_Length1;
            }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_Length2 = hv_Length2.TupleSelectMask(
                hv_BoxMask);
            hv_Length2.Dispose();
            hv_Length2 = ExpTmpLocalVar_Length2;
            }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_Phi = hv_Phi.TupleSelectMask(
                hv_BoxMask);
            hv_Phi.Dispose();
            hv_Phi = ExpTmpLocalVar_Phi;
            }
            }
          }
          //Get the scaled bounding box data.
          if ((int)(new HTuple(hv_FactorHeight.TupleEqual(hv_FactorWidth))) != 0)
          {
            //In case the factors in both directions are the same, the scaling
            //is simple and Phi stays unchanged.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_Length1 = hv_Length1*hv_FactorHeight;
            hv_Length1.Dispose();
            hv_Length1 = ExpTmpLocalVar_Length1;
            }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_Length2 = hv_Length2*hv_FactorWidth;
            hv_Length2.Dispose();
            hv_Length2 = ExpTmpLocalVar_Length2;
            }
            }
          }
          else
          {
            //In case the factors in both directions are not the same, the scaling
            //differs for the two directions.
            hv_NewRow.Dispose();hv_NewCol.Dispose();hv_NewLength1.Dispose();hv_NewLength2.Dispose();hv_NewPhi.Dispose();
            scale_rectangle2_bbox(hv_Row, hv_Col, hv_Length1, hv_Length2, hv_Phi, 
                hv_FactorHeight, hv_FactorWidth, out hv_NewRow, out hv_NewCol, out hv_NewLength1, 
                out hv_NewLength2, out hv_NewPhi);
            hv_Length1.Dispose();
            hv_Length1 = new HTuple(hv_NewLength1);
            hv_Length2.Dispose();
            hv_Length2 = new HTuple(hv_NewLength2);
            hv_Phi.Dispose();
            hv_Phi = new HTuple(hv_NewPhi);
          }
          //Collect the scaled bounding box data.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_Lengths1 = hv_Lengths1.TupleConcat(
              hv_Length1);
          hv_Lengths1.Dispose();
          hv_Lengths1 = ExpTmpLocalVar_Lengths1;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_Lengths2 = hv_Lengths2.TupleConcat(
              hv_Length2);
          hv_Lengths2.Dispose();
          hv_Lengths2 = ExpTmpLocalVar_Lengths2;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_Phis = hv_Phis.TupleConcat(
              hv_Phi);
          hv_Phis.Dispose();
          hv_Phis = ExpTmpLocalVar_Phis;
          }
          }
        }
        else
        {
          throw new HalconException("Wrong instance type for deep learning object detection.");
        }
      }
      //
      //Compute the areas and aspect ratios of all bounding boxes. Also set the
      //output angles in case of rectangle2.
      if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
      {
        hv_Heights.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Heights = hv_Rows2-hv_Rows1;
        }
        hv_Widths.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Widths = hv_Cols2-hv_Cols1;
        }
        hv_Areas.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Areas = hv_Heights*hv_Widths;
        }
        hv_AspectRatios.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_AspectRatios = hv_Heights/(hv_Widths.TupleReal()
            );
        }
      }
      else if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
      {
        hv_Areas.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Areas = (4*hv_Lengths1)*hv_Lengths2;
        }
        hv_AspectRatios.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_AspectRatios = hv_Lengths2/(hv_Lengths1.TupleReal()
            );
        }
        hv_Angles.Dispose();
        hv_Angles = new HTuple(hv_Phis);
      }
      //
      ho_Image.Dispose();
      ho_Domain.Dispose();

      hv_Rows1.Dispose();
      hv_Cols1.Dispose();
      hv_Rows2.Dispose();
      hv_Cols2.Dispose();
      hv_Lengths1.Dispose();
      hv_Lengths2.Dispose();
      hv_Phis.Dispose();
      hv_Preprocessed.Dispose();
      hv_FactorWidth.Dispose();
      hv_FactorHeight.Dispose();
      hv_DLSamples.Dispose();
      hv_ImageDir.Dispose();
      hv_SampleIndices.Dispose();
      hv_IterationIndex.Dispose();
      hv_DLSampleCurrent.Dispose();
      hv_SampleIndex.Dispose();
      hv_KeyFileExists.Dispose();
      hv_FileNameRelative.Dispose();
      hv_FileNameSample.Dispose();
      hv_ImageID.Dispose();
      hv_Exception.Dispose();
      hv_ImageName.Dispose();
      hv_Width.Dispose();
      hv_Height.Dispose();
      hv_RowDomain1.Dispose();
      hv_ColumnDomain1.Dispose();
      hv_RowDomain2.Dispose();
      hv_ColumnDomain2.Dispose();
      hv_WidthDomain.Dispose();
      hv_HeightDomain.Dispose();
      hv_Row1.Dispose();
      hv_Col1.Dispose();
      hv_Row2.Dispose();
      hv_Col2.Dispose();
      hv_BoxMask.Dispose();
      hv_Row.Dispose();
      hv_Col.Dispose();
      hv_Length1.Dispose();
      hv_Length2.Dispose();
      hv_Phi.Dispose();
      hv_NewRow.Dispose();
      hv_NewCol.Dispose();
      hv_NewLength1.Dispose();
      hv_NewLength2.Dispose();
      hv_NewPhi.Dispose();
      hv_Heights.Dispose();
      hv_Widths.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Image.Dispose();
      ho_Domain.Dispose();

      hv_Rows1.Dispose();
      hv_Cols1.Dispose();
      hv_Rows2.Dispose();
      hv_Cols2.Dispose();
      hv_Lengths1.Dispose();
      hv_Lengths2.Dispose();
      hv_Phis.Dispose();
      hv_Preprocessed.Dispose();
      hv_FactorWidth.Dispose();
      hv_FactorHeight.Dispose();
      hv_DLSamples.Dispose();
      hv_ImageDir.Dispose();
      hv_SampleIndices.Dispose();
      hv_IterationIndex.Dispose();
      hv_DLSampleCurrent.Dispose();
      hv_SampleIndex.Dispose();
      hv_KeyFileExists.Dispose();
      hv_FileNameRelative.Dispose();
      hv_FileNameSample.Dispose();
      hv_ImageID.Dispose();
      hv_Exception.Dispose();
      hv_ImageName.Dispose();
      hv_Width.Dispose();
      hv_Height.Dispose();
      hv_RowDomain1.Dispose();
      hv_ColumnDomain1.Dispose();
      hv_RowDomain2.Dispose();
      hv_ColumnDomain2.Dispose();
      hv_WidthDomain.Dispose();
      hv_HeightDomain.Dispose();
      hv_Row1.Dispose();
      hv_Col1.Dispose();
      hv_Row2.Dispose();
      hv_Col2.Dispose();
      hv_BoxMask.Dispose();
      hv_Row.Dispose();
      hv_Col.Dispose();
      hv_Length1.Dispose();
      hv_Length2.Dispose();
      hv_Phi.Dispose();
      hv_NewRow.Dispose();
      hv_NewCol.Dispose();
      hv_NewLength1.Dispose();
      hv_NewLength2.Dispose();
      hv_NewPhi.Dispose();
      hv_Heights.Dispose();
      hv_Widths.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Short Description: Create a lookup table and convert a grey scale image. 
  public void apply_colorscheme_on_gray_value_image (HObject ho_InputImage, out HObject ho_ResultImage, 
      HTuple hv_Schema)
  {




    // Local iconic variables 

    HObject ho_ImageR, ho_ImageG, ho_ImageB;

    // Local control variables 

    HTuple hv_X = new HTuple(), hv_Low = new HTuple();
    HTuple hv_High = new HTuple(), hv_OffR = new HTuple();
    HTuple hv_OffG = new HTuple(), hv_OffB = new HTuple();
    HTuple hv_A1 = new HTuple(), hv_A0 = new HTuple(), hv_R = new HTuple();
    HTuple hv_G = new HTuple(), hv_B = new HTuple(), hv_A0R = new HTuple();
    HTuple hv_A0G = new HTuple(), hv_A0B = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ResultImage);
    HOperatorSet.GenEmptyObj(out ho_ImageR);
    HOperatorSet.GenEmptyObj(out ho_ImageG);
    HOperatorSet.GenEmptyObj(out ho_ImageB);
    try
    {
      //
      //This procedure generates an RGB ResultImage for a grey-value InputImage.
      //In order to do so, create a color distribution as look up table
      //according to the Schema.
      //
      hv_X.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_X = HTuple.TupleGenSequence(
          0,255,1);
      }
      hv_Low.Dispose();
      HOperatorSet.TupleGenConst(256, 0, out hv_Low);
      hv_High.Dispose();
      HOperatorSet.TupleGenConst(256, 255, out hv_High);
      //
      if ((int)(new HTuple(hv_Schema.TupleEqual("jet"))) != 0)
      {
        //Scheme Jet: from blue to red
        hv_OffR.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_OffR = 3.0*64.0;
        }
        hv_OffG.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_OffG = 2.0*64.0;
        }
        hv_OffB.Dispose();
        hv_OffB = 64.0;
        hv_A1.Dispose();
        hv_A1 = -4.0;
        hv_A0.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_A0 = 255.0+128.0;
        }
        hv_R.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_R = ((((((((hv_X-hv_OffR)).TupleAbs()
            )*hv_A1)+hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
        }
        hv_G.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_G = ((((((((hv_X-hv_OffG)).TupleAbs()
            )*hv_A1)+hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
        }
        hv_B.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_B = ((((((((hv_X-hv_OffB)).TupleAbs()
            )*hv_A1)+hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
        }
        //
      }
      else if ((int)(new HTuple(hv_Schema.TupleEqual("inverse_jet"))) != 0)
      {
        //Scheme InvJet: from red to blue.
        hv_OffR.Dispose();
        hv_OffR = 64;
        hv_OffG.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_OffG = 2*64;
        }
        hv_OffB.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_OffB = 3*64;
        }
        hv_A1.Dispose();
        hv_A1 = -4.0;
        hv_A0.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_A0 = 255.0+128.0;
        }
        hv_R.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_R = ((((((((hv_X-hv_OffR)).TupleAbs()
            )*hv_A1)+hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
        }
        hv_G.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_G = ((((((((hv_X-hv_OffG)).TupleAbs()
            )*hv_A1)+hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
        }
        hv_B.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_B = ((((((((hv_X-hv_OffB)).TupleAbs()
            )*hv_A1)+hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
        }
        //
      }
      else if ((int)(new HTuple(hv_Schema.TupleEqual("hot"))) != 0)
      {
        //Scheme Hot.
        hv_A1.Dispose();
        hv_A1 = 3.0;
        hv_A0R.Dispose();
        hv_A0R = 0.0;
        hv_A0G.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_A0G = ((1.0/3.0)*hv_A1)*255.0;
        }
        hv_A0B.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_A0B = ((2.0/3.0)*hv_A1)*255.0;
        }
        hv_R.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_R = (((((hv_X*hv_A1)-hv_A0R)).TupleMax2(
            hv_Low))).TupleMin2(hv_High);
        }
        hv_G.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_G = (((((hv_X*hv_A1)-hv_A0G)).TupleMax2(
            hv_Low))).TupleMin2(hv_High);
        }
        hv_B.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_B = (((((hv_X*hv_A1)-hv_A0B)).TupleMax2(
            hv_Low))).TupleMin2(hv_High);
        }
        //
      }
      else if ((int)(new HTuple(hv_Schema.TupleEqual("inverse_hot"))) != 0)
      {
        //Scheme Inverse Hot.
        hv_A1.Dispose();
        hv_A1 = -3.0;
        hv_A0R.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_A0R = hv_A1*255.0;
        }
        hv_A0G.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_A0G = ((2.0/3.0)*hv_A1)*255.0;
        }
        hv_A0B.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_A0B = ((1.0/3.0)*hv_A1)*255.0;
        }
        hv_R.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_R = (((((hv_X*hv_A1)-hv_A0R)).TupleMax2(
            hv_Low))).TupleMin2(hv_High);
        }
        hv_G.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_G = (((((hv_X*hv_A1)-hv_A0G)).TupleMax2(
            hv_Low))).TupleMin2(hv_High);
        }
        hv_B.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_B = (((((hv_X*hv_A1)-hv_A0B)).TupleMax2(
            hv_Low))).TupleMin2(hv_High);
        }
        //
      }
      else
      {
        //
        throw new HalconException(("Unknown color schema: "+hv_Schema)+".");
        //
      }
      //
      ho_ImageR.Dispose();
      HOperatorSet.LutTrans(ho_InputImage, out ho_ImageR, hv_R);
      ho_ImageG.Dispose();
      HOperatorSet.LutTrans(ho_InputImage, out ho_ImageG, hv_G);
      ho_ImageB.Dispose();
      HOperatorSet.LutTrans(ho_InputImage, out ho_ImageB, hv_B);
      ho_ResultImage.Dispose();
      HOperatorSet.Compose3(ho_ImageR, ho_ImageG, ho_ImageB, out ho_ResultImage);
      //
      ho_ImageR.Dispose();
      ho_ImageG.Dispose();
      ho_ImageB.Dispose();

      hv_X.Dispose();
      hv_Low.Dispose();
      hv_High.Dispose();
      hv_OffR.Dispose();
      hv_OffG.Dispose();
      hv_OffB.Dispose();
      hv_A1.Dispose();
      hv_A0.Dispose();
      hv_R.Dispose();
      hv_G.Dispose();
      hv_B.Dispose();
      hv_A0R.Dispose();
      hv_A0G.Dispose();
      hv_A0B.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_ImageR.Dispose();
      ho_ImageG.Dispose();
      ho_ImageB.Dispose();

      hv_X.Dispose();
      hv_Low.Dispose();
      hv_High.Dispose();
      hv_OffR.Dispose();
      hv_OffG.Dispose();
      hv_OffB.Dispose();
      hv_A1.Dispose();
      hv_A0.Dispose();
      hv_R.Dispose();
      hv_G.Dispose();
      hv_B.Dispose();
      hv_A0R.Dispose();
      hv_A0G.Dispose();
      hv_A0B.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Semantic Segmentation
  // Short Description: Calculate the class weights for a semantic segmentation dataset. 
  public void calculate_dl_segmentation_class_weights (HTuple hv_DLDataset, HTuple hv_MaxWeight, 
      HTuple hv_IgnoreClassIDs, out HTuple hv_ClassWeights)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_SegmentationImage=null;

    // Local control variables 

    HTuple hv_KeysExists = new HTuple(), hv_DLSamples = new HTuple();
    HTuple hv_SampleIndices = new HTuple(), hv_ClassIDs = new HTuple();
    HTuple hv_NumClasses = new HTuple(), hv_ClassIDsToClassIdx = new HTuple();
    HTuple hv_ClassAreas = new HTuple(), hv_SampleIndex = new HTuple();
    HTuple hv_DLSample = new HTuple(), hv_ImageType = new HTuple();
    HTuple hv_AbsoluteHisto = new HTuple(), hv_TotalArea = new HTuple();
    HTuple hv_ValidClasses = new HTuple(), hv_ClassFreq = new HTuple();
    HTuple hv_IndicesToClip = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_SegmentationImage);
    hv_ClassWeights = new HTuple();
    try
    {
      //
      //This procedure calculates a weight for each class that is present in the Dataset.
      //The class weights are calculated according to the inverse class frequencies
      //in the training dataset.
      //Therefore, the dataset has to be split before calling this procedure.
      //
      //Check if the input is correct.
      hv_KeysExists.Dispose();
      HOperatorSet.GetDictParam(hv_DLDataset, "key_exists", (new HTuple("samples")).TupleConcat(
          "class_ids"), out hv_KeysExists);
      if ((int)(((hv_KeysExists.TupleSelect(0))).TupleNot()) != 0)
      {
        throw new HalconException("DLDataset must contain a key-value pair for 'samples'");
      }
      if ((int)(((hv_KeysExists.TupleSelect(1))).TupleNot()) != 0)
      {
        throw new HalconException("DLDataset must contain a key-value pair for 'class_ids'");
      }
      if ((int)(new HTuple(hv_MaxWeight.TupleLessEqual(0))) != 0)
      {
        throw new HalconException("MaxWeight must be greater than 0");
      }
      //
      //Get the samples of the dataset.
      hv_DLSamples.Dispose();
      HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLSamples);
      //Get the train samples.
      hv_SampleIndices.Dispose();
      find_dl_samples(hv_DLSamples, "split", "train", "match", out hv_SampleIndices);
      if ((int)(new HTuple((new HTuple(hv_SampleIndices.TupleLength())).TupleEqual(
          0))) != 0)
      {
        throw new HalconException("The DLDataset does not contain any samples with value 'train' for key 'split'");
      }
      //
      //Get the class IDs of the dataset.
      hv_ClassIDs.Dispose();
      HOperatorSet.GetDictTuple(hv_DLDataset, "class_ids", out hv_ClassIDs);
      hv_NumClasses.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NumClasses = new HTuple(hv_ClassIDs.TupleLength()
          );
      }
      //
      //Define mapping from class ID to class index.
      hv_ClassIDsToClassIdx.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ClassIDsToClassIdx = HTuple.TupleGenConst(
          (hv_ClassIDs.TupleMax())+1,-1);
      }
      if (hv_ClassIDsToClassIdx == null)
        hv_ClassIDsToClassIdx = new HTuple();
      hv_ClassIDsToClassIdx[hv_ClassIDs] = HTuple.TupleGenSequence(0,(new HTuple(hv_ClassIDs.TupleLength()
          ))-1,1);
      //
      //We want to collect the number of pixels for each class.
      hv_ClassAreas.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ClassAreas = HTuple.TupleGenConst(
          new HTuple(hv_ClassIDs.TupleLength()),0);
      }
      //
      //Loop over the samples.
      for (hv_SampleIndex=0; (int)hv_SampleIndex<=(int)((new HTuple(hv_SampleIndices.TupleLength()
          ))-1); hv_SampleIndex = (int)hv_SampleIndex + 1)
      {
        //
        //Read the sample.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DLSample.Dispose();
        read_dl_samples(hv_DLDataset, hv_SampleIndices.TupleSelect(hv_SampleIndex), 
            out hv_DLSample);
        }
        //
        //Get the segmentation image.
        ho_SegmentationImage.Dispose();
        HOperatorSet.GetDictObject(out ho_SegmentationImage, hv_DLSample, "segmentation_image");
        //
        //Convert the segmentation image if necessary.
        hv_ImageType.Dispose();
        HOperatorSet.GetImageType(ho_SegmentationImage, out hv_ImageType);
        if ((int)(new HTuple((new HTuple(((((new HTuple("int1")).TupleConcat("int2")).TupleConcat(
            "uint2")).TupleConcat("byte")).TupleFind(hv_ImageType))).TupleEqual(-1))) != 0)
        {
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.ConvertImageType(ho_SegmentationImage, out ExpTmpOutVar_0, 
              "uint2");
          ho_SegmentationImage.Dispose();
          ho_SegmentationImage = ExpTmpOutVar_0;
          }
        }
        //
        //Get the number of pixels for each class.
        hv_AbsoluteHisto.Dispose();
        HOperatorSet.GrayHistoAbs(ho_SegmentationImage, ho_SegmentationImage, 1, 
            out hv_AbsoluteHisto);
        //
        //Accumulate the areas.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ClassAreas = hv_ClassAreas+(hv_AbsoluteHisto.TupleSelect(
            hv_ClassIDs));
        hv_ClassAreas.Dispose();
        hv_ClassAreas = ExpTmpLocalVar_ClassAreas;
        }
        }
      }
      //
      //Get the total number of pixels without the area of ignore classes.
      if (hv_ClassAreas == null)
        hv_ClassAreas = new HTuple();
      hv_ClassAreas[hv_ClassIDsToClassIdx.TupleSelect(hv_IgnoreClassIDs)] = 0;
      hv_TotalArea.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TotalArea = hv_ClassAreas.TupleSum()
          ;
      }
      //
      //Calculate the inverse class frequencies.
      hv_ClassWeights.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ClassWeights = HTuple.TupleGenConst(
          new HTuple(hv_ClassIDs.TupleLength()),0.0);
      }
      hv_ValidClasses.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ValidClasses = ((hv_ClassAreas.TupleNotEqualElem(
          0))).TupleFind(1);
      }
      hv_ClassFreq.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ClassFreq = hv_ClassAreas/(hv_TotalArea.TupleReal()
          );
      }
      if (hv_ClassWeights == null)
        hv_ClassWeights = new HTuple();
      hv_ClassWeights[hv_ValidClasses] = 1.0/((hv_ClassFreq.TupleSelect(hv_ValidClasses))+0.0001);
      //
      //Scale the weights to obtain a final output of 1.0 for the most frequent class.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_ClassWeights = hv_ClassWeights/(((hv_ClassWeights.TupleSelect(
          hv_ValidClasses))).TupleMin());
      hv_ClassWeights.Dispose();
      hv_ClassWeights = ExpTmpLocalVar_ClassWeights;
      }
      }
      //Clip the weights.
      hv_IndicesToClip.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_IndicesToClip = ((hv_ClassWeights.TupleGreaterElem(
          hv_MaxWeight))).TupleFind(1);
      }
      if ((int)(new HTuple(hv_IndicesToClip.TupleNotEqual(-1))) != 0)
      {
        if (hv_ClassWeights == null)
          hv_ClassWeights = new HTuple();
        hv_ClassWeights[hv_IndicesToClip] = hv_MaxWeight;
      }

      ho_SegmentationImage.Dispose();

      hv_KeysExists.Dispose();
      hv_DLSamples.Dispose();
      hv_SampleIndices.Dispose();
      hv_ClassIDs.Dispose();
      hv_NumClasses.Dispose();
      hv_ClassIDsToClassIdx.Dispose();
      hv_ClassAreas.Dispose();
      hv_SampleIndex.Dispose();
      hv_DLSample.Dispose();
      hv_ImageType.Dispose();
      hv_AbsoluteHisto.Dispose();
      hv_TotalArea.Dispose();
      hv_ValidClasses.Dispose();
      hv_ClassFreq.Dispose();
      hv_IndicesToClip.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_SegmentationImage.Dispose();

      hv_KeysExists.Dispose();
      hv_DLSamples.Dispose();
      hv_SampleIndices.Dispose();
      hv_ClassIDs.Dispose();
      hv_NumClasses.Dispose();
      hv_ClassIDsToClassIdx.Dispose();
      hv_ClassAreas.Dispose();
      hv_SampleIndex.Dispose();
      hv_DLSample.Dispose();
      hv_ImageType.Dispose();
      hv_AbsoluteHisto.Dispose();
      hv_TotalArea.Dispose();
      hv_ValidClasses.Dispose();
      hv_ClassFreq.Dispose();
      hv_IndicesToClip.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: Checks the content of the parameter dictionary DLPreprocessParam. 
  public void check_dl_preprocess_param (HTuple hv_DLPreprocessParam)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_DLModelType = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_SupportedModelTypes = new HTuple(), hv_Index = new HTuple();
    HTuple hv_ParamNamesGeneral = new HTuple(), hv_ParamNamesSegmentation = new HTuple();
    HTuple hv_ParamNamesDetectionOptional = new HTuple(), hv_ParamNamesPreprocessingOptional = new HTuple();
    HTuple hv_ParamNamesAll = new HTuple(), hv_ParamNames = new HTuple();
    HTuple hv_KeysExists = new HTuple(), hv_I = new HTuple();
    HTuple hv_Exists = new HTuple(), hv_InputKeys = new HTuple();
    HTuple hv_Key = new HTuple(), hv_Value = new HTuple();
    HTuple hv_Indices = new HTuple(), hv_ValidValues = new HTuple();
    HTuple hv_ValidTypes = new HTuple(), hv_V = new HTuple();
    HTuple hv_T = new HTuple(), hv_IsInt = new HTuple(), hv_ValidTypesListing = new HTuple();
    HTuple hv_ValidValueListing = new HTuple(), hv_EmptyStrings = new HTuple();
    HTuple hv_ImageRangeMinExists = new HTuple(), hv_ImageRangeMaxExists = new HTuple();
    HTuple hv_ImageRangeMin = new HTuple(), hv_ImageRangeMax = new HTuple();
    HTuple hv_IndexParam = new HTuple(), hv_SetBackgroundID = new HTuple();
    HTuple hv_ClassIDsBackground = new HTuple(), hv_Intersection = new HTuple();
    HTuple hv_IgnoreClassIDs = new HTuple(), hv_KnownClasses = new HTuple();
    HTuple hv_IgnoreClassID = new HTuple(), hv_OptionalKeysExist = new HTuple();
    HTuple hv_InstanceType = new HTuple(), hv_IgnoreDirection = new HTuple();
    HTuple hv_ClassIDsNoOrientation = new HTuple(), hv_SemTypes = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //
      //This procedure checks a dictionary with parameters for DL preprocessing.
      //
      try
      {
        hv_DLModelType.Dispose();
        HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "model_type", out hv_DLModelType);
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        throw new HalconException(new HTuple(new HTuple("DLPreprocessParam needs the parameter: '")+"model_type")+"'");
      }
      //
      //Check for correct model type.
      hv_SupportedModelTypes.Dispose();
      hv_SupportedModelTypes = new HTuple();
      hv_SupportedModelTypes[0] = "anomaly_detection";
      hv_SupportedModelTypes[1] = "classification";
      hv_SupportedModelTypes[2] = "detection";
      hv_SupportedModelTypes[3] = "segmentation";
      hv_Index.Dispose();
      HOperatorSet.TupleFind(hv_SupportedModelTypes, hv_DLModelType, out hv_Index);
      if ((int)((new HTuple(hv_Index.TupleEqual(-1))).TupleOr(new HTuple(hv_Index.TupleEqual(
          new HTuple())))) != 0)
      {
        throw new HalconException(new HTuple("Only models of type 'anomaly_detection', 'classification', 'detection', or 'segmentation' are supported"));

        hv_DLModelType.Dispose();
        hv_Exception.Dispose();
        hv_SupportedModelTypes.Dispose();
        hv_Index.Dispose();
        hv_ParamNamesGeneral.Dispose();
        hv_ParamNamesSegmentation.Dispose();
        hv_ParamNamesDetectionOptional.Dispose();
        hv_ParamNamesPreprocessingOptional.Dispose();
        hv_ParamNamesAll.Dispose();
        hv_ParamNames.Dispose();
        hv_KeysExists.Dispose();
        hv_I.Dispose();
        hv_Exists.Dispose();
        hv_InputKeys.Dispose();
        hv_Key.Dispose();
        hv_Value.Dispose();
        hv_Indices.Dispose();
        hv_ValidValues.Dispose();
        hv_ValidTypes.Dispose();
        hv_V.Dispose();
        hv_T.Dispose();
        hv_IsInt.Dispose();
        hv_ValidTypesListing.Dispose();
        hv_ValidValueListing.Dispose();
        hv_EmptyStrings.Dispose();
        hv_ImageRangeMinExists.Dispose();
        hv_ImageRangeMaxExists.Dispose();
        hv_ImageRangeMin.Dispose();
        hv_ImageRangeMax.Dispose();
        hv_IndexParam.Dispose();
        hv_SetBackgroundID.Dispose();
        hv_ClassIDsBackground.Dispose();
        hv_Intersection.Dispose();
        hv_IgnoreClassIDs.Dispose();
        hv_KnownClasses.Dispose();
        hv_IgnoreClassID.Dispose();
        hv_OptionalKeysExist.Dispose();
        hv_InstanceType.Dispose();
        hv_IgnoreDirection.Dispose();
        hv_ClassIDsNoOrientation.Dispose();
        hv_SemTypes.Dispose();

        return;
      }
      //
      //Parameter names that are required.
      //General parameters.
      hv_ParamNamesGeneral.Dispose();
      hv_ParamNamesGeneral = new HTuple();
      hv_ParamNamesGeneral[0] = "model_type";
      hv_ParamNamesGeneral[1] = "image_width";
      hv_ParamNamesGeneral[2] = "image_height";
      hv_ParamNamesGeneral[3] = "image_num_channels";
      hv_ParamNamesGeneral[4] = "image_range_min";
      hv_ParamNamesGeneral[5] = "image_range_max";
      hv_ParamNamesGeneral[6] = "normalization_type";
      hv_ParamNamesGeneral[7] = "domain_handling";
      //Segmentation specific parameters.
      hv_ParamNamesSegmentation.Dispose();
      hv_ParamNamesSegmentation = new HTuple();
      hv_ParamNamesSegmentation[0] = "ignore_class_ids";
      hv_ParamNamesSegmentation[1] = "set_background_id";
      hv_ParamNamesSegmentation[2] = "class_ids_background";
      //Detection specific parameters.
      hv_ParamNamesDetectionOptional.Dispose();
      hv_ParamNamesDetectionOptional = new HTuple();
      hv_ParamNamesDetectionOptional[0] = "instance_type";
      hv_ParamNamesDetectionOptional[1] = "ignore_direction";
      hv_ParamNamesDetectionOptional[2] = "class_ids_no_orientation";
      //Normalization specific parameters.
      hv_ParamNamesPreprocessingOptional.Dispose();
      hv_ParamNamesPreprocessingOptional = new HTuple();
      hv_ParamNamesPreprocessingOptional[0] = "mean_values_normalization";
      hv_ParamNamesPreprocessingOptional[1] = "deviation_values_normalization";
      //All parameters
      hv_ParamNamesAll.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ParamNamesAll = new HTuple();
      hv_ParamNamesAll = hv_ParamNamesAll.TupleConcat(hv_ParamNamesGeneral, hv_ParamNamesSegmentation, hv_ParamNamesDetectionOptional, hv_ParamNamesPreprocessingOptional);
      }
      hv_ParamNames.Dispose();
      hv_ParamNames = new HTuple(hv_ParamNamesGeneral);
      if ((int)(new HTuple(hv_DLModelType.TupleEqual("segmentation"))) != 0)
      {
        //Extend ParamNames for models of type segmentation.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ParamNames = hv_ParamNames.TupleConcat(
            hv_ParamNamesSegmentation);
        hv_ParamNames.Dispose();
        hv_ParamNames = ExpTmpLocalVar_ParamNames;
        }
        }
      }
      //
      //Check if legacy parameter exist.
      //Otherwise map it to the legal parameter.
      replace_legacy_preprocessing_parameters(hv_DLPreprocessParam);
      //
      //Check that all necessary parameters are included.
      //
      hv_KeysExists.Dispose();
      HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", hv_ParamNames, 
          out hv_KeysExists);
      if ((int)(new HTuple(((((hv_KeysExists.TupleEqualElem(0))).TupleSum())).TupleGreater(
          0))) != 0)
      {
        for (hv_I=0; (int)hv_I<=(int)(new HTuple(hv_KeysExists.TupleLength())); hv_I = (int)hv_I + 1)
        {
          hv_Exists.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Exists = hv_KeysExists.TupleSelect(
              hv_I);
          }
          if ((int)(hv_Exists.TupleNot()) != 0)
          {
            throw new HalconException(("DLPreprocessParam needs the parameter: '"+(hv_ParamNames.TupleSelect(
                hv_I)))+"'");
          }
        }
      }
      //
      //Check the keys provided.
      hv_InputKeys.Dispose();
      HOperatorSet.GetDictParam(hv_DLPreprocessParam, "keys", new HTuple(), out hv_InputKeys);
      for (hv_I=0; (int)hv_I<=(int)((new HTuple(hv_InputKeys.TupleLength()))-1); hv_I = (int)hv_I + 1)
      {
        hv_Key.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Key = hv_InputKeys.TupleSelect(
            hv_I);
        }
        hv_Value.Dispose();
        HOperatorSet.GetDictTuple(hv_DLPreprocessParam, hv_Key, out hv_Value);
        //Check that the key is known.
        hv_Indices.Dispose();
        HOperatorSet.TupleFind(hv_ParamNamesAll, hv_Key, out hv_Indices);
        if ((int)(new HTuple(hv_Indices.TupleEqual(-1))) != 0)
        {
          throw new HalconException(("Unknown key for DLPreprocessParam: '"+(hv_InputKeys.TupleSelect(
              hv_I)))+"'");

          hv_DLModelType.Dispose();
          hv_Exception.Dispose();
          hv_SupportedModelTypes.Dispose();
          hv_Index.Dispose();
          hv_ParamNamesGeneral.Dispose();
          hv_ParamNamesSegmentation.Dispose();
          hv_ParamNamesDetectionOptional.Dispose();
          hv_ParamNamesPreprocessingOptional.Dispose();
          hv_ParamNamesAll.Dispose();
          hv_ParamNames.Dispose();
          hv_KeysExists.Dispose();
          hv_I.Dispose();
          hv_Exists.Dispose();
          hv_InputKeys.Dispose();
          hv_Key.Dispose();
          hv_Value.Dispose();
          hv_Indices.Dispose();
          hv_ValidValues.Dispose();
          hv_ValidTypes.Dispose();
          hv_V.Dispose();
          hv_T.Dispose();
          hv_IsInt.Dispose();
          hv_ValidTypesListing.Dispose();
          hv_ValidValueListing.Dispose();
          hv_EmptyStrings.Dispose();
          hv_ImageRangeMinExists.Dispose();
          hv_ImageRangeMaxExists.Dispose();
          hv_ImageRangeMin.Dispose();
          hv_ImageRangeMax.Dispose();
          hv_IndexParam.Dispose();
          hv_SetBackgroundID.Dispose();
          hv_ClassIDsBackground.Dispose();
          hv_Intersection.Dispose();
          hv_IgnoreClassIDs.Dispose();
          hv_KnownClasses.Dispose();
          hv_IgnoreClassID.Dispose();
          hv_OptionalKeysExist.Dispose();
          hv_InstanceType.Dispose();
          hv_IgnoreDirection.Dispose();
          hv_ClassIDsNoOrientation.Dispose();
          hv_SemTypes.Dispose();

          return;
        }
        //Set expected values and types.
        hv_ValidValues.Dispose();
        hv_ValidValues = new HTuple();
        hv_ValidTypes.Dispose();
        hv_ValidTypes = new HTuple();
        if ((int)(new HTuple(hv_Key.TupleEqual("normalization_type"))) != 0)
        {
          hv_ValidValues.Dispose();
          hv_ValidValues = new HTuple();
          hv_ValidValues[0] = "all_channels";
          hv_ValidValues[1] = "first_channel";
          hv_ValidValues[2] = "constant_values";
          hv_ValidValues[3] = "none";
        }
        else if ((int)(new HTuple(hv_Key.TupleEqual("domain_handling"))) != 0)
        {
          if ((int)(new HTuple(hv_DLModelType.TupleEqual("anomaly_detection"))) != 0)
          {
            hv_ValidValues.Dispose();
            hv_ValidValues = new HTuple();
            hv_ValidValues[0] = "full_domain";
            hv_ValidValues[1] = "crop_domain";
            hv_ValidValues[2] = "keep_domain";
          }
          else
          {
            hv_ValidValues.Dispose();
            hv_ValidValues = new HTuple();
            hv_ValidValues[0] = "full_domain";
            hv_ValidValues[1] = "crop_domain";
          }
        }
        else if ((int)(new HTuple(hv_Key.TupleEqual("model_type"))) != 0)
        {
          hv_ValidValues.Dispose();
          hv_ValidValues = new HTuple();
          hv_ValidValues[0] = "anomaly_detection";
          hv_ValidValues[1] = "classification";
          hv_ValidValues[2] = "detection";
          hv_ValidValues[3] = "segmentation";
        }
        else if ((int)(new HTuple(hv_Key.TupleEqual("set_background_id"))) != 0)
        {
          hv_ValidTypes.Dispose();
          hv_ValidTypes = "int";
        }
        else if ((int)(new HTuple(hv_Key.TupleEqual("class_ids_background"))) != 0)
        {
          hv_ValidTypes.Dispose();
          hv_ValidTypes = "int";
        }
        //Check that type is valid.
        if ((int)(new HTuple((new HTuple(hv_ValidTypes.TupleLength())).TupleGreater(
            0))) != 0)
        {
          for (hv_V=0; (int)hv_V<=(int)((new HTuple(hv_ValidTypes.TupleLength()))-1); hv_V = (int)hv_V + 1)
          {
            hv_T.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_T = hv_ValidTypes.TupleSelect(
                hv_V);
            }
            if ((int)(new HTuple(hv_T.TupleEqual("int"))) != 0)
            {
              hv_IsInt.Dispose();
              HOperatorSet.TupleIsInt(hv_Value, out hv_IsInt);
              if ((int)(hv_IsInt.TupleNot()) != 0)
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                {
                HTuple 
                  ExpTmpLocalVar_ValidTypes = ("'"+hv_ValidTypes)+"'";
                hv_ValidTypes.Dispose();
                hv_ValidTypes = ExpTmpLocalVar_ValidTypes;
                }
                }
                if ((int)(new HTuple((new HTuple(hv_ValidTypes.TupleLength())).TupleLess(
                    2))) != 0)
                {
                  hv_ValidTypesListing.Dispose();
                  hv_ValidTypesListing = new HTuple(hv_ValidTypes);
                }
                else
                {
                  hv_ValidTypesListing.Dispose();
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  hv_ValidTypesListing = ((((hv_ValidTypes.TupleSelectRange(
                      0,(new HTuple(0)).TupleMax2((new HTuple(hv_ValidTypes.TupleLength()
                      ))-2)))+new HTuple(", "))+(hv_ValidTypes.TupleSelect((new HTuple(hv_ValidTypes.TupleLength()
                      ))-1)))).TupleSum();
                  }
                }
                throw new HalconException(((((("The value given in the key '"+hv_Key)+"' of DLPreprocessParam is invalid. Valid types are: ")+hv_ValidTypesListing)+". The given value was '")+hv_Value)+"'.");

                hv_DLModelType.Dispose();
                hv_Exception.Dispose();
                hv_SupportedModelTypes.Dispose();
                hv_Index.Dispose();
                hv_ParamNamesGeneral.Dispose();
                hv_ParamNamesSegmentation.Dispose();
                hv_ParamNamesDetectionOptional.Dispose();
                hv_ParamNamesPreprocessingOptional.Dispose();
                hv_ParamNamesAll.Dispose();
                hv_ParamNames.Dispose();
                hv_KeysExists.Dispose();
                hv_I.Dispose();
                hv_Exists.Dispose();
                hv_InputKeys.Dispose();
                hv_Key.Dispose();
                hv_Value.Dispose();
                hv_Indices.Dispose();
                hv_ValidValues.Dispose();
                hv_ValidTypes.Dispose();
                hv_V.Dispose();
                hv_T.Dispose();
                hv_IsInt.Dispose();
                hv_ValidTypesListing.Dispose();
                hv_ValidValueListing.Dispose();
                hv_EmptyStrings.Dispose();
                hv_ImageRangeMinExists.Dispose();
                hv_ImageRangeMaxExists.Dispose();
                hv_ImageRangeMin.Dispose();
                hv_ImageRangeMax.Dispose();
                hv_IndexParam.Dispose();
                hv_SetBackgroundID.Dispose();
                hv_ClassIDsBackground.Dispose();
                hv_Intersection.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_KnownClasses.Dispose();
                hv_IgnoreClassID.Dispose();
                hv_OptionalKeysExist.Dispose();
                hv_InstanceType.Dispose();
                hv_IgnoreDirection.Dispose();
                hv_ClassIDsNoOrientation.Dispose();
                hv_SemTypes.Dispose();

                return;
              }
            }
            else
            {
              throw new HalconException("Internal error. Unknown valid type.");
            }
          }
        }
        //Check that value is valid.
        if ((int)(new HTuple((new HTuple(hv_ValidValues.TupleLength())).TupleGreater(
            0))) != 0)
        {
          hv_Index.Dispose();
          HOperatorSet.TupleFindFirst(hv_ValidValues, hv_Value, out hv_Index);
          if ((int)(new HTuple(hv_Index.TupleEqual(-1))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_ValidValues = ("'"+hv_ValidValues)+"'";
            hv_ValidValues.Dispose();
            hv_ValidValues = ExpTmpLocalVar_ValidValues;
            }
            }
            if ((int)(new HTuple((new HTuple(hv_ValidValues.TupleLength())).TupleLess(
                2))) != 0)
            {
              hv_ValidValueListing.Dispose();
              hv_ValidValueListing = new HTuple(hv_ValidValues);
            }
            else
            {
              hv_EmptyStrings.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_EmptyStrings = HTuple.TupleGenConst(
                  (new HTuple(hv_ValidValues.TupleLength()))-2,"");
              }
              hv_ValidValueListing.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_ValidValueListing = ((((hv_ValidValues.TupleSelectRange(
                  0,(new HTuple(0)).TupleMax2((new HTuple(hv_ValidValues.TupleLength()
                  ))-2)))+new HTuple(", "))+(hv_EmptyStrings.TupleConcat(hv_ValidValues.TupleSelect(
                  (new HTuple(hv_ValidValues.TupleLength()))-1))))).TupleSum();
              }
            }
            throw new HalconException(((((("The value given in the key '"+hv_Key)+"' of DLPreprocessParam is invalid. Valid values are: ")+hv_ValidValueListing)+". The given value was '")+hv_Value)+"'.");
          }
        }
      }
      //
      //Check the correct setting of ImageRangeMin and ImageRangeMax.
      if ((int)((new HTuple(hv_DLModelType.TupleEqual("classification"))).TupleOr(
          new HTuple(hv_DLModelType.TupleEqual("detection")))) != 0)
      {
        //Check ImageRangeMin and ImageRangeMax.
        hv_ImageRangeMinExists.Dispose();
        HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", "image_range_min", 
            out hv_ImageRangeMinExists);
        hv_ImageRangeMaxExists.Dispose();
        HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", "image_range_max", 
            out hv_ImageRangeMaxExists);
        //If they are present, check that they are set correctly.
        if ((int)(hv_ImageRangeMinExists) != 0)
        {
          hv_ImageRangeMin.Dispose();
          HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_min", out hv_ImageRangeMin);
          if ((int)(new HTuple(hv_ImageRangeMin.TupleNotEqual(-127))) != 0)
          {
            throw new HalconException(("For model type "+hv_DLModelType)+" ImageRangeMin has to be -127.");
          }
        }
        if ((int)(hv_ImageRangeMaxExists) != 0)
        {
          hv_ImageRangeMax.Dispose();
          HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_max", out hv_ImageRangeMax);
          if ((int)(new HTuple(hv_ImageRangeMax.TupleNotEqual(128))) != 0)
          {
            throw new HalconException(("For model type "+hv_DLModelType)+" ImageRangeMax has to be 128.");
          }
        }
      }
      //
      //Check segmentation specific parameters.
      if ((int)(new HTuple(hv_DLModelType.TupleEqual("segmentation"))) != 0)
      {
        //Check if detection specific parameters are set.
        hv_KeysExists.Dispose();
        HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", hv_ParamNamesDetectionOptional, 
            out hv_KeysExists);
        //If they are present, check that they are [].
        for (hv_IndexParam=0; (int)hv_IndexParam<=(int)((new HTuple(hv_ParamNamesDetectionOptional.TupleLength()
            ))-1); hv_IndexParam = (int)hv_IndexParam + 1)
        {
          if ((int)(hv_KeysExists.TupleSelect(hv_IndexParam)) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Value.Dispose();
            HOperatorSet.GetDictTuple(hv_DLPreprocessParam, hv_ParamNamesDetectionOptional.TupleSelect(
                hv_IndexParam), out hv_Value);
            }
            if ((int)(new HTuple(hv_Value.TupleNotEqual(new HTuple()))) != 0)
            {
              throw new HalconException(((("The preprocessing parameter '"+(hv_ParamNamesDetectionOptional.TupleSelect(
                  hv_IndexParam)))+"' was set to ")+hv_Value)+new HTuple(" but for segmentation it should be set to [], as it is not used for this method."));
            }
          }
        }
        //Check 'set_background_id'.
        hv_SetBackgroundID.Dispose();
        HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "set_background_id", out hv_SetBackgroundID);
        if ((int)(new HTuple((new HTuple(hv_SetBackgroundID.TupleLength())).TupleGreater(
            1))) != 0)
        {
          throw new HalconException("Only one class_id as 'set_background_id' allowed.");
        }
        //Check 'class_ids_background'.
        hv_ClassIDsBackground.Dispose();
        HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "class_ids_background", out hv_ClassIDsBackground);
        if ((int)((new HTuple((new HTuple((new HTuple(hv_SetBackgroundID.TupleLength()
            )).TupleGreater(0))).TupleAnd((new HTuple((new HTuple(hv_ClassIDsBackground.TupleLength()
            )).TupleGreater(0))).TupleNot()))).TupleOr((new HTuple((new HTuple(hv_ClassIDsBackground.TupleLength()
            )).TupleGreater(0))).TupleAnd((new HTuple((new HTuple(hv_SetBackgroundID.TupleLength()
            )).TupleGreater(0))).TupleNot()))) != 0)
        {
          throw new HalconException("Both keys 'set_background_id' and 'class_ids_background' are required.");
        }
        //Check that 'class_ids_background' and 'set_background_id' are disjoint.
        if ((int)(new HTuple((new HTuple(hv_SetBackgroundID.TupleLength())).TupleGreater(
            0))) != 0)
        {
          hv_Intersection.Dispose();
          HOperatorSet.TupleIntersection(hv_SetBackgroundID, hv_ClassIDsBackground, 
              out hv_Intersection);
          if ((int)(new HTuple(hv_Intersection.TupleLength())) != 0)
          {
            throw new HalconException("Class IDs in 'set_background_id' and 'class_ids_background' need to be disjoint.");
          }
        }
        //Check 'ignore_class_ids'.
        hv_IgnoreClassIDs.Dispose();
        HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "ignore_class_ids", out hv_IgnoreClassIDs);
        hv_KnownClasses.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_KnownClasses = new HTuple();
        hv_KnownClasses = hv_KnownClasses.TupleConcat(hv_SetBackgroundID, hv_ClassIDsBackground);
        }
        for (hv_I=0; (int)hv_I<=(int)((new HTuple(hv_IgnoreClassIDs.TupleLength()
            ))-1); hv_I = (int)hv_I + 1)
        {
          hv_IgnoreClassID.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_IgnoreClassID = hv_IgnoreClassIDs.TupleSelect(
              hv_I);
          }
          hv_Index.Dispose();
          HOperatorSet.TupleFindFirst(hv_KnownClasses, hv_IgnoreClassID, out hv_Index);
          if ((int)((new HTuple((new HTuple(hv_Index.TupleLength())).TupleGreater(
              0))).TupleAnd(new HTuple(hv_Index.TupleNotEqual(-1)))) != 0)
          {
            throw new HalconException("The given 'ignore_class_ids' must not be included in the 'class_ids_background' or 'set_background_id'.");
          }
        }
      }
      else if ((int)(new HTuple(hv_DLModelType.TupleEqual("detection"))) != 0)
      {
        //Check if segmentation specific parameters are set.
        hv_KeysExists.Dispose();
        HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", hv_ParamNamesSegmentation, 
            out hv_KeysExists);
        //If they are present, check that they are [].
        for (hv_IndexParam=0; (int)hv_IndexParam<=(int)((new HTuple(hv_ParamNamesSegmentation.TupleLength()
            ))-1); hv_IndexParam = (int)hv_IndexParam + 1)
        {
          if ((int)(hv_KeysExists.TupleSelect(hv_IndexParam)) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Value.Dispose();
            HOperatorSet.GetDictTuple(hv_DLPreprocessParam, hv_ParamNamesSegmentation.TupleSelect(
                hv_IndexParam), out hv_Value);
            }
            if ((int)(new HTuple(hv_Value.TupleNotEqual(new HTuple()))) != 0)
            {
              throw new HalconException(((("The preprocessing parameter '"+(hv_ParamNamesSegmentation.TupleSelect(
                  hv_IndexParam)))+"' was set to ")+hv_Value)+new HTuple(" but for detection it should be set to [], as it is not used for this method."));
            }
          }
        }
        //Check optional parameters.
        hv_OptionalKeysExist.Dispose();
        HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", hv_ParamNamesDetectionOptional, 
            out hv_OptionalKeysExist);
        if ((int)(hv_OptionalKeysExist.TupleSelect(0)) != 0)
        {
          //Check 'instance_type'.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_InstanceType.Dispose();
          HOperatorSet.GetDictTuple(hv_DLPreprocessParam, hv_ParamNamesDetectionOptional.TupleSelect(
              0), out hv_InstanceType);
          }
          if ((int)(new HTuple((new HTuple(((new HTuple("rectangle1")).TupleConcat(
              "rectangle2")).TupleFind(hv_InstanceType))).TupleEqual(-1))) != 0)
          {
            throw new HalconException(("Invalid generic parameter for 'instance_type': "+hv_InstanceType)+new HTuple(", only 'rectangle1' and 'rectangle2' are allowed"));
          }
        }
        hv_OptionalKeysExist.Dispose();
        HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", hv_ParamNamesDetectionOptional, 
            out hv_OptionalKeysExist);
        if ((int)(hv_OptionalKeysExist.TupleSelect(1)) != 0)
        {
          //Check 'ignore_direction'.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_IgnoreDirection.Dispose();
          HOperatorSet.GetDictTuple(hv_DLPreprocessParam, hv_ParamNamesDetectionOptional.TupleSelect(
              1), out hv_IgnoreDirection);
          }
          if ((int)(new HTuple((new HTuple(((new HTuple(1)).TupleConcat(0)).TupleFind(
              hv_IgnoreDirection))).TupleEqual(-1))) != 0)
          {
            throw new HalconException(("Invalid generic parameter for 'ignore_direction': "+hv_IgnoreDirection)+new HTuple(", only true and false are allowed"));
          }
        }
        if ((int)(hv_OptionalKeysExist.TupleSelect(2)) != 0)
        {
          //Check 'class_ids_no_orientation'.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ClassIDsNoOrientation.Dispose();
          HOperatorSet.GetDictTuple(hv_DLPreprocessParam, hv_ParamNamesDetectionOptional.TupleSelect(
              2), out hv_ClassIDsNoOrientation);
          }
          hv_SemTypes.Dispose();
          HOperatorSet.TupleSemTypeElem(hv_ClassIDsNoOrientation, out hv_SemTypes);
          if ((int)((new HTuple(hv_ClassIDsNoOrientation.TupleNotEqual(new HTuple()))).TupleAnd(
              new HTuple(((((hv_SemTypes.TupleEqualElem("integer"))).TupleSum())).TupleNotEqual(
              new HTuple(hv_ClassIDsNoOrientation.TupleLength()))))) != 0)
          {
            throw new HalconException(("Invalid generic parameter for 'class_ids_no_orientation': "+hv_ClassIDsNoOrientation)+new HTuple(", only integers are allowed"));
          }
          else
          {
            if ((int)((new HTuple(hv_ClassIDsNoOrientation.TupleNotEqual(new HTuple()))).TupleAnd(
                new HTuple(((((hv_ClassIDsNoOrientation.TupleGreaterEqualElem(0))).TupleSum()
                )).TupleNotEqual(new HTuple(hv_ClassIDsNoOrientation.TupleLength()
                ))))) != 0)
            {
              throw new HalconException(("Invalid generic parameter for 'class_ids_no_orientation': "+hv_ClassIDsNoOrientation)+new HTuple(", only non-negative integers are allowed"));
            }
          }
        }
      }
      //

      hv_DLModelType.Dispose();
      hv_Exception.Dispose();
      hv_SupportedModelTypes.Dispose();
      hv_Index.Dispose();
      hv_ParamNamesGeneral.Dispose();
      hv_ParamNamesSegmentation.Dispose();
      hv_ParamNamesDetectionOptional.Dispose();
      hv_ParamNamesPreprocessingOptional.Dispose();
      hv_ParamNamesAll.Dispose();
      hv_ParamNames.Dispose();
      hv_KeysExists.Dispose();
      hv_I.Dispose();
      hv_Exists.Dispose();
      hv_InputKeys.Dispose();
      hv_Key.Dispose();
      hv_Value.Dispose();
      hv_Indices.Dispose();
      hv_ValidValues.Dispose();
      hv_ValidTypes.Dispose();
      hv_V.Dispose();
      hv_T.Dispose();
      hv_IsInt.Dispose();
      hv_ValidTypesListing.Dispose();
      hv_ValidValueListing.Dispose();
      hv_EmptyStrings.Dispose();
      hv_ImageRangeMinExists.Dispose();
      hv_ImageRangeMaxExists.Dispose();
      hv_ImageRangeMin.Dispose();
      hv_ImageRangeMax.Dispose();
      hv_IndexParam.Dispose();
      hv_SetBackgroundID.Dispose();
      hv_ClassIDsBackground.Dispose();
      hv_Intersection.Dispose();
      hv_IgnoreClassIDs.Dispose();
      hv_KnownClasses.Dispose();
      hv_IgnoreClassID.Dispose();
      hv_OptionalKeysExist.Dispose();
      hv_InstanceType.Dispose();
      hv_IgnoreDirection.Dispose();
      hv_ClassIDsNoOrientation.Dispose();
      hv_SemTypes.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_DLModelType.Dispose();
      hv_Exception.Dispose();
      hv_SupportedModelTypes.Dispose();
      hv_Index.Dispose();
      hv_ParamNamesGeneral.Dispose();
      hv_ParamNamesSegmentation.Dispose();
      hv_ParamNamesDetectionOptional.Dispose();
      hv_ParamNamesPreprocessingOptional.Dispose();
      hv_ParamNamesAll.Dispose();
      hv_ParamNames.Dispose();
      hv_KeysExists.Dispose();
      hv_I.Dispose();
      hv_Exists.Dispose();
      hv_InputKeys.Dispose();
      hv_Key.Dispose();
      hv_Value.Dispose();
      hv_Indices.Dispose();
      hv_ValidValues.Dispose();
      hv_ValidTypes.Dispose();
      hv_V.Dispose();
      hv_T.Dispose();
      hv_IsInt.Dispose();
      hv_ValidTypesListing.Dispose();
      hv_ValidValueListing.Dispose();
      hv_EmptyStrings.Dispose();
      hv_ImageRangeMinExists.Dispose();
      hv_ImageRangeMaxExists.Dispose();
      hv_ImageRangeMin.Dispose();
      hv_ImageRangeMax.Dispose();
      hv_IndexParam.Dispose();
      hv_SetBackgroundID.Dispose();
      hv_ClassIDsBackground.Dispose();
      hv_Intersection.Dispose();
      hv_IgnoreClassIDs.Dispose();
      hv_KnownClasses.Dispose();
      hv_IgnoreClassID.Dispose();
      hv_OptionalKeysExist.Dispose();
      hv_InstanceType.Dispose();
      hv_IgnoreDirection.Dispose();
      hv_ClassIDsNoOrientation.Dispose();
      hv_SemTypes.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Object Detection
  // Short Description: This procedure performs k-means clustering on the given parameter values. 
  public void cluster_dl_detection_param (HTuple hv_Values, HTuple hv_K, HTuple hv_MinRatio, 
      HTuple hv_MinDiff, out HTuple hv_ClusteredValues)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_KCurrent = new HTuple(), hv_MinDelta = new HTuple();
    HTuple hv_MaxIteration = new HTuple(), hv_Points = new HTuple();
    HTuple hv_NumPoints = new HTuple(), hv_Repeat = new HTuple();
    HTuple hv_InitialClusterCenters = new HTuple(), hv_Step = new HTuple();
    HTuple hv_Index = new HTuple(), hv_ClusterCenters = new HTuple();
    HTuple hv_MinMembers = new HTuple(), hv_ClusterCentersSorted = new HTuple();
    HTuple hv_Diffs = new HTuple();

    HTupleVector hvec_PointClusters = new HTupleVector(1);
    // Initialize local and output iconic variables 
    hv_ClusteredValues = new HTuple();
    try
    {
      //This procedure performs clustering on the given input data using
      //a simplified 1D k-means algorithm in order to find a small number
      //of values which represent the data well.
      //
      //
      //The number of clusters may be changed, set the initial number given
      //by the input parameter K.
      hv_KCurrent.Dispose();
      hv_KCurrent = new HTuple(hv_K);
      //Stop the clustering iteration if the cluster centers do not change
      //more than MaxDelta or after MaxIteration iterations.
      hv_MinDelta.Dispose();
      hv_MinDelta = 1e-5;
      hv_MaxIteration.Dispose();
      hv_MaxIteration = 100;
      //
      //Sort the values in order to generate cluster centers.
      hv_Points.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Points = hv_Values.TupleSort()
          ;
      }
      hv_NumPoints.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NumPoints = new HTuple(hv_Points.TupleLength()
          );
      }
      //
      //Check the inputs.
      if ((int)(new HTuple(hv_K.TupleLess(1))) != 0)
      {
        throw new HalconException("K has to be at least 1.");
      }
      if ((int)(new HTuple(hv_NumPoints.TupleLess(1))) != 0)
      {
        throw new HalconException("No data to cluster.");
      }
      //
      hv_Repeat.Dispose();
      hv_Repeat = 1;
      //Repeat as long as the number of clusters is reduced during the iteration.
      while ((int)(hv_Repeat) != 0)
      {
        hv_Repeat.Dispose();
        hv_Repeat = 0;
        //
        //Initializie the cluster centers by taking points from the input data
        //in equal distances.
        hv_InitialClusterCenters.Dispose();
        hv_InitialClusterCenters = new HTuple();
        if ((int)(new HTuple(hv_KCurrent.TupleGreater(1))) != 0)
        {
          hv_Step.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Step = hv_NumPoints/(hv_KCurrent-1);
          }
          HTuple end_val35 = hv_KCurrent-2;
          HTuple step_val35 = 1;
          for (hv_Index=0; hv_Index.Continue(end_val35, step_val35); hv_Index = hv_Index.TupleAdd(step_val35))
          {
            if (hv_InitialClusterCenters == null)
              hv_InitialClusterCenters = new HTuple();
            hv_InitialClusterCenters[hv_Index] = hv_Points.TupleSelect(hv_Index*hv_Step);
          }
          if (hv_InitialClusterCenters == null)
            hv_InitialClusterCenters = new HTuple();
          hv_InitialClusterCenters[hv_KCurrent-1] = hv_Points.TupleSelect(hv_NumPoints-1);
        }
        else if ((int)(new HTuple(hv_KCurrent.TupleEqual(1))) != 0)
        {
          hv_InitialClusterCenters.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_InitialClusterCenters = hv_Points.TupleSelect(
              hv_NumPoints/2);
          }
        }
        else
        {
          throw new HalconException("Invalid value for K.");
        }
        //
        //Perform k-means clustering with the given initial cluster centers.
        hvec_PointClusters.Dispose();hv_ClusterCenters.Dispose();
        cluster_kmeans_1d(hv_Points, hv_InitialClusterCenters, hv_MaxIteration, hv_MinDelta, 
            out hvec_PointClusters, out hv_ClusterCenters);
        //It is possible that the number of centers is reduced after the clustering,
        //so read it after the process.
        hv_KCurrent.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_KCurrent = new HTuple(hv_ClusterCenters.TupleLength()
            );
        }
        //
        //Check the clusters for the restrictions.
        //
        //Each cluster should contain at least a ratio (MinRatio) of the total number
        //of data points. If at least one cluster does not fulfill this restriction,
        //reduce the number of clusters and redo the clustering.
        hv_MinMembers.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MinMembers = hv_MinRatio*hv_NumPoints;
        }
        HTuple end_val57 = new HTuple(hvec_PointClusters.Length)-1;
        HTuple step_val57 = 1;
        for (hv_Index=0; hv_Index.Continue(end_val57, step_val57); hv_Index = hv_Index.TupleAdd(step_val57))
        {
          if ((int)(new HTuple((new HTuple((hvec_PointClusters[hv_Index].T).TupleLength()
              )).TupleLess(hv_MinMembers))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_KCurrent = hv_KCurrent-1;
            hv_KCurrent.Dispose();
            hv_KCurrent = ExpTmpLocalVar_KCurrent;
            }
            }
            hv_Repeat.Dispose();
            hv_Repeat = 1;
            break;
          }
        }
        //
        if ((int)(hv_Repeat) != 0)
        {
          continue;
        }
        //
        //The cluster centers should have a certain distance from each other
        //(specified with MinDiff). If the centers do not fulfill this restriction,
        //also reduce the number of clusters and redo the clustering.
        hv_ClusterCentersSorted.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ClusterCentersSorted = hv_ClusterCenters.TupleSort()
            ;
        }
        hv_Diffs.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Diffs = (hv_ClusterCentersSorted.TupleSelectRange(
            1,(new HTuple(hv_ClusterCentersSorted.TupleLength()))-1))-(hv_ClusterCentersSorted.TupleSelectRange(
            0,(new HTuple(hv_ClusterCentersSorted.TupleLength()))-2));
        }
        if ((int)(new HTuple(((((hv_Diffs.TupleLessElem(hv_MinDiff))).TupleSum())).TupleGreater(
            0))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_KCurrent = hv_KCurrent-1;
          hv_KCurrent.Dispose();
          hv_KCurrent = ExpTmpLocalVar_KCurrent;
          }
          }
          hv_Repeat.Dispose();
          hv_Repeat = 1;
        }
        //
      }
      //
      hv_ClusteredValues.Dispose();
      hv_ClusteredValues = new HTuple(hv_ClusterCentersSorted);
      //

      hv_KCurrent.Dispose();
      hv_MinDelta.Dispose();
      hv_MaxIteration.Dispose();
      hv_Points.Dispose();
      hv_NumPoints.Dispose();
      hv_Repeat.Dispose();
      hv_InitialClusterCenters.Dispose();
      hv_Step.Dispose();
      hv_Index.Dispose();
      hv_ClusterCenters.Dispose();
      hv_MinMembers.Dispose();
      hv_ClusterCentersSorted.Dispose();
      hv_Diffs.Dispose();
      hvec_PointClusters.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_KCurrent.Dispose();
      hv_MinDelta.Dispose();
      hv_MaxIteration.Dispose();
      hv_Points.Dispose();
      hv_NumPoints.Dispose();
      hv_Repeat.Dispose();
      hv_InitialClusterCenters.Dispose();
      hv_Step.Dispose();
      hv_Index.Dispose();
      hv_ClusterCenters.Dispose();
      hv_MinMembers.Dispose();
      hv_ClusterCentersSorted.Dispose();
      hv_Diffs.Dispose();
      hvec_PointClusters.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Object Detection
  // Short Description: This procedure clusters the given data Points with the specified initial cluster centers InitialClusterCenters. It returns the optimized cluster centers ClusterCenters and the clustered data points PointClusters. 
  public void cluster_kmeans_1d (HTuple hv_Points, HTuple hv_InitialClusterCenters, 
      HTuple hv_MaxIteration, HTuple hv_MinDelta, out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_PointClusters, 
      out HTuple hv_ClusterCenters)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_NumClusters = new HTuple(), hv_NumPoints = new HTuple();
    HTuple hv_Iteration = new HTuple(), hv_CIdx = new HTuple();
    HTuple hv_PIdx = new HTuple(), hv_CurrentPoint = new HTuple();
    HTuple hv_Distances = new HTuple(), hv_ClusterIndex = new HTuple();
    HTuple hv_ClusterChanged = new HTuple(), hv_ClusterCenterNew = new HTuple();

    HTupleVector hvec_Clusters = new HTupleVector(1);
    // Initialize local and output iconic variables 
    hvec_PointClusters = new HTupleVector(1);
    hv_ClusterCenters = new HTuple();
    try
    {
      //This procedure performs clustering on the given
      //data points with the specified initial cluster centers.
      //
      hv_ClusterCenters.Dispose();
      hv_ClusterCenters = new HTuple(hv_InitialClusterCenters);
      hv_NumClusters.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NumClusters = new HTuple(hv_ClusterCenters.TupleLength()
          );
      }
      hv_NumPoints.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NumPoints = new HTuple(hv_Points.TupleLength()
          );
      }
      //
      HTuple end_val7 = hv_MaxIteration-1;
      HTuple step_val7 = 1;
      for (hv_Iteration=0; hv_Iteration.Continue(end_val7, step_val7); hv_Iteration = hv_Iteration.TupleAdd(step_val7))
      {
        //Initialize new cluster vector to store clustered points.
        HTuple end_val9 = hv_NumClusters-1;
        HTuple step_val9 = 1;
        for (hv_CIdx=0; hv_CIdx.Continue(end_val9, step_val9); hv_CIdx = hv_CIdx.TupleAdd(step_val9))
        {
          hvec_Clusters[hv_CIdx] = new HTupleVector(new HTuple());
        }
        //Assign each point to the closest cluster center.
        HTuple end_val13 = hv_NumPoints-1;
        HTuple step_val13 = 1;
        for (hv_PIdx=0; hv_PIdx.Continue(end_val13, step_val13); hv_PIdx = hv_PIdx.TupleAdd(step_val13))
        {
          hv_CurrentPoint.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentPoint = hv_Points.TupleSelect(
              hv_PIdx);
          }
          hv_Distances.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Distances = ((hv_ClusterCenters-hv_CurrentPoint)).TupleAbs()
              ;
          }
          hv_ClusterIndex.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ClusterIndex = hv_Distances.TupleFindFirst(
              hv_Distances.TupleMin());
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hvec_Clusters[hv_ClusterIndex] = dh.Add(new HTupleVector((hvec_Clusters[hv_ClusterIndex].T).TupleConcat(
              hv_CurrentPoint)));
          }
        }
        //Check that all clusters have at least one data point.
        //If not -> remove the cluster and the corresponding center.
        HTuple end_val21 = 0;
        HTuple step_val21 = -1;
        for (hv_CIdx=hv_NumClusters-1; hv_CIdx.Continue(end_val21, step_val21); hv_CIdx = hv_CIdx.TupleAdd(step_val21))
        {
          if ((int)(new HTuple((new HTuple((hvec_Clusters[hv_CIdx].T).TupleLength()
              )).TupleEqual(0))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hvec_Clusters.Remove(hv_CIdx);
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_ClusterCenters = hv_ClusterCenters.TupleRemove(
                hv_CIdx);
            hv_ClusterCenters.Dispose();
            hv_ClusterCenters = ExpTmpLocalVar_ClusterCenters;
            }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_NumClusters = hv_NumClusters-1;
            hv_NumClusters.Dispose();
            hv_NumClusters = ExpTmpLocalVar_NumClusters;
            }
            }
          }
        }
        //Update cluster centers based on point clusters.
        hv_ClusterChanged.Dispose();
        hv_ClusterChanged = 0;
        HTuple end_val30 = hv_NumClusters-1;
        HTuple step_val30 = 1;
        for (hv_CIdx=0; hv_CIdx.Continue(end_val30, step_val30); hv_CIdx = hv_CIdx.TupleAdd(step_val30))
        {
          hv_ClusterCenterNew.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ClusterCenterNew = (hvec_Clusters[hv_CIdx].T).TupleMean()
              ;
          }
          if ((int)(new HTuple(((((hv_ClusterCenterNew-(hv_ClusterCenters.TupleSelect(
              hv_CIdx)))).TupleAbs())).TupleGreater(hv_MinDelta))) != 0)
          {
            if (hv_ClusterCenters == null)
              hv_ClusterCenters = new HTuple();
            hv_ClusterCenters[hv_CIdx] = hv_ClusterCenterNew;
            hv_ClusterChanged.Dispose();
            hv_ClusterChanged = 1;
          }
        }
        //If clusters did not change, exit early.
        if ((int)(hv_ClusterChanged.TupleNot()) != 0)
        {
          break;
        }
      }
      //
      hvec_PointClusters.Dispose();
      hvec_PointClusters = new HTupleVector(hvec_Clusters);
      //

      hv_NumClusters.Dispose();
      hv_NumPoints.Dispose();
      hv_Iteration.Dispose();
      hv_CIdx.Dispose();
      hv_PIdx.Dispose();
      hv_CurrentPoint.Dispose();
      hv_Distances.Dispose();
      hv_ClusterIndex.Dispose();
      hv_ClusterChanged.Dispose();
      hv_ClusterCenterNew.Dispose();
      hvec_Clusters.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_NumClusters.Dispose();
      hv_NumPoints.Dispose();
      hv_Iteration.Dispose();
      hv_CIdx.Dispose();
      hv_PIdx.Dispose();
      hv_CurrentPoint.Dispose();
      hv_Distances.Dispose();
      hv_ClusterIndex.Dispose();
      hv_ClusterChanged.Dispose();
      hv_ClusterCenterNew.Dispose();
      hvec_Clusters.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Tools / Geometry
  // Short Description: Convert the parameters of rectangles with format rectangle2 to the coordinates of its 4 corner-points. 
  public void convert_rect2_5to8param (HTuple hv_Row, HTuple hv_Col, HTuple hv_Length1, 
      HTuple hv_Length2, HTuple hv_Phi, out HTuple hv_Row1, out HTuple hv_Col1, out HTuple hv_Row2, 
      out HTuple hv_Col2, out HTuple hv_Row3, out HTuple hv_Col3, out HTuple hv_Row4, 
      out HTuple hv_Col4)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Co1 = new HTuple(), hv_Co2 = new HTuple();
    HTuple hv_Si1 = new HTuple(), hv_Si2 = new HTuple();
    // Initialize local and output iconic variables 
    hv_Row1 = new HTuple();
    hv_Col1 = new HTuple();
    hv_Row2 = new HTuple();
    hv_Col2 = new HTuple();
    hv_Row3 = new HTuple();
    hv_Col3 = new HTuple();
    hv_Row4 = new HTuple();
    hv_Col4 = new HTuple();
    try
    {
      //This procedure takes the parameters for a rectangle of type 'rectangle2'
      //and returns the coordinates of the four corners.
      //
      hv_Co1.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Co1 = (hv_Phi.TupleCos()
          )*hv_Length1;
      }
      hv_Co2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Co2 = (hv_Phi.TupleCos()
          )*hv_Length2;
      }
      hv_Si1.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Si1 = (hv_Phi.TupleSin()
          )*hv_Length1;
      }
      hv_Si2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Si2 = (hv_Phi.TupleSin()
          )*hv_Length2;
      }

      hv_Col1.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Col1 = (hv_Co1-hv_Si2)+hv_Col;
      }
      hv_Row1.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Row1 = ((-hv_Si1)-hv_Co2)+hv_Row;
      }
      hv_Col2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Col2 = ((-hv_Co1)-hv_Si2)+hv_Col;
      }
      hv_Row2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Row2 = (hv_Si1-hv_Co2)+hv_Row;
      }
      hv_Col3.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Col3 = ((-hv_Co1)+hv_Si2)+hv_Col;
      }
      hv_Row3.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Row3 = (hv_Si1+hv_Co2)+hv_Row;
      }
      hv_Col4.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Col4 = (hv_Co1+hv_Si2)+hv_Col;
      }
      hv_Row4.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Row4 = ((-hv_Si1)+hv_Co2)+hv_Row;
      }


      hv_Co1.Dispose();
      hv_Co2.Dispose();
      hv_Si1.Dispose();
      hv_Si2.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_Co1.Dispose();
      hv_Co2.Dispose();
      hv_Si1.Dispose();
      hv_Si2.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Tools / Geometry
  // Short Description: Convert for four-sided figures the coordinates of the 4 corner-points to the parameters of format rectangle2. 
  public void convert_rect2_8to5param (HTuple hv_Row1, HTuple hv_Col1, HTuple hv_Row2, 
      HTuple hv_Col2, HTuple hv_Row3, HTuple hv_Col3, HTuple hv_Row4, HTuple hv_Col4, 
      HTuple hv_ForceL1LargerL2, out HTuple hv_Row, out HTuple hv_Col, out HTuple hv_Length1, 
      out HTuple hv_Length2, out HTuple hv_Phi)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Hor = new HTuple(), hv_Vert = new HTuple();
    HTuple hv_IdxSwap = new HTuple(), hv_Tmp = new HTuple();
    // Initialize local and output iconic variables 
    hv_Row = new HTuple();
    hv_Col = new HTuple();
    hv_Length1 = new HTuple();
    hv_Length2 = new HTuple();
    hv_Phi = new HTuple();
    try
    {
      //This procedure takes the corners of four-sided figures
      //and returns the parameters of type 'rectangle2'.
      //
      //Calculate center row and column.
      hv_Row.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Row = (((hv_Row1+hv_Row2)+hv_Row3)+hv_Row4)/4.0;
      }
      hv_Col.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Col = (((hv_Col1+hv_Col2)+hv_Col3)+hv_Col4)/4.0;
      }
      //Length1 and Length2.
      hv_Length1.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Length1 = (((((hv_Row1-hv_Row2)*(hv_Row1-hv_Row2))+((hv_Col1-hv_Col2)*(hv_Col1-hv_Col2)))).TupleSqrt()
          )/2.0;
      }
      hv_Length2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Length2 = (((((hv_Row2-hv_Row3)*(hv_Row2-hv_Row3))+((hv_Col2-hv_Col3)*(hv_Col2-hv_Col3)))).TupleSqrt()
          )/2.0;
      }
      //Calculate the angle phi.
      hv_Hor.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Hor = hv_Col1-hv_Col2;
      }
      hv_Vert.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Vert = hv_Row2-hv_Row1;
      }
      if ((int)(hv_ForceL1LargerL2) != 0)
      {
        //Swap length1 and length2 if necessary.
        hv_IdxSwap.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_IdxSwap = ((((hv_Length2-hv_Length1)).TupleGreaterElem(
            1e-9))).TupleFind(1);
        }
        if ((int)(new HTuple(hv_IdxSwap.TupleNotEqual(-1))) != 0)
        {
          hv_Tmp.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Tmp = hv_Length1.TupleSelect(
              hv_IdxSwap);
          }
          if (hv_Length1 == null)
            hv_Length1 = new HTuple();
          hv_Length1[hv_IdxSwap] = hv_Length2.TupleSelect(hv_IdxSwap);
          if (hv_Length2 == null)
            hv_Length2 = new HTuple();
          hv_Length2[hv_IdxSwap] = hv_Tmp;
          if (hv_Hor == null)
            hv_Hor = new HTuple();
          hv_Hor[hv_IdxSwap] = (hv_Col2.TupleSelect(hv_IdxSwap))-(hv_Col3.TupleSelect(
              hv_IdxSwap));
          if (hv_Vert == null)
            hv_Vert = new HTuple();
          hv_Vert[hv_IdxSwap] = (hv_Row3.TupleSelect(hv_IdxSwap))-(hv_Row2.TupleSelect(
              hv_IdxSwap));
        }
      }
      hv_Phi.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Phi = hv_Vert.TupleAtan2(
          hv_Hor);
      }
      //

      hv_Hor.Dispose();
      hv_Vert.Dispose();
      hv_IdxSwap.Dispose();
      hv_Tmp.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_Hor.Dispose();
      hv_Vert.Dispose();
      hv_IdxSwap.Dispose();
      hv_Tmp.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: Creates a dictionary with preprocessing parameters. 
  public void create_dl_preprocess_param (HTuple hv_DLModelType, HTuple hv_ImageWidth, 
      HTuple hv_ImageHeight, HTuple hv_ImageNumChannels, HTuple hv_ImageRangeMin, 
      HTuple hv_ImageRangeMax, HTuple hv_NormalizationType, HTuple hv_DomainHandling, 
      HTuple hv_IgnoreClassIDs, HTuple hv_SetBackgroundID, HTuple hv_ClassIDsBackground, 
      HTuple hv_GenParam, out HTuple hv_DLPreprocessParam)
  {



    // Local control variables 

    HTuple hv_GenParamNames = new HTuple(), hv_GenParamIndex = new HTuple();
    HTuple hv_GenParamValue = new HTuple(), hv_KeysExist = new HTuple();
    HTuple hv_InstanceType = new HTuple();
    // Initialize local and output iconic variables 
    hv_DLPreprocessParam = new HTuple();
    try
    {
      //
      //This procedure creates a dictionary with all parameters needed for preprocessing.
      //
      hv_DLPreprocessParam.Dispose();
      HOperatorSet.CreateDict(out hv_DLPreprocessParam);
      HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "model_type", hv_DLModelType);
      HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "image_width", hv_ImageWidth);
      HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "image_height", hv_ImageHeight);
      HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "image_num_channels", hv_ImageNumChannels);
      if ((int)(new HTuple(hv_ImageRangeMin.TupleEqual(new HTuple()))) != 0)
      {
        HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "image_range_min", -127);
      }
      else
      {
        HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "image_range_min", hv_ImageRangeMin);
      }
      if ((int)(new HTuple(hv_ImageRangeMax.TupleEqual(new HTuple()))) != 0)
      {
        HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "image_range_max", 128);
      }
      else
      {
        HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "image_range_max", hv_ImageRangeMax);
      }
      HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "normalization_type", hv_NormalizationType);
      //Replace possible legacy parameters.
      replace_legacy_preprocessing_parameters(hv_DLPreprocessParam);
      HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "domain_handling", hv_DomainHandling);
      //
      //Set segmentation specific parameters.
      if ((int)(new HTuple(hv_DLModelType.TupleEqual("segmentation"))) != 0)
      {
        HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "ignore_class_ids", hv_IgnoreClassIDs);
        HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "set_background_id", hv_SetBackgroundID);
        HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "class_ids_background", hv_ClassIDsBackground);
      }
      //
      //Set generic parameters.
      if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
      {
        hv_GenParamNames.Dispose();
        HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_GenParamNames);
        for (hv_GenParamIndex=0; (int)hv_GenParamIndex<=(int)((new HTuple(hv_GenParamNames.TupleLength()
            ))-1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_GenParamValue.Dispose();
          HOperatorSet.GetDictTuple(hv_GenParam, hv_GenParamNames.TupleSelect(hv_GenParamIndex), 
              out hv_GenParamValue);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetDictTuple(hv_DLPreprocessParam, hv_GenParamNames.TupleSelect(
              hv_GenParamIndex), hv_GenParamValue);
          }
        }
      }
      //
      //Set necessary default values.
      if ((int)(new HTuple(hv_DLModelType.TupleEqual("detection"))) != 0)
      {
        hv_KeysExist.Dispose();
        HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", (new HTuple("instance_type")).TupleConcat(
            "ignore_direction"), out hv_KeysExist);
        if ((int)(((hv_KeysExist.TupleSelect(0))).TupleNot()) != 0)
        {
          HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "instance_type", "rectangle1");
        }
        //Set default for 'ignore_direction' only if instance_type is 'rectangle2'.
        hv_InstanceType.Dispose();
        HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "instance_type", out hv_InstanceType);
        if ((int)((new HTuple(hv_InstanceType.TupleEqual("rectangle2"))).TupleAnd(
            ((hv_KeysExist.TupleSelect(1))).TupleNot())) != 0)
        {
          HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "ignore_direction", 0);
        }
      }
      //
      //Check the validity of the preprocessing parameters.
      check_dl_preprocess_param(hv_DLPreprocessParam);
      //

      hv_GenParamNames.Dispose();
      hv_GenParamIndex.Dispose();
      hv_GenParamValue.Dispose();
      hv_KeysExist.Dispose();
      hv_InstanceType.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_GenParamNames.Dispose();
      hv_GenParamIndex.Dispose();
      hv_GenParamValue.Dispose();
      hv_KeysExist.Dispose();
      hv_InstanceType.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: Creates a dictionary with the preprocessing parameters based on a given DL model. 
  public void create_dl_preprocess_param_from_model (HTuple hv_DLModelHandle, HTuple hv_NormalizationType, 
      HTuple hv_DomainHandling, HTuple hv_SetBackgroundID, HTuple hv_ClassIDsBackground, 
      HTuple hv_GenParam, out HTuple hv_DLPreprocessParam)
  {



        // Local iconic variables 

        // Local control variables 

        HTuple hv_ModelType = new HTuple(), hv_ImageWidth = new HTuple();
        HTuple hv_ImageHeight = new HTuple(), hv_ImageNumChannels = new HTuple();
        HTuple hv_ImageRangeMin = new HTuple(), hv_ImageRangeMax = new HTuple();
        HTuple hv_IgnoreClassIDs = new HTuple(), hv_InstanceType = new HTuple();
        HTuple hv_IgnoreDirection = new HTuple(), hv_ClassIDsNoOrientation = new HTuple();
        HTuple   hv_GenParam_COPY_INP_TMP = new HTuple(hv_GenParam);

        // Initialize local and output iconic variables 
        hv_DLPreprocessParam = new HTuple();
        try
        {
      //
      //This procedure creates a dictionary with all parameters needed for preprocessing
      //according to a model provided through DLModelHandle.
      //
      //Get the relevant model parameters.
      hv_ModelType.Dispose();
      HOperatorSet.GetDlModelParam(hv_DLModelHandle, "type", out hv_ModelType);
      hv_ImageWidth.Dispose();
      HOperatorSet.GetDlModelParam(hv_DLModelHandle, "image_width", out hv_ImageWidth);
      hv_ImageHeight.Dispose();
      HOperatorSet.GetDlModelParam(hv_DLModelHandle, "image_height", out hv_ImageHeight);
      hv_ImageNumChannels.Dispose();
      HOperatorSet.GetDlModelParam(hv_DLModelHandle, "image_num_channels", out hv_ImageNumChannels);
      hv_ImageRangeMin.Dispose();
      HOperatorSet.GetDlModelParam(hv_DLModelHandle, "image_range_min", out hv_ImageRangeMin);
      hv_ImageRangeMax.Dispose();
      HOperatorSet.GetDlModelParam(hv_DLModelHandle, "image_range_max", out hv_ImageRangeMax);
      hv_IgnoreClassIDs.Dispose();
      hv_IgnoreClassIDs = new HTuple();
      //
      //Get model specific parameters.
      if ((int)(new HTuple(hv_ModelType.TupleEqual("anomaly_detection"))) != 0)
      {
        //No anomaly detection specific parameters.
      }
      else if ((int)(new HTuple(hv_ModelType.TupleEqual("classification"))) != 0)
      {
        //No classification specific parameters.
      }
      else if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
      {
        //Get detection specific parameters.
        //If GenParam has not been created yet, create it to add new generic parameters.
        if ((int)(new HTuple((new HTuple(hv_GenParam_COPY_INP_TMP.TupleLength())).TupleEqual(
            0))) != 0)
        {
          hv_GenParam_COPY_INP_TMP.Dispose();
          HOperatorSet.CreateDict(out hv_GenParam_COPY_INP_TMP);
        }
        //Add instance_type.
        hv_InstanceType.Dispose();
        HOperatorSet.GetDlModelParam(hv_DLModelHandle, "instance_type", out hv_InstanceType);
        HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "instance_type", hv_InstanceType);
        //For instance_type 'rectangle2', add the boolean ignore_direction and class IDs without orientation.
        if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
        {
          hv_IgnoreDirection.Dispose();
          HOperatorSet.GetDlModelParam(hv_DLModelHandle, "ignore_direction", out hv_IgnoreDirection);
          if ((int)(new HTuple(hv_IgnoreDirection.TupleEqual("true"))) != 0)
          {
            HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "ignore_direction", 
                1);
          }
          else if ((int)(new HTuple(hv_IgnoreDirection.TupleEqual("false"))) != 0)
          {
            HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "ignore_direction", 
                0);
          }
          hv_ClassIDsNoOrientation.Dispose();
          HOperatorSet.GetDlModelParam(hv_DLModelHandle, "class_ids_no_orientation", 
              out hv_ClassIDsNoOrientation);
          HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "class_ids_no_orientation", 
              hv_ClassIDsNoOrientation);
        }
      }
      else if ((int)(new HTuple(hv_ModelType.TupleEqual("segmentation"))) != 0)
      {
        //Get segmentation specific parameters.
        hv_IgnoreClassIDs.Dispose();
        HOperatorSet.GetDlModelParam(hv_DLModelHandle, "ignore_class_ids", out hv_IgnoreClassIDs);
      }
      //
      //Create the dictionary with the preprocessing parameters returned by this procedure.
      hv_DLPreprocessParam.Dispose();
      create_dl_preprocess_param(hv_ModelType, hv_ImageWidth, hv_ImageHeight, hv_ImageNumChannels, 
          hv_ImageRangeMin, hv_ImageRangeMax, hv_NormalizationType, hv_DomainHandling, 
          hv_IgnoreClassIDs, hv_SetBackgroundID, hv_ClassIDsBackground, hv_GenParam_COPY_INP_TMP, 
          out hv_DLPreprocessParam);
      //

      hv_GenParam_COPY_INP_TMP.Dispose();
      hv_ModelType.Dispose();
      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_ImageNumChannels.Dispose();
      hv_ImageRangeMin.Dispose();
      hv_ImageRangeMax.Dispose();
      hv_IgnoreClassIDs.Dispose();
      hv_InstanceType.Dispose();
      hv_IgnoreDirection.Dispose();
      hv_ClassIDsNoOrientation.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_GenParam_COPY_INP_TMP.Dispose();
      hv_ModelType.Dispose();
      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_ImageNumChannels.Dispose();
      hv_ImageRangeMin.Dispose();
      hv_ImageRangeMax.Dispose();
      hv_IgnoreClassIDs.Dispose();
      hv_InstanceType.Dispose();
      hv_IgnoreDirection.Dispose();
      hv_ClassIDsNoOrientation.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Object Detection
  // Short Description: Analyze the provided DLDataset for object detection to find model parameters relevant for anchor generation. 
  public void determine_dl_model_detection_param (HTuple hv_DLDataset, HTuple hv_ImageWidthTarget, 
      HTuple hv_ImageHeightTarget, HTuple hv_GenParam, out HTuple hv_DLDetectionModelParam)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ImageWidthRaw = new HTuple(), hv_ImageHeightRaw = new HTuple();
    HTuple hv_MinLevel = new HTuple(), hv_MaxLevel = new HTuple();
    HTuple hv_AnchorNumSubscales = new HTuple(), hv_DomainHandling = new HTuple();
    HTuple hv_DatasetSplit = new HTuple(), hv_DisplayHistogram = new HTuple();
    HTuple hv_PreprocessedPath = new HTuple(), hv_GenParamName = new HTuple();
    HTuple hv_GenParamIndex = new HTuple(), hv_DisplayBool = new HTuple();
    HTuple hv_DatasetKeys = new HTuple(), hv_KeyIndex = new HTuple();
    HTuple hv_DatasetKeyExists = new HTuple(), hv_Rect1Keys = new HTuple();
    HTuple hv_Rect2Keys = new HTuple(), hv_DLSamples = new HTuple();
    HTuple hv_Rect1KeysExist = new HTuple(), hv_Rect2KeysExist = new HTuple();
    HTuple hv_InstanceType = new HTuple(), hv_PreprocessedKey = new HTuple();
    HTuple hv_PreprocessedKeyExists = new HTuple(), hv_Areas = new HTuple();
    HTuple hv_AspectRatios = new HTuple(), hv_Angles = new HTuple();
    HTuple hv_AreasReduced = new HTuple(), hv_AspectRatiosReduced = new HTuple();
    HTuple hv_AnglesReduced = new HTuple(), hv_MinLevelToUse = new HTuple();
    HTuple hv_MaxLevelToUse = new HTuple(), hv_AnchorNumSubscalesToUse = new HTuple();
    HTuple hv_MinRatio = new HTuple(), hv_MinDiff = new HTuple();
    HTuple hv_K = new HTuple(), hv_ClusteredAspectRatios = new HTuple();
    HTuple hv_ClusteredAngles = new HTuple(), hv_WindowBGColor = new HTuple();
    HTuple hv_SplitText = new HTuple(), hv_WindowHandle = new HTuple();
    HTuple hv_WindowHandle2 = new HTuple(), hv_WindowHandle3 = new HTuple();
    // Initialize local and output iconic variables 
    hv_DLDetectionModelParam = new HTuple();
    try
    {
      //This procedure analyzes the input DLDataset for object detection
      //in order to find good values for parameters which control the
      //generation of anchor bounding boxes.
      //
      //
      //Set default values for generic parameters.
      hv_ImageWidthRaw.Dispose();
      hv_ImageWidthRaw = new HTuple();
      hv_ImageHeightRaw.Dispose();
      hv_ImageHeightRaw = new HTuple();
      hv_MinLevel.Dispose();
      hv_MinLevel = 2;
      hv_MaxLevel.Dispose();
      hv_MaxLevel = 6;
      hv_AnchorNumSubscales.Dispose();
      hv_AnchorNumSubscales = 3;
      hv_DomainHandling.Dispose();
      hv_DomainHandling = "full_domain";
      hv_DatasetSplit.Dispose();
      hv_DatasetSplit = "all";
      hv_DisplayHistogram.Dispose();
      hv_DisplayHistogram = 0;
      hv_PreprocessedPath.Dispose();
      hv_PreprocessedPath = "";
      //
      //Read generic parameters and check the provided values.
      if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
      {
        hv_GenParamName.Dispose();
        HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_GenParamName);
        for (hv_GenParamIndex=0; (int)hv_GenParamIndex<=(int)((new HTuple(hv_GenParamName.TupleLength()
            ))-1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
        {
          if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
              "raw_width"))) != 0)
          {
            hv_ImageWidthRaw.Dispose();
            HOperatorSet.GetDictTuple(hv_GenParam, "raw_width", out hv_ImageWidthRaw);
            if ((int)(((hv_ImageWidthRaw.TupleIsInt())).TupleNot()) != 0)
            {
              throw new HalconException((hv_GenParamName.TupleSelect(
                  hv_GenParamIndex))+" should be of type int");
            }
            if ((int)(new HTuple(hv_ImageWidthRaw.TupleLess(1))) != 0)
            {
              throw new HalconException(("Invalid value for parameter 'raw_width': "+hv_ImageWidthRaw)+".");
            }
          }
          else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
              "raw_height"))) != 0)
          {
            hv_ImageHeightRaw.Dispose();
            HOperatorSet.GetDictTuple(hv_GenParam, "raw_height", out hv_ImageHeightRaw);
            if ((int)(((hv_ImageHeightRaw.TupleIsInt())).TupleNot()) != 0)
            {
              throw new HalconException((hv_GenParamName.TupleSelect(
                  hv_GenParamIndex))+" should be of type int");
            }
            if ((int)(new HTuple(hv_ImageHeightRaw.TupleLess(1))) != 0)
            {
              throw new HalconException(("Invalid value for parameter 'raw_height': "+hv_ImageHeightRaw)+".");
            }
          }
          else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
              "min_level"))) != 0)
          {
            hv_MinLevel.Dispose();
            HOperatorSet.GetDictTuple(hv_GenParam, "min_level", out hv_MinLevel);
            if ((int)(((hv_MinLevel.TupleIsInt())).TupleNot()) != 0)
            {
              throw new HalconException((hv_GenParamName.TupleSelect(
                  hv_GenParamIndex))+" should be of type int");
            }
            if ((int)(new HTuple(hv_MinLevel.TupleLess(2))) != 0)
            {
              throw new HalconException(("Invalid value for parameter 'min_level': "+hv_MinLevel)+". The minimum value is 2.");
            }
          }
          else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
              "max_level"))) != 0)
          {
            hv_MaxLevel.Dispose();
            HOperatorSet.GetDictTuple(hv_GenParam, "max_level", out hv_MaxLevel);
            if ((int)(((hv_MaxLevel.TupleIsInt())).TupleNot()) != 0)
            {
              throw new HalconException((hv_GenParamName.TupleSelect(
                  hv_GenParamIndex))+" should be of type int");
            }
            if ((int)(new HTuple(hv_MaxLevel.TupleLess(2))) != 0)
            {
              throw new HalconException(("Invalid value for parameter 'max_level': "+hv_MaxLevel)+". The minimum value is 2.");
            }
          }
          else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
              "anchor_num_subscales"))) != 0)
          {
            hv_AnchorNumSubscales.Dispose();
            HOperatorSet.GetDictTuple(hv_GenParam, "anchor_num_subscales", out hv_AnchorNumSubscales);
            if ((int)(((hv_AnchorNumSubscales.TupleIsInt())).TupleNot()) != 0)
            {
              throw new HalconException((hv_GenParamName.TupleSelect(
                  hv_GenParamIndex))+" should be of type int");
            }
            if ((int)(new HTuple(hv_AnchorNumSubscales.TupleLess(1))) != 0)
            {
              throw new HalconException(("Invalid value for parameter 'anchor_num_subscales': "+hv_AnchorNumSubscales)+". The minimum value is 1.");
            }
          }
          else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
              "domain_handling"))) != 0)
          {
            hv_DomainHandling.Dispose();
            HOperatorSet.GetDictTuple(hv_GenParam, "domain_handling", out hv_DomainHandling);
            if ((int)((new HTuple(hv_DomainHandling.TupleNotEqual("full_domain"))).TupleAnd(
                new HTuple(hv_DomainHandling.TupleNotEqual("crop_domain")))) != 0)
            {
              throw new HalconException(("Invalid value for parameter 'domain_handling': "+hv_DomainHandling)+".");
            }
          }
          else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
              "display_histogram"))) != 0)
          {
            hv_DisplayBool.Dispose();
            HOperatorSet.GetDictTuple(hv_GenParam, "display_histogram", out hv_DisplayBool);
            hv_DisplayHistogram.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_DisplayHistogram = (new HTuple(hv_DisplayBool.TupleEqual(
                "true"))).TupleOr(new HTuple(hv_DisplayBool.TupleEqual(1)));
            }
          }
          else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
              "split"))) != 0)
          {
            hv_DatasetSplit.Dispose();
            HOperatorSet.GetDictTuple(hv_GenParam, "split", out hv_DatasetSplit);
            if ((int)(((hv_DatasetSplit.TupleIsString())).TupleNot()) != 0)
            {
              throw new HalconException((hv_GenParamName.TupleSelect(
                  hv_GenParamIndex))+" should be of type string");
            }
          }
          else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
              "preprocessed_path"))) != 0)
          {
            hv_PreprocessedPath.Dispose();
            HOperatorSet.GetDictTuple(hv_GenParam, "preprocessed_path", out hv_PreprocessedPath);
            if ((int)(((hv_PreprocessedPath.TupleIsString())).TupleNot()) != 0)
            {
              throw new HalconException((hv_GenParamName.TupleSelect(
                  hv_GenParamIndex))+" should be of type string");
            }
          }
          else
          {
            throw new HalconException(("Unsupported generic parameter: '"+(hv_GenParamName.TupleSelect(
                hv_GenParamIndex)))+"'");
          }
        }
      }
      //
      //Check that all necessary keys (for this procedure) exist in the input dataset.
      hv_DatasetKeys.Dispose();
      hv_DatasetKeys = new HTuple();
      hv_DatasetKeys[0] = "image_dir";
      hv_DatasetKeys[1] = "samples";
      for (hv_KeyIndex=0; (int)hv_KeyIndex<=(int)((new HTuple(hv_DatasetKeys.TupleLength()
          ))-1); hv_KeyIndex = (int)hv_KeyIndex + 1)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DatasetKeyExists.Dispose();
        HOperatorSet.GetDictParam(hv_DLDataset, "key_exists", hv_DatasetKeys.TupleSelect(
            hv_KeyIndex), out hv_DatasetKeyExists);
        }
        if ((int)(hv_DatasetKeyExists.TupleNot()) != 0)
        {
          throw new HalconException(("Missing key in DLDataset: '"+(hv_DatasetKeys.TupleSelect(
              hv_KeyIndex)))+"'.");
        }
      }
      //Check that MaxLevel >= MinLevel
      if ((int)(new HTuple(hv_MaxLevel.TupleLess(hv_MinLevel))) != 0)
      {
        throw new HalconException("Value for parameter 'max_level' should not be smaller than 'min_level'.");
      }
      //
      //Get instance type of the dataset.
      //
      //Keys defining bounding boxes of instance type rectangle1 and rectangle2, respectively.
      hv_Rect1Keys.Dispose();
      hv_Rect1Keys = new HTuple();
      hv_Rect1Keys[0] = "bbox_row1";
      hv_Rect1Keys[1] = "bbox_col1";
      hv_Rect1Keys[2] = "bbox_row2";
      hv_Rect1Keys[3] = "bbox_col2";
      hv_Rect2Keys.Dispose();
      hv_Rect2Keys = new HTuple();
      hv_Rect2Keys[0] = "bbox_row";
      hv_Rect2Keys[1] = "bbox_col";
      hv_Rect2Keys[2] = "bbox_length1";
      hv_Rect2Keys[3] = "bbox_length2";
      hv_Rect2Keys[4] = "bbox_phi";
      //
      hv_DLSamples.Dispose();
      HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLSamples);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Rect1KeysExist.Dispose();
      HOperatorSet.GetDictParam(hv_DLSamples.TupleSelect(0), "key_exists", hv_Rect1Keys, 
          out hv_Rect1KeysExist);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Rect2KeysExist.Dispose();
      HOperatorSet.GetDictParam(hv_DLSamples.TupleSelect(0), "key_exists", hv_Rect2Keys, 
          out hv_Rect2KeysExist);
      }
      if ((int)(new HTuple(((hv_Rect1KeysExist.TupleSum())).TupleEqual(new HTuple(hv_Rect1Keys.TupleLength()
          )))) != 0)
      {
        hv_InstanceType.Dispose();
        hv_InstanceType = "rectangle1";
      }
      else if ((int)(new HTuple(((hv_Rect2KeysExist.TupleSum())).TupleEqual(
          new HTuple(hv_Rect2Keys.TupleLength())))) != 0)
      {
        hv_InstanceType.Dispose();
        hv_InstanceType = "rectangle2";
      }
      else
      {
        throw new HalconException("Please provide the data labeled for an object detection model of either instance type rectangle1 or rectangle2.");
      }
      //
      //Check whether the DLDataset is already preprocessed.
      hv_PreprocessedKey.Dispose();
      hv_PreprocessedKey = "dlsample_dir";
      hv_PreprocessedKeyExists.Dispose();
      HOperatorSet.GetDictParam(hv_DLDataset, "key_exists", hv_PreprocessedKey, out hv_PreprocessedKeyExists);
      if ((int)(hv_PreprocessedKeyExists) != 0)
      {
        if ((int)(new HTuple(hv_PreprocessedPath.TupleEqual(""))) != 0)
        {
          hv_PreprocessedPath.Dispose();
          HOperatorSet.GetDictTuple(hv_DLDataset, hv_PreprocessedKey, out hv_PreprocessedPath);
        }
        else
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_PreprocessedPath = hv_PreprocessedPath+"/samples";
          hv_PreprocessedPath.Dispose();
          hv_PreprocessedPath = ExpTmpLocalVar_PreprocessedPath;
          }
          }
        }
      }
      else
      {
        if ((int)(new HTuple(hv_PreprocessedPath.TupleNotEqual(""))) != 0)
        {
          throw new HalconException("The given dataset is not preprocessed but a preprocessing path is given.                  Please either use a preprocessed dataset as input or remove the specification for                  'preprocessed_path' from the generic parameter dictionary GenParam.");
        }
      }
      //
      //Create output param dictionary.
      hv_DLDetectionModelParam.Dispose();
      HOperatorSet.CreateDict(out hv_DLDetectionModelParam);
      //
      //Create relevant information collections from the dataset.
      hv_Areas.Dispose();hv_AspectRatios.Dispose();hv_Angles.Dispose();
      analyze_dl_dataset_detection(hv_DLDataset, hv_InstanceType, hv_ImageWidthRaw, 
          hv_ImageHeightRaw, hv_ImageWidthTarget, hv_ImageHeightTarget, hv_DomainHandling, 
          hv_PreprocessedPath, hv_DatasetSplit, out hv_Areas, out hv_AspectRatios, 
          out hv_Angles);
      //
      //Remove outliers in the data which could potentially have a big impact on the results
      //of this procedure. If you wish not to do so, comment out the following procedure calls
      //and set the variables AreasReduce, AspectRatiosReduced and AnglesReduced accordingly.
      hv_AreasReduced.Dispose();
      remove_dl_data_outliers(hv_Areas, out hv_AreasReduced);
      hv_AspectRatiosReduced.Dispose();
      remove_dl_data_outliers(hv_AspectRatios, out hv_AspectRatiosReduced);
      hv_AnglesReduced.Dispose();
      remove_dl_data_outliers(hv_Angles, out hv_AnglesReduced);
      //
      //Select min_level, max_level and anchor_num_subscales based on the retrieved ground truth
      //bounding box areas.
      hv_MinLevelToUse.Dispose();hv_MaxLevelToUse.Dispose();hv_AnchorNumSubscalesToUse.Dispose();
      select_dl_detection_levels(hv_AreasReduced, hv_MinLevel, hv_MaxLevel, hv_AnchorNumSubscales, 
          out hv_MinLevelToUse, out hv_MaxLevelToUse, out hv_AnchorNumSubscalesToUse);
      HOperatorSet.SetDictTuple(hv_DLDetectionModelParam, "min_level", hv_MinLevelToUse);
      HOperatorSet.SetDictTuple(hv_DLDetectionModelParam, "max_level", hv_MaxLevelToUse);
      HOperatorSet.SetDictTuple(hv_DLDetectionModelParam, "anchor_num_subscales", 
          hv_AnchorNumSubscalesToUse);
      //
      //Determine values for anchor aspect ratios and angles using k-means clustering.
      //
      //Minimum ratio of members each cluster should at least have.
      hv_MinRatio.Dispose();
      hv_MinRatio = 0.01;
      //Minimum distance between the cluster centers.
      hv_MinDiff.Dispose();
      hv_MinDiff = 0.1;
      //Number of centers to start k-means with. For aspect ratios, set K to 4.
      hv_K.Dispose();
      hv_K = 4;
      //Perform clustering of collected aspect ratios.
      hv_ClusteredAspectRatios.Dispose();
      cluster_dl_detection_param(hv_AspectRatiosReduced, hv_K, hv_MinRatio, hv_MinDiff, 
          out hv_ClusteredAspectRatios);
      HOperatorSet.SetDictTuple(hv_DLDetectionModelParam, "anchor_aspect_ratios", 
          hv_ClusteredAspectRatios);
      //
      //For rectangle2, also perform clustering on the angles.
      if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
      {
        //Since the variance for the angles is usually greater,
        //adapt K and MinDiff accordingly.
        hv_K.Dispose();
        hv_K = 8;
        hv_MinDiff.Dispose();
        hv_MinDiff = 0.4;
        //Perform clustering of collected angles.
        hv_ClusteredAngles.Dispose();
        cluster_dl_detection_param(hv_AnglesReduced, hv_K, hv_MinRatio, hv_MinDiff, 
            out hv_ClusteredAngles);
        HOperatorSet.SetDictTuple(hv_DLDetectionModelParam, "anchor_angles", hv_ClusteredAngles);
      }
      //
      //Display the histograms calculated from the data collections.
      hv_WindowBGColor.Dispose();
      hv_WindowBGColor = "light gray";
      hv_SplitText.Dispose();
      hv_SplitText = "";
      if ((int)(new HTuple(hv_DatasetSplit.TupleNotEqual("all"))) != 0)
      {
        hv_SplitText.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SplitText = (" ("+hv_DatasetSplit)+")";
        }
      }
      if ((int)(hv_DisplayHistogram) != 0)
      {
        //Plot histogram of bounding box areas.
        HOperatorSet.SetWindowAttr("background_color",hv_WindowBGColor);
        HOperatorSet.OpenWindow(0,0,512,400,0,"visible","",out hv_WindowHandle);
        HDevWindowStack.Push(hv_WindowHandle);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        plot_dl_detection_histogram(hv_Areas, "#ff6384", (new HTuple("title")).TupleConcat(
            "label_x"), (("Histogram of bounding box areas"+hv_SplitText)).TupleConcat(
            "Bounding box area"), hv_WindowHandle);
        }
        //Plot histogram of aspect ratios.
        HOperatorSet.SetWindowAttr("background_color",hv_WindowBGColor);
        HOperatorSet.OpenWindow(0,520,512,400,0,"visible","",out hv_WindowHandle2);
        HDevWindowStack.Push(hv_WindowHandle2);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        plot_dl_detection_histogram(hv_AspectRatios, "#66ff92", (new HTuple("title")).TupleConcat(
            "label_x"), (("Histogram of aspect ratios"+hv_SplitText)).TupleConcat(
            "Aspect ratio"), hv_WindowHandle2);
        }
        if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
        {
          //Plot histogram of anchor angles.
          HOperatorSet.SetWindowAttr("background_color",hv_WindowBGColor);
          HOperatorSet.OpenWindow(450,0,512,400,0,"visible","",out hv_WindowHandle3);
          HDevWindowStack.Push(hv_WindowHandle3);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          plot_dl_detection_histogram(hv_Angles, "#36a2eb", (new HTuple("title")).TupleConcat(
              "label_x"), (("Histogram of angles"+hv_SplitText)).TupleConcat("Angle (rad)"), 
              hv_WindowHandle3);
          }
        }
      }
      //

      hv_ImageWidthRaw.Dispose();
      hv_ImageHeightRaw.Dispose();
      hv_MinLevel.Dispose();
      hv_MaxLevel.Dispose();
      hv_AnchorNumSubscales.Dispose();
      hv_DomainHandling.Dispose();
      hv_DatasetSplit.Dispose();
      hv_DisplayHistogram.Dispose();
      hv_PreprocessedPath.Dispose();
      hv_GenParamName.Dispose();
      hv_GenParamIndex.Dispose();
      hv_DisplayBool.Dispose();
      hv_DatasetKeys.Dispose();
      hv_KeyIndex.Dispose();
      hv_DatasetKeyExists.Dispose();
      hv_Rect1Keys.Dispose();
      hv_Rect2Keys.Dispose();
      hv_DLSamples.Dispose();
      hv_Rect1KeysExist.Dispose();
      hv_Rect2KeysExist.Dispose();
      hv_InstanceType.Dispose();
      hv_PreprocessedKey.Dispose();
      hv_PreprocessedKeyExists.Dispose();
      hv_Areas.Dispose();
      hv_AspectRatios.Dispose();
      hv_Angles.Dispose();
      hv_AreasReduced.Dispose();
      hv_AspectRatiosReduced.Dispose();
      hv_AnglesReduced.Dispose();
      hv_MinLevelToUse.Dispose();
      hv_MaxLevelToUse.Dispose();
      hv_AnchorNumSubscalesToUse.Dispose();
      hv_MinRatio.Dispose();
      hv_MinDiff.Dispose();
      hv_K.Dispose();
      hv_ClusteredAspectRatios.Dispose();
      hv_ClusteredAngles.Dispose();
      hv_WindowBGColor.Dispose();
      hv_SplitText.Dispose();
      hv_WindowHandle.Dispose();
      hv_WindowHandle2.Dispose();
      hv_WindowHandle3.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_ImageWidthRaw.Dispose();
      hv_ImageHeightRaw.Dispose();
      hv_MinLevel.Dispose();
      hv_MaxLevel.Dispose();
      hv_AnchorNumSubscales.Dispose();
      hv_DomainHandling.Dispose();
      hv_DatasetSplit.Dispose();
      hv_DisplayHistogram.Dispose();
      hv_PreprocessedPath.Dispose();
      hv_GenParamName.Dispose();
      hv_GenParamIndex.Dispose();
      hv_DisplayBool.Dispose();
      hv_DatasetKeys.Dispose();
      hv_KeyIndex.Dispose();
      hv_DatasetKeyExists.Dispose();
      hv_Rect1Keys.Dispose();
      hv_Rect2Keys.Dispose();
      hv_DLSamples.Dispose();
      hv_Rect1KeysExist.Dispose();
      hv_Rect2KeysExist.Dispose();
      hv_InstanceType.Dispose();
      hv_PreprocessedKey.Dispose();
      hv_PreprocessedKeyExists.Dispose();
      hv_Areas.Dispose();
      hv_AspectRatios.Dispose();
      hv_Angles.Dispose();
      hv_AreasReduced.Dispose();
      hv_AspectRatiosReduced.Dispose();
      hv_AnglesReduced.Dispose();
      hv_MinLevelToUse.Dispose();
      hv_MaxLevelToUse.Dispose();
      hv_AnchorNumSubscalesToUse.Dispose();
      hv_MinRatio.Dispose();
      hv_MinDiff.Dispose();
      hv_K.Dispose();
      hv_ClusteredAspectRatios.Dispose();
      hv_ClusteredAngles.Dispose();
      hv_WindowBGColor.Dispose();
      hv_SplitText.Dispose();
      hv_WindowHandle.Dispose();
      hv_WindowHandle2.Dispose();
      hv_WindowHandle3.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Graphics / Window
  // Short Description: Close all window handles contained in a dictionary. 
  public void dev_close_window_dict (HTuple hv_WindowHandleDict)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_WindowHandleKeys = new HTuple();
    HTuple hv_Index = new HTuple(), hv_WindowHandles = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_RemovedWindowIndices = new HTuple();
    HTuple hv_WindowHandleIndex = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //
      //This procedure closes all window handles
      //that are contained in the dictionary WindowHandleDict.
      //
      hv_WindowHandleKeys.Dispose();
      HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_WindowHandleKeys);
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_WindowHandleKeys.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        try
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_WindowHandles.Dispose();
          HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKeys.TupleSelect(
              hv_Index), out hv_WindowHandles);
          }
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException1)
        {
          HDevExpDefaultException1.ToHTuple(out hv_Exception);
          continue;
        }
        hv_RemovedWindowIndices.Dispose();
        hv_RemovedWindowIndices = new HTuple();
        for (hv_WindowHandleIndex=0; (int)hv_WindowHandleIndex<=(int)((new HTuple(hv_WindowHandles.TupleLength()
            ))-1); hv_WindowHandleIndex = (int)hv_WindowHandleIndex + 1)
        {
          //Not every entry has to be a window handle, therefore use try-catch.
          try
          {
            //Call set_window_param to check if the handle is a window handle.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowHandleIndex), 
                "flush", "false");
            }
            HDevWindowStack.SetActive(hv_WindowHandles.TupleSelect(
                hv_WindowHandleIndex));
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.CloseWindow(HDevWindowStack.Pop());
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_RemovedWindowIndices = hv_RemovedWindowIndices.TupleConcat(
                hv_WindowHandleIndex);
            hv_RemovedWindowIndices.Dispose();
            hv_RemovedWindowIndices = ExpTmpLocalVar_RemovedWindowIndices;
            }
            }
          }
          // catch (Exception) 
          catch (HalconException HDevExpDefaultException1)
          {
            HDevExpDefaultException1.ToHTuple(out hv_Exception);
          }
        }
        {
        HTuple ExpTmpOutVar_0;
        HOperatorSet.TupleRemove(hv_WindowHandles, hv_RemovedWindowIndices, out ExpTmpOutVar_0);
        hv_WindowHandles.Dispose();
        hv_WindowHandles = ExpTmpOutVar_0;
        }
        //If some entries remained, set reduced tuple. Otherwise, remove whole key entry.
        if ((int)(new HTuple((new HTuple(hv_WindowHandles.TupleLength())).TupleGreater(
            0))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetDictTuple(hv_WindowHandleDict, hv_WindowHandleKeys.TupleSelect(
              hv_Index), hv_WindowHandles);
          }
        }
        else
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.RemoveDictKey(hv_WindowHandleDict, hv_WindowHandleKeys.TupleSelect(
              hv_Index));
          }
        }
      }
      //

      hv_WindowHandleKeys.Dispose();
      hv_Index.Dispose();
      hv_WindowHandles.Dispose();
      hv_Exception.Dispose();
      hv_RemovedWindowIndices.Dispose();
      hv_WindowHandleIndex.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_WindowHandleKeys.Dispose();
      hv_Index.Dispose();
      hv_WindowHandles.Dispose();
      hv_Exception.Dispose();
      hv_RemovedWindowIndices.Dispose();
      hv_WindowHandleIndex.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Graphics / Output
  // Short Description: Display a map of the confidences. 
  public void dev_display_confidence_regions (HObject ho_ImageConfidence, HTuple hv_DrawTransparency, 
      out HTuple hv_Colors)
  {




    // Local iconic variables 

    HObject ho_Region=null;

    // Local control variables 

    HTuple hv_NumColors = new HTuple(), hv_WeightsColorsAlpha = new HTuple();
    HTuple hv_ColorIndex = new HTuple(), hv_Threshold = new HTuple();
    HTuple hv_MinGray = new HTuple(), hv_MaxGray = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Region);
    hv_Colors = new HTuple();
    try
    {
      //
      //This procedure displays a map of the confidences
      //given in ImageConfidence as regions.
      //DrawTransparency determines the alpha value of the colors.
      //The used colors are returned.
      //
      //Define colors.
      hv_NumColors.Dispose();
      hv_NumColors = 20;
      hv_Colors.Dispose();
      get_distinct_colors_dl_visualization(hv_NumColors, 0, 0, 100, out hv_Colors);
      hv_WeightsColorsAlpha.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WeightsColorsAlpha = hv_Colors+hv_DrawTransparency;
      }
      hv_ColorIndex.Dispose();
      hv_ColorIndex = 0;
      //
      //Threshold the image according to
      //the number of colors and
      //display resulting regions.
      HTuple end_val15 = hv_NumColors-1;
      HTuple step_val15 = 1;
      for (hv_ColorIndex=0; hv_ColorIndex.Continue(end_val15, step_val15); hv_ColorIndex = hv_ColorIndex.TupleAdd(step_val15))
      {
        hv_Threshold.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Threshold = hv_ColorIndex*(1.0/hv_NumColors);
        }
        hv_MinGray.Dispose();
        hv_MinGray = new HTuple(hv_Threshold);
        hv_MaxGray.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MaxGray = hv_Threshold+(1/hv_NumColors);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_Region.Dispose();
        HOperatorSet.Threshold(ho_ImageConfidence, out ho_Region, hv_Threshold, hv_Threshold+(1.0/hv_NumColors));
        }
        if (HDevWindowStack.IsOpen())
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_WeightsColorsAlpha.TupleSelect(
              hv_ColorIndex));
          }
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_Region, HDevWindowStack.GetActive());
        }
      }
      ho_Region.Dispose();

      hv_NumColors.Dispose();
      hv_WeightsColorsAlpha.Dispose();
      hv_ColorIndex.Dispose();
      hv_Threshold.Dispose();
      hv_MinGray.Dispose();
      hv_MaxGray.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Region.Dispose();

      hv_NumColors.Dispose();
      hv_WeightsColorsAlpha.Dispose();
      hv_ColorIndex.Dispose();
      hv_Threshold.Dispose();
      hv_MinGray.Dispose();
      hv_MaxGray.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: Visualize different images, annotations and inference results for a sample. 
  public void dev_display_dl_data (HTuple hv_DLSample, HTuple hv_DLResult, HTuple hv_DLDatasetInfo, 
      HTuple hv_KeysForDisplay, HTuple hv_GenParam, HTuple hv_WindowHandleDict)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_Image=null, ho_AnomalyImage=null;
    HObject ho_AnomalyRegion=null, ho_PredictionColorFrame=null;
    HObject ho_ImageHeatmap=null, ho_ImageWeight=null, ho_ImageConfidence=null;
    HObject ho_SegmentationImagGroundTruth=null, ho_SegmentationImageResult=null;
    HObject ho_ImageAbsDiff=null, ho_DiffRegion=null;

    // Local control variables 

    HTuple hv_ThresholdWidth = new HTuple(), hv_ScaleWindows = new HTuple();
    HTuple hv_Font = new HTuple(), hv_FontSize = new HTuple();
    HTuple hv_LineWidth = new HTuple(), hv_MapTransparency = new HTuple();
    HTuple hv_MapColorBarWidth = new HTuple(), hv_AnomalyRegionThreshold = new HTuple();
    HTuple hv_AnomalyClassificationThreshold = new HTuple();
    HTuple hv_AnomalyRegionLabelColor = new HTuple(), hv_AnomalyColorTransparency = new HTuple();
    HTuple hv_AnomalyRegionResultColor = new HTuple(), hv_SegMaxWeight = new HTuple();
    HTuple hv_SegDraw = new HTuple(), hv_SegTransparency = new HTuple();
    HTuple hv_SegExcludeClassIDs = new HTuple(), hv_BboxLabelColor = new HTuple();
    HTuple hv_BboxDisplayConfidence = new HTuple(), hv_BboxTextColor = new HTuple();
    HTuple hv_ShowBottomDesc = new HTuple(), hv_ShowLegend = new HTuple();
    HTuple hv_ShowGroundTruthAnomalyRegions = new HTuple();
    HTuple hv_ShowClassificationIDs = new HTuple(), hv_ShowClassificationColorFrame = new HTuple();
    HTuple hv_ShowLabels = new HTuple(), hv_ShowDirection = new HTuple();
    HTuple hv_HeatmapColorScheme = new HTuple(), hv_GenParamNames = new HTuple();
    HTuple hv_ParamIndex = new HTuple(), hv_GenParamName = new HTuple();
    HTuple hv_GenParamValue = new HTuple(), hv_SampleKeys = new HTuple();
    HTuple hv_ResultKeys = new HTuple(), hv_ImageIDExists = new HTuple();
    HTuple hv_ImageID = new HTuple(), hv_ImageIDString = new HTuple();
    HTuple hv_ImageIDStringBraces = new HTuple(), hv_ImageIDStringCapital = new HTuple();
    HTuple hv_NeededKeys = new HTuple(), hv_Index = new HTuple();
    HTuple hv_DLDatasetInfoKeys = new HTuple(), hv_ClassNames = new HTuple();
    HTuple hv_ClassIDs = new HTuple(), hv_Colors = new HTuple();
    HTuple hv_ClassesLegend = new HTuple(), hv_PrevWindowCoordinates = new HTuple();
    HTuple hv_Keys = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_MetaInfoIndex = new HTuple(), hv_MetaInfo = new HTuple();
    HTuple hv_FlushValues = new HTuple(), hv_WindowHandleKeys = new HTuple();
    HTuple hv_KeyIndex = new HTuple(), hv_WindowHandles = new HTuple();
    HTuple hv_WindowIndex = new HTuple(), hv_FlushValue = new HTuple();
    HTuple hv_WidthImage = new HTuple(), hv_HeightImage = new HTuple();
    HTuple hv_CurrentWindowHandle = new HTuple(), hv_WindowImageRatio = new HTuple();
    HTuple hv_AnomalyLabelGroundTruth = new HTuple(), hv_AnomalyLabelIDGroundTruth = new HTuple();
    HTuple hv_AnomalyRegionExists = new HTuple(), hv_Text = new HTuple();
    HTuple hv_AnomalyScore = new HTuple(), hv_AnomalyClassID = new HTuple();
    HTuple hv_AnomalyRegionGroundTruthExists = new HTuple();
    HTuple hv_PredictionColor = new HTuple(), hv_LineColors = new HTuple();
    HTuple hv_ClassificationLabelIDGroundTruth = new HTuple();
    HTuple hv_ClassificationLabelIDResult = new HTuple(), hv_MarginBottom = new HTuple();
    HTuple hv_WindowCoordinates = new HTuple(), hv_CurrentWindowHeight = new HTuple();
    HTuple hv__ = new HTuple(), hv_MaxHeight = new HTuple();
    HTuple hv_PredictionText = new HTuple(), hv_BoarderOffset = new HTuple();
    HTuple hv_WindowImageRatioHeight = new HTuple(), hv_WindowImageRatioWidth = new HTuple();
    HTuple hv_BoarderOffsetRow = new HTuple(), hv_BoarderOffsetCol = new HTuple();
    HTuple hv_SelectedHeatmapMethod = new HTuple(), hv_DictHeatmap = new HTuple();
    HTuple hv_MethodName = new HTuple(), hv_HeatmapKeys = new HTuple();
    HTuple hv_HeatmapImageName = new HTuple(), hv_TargetClassID = new HTuple();
    HTuple hv_Confidences = new HTuple(), hv_MaxDeviation = new HTuple();
    HTuple hv_ClassificationLabelNameResult = new HTuple();
    HTuple hv_TargetClassConfidence = new HTuple(), hv_ClassificationLabelNamesGroundTruth = new HTuple();
    HTuple hv_BboxIDs = new HTuple(), hv_BboxColors = new HTuple();
    HTuple hv_BboxIDsUniq = new HTuple(), hv_BboxConfidences = new HTuple();
    HTuple hv_TextConf = new HTuple(), hv_BboxClassIndex = new HTuple();
    HTuple hv_BboxColorsResults = new HTuple(), hv_BboxClassIndexUniq = new HTuple();
    HTuple hv_BboxLabelIndex = new HTuple(), hv_BboxColorsBoth = new HTuple();
    HTuple hv_BboxClassLabelIndexUniq = new HTuple(), hv_ColorsSegmentation = new HTuple();
    HTuple hv_DrawMode = new HTuple(), hv_Width = new HTuple();
    HTuple hv_ImageClassIDs = new HTuple(), hv_ImageClassIDsUniq = new HTuple();
    HTuple hv_ColorsResults = new HTuple(), hv_GroundTruthIDs = new HTuple();
    HTuple hv_ResultIDs = new HTuple(), hv_StringSegExcludeClassIDs = new HTuple();
    HTuple hv_StringIndex = new HTuple(), hv_Min = new HTuple();
    HTuple hv_Max = new HTuple(), hv_Range = new HTuple();
    HTuple hv_MinWeight = new HTuple(), hv_WeightsColors = new HTuple();
    HTuple hv_ConfidenceColors = new HTuple(), hv_Indices = new HTuple();
    HTuple hv_WindowHandleKeysNew = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    HOperatorSet.GenEmptyObj(out ho_AnomalyImage);
    HOperatorSet.GenEmptyObj(out ho_AnomalyRegion);
    HOperatorSet.GenEmptyObj(out ho_PredictionColorFrame);
    HOperatorSet.GenEmptyObj(out ho_ImageHeatmap);
    HOperatorSet.GenEmptyObj(out ho_ImageWeight);
    HOperatorSet.GenEmptyObj(out ho_ImageConfidence);
    HOperatorSet.GenEmptyObj(out ho_SegmentationImagGroundTruth);
    HOperatorSet.GenEmptyObj(out ho_SegmentationImageResult);
    HOperatorSet.GenEmptyObj(out ho_ImageAbsDiff);
    HOperatorSet.GenEmptyObj(out ho_DiffRegion);
    try
    {
      //
      //This procedure displays the content of the provided DLSample and/or DLResult
      //depending on the input string KeysForDisplay.
      //DLDatasetInfo is a dictionary containing the information about the dataset.
      //The visualization can be adapted with GenParam.
      //
      //** Set the default values: ***
      //
      //Define the screen width when a new window row is started.
      hv_ThresholdWidth.Dispose();
      hv_ThresholdWidth = 1024;
      //Since potentially a lot of windows are opened,
      //scale the windows consistently.
      hv_ScaleWindows.Dispose();
      hv_ScaleWindows = 0.8;
      //Set a font and a font size.
      hv_Font.Dispose();
      hv_Font = "mono";
      hv_FontSize.Dispose();
      hv_FontSize = 14;
      //
      hv_LineWidth.Dispose();
      hv_LineWidth = 2;
      hv_MapTransparency.Dispose();
      hv_MapTransparency = "cc";
      hv_MapColorBarWidth.Dispose();
      hv_MapColorBarWidth = 140;
      //
      //Define anomaly detection-specific parameter values.
      hv_AnomalyRegionThreshold.Dispose();
      hv_AnomalyRegionThreshold = -1;
      hv_AnomalyClassificationThreshold.Dispose();
      hv_AnomalyClassificationThreshold = -1;
      hv_AnomalyRegionLabelColor.Dispose();
      hv_AnomalyRegionLabelColor = "#40e0d0";
      hv_AnomalyColorTransparency.Dispose();
      hv_AnomalyColorTransparency = "40";
      hv_AnomalyRegionResultColor.Dispose();
      hv_AnomalyRegionResultColor = "#ff0000c0";
      //
      //Define segmentation-specific parameter values.
      hv_SegMaxWeight.Dispose();
      hv_SegMaxWeight = 0;
      hv_SegDraw.Dispose();
      hv_SegDraw = "fill";
      hv_SegTransparency.Dispose();
      hv_SegTransparency = "aa";
      hv_SegExcludeClassIDs.Dispose();
      hv_SegExcludeClassIDs = new HTuple();
      //
      //Define bounding box-specific parameter values.
      hv_BboxLabelColor.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_BboxLabelColor = new HTuple("#000000")+"99";
      }
      hv_BboxDisplayConfidence.Dispose();
      hv_BboxDisplayConfidence = 1;
      hv_BboxTextColor.Dispose();
      hv_BboxTextColor = "#eeeeee";
      //
      //By default, display a description on the bottom.
      hv_ShowBottomDesc.Dispose();
      hv_ShowBottomDesc = 1;
      //
      //By default, show a legend with class IDs.
      hv_ShowLegend.Dispose();
      hv_ShowLegend = 1;
      //
      //By default, show the anomaly ground truth regions.
      hv_ShowGroundTruthAnomalyRegions.Dispose();
      hv_ShowGroundTruthAnomalyRegions = 1;
      //
      //By default, show class IDs and color frames for classification ground truth/results.
      hv_ShowClassificationIDs.Dispose();
      hv_ShowClassificationIDs = 1;
      hv_ShowClassificationColorFrame.Dispose();
      hv_ShowClassificationColorFrame = 1;
      //
      //By default, show class labels for detection ground truth/results.
      hv_ShowLabels.Dispose();
      hv_ShowLabels = 1;
      //
      //By default, show direction of the ground truth/results instances for detection with instance_type 'rectangle2'.
      hv_ShowDirection.Dispose();
      hv_ShowDirection = 1;
      //
      //By default, use color scheme 'Jet' for the heatmap display.
      hv_HeatmapColorScheme.Dispose();
      hv_HeatmapColorScheme = "jet";
      //** Set user defined values: ***
      //
      //Overwrite default values by given generic parameters.
      if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
      {
        hv_GenParamNames.Dispose();
        HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_GenParamNames);
        for (hv_ParamIndex=0; (int)hv_ParamIndex<=(int)((new HTuple(hv_GenParamNames.TupleLength()
            ))-1); hv_ParamIndex = (int)hv_ParamIndex + 1)
        {
          hv_GenParamName.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_GenParamName = hv_GenParamNames.TupleSelect(
              hv_ParamIndex);
          }
          hv_GenParamValue.Dispose();
          HOperatorSet.GetDictTuple(hv_GenParam, hv_GenParamName, out hv_GenParamValue);
          if ((int)(new HTuple(hv_GenParamName.TupleEqual("threshold_width"))) != 0)
          {
            hv_ThresholdWidth.Dispose();
            hv_ThresholdWidth = new HTuple(hv_GenParamValue);
          }
          else if ((int)(new HTuple(hv_GenParamName.TupleEqual("scale_windows"))) != 0)
          {
            hv_ScaleWindows.Dispose();
            hv_ScaleWindows = new HTuple(hv_GenParamValue);
          }
          else if ((int)(new HTuple(hv_GenParamName.TupleEqual("font"))) != 0)
          {
            hv_Font.Dispose();
            hv_Font = new HTuple(hv_GenParamValue);
          }
          else if ((int)(new HTuple(hv_GenParamName.TupleEqual("font_size"))) != 0)
          {
            hv_FontSize.Dispose();
            hv_FontSize = new HTuple(hv_GenParamValue);
          }
          else if ((int)(new HTuple(hv_GenParamName.TupleEqual("line_width"))) != 0)
          {
            hv_LineWidth.Dispose();
            hv_LineWidth = new HTuple(hv_GenParamValue);
          }
          else if ((int)(new HTuple(hv_GenParamName.TupleEqual("map_transparency"))) != 0)
          {
            hv_MapTransparency.Dispose();
            hv_MapTransparency = new HTuple(hv_GenParamValue);
          }
          else if ((int)(new HTuple(hv_GenParamName.TupleEqual("map_color_bar_width"))) != 0)
          {
            hv_MapColorBarWidth.Dispose();
            hv_MapColorBarWidth = new HTuple(hv_GenParamValue);
          }
          else if ((int)(new HTuple(hv_GenParamName.TupleEqual("segmentation_max_weight"))) != 0)
          {
            hv_SegMaxWeight.Dispose();
            hv_SegMaxWeight = new HTuple(hv_GenParamValue);
          }
          else if ((int)(new HTuple(hv_GenParamName.TupleEqual("segmentation_draw"))) != 0)
          {
            hv_SegDraw.Dispose();
            hv_SegDraw = new HTuple(hv_GenParamValue);
          }
          else if ((int)(new HTuple(hv_GenParamName.TupleEqual("segmentation_transparency"))) != 0)
          {
            hv_SegTransparency.Dispose();
            hv_SegTransparency = new HTuple(hv_GenParamValue);
          }
          else if ((int)(new HTuple(hv_GenParamName.TupleEqual("segmentation_exclude_class_ids"))) != 0)
          {
            hv_SegExcludeClassIDs.Dispose();
            hv_SegExcludeClassIDs = new HTuple(hv_GenParamValue);
          }
          else if ((int)(new HTuple(hv_GenParamName.TupleEqual("bbox_label_color"))) != 0)
          {
            hv_BboxLabelColor.Dispose();
            hv_BboxLabelColor = new HTuple(hv_GenParamValue);
          }
          else if ((int)(new HTuple(hv_GenParamName.TupleEqual("bbox_display_confidence"))) != 0)
          {
            hv_BboxDisplayConfidence.Dispose();
            hv_BboxDisplayConfidence = new HTuple(hv_GenParamValue);
          }
          else if ((int)(new HTuple(hv_GenParamName.TupleEqual("bbox_text_color"))) != 0)
          {
            hv_BboxTextColor.Dispose();
            hv_BboxTextColor = new HTuple(hv_GenParamValue);
          }
          else if ((int)(new HTuple(hv_GenParamName.TupleEqual("display_bottom_desc"))) != 0)
          {
            hv_ShowBottomDesc.Dispose();
            hv_ShowBottomDesc = new HTuple(hv_GenParamValue);
          }
          else if ((int)(new HTuple(hv_GenParamName.TupleEqual("display_legend"))) != 0)
          {
            hv_ShowLegend.Dispose();
            hv_ShowLegend = new HTuple(hv_GenParamValue);
          }
          else if ((int)(new HTuple(hv_GenParamName.TupleEqual("display_classification_ids"))) != 0)
          {
            hv_ShowClassificationIDs.Dispose();
            hv_ShowClassificationIDs = new HTuple(hv_GenParamValue);
          }
          else if ((int)(new HTuple(hv_GenParamName.TupleEqual("display_classification_color_frame"))) != 0)
          {
            hv_ShowClassificationColorFrame.Dispose();
            hv_ShowClassificationColorFrame = new HTuple(hv_GenParamValue);
          }
          else if ((int)(new HTuple(hv_GenParamName.TupleEqual("display_labels"))) != 0)
          {
            hv_ShowLabels.Dispose();
            hv_ShowLabels = new HTuple(hv_GenParamValue);
          }
          else if ((int)(new HTuple(hv_GenParamName.TupleEqual("display_direction"))) != 0)
          {
            hv_ShowDirection.Dispose();
            hv_ShowDirection = new HTuple(hv_GenParamValue);
          }
          else if ((int)(new HTuple(hv_GenParamName.TupleEqual("heatmap_color_scheme"))) != 0)
          {
            hv_HeatmapColorScheme.Dispose();
            hv_HeatmapColorScheme = new HTuple(hv_GenParamValue);
          }
          else if ((int)(new HTuple(hv_GenParamName.TupleEqual("display_ground_truth_anomaly_regions"))) != 0)
          {
            hv_ShowGroundTruthAnomalyRegions.Dispose();
            hv_ShowGroundTruthAnomalyRegions = new HTuple(hv_GenParamValue);
          }
          else if ((int)(new HTuple(hv_GenParamName.TupleEqual("anomaly_region_threshold"))) != 0)
          {
            hv_AnomalyRegionThreshold.Dispose();
            hv_AnomalyRegionThreshold = new HTuple(hv_GenParamValue);
          }
          else if ((int)(new HTuple(hv_GenParamName.TupleEqual("anomaly_classification_threshold"))) != 0)
          {
            hv_AnomalyClassificationThreshold.Dispose();
            hv_AnomalyClassificationThreshold = new HTuple(hv_GenParamValue);
          }
          else if ((int)(new HTuple(hv_GenParamName.TupleEqual("anomaly_region_label_color"))) != 0)
          {
            hv_AnomalyRegionLabelColor.Dispose();
            hv_AnomalyRegionLabelColor = new HTuple(hv_GenParamValue);
          }
          else if ((int)(new HTuple(hv_GenParamName.TupleEqual("anomaly_region_result_color"))) != 0)
          {
            hv_AnomalyRegionResultColor.Dispose();
            hv_AnomalyRegionResultColor = new HTuple(hv_GenParamValue);
          }
          else if ((int)(new HTuple(hv_GenParamName.TupleEqual("anomaly_color_transparency"))) != 0)
          {
            hv_AnomalyColorTransparency.Dispose();
            hv_AnomalyColorTransparency = new HTuple(hv_GenParamValue);
          }
          else
          {
            throw new HalconException(("Unknown generic parameter: "+hv_GenParamName)+".");
          }
        }
      }
      //
      //Get the dictionary keys.
      hv_SampleKeys.Dispose();
      HOperatorSet.GetDictParam(hv_DLSample, "keys", new HTuple(), out hv_SampleKeys);
      if ((int)(new HTuple(hv_DLResult.TupleNotEqual(new HTuple()))) != 0)
      {
        hv_ResultKeys.Dispose();
        HOperatorSet.GetDictParam(hv_DLResult, "keys", new HTuple(), out hv_ResultKeys);
      }
      //
      //Get image ID if it is available.
      hv_ImageIDExists.Dispose();
      HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "image_id", out hv_ImageIDExists);
      if ((int)(hv_ImageIDExists) != 0)
      {
        hv_ImageID.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "image_id", out hv_ImageID);
        hv_ImageIDString.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ImageIDString = "image ID "+hv_ImageID;
        }
        hv_ImageIDStringBraces.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ImageIDStringBraces = ("(image ID "+hv_ImageID)+")";
        }
        hv_ImageIDStringCapital.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ImageIDStringCapital = "Image ID "+hv_ImageID;
        }
      }
      else
      {
        hv_ImageIDString.Dispose();
        hv_ImageIDString = "";
        hv_ImageIDStringBraces.Dispose();
        hv_ImageIDStringBraces = new HTuple(hv_ImageIDString);
        hv_ImageIDStringCapital.Dispose();
        hv_ImageIDStringCapital = new HTuple(hv_ImageIDString);
      }
      //
      //Check if DLDatasetInfo is valid.
      if ((int)(new HTuple(hv_DLDatasetInfo.TupleEqual(new HTuple()))) != 0)
      {
        //If DLDatasetInfo is empty, 'image' is the only key allowed in KeysForDisplay.
        if ((int)((new HTuple((new HTuple(hv_KeysForDisplay.TupleLength())).TupleNotEqual(
            1))).TupleOr(new HTuple(((hv_KeysForDisplay.TupleSelect(0))).TupleNotEqual(
            "image")))) != 0)
        {
          throw new HalconException("DLDatasetInfo is needed for requested keys in KeysForDisplay.");
        }
      }
      else
      {
        //Check if DLDatasetInfo contains necessary keys.
        hv_NeededKeys.Dispose();
        hv_NeededKeys = new HTuple();
        hv_NeededKeys[0] = "class_names";
        hv_NeededKeys[1] = "class_ids";
        for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_NeededKeys.TupleLength()
            ))-1); hv_Index = (int)hv_Index + 1)
        {
          hv_DLDatasetInfoKeys.Dispose();
          HOperatorSet.GetDictParam(hv_DLDatasetInfo, "keys", new HTuple(), out hv_DLDatasetInfoKeys);
          if ((int)(new HTuple(((hv_DLDatasetInfoKeys.TupleFindFirst(hv_NeededKeys.TupleSelect(
              hv_Index)))).TupleEqual(-1))) != 0)
          {
            throw new HalconException(("Key "+(hv_NeededKeys.TupleSelect(
                hv_Index)))+" is missing in DLDatasetInfo.");
          }
        }
        //
        //Get the general dataset information, if available.
        hv_ClassNames.Dispose();
        HOperatorSet.GetDictTuple(hv_DLDatasetInfo, "class_names", out hv_ClassNames);
        hv_ClassIDs.Dispose();
        HOperatorSet.GetDictTuple(hv_DLDatasetInfo, "class_ids", out hv_ClassIDs);
        //
        //Define distinct colors for the classes.
        hv_Colors.Dispose();
        get_dl_class_colors(hv_ClassNames, out hv_Colors);
        //
        hv_ClassesLegend.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ClassesLegend = (hv_ClassIDs+" : ")+hv_ClassNames;
        }
      }
      //
      //** Set window parameters: ***
      //
      //Set previous window coordinates.
      hv_PrevWindowCoordinates.Dispose();
      hv_PrevWindowCoordinates = new HTuple();
      hv_PrevWindowCoordinates[0] = 0;
      hv_PrevWindowCoordinates[1] = 0;
      hv_PrevWindowCoordinates[2] = 0;
      hv_PrevWindowCoordinates[3] = 0;
      hv_PrevWindowCoordinates[4] = 1;
      //
      //Check that the WindowHandleDict is of type dictionary.
      try
      {
        hv_Keys.Dispose();
        HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_Keys);
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        if ((int)(new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(1401))) != 0)
        {
          throw new HalconException("WindowHandleDict has to be of type dictionary. Use create_dict to create an empty dictionary.");
        }
        else
        {
          throw new HalconException(hv_Exception);
        }
      }
      //For better usage, add meta information about the window handles in WindowHandleDict.
      hv_MetaInfoIndex.Dispose();
      HOperatorSet.TupleFind(hv_Keys, "meta_information", out hv_MetaInfoIndex);
      if ((int)((new HTuple(hv_MetaInfoIndex.TupleEqual(-1))).TupleOr(new HTuple(hv_MetaInfoIndex.TupleEqual(
          new HTuple())))) != 0)
      {
        hv_MetaInfo.Dispose();
        HOperatorSet.CreateDict(out hv_MetaInfo);
        HOperatorSet.SetDictTuple(hv_WindowHandleDict, "meta_information", hv_MetaInfo);
      }
      //
      //For each window, set 'flush' to 'false' to avoid flickering.
      hv_FlushValues.Dispose();
      hv_FlushValues = new HTuple();
      hv_WindowHandleKeys.Dispose();
      HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_WindowHandleKeys);
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_WindowHandleKeys.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        //Only consider the WindowHandleKeys that are needed for the current visualization.
        hv_KeyIndex.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_KeyIndex = hv_KeysForDisplay.TupleFind(
            hv_WindowHandleKeys.TupleSelect(hv_Index));
        }
        if ((int)((new HTuple(hv_KeyIndex.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_KeyIndex.TupleNotEqual(
            new HTuple())))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_WindowHandles.Dispose();
          HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKeys.TupleSelect(
              hv_Index), out hv_WindowHandles);
          }
          for (hv_WindowIndex=0; (int)hv_WindowIndex<=(int)((new HTuple(hv_WindowHandles.TupleLength()
              ))-1); hv_WindowIndex = (int)hv_WindowIndex + 1)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_FlushValue.Dispose();
            HOperatorSet.GetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex), 
                "flush", out hv_FlushValue);
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_FlushValues = hv_FlushValues.TupleConcat(
                hv_FlushValue);
            hv_FlushValues.Dispose();
            hv_FlushValues = ExpTmpLocalVar_FlushValues;
            }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex), 
                "flush", "false");
            }
          }
        }
      }
      //
      //** Display the data: ***
      //
      //Display data dictionaries.
      for (hv_KeyIndex=0; (int)hv_KeyIndex<=(int)((new HTuple(hv_KeysForDisplay.TupleLength()
          ))-1); hv_KeyIndex = (int)hv_KeyIndex + 1)
      {
        if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
            "image"))) != 0)
        {
          //
          //Image.
          ho_Image.Dispose();
          get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, 
              hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, 
              hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          if ((int)(hv_ShowBottomDesc) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ImageIDStringCapital, 
                  "window", "bottom", "left", "white", "box", "false");
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
            "anomaly_ground_truth"))) != 0)
        {
          //Image.
          ho_Image.Dispose();
          get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
          hv_AnomalyLabelGroundTruth.Dispose();hv_AnomalyLabelIDGroundTruth.Dispose();
          get_anomaly_ground_truth_label(hv_SampleKeys, hv_DLSample, out hv_AnomalyLabelGroundTruth, 
              out hv_AnomalyLabelIDGroundTruth);
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, 
              hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, 
              hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Visualize image.
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          //
          hv_AnomalyRegionExists.Dispose();
          hv_AnomalyRegionExists = "false";
          if ((int)(hv_ShowGroundTruthAnomalyRegions) != 0)
          {
            //Show the ground truth region.
            hv_AnomalyRegionExists.Dispose();
            dev_display_ground_truth_anomaly_regions(hv_SampleKeys, hv_DLSample, 
                hv_CurrentWindowHandle, hv_LineWidth, hv_AnomalyRegionLabelColor, 
                hv_AnomalyColorTransparency, out hv_AnomalyRegionExists);
          }
          //
          hv_Text.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Text = "Ground truth anomalies "+hv_ImageIDStringBraces;
          }
          if ((int)(hv_ShowBottomDesc) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
          //
          //Display the legend.
          if ((int)(hv_ShowLegend) != 0)
          {
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = ((hv_AnomalyLabelIDGroundTruth+" : '")+hv_AnomalyLabelGroundTruth)+"'";
            if ((int)((new HTuple((new HTuple(hv_AnomalyRegionExists.TupleEqual("false"))).TupleAnd(
                new HTuple(hv_AnomalyLabelIDGroundTruth.TupleEqual(1))))).TupleAnd(
                hv_ShowGroundTruthAnomalyRegions)) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "";
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "No 'anomaly_ground_truth' exists!";
            }
            //
            //Get or open next child window
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
            get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates, 
                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), 
                out hv_WindowImageRatio, out ExpTmpOutVar_0);
            hv_PrevWindowCoordinates.Dispose();
            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", "white", "box", "false");
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
            "anomaly_result"))) != 0)
        {
          //
          //Get image.
          ho_Image.Dispose();
          get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
          //
          //Get the anomaly image out of DLResult.
          ho_AnomalyImage.Dispose();hv_AnomalyScore.Dispose();hv_AnomalyClassID.Dispose();
          get_anomaly_result(out ho_AnomalyImage, hv_ResultKeys, hv_DLResult, out hv_AnomalyScore, 
              out hv_AnomalyClassID);
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, 
              hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, 
              hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Visualize image.
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          //
          //Display predicted anomaly regions.
          if ((int)(new HTuple(hv_AnomalyRegionThreshold.TupleNotEqual(-1))) != 0)
          {
            ho_AnomalyRegion.Dispose();
            dev_display_result_anomaly_regions(ho_AnomalyImage, out ho_AnomalyRegion, 
                hv_CurrentWindowHandle, hv_AnomalyRegionThreshold, hv_LineWidth, 
                hv_AnomalyRegionResultColor);
          }
          //
          hv_Text.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Text = "Detected anomalies "+hv_ImageIDStringBraces;
          }
          if ((int)(hv_ShowBottomDesc) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
          //
          //Display the legend.
          if ((int)(hv_ShowLegend) != 0)
          {
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "Results ";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
            if ((int)(new HTuple(hv_AnomalyClassID.TupleEqual(1))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID+" : 'nok'";
            }
            else
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID+" : 'ok'";
            }
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "Anomaly score: "+(hv_AnomalyScore.TupleString(
                ".2f"));
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if ((int)((new HTuple(hv_AnomalyClassificationThreshold.TupleNotEqual(
                -1))).TupleOr(new HTuple(hv_AnomalyRegionThreshold.TupleNotEqual(
                -1)))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "";
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "Thresholds ";
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
            }
            //
            if ((int)(new HTuple(hv_AnomalyClassificationThreshold.TupleNotEqual(
                -1))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "Classification: "+(hv_AnomalyClassificationThreshold.TupleString(
                  ".2f"));
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            }
            if ((int)(new HTuple(hv_AnomalyRegionThreshold.TupleNotEqual(-1))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "Segmentation: "+(hv_AnomalyRegionThreshold.TupleString(
                  ".2f"));
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            }
            //
            //Get or open next child window
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
            get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates, 
                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), 
                out hv_WindowImageRatio, out ExpTmpOutVar_0);
            hv_PrevWindowCoordinates.Dispose();
            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", "white", "box", "false");
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
            "anomaly_both"))) != 0)
        {
          //
          //Get image, ground truth and results.
          ho_Image.Dispose();
          get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
          hv_AnomalyLabelGroundTruth.Dispose();hv_AnomalyLabelIDGroundTruth.Dispose();
          get_anomaly_ground_truth_label(hv_SampleKeys, hv_DLSample, out hv_AnomalyLabelGroundTruth, 
              out hv_AnomalyLabelIDGroundTruth);
          ho_AnomalyImage.Dispose();hv_AnomalyScore.Dispose();hv_AnomalyClassID.Dispose();
          get_anomaly_result(out ho_AnomalyImage, hv_ResultKeys, hv_DLResult, out hv_AnomalyScore, 
              out hv_AnomalyClassID);
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, 
              hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, 
              hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Visualize image, ground truth (if available), and result regions.
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          hv_AnomalyRegionGroundTruthExists.Dispose();
          hv_AnomalyRegionGroundTruthExists = "false";
          if ((int)(hv_ShowGroundTruthAnomalyRegions) != 0)
          {
            hv_AnomalyRegionGroundTruthExists.Dispose();
            dev_display_ground_truth_anomaly_regions(hv_SampleKeys, hv_DLSample, 
                hv_CurrentWindowHandle, hv_LineWidth, hv_AnomalyRegionLabelColor, 
                hv_AnomalyColorTransparency, out hv_AnomalyRegionGroundTruthExists);
          }
          //
          //Display result anomaly regions.
          ho_AnomalyRegion.Dispose();
          dev_display_result_anomaly_regions(ho_AnomalyImage, out ho_AnomalyRegion, 
              hv_CurrentWindowHandle, hv_AnomalyRegionThreshold, hv_LineWidth, hv_AnomalyRegionResultColor);
          //
          hv_Text.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Text = "GT and detected anomalies "+hv_ImageIDStringBraces;
          }
          if ((int)(hv_ShowBottomDesc) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
          //
          //Get prediction color.
          hv_PredictionColor.Dispose();
          hv_PredictionColor = "white";
          if ((int)(new HTuple(hv_AnomalyLabelIDGroundTruth.TupleEqual(hv_AnomalyClassID))) != 0)
          {
            hv_PredictionColor.Dispose();
            hv_PredictionColor = "green";
          }
          else
          {
            hv_PredictionColor.Dispose();
            hv_PredictionColor = "red";
          }
          //
          //Display the legend.
          if ((int)(hv_ShowLegend) != 0)
          {
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "Ground truth ";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = ((hv_AnomalyLabelIDGroundTruth+" : '")+hv_AnomalyLabelGroundTruth)+"'";
            if ((int)((new HTuple((new HTuple(hv_AnomalyRegionGroundTruthExists.TupleEqual(
                "false"))).TupleAnd(new HTuple(hv_AnomalyLabelIDGroundTruth.TupleEqual(
                1))))).TupleAnd(hv_ShowGroundTruthAnomalyRegions)) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "";
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = " No 'anomaly_ground_truth' exists!";
            }
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "Results ";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
            if ((int)(new HTuple(hv_AnomalyClassID.TupleEqual(1))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID+" : 'nok'";
            }
            else
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID+" : 'ok'";
            }
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "Anomaly score: "+(hv_AnomalyScore.TupleString(
                ".2f"));
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if ((int)((new HTuple(hv_AnomalyClassificationThreshold.TupleNotEqual(
                -1))).TupleOr(new HTuple(hv_AnomalyRegionThreshold.TupleNotEqual(
                -1)))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "";
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "Thresholds ";
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
            }
            //
            if ((int)(new HTuple(hv_AnomalyClassificationThreshold.TupleNotEqual(
                -1))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "Classification: "+(hv_AnomalyClassificationThreshold.TupleString(
                  ".2f"));
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            }
            if ((int)(new HTuple(hv_AnomalyRegionThreshold.TupleNotEqual(-1))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "Segmentation: "+(hv_AnomalyRegionThreshold.TupleString(
                  ".2f"));
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            }
            //Get or open next child window
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
            get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates, 
                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), 
                out hv_WindowImageRatio, out ExpTmpOutVar_0);
            hv_PrevWindowCoordinates.Dispose();
            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_LineColors.Dispose();
            HOperatorSet.TupleGenConst(new HTuple(hv_Text.TupleLength()), "white", 
                out hv_LineColors);
            }
            if (hv_LineColors == null)
              hv_LineColors = new HTuple();
            hv_LineColors[(new HTuple(hv_LineColors.TupleLength()))-8] = hv_PredictionColor;
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", hv_LineColors, "box", "false");
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
            "anomaly_image"))) != 0)
        {
          //
          //Image.
          ho_Image.Dispose();
          get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
          //
          ho_AnomalyImage.Dispose();hv_AnomalyScore.Dispose();hv_AnomalyClassID.Dispose();
          get_anomaly_result(out ho_AnomalyImage, hv_ResultKeys, hv_DLResult, out hv_AnomalyScore, 
              out hv_AnomalyClassID);
          //
          //Read in input image.
          ho_Image.Dispose();
          HOperatorSet.GetDictObject(out ho_Image, hv_DLSample, "image");
          //Add the anomaly image to the input image.
          {
          HObject ExpTmpOutVar_0;
          add_colormap_to_image(ho_AnomalyImage, ho_Image, out ExpTmpOutVar_0, hv_HeatmapColorScheme);
          ho_AnomalyImage.Dispose();
          ho_AnomalyImage = ExpTmpOutVar_0;
          }
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, 
              hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, 
              hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_AnomalyImage, HDevWindowStack.GetActive());
          }
          hv_Text.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Text = "Anomaly image "+hv_ImageIDStringBraces;
          }
          if ((int)(hv_ShowBottomDesc) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
          //Display the legend.
          if ((int)(hv_ShowLegend) != 0)
          {
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if ((int)(new HTuple(hv_AnomalyClassID.TupleEqual(1))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID+" : 'nok'";
            }
            else
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID+" : 'ok'";
            }
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "Anomaly score: "+(hv_AnomalyScore.TupleString(
                ".2f"));
            //Get or open next child window
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
            get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates, 
                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), 
                out hv_WindowImageRatio, out ExpTmpOutVar_0);
            hv_PrevWindowCoordinates.Dispose();
            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", "white", "box", "false");
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
            "classification_ground_truth"))) != 0)
        {
          //
          //Ground truth classification image and class label.
          ho_Image.Dispose();
          get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
          //
          hv_ClassificationLabelIDGroundTruth.Dispose();
          get_classification_ground_truth(hv_SampleKeys, hv_DLSample, out hv_ClassificationLabelIDGroundTruth);
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, 
              hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, 
              hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Visualization.
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          //
          if ((int)(hv_ShowClassificationIDs) != 0)
          {
            hv_Text.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Text = "GT label ID: "+hv_ClassificationLabelIDGroundTruth;
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", "white", "box", "false");
            }
          }
          //
          if ((int)(hv_ShowBottomDesc) != 0)
          {
            hv_Text.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Text = "Ground truth classification "+hv_ImageIDStringBraces;
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
          //
          //Display the legend.
          if ((int)(hv_ShowLegend) != 0)
          {
            hv_Text.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Text = "Ground truth class ID "+hv_ImageIDStringBraces;
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                hv_ClassesLegend.TupleSelect(hv_ClassificationLabelIDGroundTruth));
            hv_Text.Dispose();
            hv_Text = ExpTmpLocalVar_Text;
            }
            }
            //
            //Get or open next child window
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
            get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates, 
                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), 
                out hv_WindowImageRatio, out ExpTmpOutVar_0);
            hv_PrevWindowCoordinates.Dispose();
            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
            }
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", (new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                  hv_ClassificationLabelIDGroundTruth)), "box", "false");
              }
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
            "classification_result"))) != 0)
        {
          //
          //Ground truth classification image.
          ho_Image.Dispose();
          get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
          //
          hv_ClassificationLabelIDResult.Dispose();
          get_classification_result(hv_ResultKeys, hv_DLResult, out hv_ClassificationLabelIDResult);
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, 
              hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, 
              hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Visualization.
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          //
          //Display the class IDs.
          if ((int)(hv_ShowClassificationIDs) != 0)
          {
            hv_MetaInfo.Dispose();
            HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
            hv_MarginBottom.Dispose();
            HOperatorSet.GetDictTuple(hv_MetaInfo, "classification_result_margin_bottom", 
                out hv_MarginBottom);
            hv_WindowCoordinates.Dispose();
            HOperatorSet.GetDictTuple(hv_MetaInfo, "classification_result_window_coordinates", 
                out hv_WindowCoordinates);
            hv_CurrentWindowHeight.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_CurrentWindowHeight = (hv_WindowCoordinates.TupleSelect(
                3))-(hv_WindowCoordinates.TupleSelect(0));
            }
            hv__.Dispose();hv__.Dispose();hv__.Dispose();hv_MaxHeight.Dispose();
            HOperatorSet.GetFontExtents(hv_CurrentWindowHandle, out hv__, out hv__, 
                out hv__, out hv_MaxHeight);
            hv_Text.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Text = "Result class ID: "+hv_ClassificationLabelIDResult;
            }
            if ((int)(hv_ShowBottomDesc) != 0)
            {
              if (HDevWindowStack.IsOpen())
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                    hv_CurrentWindowHeight-((hv_MarginBottom+hv_MaxHeight)+10), "left", 
                    "white", "box", "false");
                }
              }
            }
            else
            {
              if (HDevWindowStack.IsOpen())
              {
                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                    "bottom", "left", "white", "box", "false");
              }
            }
          }
          //
          if ((int)(hv_ShowBottomDesc) != 0)
          {
            hv_Text.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Text = "Result classification "+hv_ImageIDStringBraces;
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
          //
          //Display the legend.
          if ((int)(hv_ShowLegend) != 0)
          {
            hv_Text.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Text = "Result class ID "+hv_ImageIDStringBraces;
            }
            if ((int)(new HTuple(hv_ClassificationLabelIDResult.TupleEqual(new HTuple()))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "No classification result is given!";
            }
            else
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                  hv_ClassesLegend.TupleSelect(hv_ClassificationLabelIDResult));
              hv_Text.Dispose();
              hv_Text = ExpTmpLocalVar_Text;
              }
              }
            }
            //
            //Get or open next child window
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
            get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates, 
                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), 
                out hv_WindowImageRatio, out ExpTmpOutVar_0);
            hv_PrevWindowCoordinates.Dispose();
            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
            }
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", (new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                  hv_ClassificationLabelIDResult)), "box", "false");
              }
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
            "classification_both"))) != 0)
        {
          //
          //Ground truth and result classification image.
          ho_Image.Dispose();
          get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
          //
          hv_ClassificationLabelIDGroundTruth.Dispose();
          get_classification_ground_truth(hv_SampleKeys, hv_DLSample, out hv_ClassificationLabelIDGroundTruth);
          hv_ClassificationLabelIDResult.Dispose();
          get_classification_result(hv_ResultKeys, hv_DLResult, out hv_ClassificationLabelIDResult);
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, 
              hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, 
              hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Visualization.
          //
          //Get prediction color.
          hv_PredictionColor.Dispose();
          hv_PredictionColor = "white";
          if ((int)(new HTuple(hv_ClassificationLabelIDGroundTruth.TupleEqual(hv_ClassificationLabelIDResult))) != 0)
          {
            hv_PredictionText.Dispose();
            hv_PredictionText = "Correct";
            hv_PredictionColor.Dispose();
            hv_PredictionColor = "green";
          }
          else
          {
            hv_PredictionText.Dispose();
            hv_PredictionText = "Wrong";
            hv_PredictionColor.Dispose();
            hv_PredictionColor = "red";
          }
          //
          //Generate prediction color frame and show image.
          if ((int)(hv_ShowClassificationColorFrame) != 0)
          {
            //Create a frame with line width 7 that is completely displayed in the window.
            hv_BoarderOffset.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_BoarderOffset = 7/2.0;
            }
            hv_MetaInfo.Dispose();
            HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
            hv_WindowImageRatioHeight.Dispose();
            HOperatorSet.GetDictTuple(hv_MetaInfo, "classification_both_window_image_ratio_height", 
                out hv_WindowImageRatioHeight);
            hv_WindowImageRatioWidth.Dispose();
            HOperatorSet.GetDictTuple(hv_MetaInfo, "classification_both_window_image_ratio_width", 
                out hv_WindowImageRatioWidth);
            hv_BoarderOffsetRow.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_BoarderOffsetRow = hv_BoarderOffset/hv_WindowImageRatioHeight;
            }
            hv_BoarderOffsetCol.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_BoarderOffsetCol = hv_BoarderOffset/hv_WindowImageRatioWidth;
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_PredictionColorFrame.Dispose();
            HOperatorSet.GenContourPolygonXld(out ho_PredictionColorFrame, ((((((((hv_BoarderOffsetRow-0.5)).TupleConcat(
                hv_BoarderOffsetRow-0.5))).TupleConcat((hv_HeightImage+0.5)-hv_BoarderOffsetRow))).TupleConcat(
                (hv_HeightImage+0.5)-hv_BoarderOffsetRow))).TupleConcat(hv_BoarderOffsetRow-0.5), 
                ((((((((hv_BoarderOffsetCol-0.5)).TupleConcat((hv_WidthImage+0.5)-hv_BoarderOffsetCol))).TupleConcat(
                (hv_WidthImage+0.5)-hv_BoarderOffsetCol))).TupleConcat(hv_BoarderOffsetCol-0.5))).TupleConcat(
                hv_BoarderOffsetCol-0.5));
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 7);
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_PredictionColor);
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_PredictionColorFrame, HDevWindowStack.GetActive()
                  );
            }
          }
          else
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
            }
          }
          //
          if ((int)(hv_ShowClassificationIDs) != 0)
          {
            hv_MetaInfo.Dispose();
            HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_MarginBottom.Dispose();
            HOperatorSet.GetDictTuple(hv_MetaInfo, (hv_KeysForDisplay.TupleSelect(
                hv_KeyIndex))+"_margin_bottom", out hv_MarginBottom);
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowCoordinates.Dispose();
            HOperatorSet.GetDictTuple(hv_MetaInfo, (hv_KeysForDisplay.TupleSelect(
                hv_KeyIndex))+"_window_coordinates", out hv_WindowCoordinates);
            }
            hv_CurrentWindowHeight.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_CurrentWindowHeight = (hv_WindowCoordinates.TupleSelect(
                3))-(hv_WindowCoordinates.TupleSelect(0));
            }
            hv__.Dispose();hv__.Dispose();hv__.Dispose();hv_MaxHeight.Dispose();
            HOperatorSet.GetFontExtents(hv_CurrentWindowHandle, out hv__, out hv__, 
                out hv__, out hv_MaxHeight);
            hv_Text.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Text = "GT label ID: "+hv_ClassificationLabelIDGroundTruth;
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", "white", "box", "false");
            }
            hv_Text.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Text = "Result class ID: "+hv_ClassificationLabelIDResult;
            }
            if ((int)(hv_ShowBottomDesc) != 0)
            {
              if (HDevWindowStack.IsOpen())
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                    hv_CurrentWindowHeight-((hv_MarginBottom+hv_MaxHeight)+10), "left", 
                    "white", "box", "false");
                }
              }
            }
            else
            {
              if (HDevWindowStack.IsOpen())
              {
                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                    "bottom", "left", "white", "box", "false");
              }
            }
          }
          //
          if ((int)(hv_ShowBottomDesc) != 0)
          {
            hv_Text.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Text = "Result/Ground truth classification "+hv_ImageIDStringBraces;
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
          //
          //Display the legend.
          if ((int)(hv_ShowLegend) != 0)
          {
            hv_Text.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Text = "Ground truth class ID "+hv_ImageIDStringBraces;
            }
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = hv_ClassesLegend.TupleSelect(
                hv_ClassificationLabelIDGroundTruth);
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "Result class ID";
            if ((int)(new HTuple(hv_ClassificationLabelIDResult.TupleEqual(new HTuple()))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "No classification result is given!";
            }
            else
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = hv_ClassesLegend.TupleSelect(
                  hv_ClassificationLabelIDResult);
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "";
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "";
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "Prediction ";
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = hv_PredictionText;
            }
            //
            //Get or open next child window.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
            get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates, 
                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), 
                out hv_WindowImageRatio, out ExpTmpOutVar_0);
            hv_PrevWindowCoordinates.Dispose();
            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_LineColors.Dispose();
            HOperatorSet.TupleGenConst(new HTuple(hv_Text.TupleLength()), "white", 
                out hv_LineColors);
            }
            if (hv_LineColors == null)
              hv_LineColors = new HTuple();
            hv_LineColors[1] = hv_Colors.TupleSelect(hv_ClassificationLabelIDGroundTruth);
            if ((int)(new HTuple(hv_ClassificationLabelIDResult.TupleNotEqual(new HTuple()))) != 0)
            {
              if (hv_LineColors == null)
                hv_LineColors = new HTuple();
              hv_LineColors[5] = hv_Colors.TupleSelect(hv_ClassificationLabelIDResult);
              if (hv_LineColors == null)
                hv_LineColors = new HTuple();
              hv_LineColors[9] = hv_PredictionColor;
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", hv_LineColors, "box", "false");
            }
          }
          //
        }
        else if ((int)((new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
            "heatmap_grad_cam"))).TupleOr(new HTuple(((hv_KeysForDisplay.TupleSelect(
            hv_KeyIndex))).TupleEqual("heatmap_confidence_based")))) != 0)
        {
          //
          //Display the heatmap image (method 'heatmap_grad_cam' or 'heatmap_confidence_based')
          //in the selected color scheme.
          //Retrieve heatmap image, inferred image, and inference results.
          hv_SelectedHeatmapMethod.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_SelectedHeatmapMethod = hv_KeysForDisplay.TupleSelect(
              hv_KeyIndex);
          }
          if ((int)((new HTuple(((hv_ResultKeys.TupleFind("heatmap_grad_cam"))).TupleNotEqual(
              -1))).TupleOr(new HTuple(((hv_ResultKeys.TupleFind("heatmap_confidence_based"))).TupleNotEqual(
              -1)))) != 0)
          {
            if ((int)(new HTuple(hv_SelectedHeatmapMethod.TupleEqual("heatmap_grad_cam"))) != 0)
            {
              hv_DictHeatmap.Dispose();
              HOperatorSet.GetDictTuple(hv_DLResult, "heatmap_grad_cam", out hv_DictHeatmap);
              hv_MethodName.Dispose();
              hv_MethodName = "Grad-CAM";
            }
            else
            {
              hv_DictHeatmap.Dispose();
              HOperatorSet.GetDictTuple(hv_DLResult, "heatmap_confidence_based", 
                  out hv_DictHeatmap);
              hv_MethodName.Dispose();
              hv_MethodName = "Confidence based";
            }
            hv_HeatmapKeys.Dispose();
            HOperatorSet.GetDictParam(hv_DictHeatmap, "keys", new HTuple(), out hv_HeatmapKeys);
            hv_HeatmapImageName.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_HeatmapImageName = hv_HeatmapKeys.TupleRegexpSelect(
                "heatmap_image_class_[0-9]*");
            }
            hv_TargetClassID.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_TargetClassID = hv_HeatmapImageName.TupleRegexpMatch(
                "heatmap_image_class_([0-9]+)$");
            }
            ho_ImageHeatmap.Dispose();
            HOperatorSet.GetDictObject(out ho_ImageHeatmap, hv_DictHeatmap, hv_HeatmapImageName);
          }
          else
          {
            throw new HalconException("Heatmap image could not be found in DLResult.");
          }
          //
          if ((int)(new HTuple(hv_SelectedHeatmapMethod.TupleEqual("heatmap_grad_cam"))) != 0)
          {
            //Read in input image.
            ho_Image.Dispose();
            HOperatorSet.GetDictObject(out ho_Image, hv_DLSample, "image");
            //Add the heatmap to the input image.
            {
            HObject ExpTmpOutVar_0;
            add_colormap_to_image(ho_ImageHeatmap, ho_Image, out ExpTmpOutVar_0, 
                hv_HeatmapColorScheme);
            ho_ImageHeatmap.Dispose();
            ho_ImageHeatmap = ExpTmpOutVar_0;
            }
          }
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_ImageHeatmap, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, 
              hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, 
              hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_ImageHeatmap, HDevWindowStack.GetActive());
          }
          if ((int)(hv_ShowBottomDesc) != 0)
          {
            hv_Text.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Text = "Classification heatmap "+hv_ImageIDStringBraces;
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
          //
          //Display the legend.
          if ((int)(hv_ShowLegend) != 0)
          {
            hv_ClassNames.Dispose();
            HOperatorSet.GetDictTuple(hv_DLResult, "classification_class_names", 
                out hv_ClassNames);
            hv_ClassIDs.Dispose();
            HOperatorSet.GetDictTuple(hv_DLResult, "classification_class_ids", out hv_ClassIDs);
            hv_Confidences.Dispose();
            HOperatorSet.GetDictTuple(hv_DLResult, "classification_confidences", 
                out hv_Confidences);
            if ((int)(new HTuple(hv_SelectedHeatmapMethod.TupleEqual("heatmap_confidence_based"))) != 0)
            {
              hv_MaxDeviation.Dispose();
              HOperatorSet.GetDictTuple(hv_DictHeatmap, "classification_heatmap_maxdeviation", 
                  out hv_MaxDeviation);
            }
            hv_ClassificationLabelNameResult.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ClassificationLabelNameResult = hv_ClassNames.TupleSelect(
                0);
            }
            hv_ClassificationLabelIDResult.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ClassificationLabelIDResult = hv_ClassIDs.TupleSelect(
                0);
            }
            hv_TargetClassConfidence.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_TargetClassConfidence = hv_Confidences.TupleSelect(
                hv_ClassIDs.TupleFind(hv_TargetClassID.TupleNumber()));
            }
            hv_Text.Dispose();
            hv_Text = "--------- ";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "Image ";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "--------- ";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("image_label_id"))).TupleNotEqual(
                -1))) != 0)
            {
              hv_ClassificationLabelIDGroundTruth.Dispose();
              HOperatorSet.GetDictTuple(hv_DLSample, "image_label_id", out hv_ClassificationLabelIDGroundTruth);
              hv_ClassificationLabelNamesGroundTruth.Dispose();
              HOperatorSet.GetDictTuple(hv_DLDatasetInfo, "class_names", out hv_ClassificationLabelNamesGroundTruth);
              //Get prediction color.
              if ((int)(new HTuple(hv_ClassificationLabelIDGroundTruth.TupleEqual(
                  hv_ClassificationLabelIDResult))) != 0)
              {
                hv_PredictionColor.Dispose();
                hv_PredictionColor = "green";
              }
              else
              {
                hv_PredictionColor.Dispose();
                hv_PredictionColor = "red";
              }
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "Ground truth class: ";
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = hv_ClassificationLabelNamesGroundTruth.TupleSelect(
                  hv_ClassificationLabelIDGroundTruth);
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            }
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "Predicted class: ";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = hv_ClassificationLabelNameResult;
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "Confidence: "+(((hv_Confidences.TupleSelect(
                0))).TupleString(".2f"));
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "--------- ";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "Heatmap ";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "--------- ";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "Method: "+hv_MethodName;
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "Target class: "+hv_TargetClassID;
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "Target class confidence: "+(hv_TargetClassConfidence.TupleString(
                ".2f"));
            if ((int)(new HTuple(hv_SelectedHeatmapMethod.TupleEqual("heatmap_confidence_based"))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = "Maximum deviation: "+(hv_MaxDeviation.TupleString(
                  ".2f"));
            }
            //
            //Get or open next child window
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
            get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates, 
                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), 
                out hv_WindowImageRatio, out ExpTmpOutVar_0);
            hv_PrevWindowCoordinates.Dispose();
            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_LineColors.Dispose();
            HOperatorSet.TupleGenConst(new HTuple(hv_Text.TupleLength()), "white", 
                out hv_LineColors);
            }
            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("image_label_id"))).TupleNotEqual(
                -1))) != 0)
            {
              if (hv_LineColors == null)
                hv_LineColors = new HTuple();
              hv_LineColors[8] = hv_PredictionColor;
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", hv_LineColors, "box", "false");
            }
          }
          //
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
            "segmentation_weight"))) != 0)
        {
          //
          //Weight image.
          ho_ImageWeight.Dispose();
          get_weight_image(out ho_ImageWeight, hv_SampleKeys, hv_DLSample);
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_ImageWeight, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, 
              hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, 
              hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_ImageWeight, HDevWindowStack.GetActive());
          }
          if ((int)(hv_ShowBottomDesc) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), "Weight image "+hv_ImageIDStringBraces, 
                  "window", "bottom", "left", "white", "box", "false");
              }
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
            "segmentation_confidence"))) != 0)
        {
          //
          //Segmentation confidences.
          ho_ImageConfidence.Dispose();
          get_confidence_image(out ho_ImageConfidence, hv_ResultKeys, hv_DLResult);
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_ImageConfidence, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, 
              hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, 
              hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_ImageConfidence, HDevWindowStack.GetActive());
          }
          if ((int)(hv_ShowBottomDesc) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), "Confidence image "+hv_ImageIDStringBraces, 
                  "window", "bottom", "left", "white", "box", "false");
              }
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
            "bbox_ground_truth"))) != 0)
        {
          //
          //Sample bounding boxes on image.
          ho_Image.Dispose();
          get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, 
              hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, 
              hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Visualization.
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          //
          hv_BboxIDs.Dispose();
          dev_display_ground_truth_detection(hv_DLSample, hv_SampleKeys, hv_LineWidth, 
              hv_ClassIDs, hv_Colors, hv_BboxLabelColor, hv_BboxTextColor, hv_ShowLabels, 
              hv_ShowDirection, hv_CurrentWindowHandle, out hv_BboxIDs);
          hv_Text.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Text = "Ground truth "+hv_ImageIDStringBraces;
          }
          if ((int)(hv_ShowBottomDesc) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
          //
          //Display the legend.
          if ((int)(hv_ShowLegend) != 0)
          {
            hv_BboxColors.Dispose();
            hv_BboxColors = "white";
            if ((int)(new HTuple(hv_BboxIDs.TupleLength())) != 0)
            {
              hv_BboxIDsUniq.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_BboxIDsUniq = ((hv_BboxIDs.TupleSort()
                  )).TupleUniq();
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                  hv_ClassesLegend.TupleSelect(hv_BboxIDsUniq));
              hv_Text.Dispose();
              hv_Text = ExpTmpLocalVar_Text;
              }
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_BboxColors = hv_BboxColors.TupleConcat(
                  hv_Colors.TupleSelect(hv_BboxIDsUniq));
              hv_BboxColors.Dispose();
              hv_BboxColors = ExpTmpLocalVar_BboxColors;
              }
              }
            }
            else
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                  "No ground truth bounding boxes present.");
              hv_Text.Dispose();
              hv_Text = ExpTmpLocalVar_Text;
              }
              }
            }
            //
            //Get or open next child window.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
            get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates, 
                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), 
                out hv_WindowImageRatio, out ExpTmpOutVar_0);
            hv_PrevWindowCoordinates.Dispose();
            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", hv_BboxColors, "box", "false");
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
            "bbox_result"))) != 0)
        {
          //
          //Result bounding boxes on image.
          ho_Image.Dispose();
          get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, 
              hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, 
              hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Visualization.
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          //
          if ((int)(new HTuple(((hv_ResultKeys.TupleFind("bbox_confidence"))).TupleNotEqual(
              -1))) != 0)
          {
            hv_BboxConfidences.Dispose();
            HOperatorSet.GetDictTuple(hv_DLResult, "bbox_confidence", out hv_BboxConfidences);
          }
          else
          {
            throw new HalconException("Result bounding box data could not be found in DLResult.");
          }
          if ((int)(hv_BboxDisplayConfidence) != 0)
          {
            hv_TextConf.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_TextConf = (" ("+(hv_BboxConfidences.TupleString(
                ".2f")))+")";
            }
          }
          else
          {
            hv_TextConf.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_TextConf = HTuple.TupleGenConst(
                new HTuple(hv_BboxConfidences.TupleLength()),"");
            }
          }
          hv_BboxClassIndex.Dispose();
          dev_display_result_detection(hv_DLResult, hv_ResultKeys, hv_LineWidth, 
              hv_ClassIDs, hv_TextConf, hv_Colors, hv_BboxLabelColor, hv_WindowImageRatio, 
              "top", hv_BboxTextColor, hv_ShowLabels, hv_ShowDirection, hv_CurrentWindowHandle, 
              out hv_BboxClassIndex);
          hv_Text.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Text = "Result bounding boxes "+hv_ImageIDStringBraces;
          }
          if ((int)(hv_ShowBottomDesc) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
          //
          //Display the legend.
          if ((int)(hv_ShowLegend) != 0)
          {
            hv_BboxColorsResults.Dispose();
            hv_BboxColorsResults = "white";
            if ((int)(new HTuple((new HTuple(hv_BboxClassIndex.TupleLength())).TupleGreater(
                0))) != 0)
            {
              hv_BboxClassIndexUniq.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_BboxClassIndexUniq = ((hv_BboxClassIndex.TupleSort()
                  )).TupleUniq();
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                  hv_ClassesLegend.TupleSelect(hv_BboxClassIndexUniq));
              hv_Text.Dispose();
              hv_Text = ExpTmpLocalVar_Text;
              }
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_BboxColorsResults = hv_BboxColorsResults.TupleConcat(
                  hv_Colors.TupleSelect(hv_BboxClassIndexUniq));
              hv_BboxColorsResults.Dispose();
              hv_BboxColorsResults = ExpTmpLocalVar_BboxColorsResults;
              }
              }
            }
            else
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                  "No result bounding boxes present.");
              hv_Text.Dispose();
              hv_Text = ExpTmpLocalVar_Text;
              }
              }
            }
            //
            //Get or open next child window.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
            get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates, 
                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), 
                out hv_WindowImageRatio, out ExpTmpOutVar_0);
            hv_PrevWindowCoordinates.Dispose();
            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", hv_BboxColorsResults, "box", "false");
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
            "bbox_both"))) != 0)
        {
          //
          //Ground truth and result bounding boxes on image.
          ho_Image.Dispose();
          get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, 
              hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, 
              hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          //
          //Visualization.
          hv_BboxLabelIndex.Dispose();
          dev_display_ground_truth_detection(hv_DLSample, hv_SampleKeys, hv_LineWidth, 
              hv_ClassIDs, hv_Colors, hv_BboxLabelColor, hv_BboxTextColor, hv_ShowLabels, 
              hv_ShowDirection, hv_CurrentWindowHandle, out hv_BboxLabelIndex);
          if ((int)(new HTuple(((hv_ResultKeys.TupleFind("bbox_confidence"))).TupleNotEqual(
              -1))) != 0)
          {
            hv_BboxConfidences.Dispose();
            HOperatorSet.GetDictTuple(hv_DLResult, "bbox_confidence", out hv_BboxConfidences);
          }
          else
          {
            throw new HalconException("Result bounding box data could not be found in DLResult.");
          }
          if ((int)(hv_BboxDisplayConfidence) != 0)
          {
            hv_TextConf.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_TextConf = (" ("+(hv_BboxConfidences.TupleString(
                ".2f")))+")";
            }
          }
          else
          {
            hv_TextConf.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_TextConf = HTuple.TupleGenConst(
                new HTuple(hv_BboxConfidences.TupleLength()),"");
            }
          }
          hv_BboxClassIndex.Dispose();
          dev_display_result_detection(hv_DLResult, hv_ResultKeys, hv_LineWidth, 
              hv_ClassIDs, hv_TextConf, hv_Colors, hv_BboxLabelColor, hv_WindowImageRatio, 
              "bottom", hv_BboxTextColor, hv_ShowLabels, hv_ShowDirection, hv_CurrentWindowHandle, 
              out hv_BboxClassIndex);
          hv_Text.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Text = "Ground truth and result bounding boxes "+hv_ImageIDStringBraces;
          }
          if ((int)(hv_ShowBottomDesc) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
          hv_Text.Dispose();
          hv_Text = "Ground truth and";
          if (hv_Text == null)
            hv_Text = new HTuple();
          hv_Text[new HTuple(hv_Text.TupleLength())] = "result bounding boxes "+hv_ImageIDStringBraces;
          //
          //Display the legend.
          if ((int)(hv_ShowLegend) != 0)
          {
            hv_BboxColorsBoth.Dispose();
            hv_BboxColorsBoth = new HTuple();
            hv_BboxColorsBoth[0] = "white";
            hv_BboxColorsBoth[1] = "white";
            if ((int)(new HTuple((new HTuple((new HTuple(hv_BboxClassIndex.TupleLength()
                ))+(new HTuple(hv_BboxLabelIndex.TupleLength())))).TupleGreater(0))) != 0)
            {
              hv_BboxClassLabelIndexUniq.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_BboxClassLabelIndexUniq = ((((hv_BboxClassIndex.TupleConcat(
                  hv_BboxLabelIndex))).TupleSort())).TupleUniq();
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                  hv_ClassesLegend.TupleSelect(hv_BboxClassLabelIndexUniq));
              hv_Text.Dispose();
              hv_Text = ExpTmpLocalVar_Text;
              }
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_BboxColorsBoth = hv_BboxColorsBoth.TupleConcat(
                  hv_Colors.TupleSelect(hv_BboxClassLabelIndexUniq));
              hv_BboxColorsBoth.Dispose();
              hv_BboxColorsBoth = ExpTmpLocalVar_BboxColorsBoth;
              }
              }
            }
            else
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                  "No ground truth nor result bounding boxes present.");
              hv_Text.Dispose();
              hv_Text = ExpTmpLocalVar_Text;
              }
              }
            }
            //
            //Get or open next child window.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
            get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates, 
                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), 
                out hv_WindowImageRatio, out ExpTmpOutVar_0);
            hv_PrevWindowCoordinates.Dispose();
            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", hv_BboxColorsBoth, "box", "false");
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
            "segmentation_image_ground_truth"))) != 0)
        {
          //
          //Ground truth segmentation image.
          ho_Image.Dispose();
          get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
          ho_SegmentationImagGroundTruth.Dispose();
          get_segmentation_image_ground_truth(out ho_SegmentationImagGroundTruth, 
              hv_SampleKeys, hv_DLSample);
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, 
              hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, 
              hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Visualization.
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          //
          //Display segmentation regions.
          hv_ColorsSegmentation.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ColorsSegmentation = hv_Colors+hv_SegTransparency;
          }
          hv_DrawMode.Dispose();
          HOperatorSet.GetDraw(hv_CurrentWindowHandle, out hv_DrawMode);
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_SegDraw);
          }
          hv_Width.Dispose();
          HOperatorSet.GetLineWidth(hv_CurrentWindowHandle, out hv_Width);
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidth);
          }
          hv_ImageClassIDs.Dispose();
          dev_display_segmentation_regions(ho_SegmentationImagGroundTruth, hv_ClassIDs, 
              hv_ColorsSegmentation, hv_SegExcludeClassIDs, out hv_ImageClassIDs);
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
          }
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_Width.TupleInt()
                );
            }
          }
          hv_Text.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Text = "Ground truth segmentation "+hv_ImageIDStringBraces;
          }
          if ((int)(hv_ShowBottomDesc) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
          //
          //Display the legend.
          if ((int)(hv_ShowLegend) != 0)
          {
            hv_ImageClassIDsUniq.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ImageClassIDsUniq = ((hv_ImageClassIDs.TupleSort()
                )).TupleUniq();
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                hv_ClassesLegend.TupleSelect(hv_ImageClassIDsUniq));
            hv_Text.Dispose();
            hv_Text = ExpTmpLocalVar_Text;
            }
            }
            //
            //Get or open next child window
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
            get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates, 
                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), 
                out hv_WindowImageRatio, out ExpTmpOutVar_0);
            hv_PrevWindowCoordinates.Dispose();
            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
            }
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", (new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                  hv_ImageClassIDsUniq)), "box", "false");
              }
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
            "segmentation_image_result"))) != 0)
        {
          //
          //Result segmentation on image.
          ho_Image.Dispose();
          get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
          ho_SegmentationImageResult.Dispose();
          get_segmentation_image_result(out ho_SegmentationImageResult, hv_ResultKeys, 
              hv_DLResult);
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, 
              hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, 
              hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Visualization.
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          //
          //Display result segmentation regions.
          hv_ColorsResults.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ColorsResults = hv_Colors+hv_SegTransparency;
          }
          hv_DrawMode.Dispose();
          HOperatorSet.GetDraw(hv_CurrentWindowHandle, out hv_DrawMode);
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_SegDraw);
          }
          hv_Width.Dispose();
          HOperatorSet.GetLineWidth(hv_CurrentWindowHandle, out hv_Width);
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidth);
          }
          hv_ImageClassIDs.Dispose();
          dev_display_segmentation_regions(ho_SegmentationImageResult, hv_ClassIDs, 
              hv_ColorsResults, hv_SegExcludeClassIDs, out hv_ImageClassIDs);
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
          }
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_Width.TupleInt()
                );
            }
          }
          hv_Text.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Text = "Result segmentation "+hv_ImageIDStringBraces;
          }
          if ((int)(hv_ShowBottomDesc) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
          //
          //Display the legend.
          if ((int)(hv_ShowLegend) != 0)
          {
            hv_ImageClassIDsUniq.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ImageClassIDsUniq = ((hv_ImageClassIDs.TupleSort()
                )).TupleUniq();
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                hv_ClassesLegend.TupleSelect(hv_ImageClassIDsUniq));
            hv_Text.Dispose();
            hv_Text = ExpTmpLocalVar_Text;
            }
            }
            //
            //Get or open next child window.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
            get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates, 
                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), 
                out hv_WindowImageRatio, out ExpTmpOutVar_0);
            hv_PrevWindowCoordinates.Dispose();
            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
            }
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", (new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                  hv_ImageClassIDsUniq)), "box", "false");
              }
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
            "segmentation_image_both"))) != 0)
        {
          //
          //Ground truth and result segmentation on image.
          ho_Image.Dispose();
          get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
          ho_SegmentationImagGroundTruth.Dispose();
          get_segmentation_image_ground_truth(out ho_SegmentationImagGroundTruth, 
              hv_SampleKeys, hv_DLSample);
          ho_SegmentationImageResult.Dispose();
          get_segmentation_image_result(out ho_SegmentationImageResult, hv_ResultKeys, 
              hv_DLResult);
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, 
              hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, 
              hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Visualization.
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          //
          //Display regions.
          hv_ColorsResults.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ColorsResults = hv_Colors+hv_SegTransparency;
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 2);
          }
          hv_GroundTruthIDs.Dispose();
          dev_display_segmentation_regions(ho_SegmentationImagGroundTruth, hv_ClassIDs, 
              hv_ColorsResults, hv_SegExcludeClassIDs, out hv_GroundTruthIDs);
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 6);
          }
          hv_ResultIDs.Dispose();
          dev_display_segmentation_regions(ho_SegmentationImageResult, hv_ClassIDs, 
              hv_ColorsResults, hv_SegExcludeClassIDs, out hv_ResultIDs);
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
          }
          hv_Text.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Text = "Ground truth and result segmentation "+hv_ImageIDStringBraces;
          }
          if ((int)(hv_ShowBottomDesc) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
          //
          //Display the legend.
          if ((int)(hv_ShowLegend) != 0)
          {
            hv_ImageClassIDsUniq.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ImageClassIDsUniq = ((((hv_GroundTruthIDs.TupleConcat(
                hv_ResultIDs))).TupleSort())).TupleUniq();
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                hv_ClassesLegend.TupleSelect(hv_ImageClassIDsUniq));
            hv_Text.Dispose();
            hv_Text = ExpTmpLocalVar_Text;
            }
            }
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[(new HTuple(hv_Text.TupleLength()))+1] = new HTuple("- thicker line: result, thinner lines: ground truth");
            if (hv_Text == null)
              hv_Text = new HTuple();
            hv_Text[new HTuple(hv_Text.TupleLength())] = "  (you may have to zoom in for a more detailed view)";
            hv_StringSegExcludeClassIDs.Dispose();
            hv_StringSegExcludeClassIDs = "";
            for (hv_StringIndex=0; (int)hv_StringIndex<=(int)((new HTuple(hv_SegExcludeClassIDs.TupleLength()
                ))-1); hv_StringIndex = (int)hv_StringIndex + 1)
            {
              if ((int)(new HTuple(hv_StringIndex.TupleEqual((new HTuple(hv_SegExcludeClassIDs.TupleLength()
                  ))-1))) != 0)
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                {
                HTuple 
                  ExpTmpLocalVar_StringSegExcludeClassIDs = hv_StringSegExcludeClassIDs+(hv_SegExcludeClassIDs.TupleSelect(
                    hv_StringIndex));
                hv_StringSegExcludeClassIDs.Dispose();
                hv_StringSegExcludeClassIDs = ExpTmpLocalVar_StringSegExcludeClassIDs;
                }
                }
              }
              else
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                {
                HTuple 
                  ExpTmpLocalVar_StringSegExcludeClassIDs = (hv_StringSegExcludeClassIDs+(hv_SegExcludeClassIDs.TupleSelect(
                    hv_StringIndex)))+new HTuple(", ");
                hv_StringSegExcludeClassIDs.Dispose();
                hv_StringSegExcludeClassIDs = ExpTmpLocalVar_StringSegExcludeClassIDs;
                }
                }
              }
            }
            if ((int)(new HTuple(hv_SegExcludeClassIDs.TupleNotEqual(new HTuple()))) != 0)
            {
              if (hv_Text == null)
                hv_Text = new HTuple();
              hv_Text[new HTuple(hv_Text.TupleLength())] = ("- (excluded classID(s) "+hv_StringSegExcludeClassIDs)+" from visualization)";
            }
            //
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
            get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates, 
                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), 
                out hv_WindowImageRatio, out ExpTmpOutVar_0);
            hv_PrevWindowCoordinates.Dispose();
            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
            }
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "top", "left", (((new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                  hv_ImageClassIDsUniq)))).TupleConcat(((new HTuple("white")).TupleConcat(
                  "white")).TupleConcat("white")), "box", "false");
              }
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
            "segmentation_image_diff"))) != 0)
        {
          //
          //Difference of ground truth and result segmentation on image.
          ho_Image.Dispose();
          get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
          ho_SegmentationImagGroundTruth.Dispose();
          get_segmentation_image_ground_truth(out ho_SegmentationImagGroundTruth, 
              hv_SampleKeys, hv_DLSample);
          ho_SegmentationImageResult.Dispose();
          get_segmentation_image_result(out ho_SegmentationImageResult, hv_ResultKeys, 
              hv_DLResult);
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, 
              hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates, 
              hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle, 
              out hv_WindowImageRatio, out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Visualization.
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          ho_ImageAbsDiff.Dispose();
          HOperatorSet.AbsDiffImage(ho_SegmentationImagGroundTruth, ho_SegmentationImageResult, 
              out ho_ImageAbsDiff, 1);
          hv_Min.Dispose();hv_Max.Dispose();hv_Range.Dispose();
          HOperatorSet.MinMaxGray(ho_SegmentationImageResult, ho_ImageAbsDiff, 0, 
              out hv_Min, out hv_Max, out hv_Range);
          if ((int)(new HTuple(hv_Min.TupleNotEqual(hv_Max))) != 0)
          {
            ho_DiffRegion.Dispose();
            HOperatorSet.Threshold(ho_ImageAbsDiff, out ho_DiffRegion, 0.00001, hv_Max);
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetColor(HDevWindowStack.GetActive(), "#ff0000"+hv_SegTransparency);
              }
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_DiffRegion, HDevWindowStack.GetActive());
            }
          }
          else
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), "No difference found.", 
                  "window", "top", "left", "black", new HTuple(), new HTuple());
            }
          }
          if ((int)(hv_ShowBottomDesc) != 0)
          {
            hv_Text.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Text = "Difference of ground truth and result segmentation "+hv_ImageIDStringBraces;
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", 
                  "bottom", "left", "white", "box", "false");
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
            "segmentation_weight_map"))) != 0)
        {
          //
          //Weight map on image.
          ho_Image.Dispose();
          get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
          ho_ImageWeight.Dispose();
          get_weight_image(out ho_ImageWeight, hv_SampleKeys, hv_DLSample);
          //
          if ((int)(new HTuple(hv_SegMaxWeight.TupleEqual(0))) != 0)
          {
            //Calculate SegMaxWeight if not given in GenParam.
            hv_MinWeight.Dispose();hv_SegMaxWeight.Dispose();hv_Range.Dispose();
            HOperatorSet.MinMaxGray(ho_ImageWeight, ho_ImageWeight, 0, out hv_MinWeight, 
                out hv_SegMaxWeight, out hv_Range);
          }
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, 
              hv_HeightImage, hv_MapColorBarWidth, hv_ScaleWindows, hv_ThresholdWidth, 
              hv_PrevWindowCoordinates, hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(
              hv_KeyIndex), out hv_CurrentWindowHandle, out hv_WindowImageRatio, 
              out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Visualization.
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          hv_WeightsColors.Dispose();
          dev_display_weight_regions(ho_ImageWeight, hv_MapTransparency, hv_SegMaxWeight, 
              out hv_WeightsColors);
          dev_display_map_color_bar(hv_WidthImage, hv_HeightImage, hv_MapColorBarWidth, 
              hv_WeightsColors, hv_SegMaxWeight, hv_WindowImageRatio, hv_CurrentWindowHandle);
          if ((int)(hv_ShowBottomDesc) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), "Weight map "+hv_ImageIDStringBraces, 
                  "window", "bottom", "left", "white", "box", "false");
              }
            }
          }
        }
        else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
            "segmentation_confidence_map"))) != 0)
        {
          //
          //Segmentation confidence map on image.
          ho_Image.Dispose();
          get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
          ho_ImageConfidence.Dispose();
          get_confidence_image(out ho_ImageConfidence, hv_ResultKeys, hv_DLResult);
          //
          //Get or open next window.
          hv_WidthImage.Dispose();hv_HeightImage.Dispose();
          HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentWindowHandle.Dispose();hv_WindowImageRatio.Dispose();HTuple ExpTmpOutVar_0;
          get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, 
              hv_HeightImage, hv_MapColorBarWidth, hv_ScaleWindows, hv_ThresholdWidth, 
              hv_PrevWindowCoordinates, hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(
              hv_KeyIndex), out hv_CurrentWindowHandle, out hv_WindowImageRatio, 
              out ExpTmpOutVar_0);
          hv_PrevWindowCoordinates.Dispose();
          hv_PrevWindowCoordinates = ExpTmpOutVar_0;
          }
          //
          //Visualization.
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
          }
          hv_ConfidenceColors.Dispose();
          dev_display_confidence_regions(ho_ImageConfidence, hv_MapTransparency, 
              out hv_ConfidenceColors);
          dev_display_map_color_bar(hv_WidthImage, hv_HeightImage, hv_MapColorBarWidth, 
              hv_ConfidenceColors, 1.0, hv_WindowImageRatio, hv_CurrentWindowHandle);
          if ((int)(hv_ShowBottomDesc) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), "Confidence map "+hv_ImageIDStringBraces, 
                  "window", "bottom", "left", "white", "box", "false");
              }
            }
          }
        }
        else
        {
          //Reset flush buffer of existing windows before throwing an exception.
          hv_WindowHandleKeys.Dispose();
          HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_WindowHandleKeys);
          for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_WindowHandleKeys.TupleLength()
              ))-1); hv_Index = (int)hv_Index + 1)
          {
            //Only consider the WindowHandleKeys that are needed for the current visualization.
            hv_Indices.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Indices = hv_KeysForDisplay.TupleFind(
                hv_WindowHandleKeys.TupleSelect(hv_Index));
            }
            if ((int)((new HTuple(hv_Indices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_Indices.TupleNotEqual(
                new HTuple())))) != 0)
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_WindowHandles.Dispose();
              HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKeys.TupleSelect(
                  hv_Index), out hv_WindowHandles);
              }
              for (hv_WindowIndex=0; (int)hv_WindowIndex<=(int)((new HTuple(hv_WindowHandles.TupleLength()
                  ))-1); hv_WindowIndex = (int)hv_WindowIndex + 1)
              {
                //Reset values of windows that have been changed temporarily.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex), 
                    "flush", hv_FlushValues.TupleSelect(hv_Index));
                }
              }
            }
          }
          throw new HalconException("Key for display unknown: "+(hv_KeysForDisplay.TupleSelect(
              hv_KeyIndex)));
        }
      }
      //
      //Display results.
      hv_WindowHandleKeysNew.Dispose();
      HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_WindowHandleKeysNew);
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_WindowHandleKeysNew.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        //Only consider the WindowHandleKeys that are needed for the current visualization.
        hv_KeyIndex.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_KeyIndex = hv_KeysForDisplay.TupleFind(
            hv_WindowHandleKeysNew.TupleSelect(hv_Index));
        }
        if ((int)((new HTuple(hv_KeyIndex.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_KeyIndex.TupleNotEqual(
            new HTuple())))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_WindowHandles.Dispose();
          HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKeysNew.TupleSelect(
              hv_Index), out hv_WindowHandles);
          }
          for (hv_WindowIndex=0; (int)hv_WindowIndex<=(int)((new HTuple(hv_WindowHandles.TupleLength()
              ))-1); hv_WindowIndex = (int)hv_WindowIndex + 1)
          {
            //Display content of window handle.
            if ((int)(new HTuple((new HTuple(hv_WindowHandleKeys.TupleLength())).TupleEqual(
                new HTuple(hv_WindowHandleKeysNew.TupleLength())))) != 0)
            {
              //Reset values of windows that have been changed temporarily.
              if ((int)(new HTuple(((hv_FlushValues.TupleSelect(hv_WindowIndex))).TupleEqual(
                  "true"))) != 0)
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.FlushBuffer(hv_WindowHandles.TupleSelect(hv_WindowIndex));
                }
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex), 
                  "flush", hv_FlushValues.TupleSelect(hv_WindowIndex));
              }
            }
            else
            {
              //Per default, 'flush' of new windows should be set to 'true'.
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.FlushBuffer(hv_WindowHandles.TupleSelect(hv_WindowIndex));
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex), 
                  "flush", "true");
              }
            }
          }
        }
      }
      //
      ho_Image.Dispose();
      ho_AnomalyImage.Dispose();
      ho_AnomalyRegion.Dispose();
      ho_PredictionColorFrame.Dispose();
      ho_ImageHeatmap.Dispose();
      ho_ImageWeight.Dispose();
      ho_ImageConfidence.Dispose();
      ho_SegmentationImagGroundTruth.Dispose();
      ho_SegmentationImageResult.Dispose();
      ho_ImageAbsDiff.Dispose();
      ho_DiffRegion.Dispose();

      hv_ThresholdWidth.Dispose();
      hv_ScaleWindows.Dispose();
      hv_Font.Dispose();
      hv_FontSize.Dispose();
      hv_LineWidth.Dispose();
      hv_MapTransparency.Dispose();
      hv_MapColorBarWidth.Dispose();
      hv_AnomalyRegionThreshold.Dispose();
      hv_AnomalyClassificationThreshold.Dispose();
      hv_AnomalyRegionLabelColor.Dispose();
      hv_AnomalyColorTransparency.Dispose();
      hv_AnomalyRegionResultColor.Dispose();
      hv_SegMaxWeight.Dispose();
      hv_SegDraw.Dispose();
      hv_SegTransparency.Dispose();
      hv_SegExcludeClassIDs.Dispose();
      hv_BboxLabelColor.Dispose();
      hv_BboxDisplayConfidence.Dispose();
      hv_BboxTextColor.Dispose();
      hv_ShowBottomDesc.Dispose();
      hv_ShowLegend.Dispose();
      hv_ShowGroundTruthAnomalyRegions.Dispose();
      hv_ShowClassificationIDs.Dispose();
      hv_ShowClassificationColorFrame.Dispose();
      hv_ShowLabels.Dispose();
      hv_ShowDirection.Dispose();
      hv_HeatmapColorScheme.Dispose();
      hv_GenParamNames.Dispose();
      hv_ParamIndex.Dispose();
      hv_GenParamName.Dispose();
      hv_GenParamValue.Dispose();
      hv_SampleKeys.Dispose();
      hv_ResultKeys.Dispose();
      hv_ImageIDExists.Dispose();
      hv_ImageID.Dispose();
      hv_ImageIDString.Dispose();
      hv_ImageIDStringBraces.Dispose();
      hv_ImageIDStringCapital.Dispose();
      hv_NeededKeys.Dispose();
      hv_Index.Dispose();
      hv_DLDatasetInfoKeys.Dispose();
      hv_ClassNames.Dispose();
      hv_ClassIDs.Dispose();
      hv_Colors.Dispose();
      hv_ClassesLegend.Dispose();
      hv_PrevWindowCoordinates.Dispose();
      hv_Keys.Dispose();
      hv_Exception.Dispose();
      hv_MetaInfoIndex.Dispose();
      hv_MetaInfo.Dispose();
      hv_FlushValues.Dispose();
      hv_WindowHandleKeys.Dispose();
      hv_KeyIndex.Dispose();
      hv_WindowHandles.Dispose();
      hv_WindowIndex.Dispose();
      hv_FlushValue.Dispose();
      hv_WidthImage.Dispose();
      hv_HeightImage.Dispose();
      hv_CurrentWindowHandle.Dispose();
      hv_WindowImageRatio.Dispose();
      hv_AnomalyLabelGroundTruth.Dispose();
      hv_AnomalyLabelIDGroundTruth.Dispose();
      hv_AnomalyRegionExists.Dispose();
      hv_Text.Dispose();
      hv_AnomalyScore.Dispose();
      hv_AnomalyClassID.Dispose();
      hv_AnomalyRegionGroundTruthExists.Dispose();
      hv_PredictionColor.Dispose();
      hv_LineColors.Dispose();
      hv_ClassificationLabelIDGroundTruth.Dispose();
      hv_ClassificationLabelIDResult.Dispose();
      hv_MarginBottom.Dispose();
      hv_WindowCoordinates.Dispose();
      hv_CurrentWindowHeight.Dispose();
      hv__.Dispose();
      hv_MaxHeight.Dispose();
      hv_PredictionText.Dispose();
      hv_BoarderOffset.Dispose();
      hv_WindowImageRatioHeight.Dispose();
      hv_WindowImageRatioWidth.Dispose();
      hv_BoarderOffsetRow.Dispose();
      hv_BoarderOffsetCol.Dispose();
      hv_SelectedHeatmapMethod.Dispose();
      hv_DictHeatmap.Dispose();
      hv_MethodName.Dispose();
      hv_HeatmapKeys.Dispose();
      hv_HeatmapImageName.Dispose();
      hv_TargetClassID.Dispose();
      hv_Confidences.Dispose();
      hv_MaxDeviation.Dispose();
      hv_ClassificationLabelNameResult.Dispose();
      hv_TargetClassConfidence.Dispose();
      hv_ClassificationLabelNamesGroundTruth.Dispose();
      hv_BboxIDs.Dispose();
      hv_BboxColors.Dispose();
      hv_BboxIDsUniq.Dispose();
      hv_BboxConfidences.Dispose();
      hv_TextConf.Dispose();
      hv_BboxClassIndex.Dispose();
      hv_BboxColorsResults.Dispose();
      hv_BboxClassIndexUniq.Dispose();
      hv_BboxLabelIndex.Dispose();
      hv_BboxColorsBoth.Dispose();
      hv_BboxClassLabelIndexUniq.Dispose();
      hv_ColorsSegmentation.Dispose();
      hv_DrawMode.Dispose();
      hv_Width.Dispose();
      hv_ImageClassIDs.Dispose();
      hv_ImageClassIDsUniq.Dispose();
      hv_ColorsResults.Dispose();
      hv_GroundTruthIDs.Dispose();
      hv_ResultIDs.Dispose();
      hv_StringSegExcludeClassIDs.Dispose();
      hv_StringIndex.Dispose();
      hv_Min.Dispose();
      hv_Max.Dispose();
      hv_Range.Dispose();
      hv_MinWeight.Dispose();
      hv_WeightsColors.Dispose();
      hv_ConfidenceColors.Dispose();
      hv_Indices.Dispose();
      hv_WindowHandleKeysNew.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Image.Dispose();
      ho_AnomalyImage.Dispose();
      ho_AnomalyRegion.Dispose();
      ho_PredictionColorFrame.Dispose();
      ho_ImageHeatmap.Dispose();
      ho_ImageWeight.Dispose();
      ho_ImageConfidence.Dispose();
      ho_SegmentationImagGroundTruth.Dispose();
      ho_SegmentationImageResult.Dispose();
      ho_ImageAbsDiff.Dispose();
      ho_DiffRegion.Dispose();

      hv_ThresholdWidth.Dispose();
      hv_ScaleWindows.Dispose();
      hv_Font.Dispose();
      hv_FontSize.Dispose();
      hv_LineWidth.Dispose();
      hv_MapTransparency.Dispose();
      hv_MapColorBarWidth.Dispose();
      hv_AnomalyRegionThreshold.Dispose();
      hv_AnomalyClassificationThreshold.Dispose();
      hv_AnomalyRegionLabelColor.Dispose();
      hv_AnomalyColorTransparency.Dispose();
      hv_AnomalyRegionResultColor.Dispose();
      hv_SegMaxWeight.Dispose();
      hv_SegDraw.Dispose();
      hv_SegTransparency.Dispose();
      hv_SegExcludeClassIDs.Dispose();
      hv_BboxLabelColor.Dispose();
      hv_BboxDisplayConfidence.Dispose();
      hv_BboxTextColor.Dispose();
      hv_ShowBottomDesc.Dispose();
      hv_ShowLegend.Dispose();
      hv_ShowGroundTruthAnomalyRegions.Dispose();
      hv_ShowClassificationIDs.Dispose();
      hv_ShowClassificationColorFrame.Dispose();
      hv_ShowLabels.Dispose();
      hv_ShowDirection.Dispose();
      hv_HeatmapColorScheme.Dispose();
      hv_GenParamNames.Dispose();
      hv_ParamIndex.Dispose();
      hv_GenParamName.Dispose();
      hv_GenParamValue.Dispose();
      hv_SampleKeys.Dispose();
      hv_ResultKeys.Dispose();
      hv_ImageIDExists.Dispose();
      hv_ImageID.Dispose();
      hv_ImageIDString.Dispose();
      hv_ImageIDStringBraces.Dispose();
      hv_ImageIDStringCapital.Dispose();
      hv_NeededKeys.Dispose();
      hv_Index.Dispose();
      hv_DLDatasetInfoKeys.Dispose();
      hv_ClassNames.Dispose();
      hv_ClassIDs.Dispose();
      hv_Colors.Dispose();
      hv_ClassesLegend.Dispose();
      hv_PrevWindowCoordinates.Dispose();
      hv_Keys.Dispose();
      hv_Exception.Dispose();
      hv_MetaInfoIndex.Dispose();
      hv_MetaInfo.Dispose();
      hv_FlushValues.Dispose();
      hv_WindowHandleKeys.Dispose();
      hv_KeyIndex.Dispose();
      hv_WindowHandles.Dispose();
      hv_WindowIndex.Dispose();
      hv_FlushValue.Dispose();
      hv_WidthImage.Dispose();
      hv_HeightImage.Dispose();
      hv_CurrentWindowHandle.Dispose();
      hv_WindowImageRatio.Dispose();
      hv_AnomalyLabelGroundTruth.Dispose();
      hv_AnomalyLabelIDGroundTruth.Dispose();
      hv_AnomalyRegionExists.Dispose();
      hv_Text.Dispose();
      hv_AnomalyScore.Dispose();
      hv_AnomalyClassID.Dispose();
      hv_AnomalyRegionGroundTruthExists.Dispose();
      hv_PredictionColor.Dispose();
      hv_LineColors.Dispose();
      hv_ClassificationLabelIDGroundTruth.Dispose();
      hv_ClassificationLabelIDResult.Dispose();
      hv_MarginBottom.Dispose();
      hv_WindowCoordinates.Dispose();
      hv_CurrentWindowHeight.Dispose();
      hv__.Dispose();
      hv_MaxHeight.Dispose();
      hv_PredictionText.Dispose();
      hv_BoarderOffset.Dispose();
      hv_WindowImageRatioHeight.Dispose();
      hv_WindowImageRatioWidth.Dispose();
      hv_BoarderOffsetRow.Dispose();
      hv_BoarderOffsetCol.Dispose();
      hv_SelectedHeatmapMethod.Dispose();
      hv_DictHeatmap.Dispose();
      hv_MethodName.Dispose();
      hv_HeatmapKeys.Dispose();
      hv_HeatmapImageName.Dispose();
      hv_TargetClassID.Dispose();
      hv_Confidences.Dispose();
      hv_MaxDeviation.Dispose();
      hv_ClassificationLabelNameResult.Dispose();
      hv_TargetClassConfidence.Dispose();
      hv_ClassificationLabelNamesGroundTruth.Dispose();
      hv_BboxIDs.Dispose();
      hv_BboxColors.Dispose();
      hv_BboxIDsUniq.Dispose();
      hv_BboxConfidences.Dispose();
      hv_TextConf.Dispose();
      hv_BboxClassIndex.Dispose();
      hv_BboxColorsResults.Dispose();
      hv_BboxClassIndexUniq.Dispose();
      hv_BboxLabelIndex.Dispose();
      hv_BboxColorsBoth.Dispose();
      hv_BboxClassLabelIndexUniq.Dispose();
      hv_ColorsSegmentation.Dispose();
      hv_DrawMode.Dispose();
      hv_Width.Dispose();
      hv_ImageClassIDs.Dispose();
      hv_ImageClassIDsUniq.Dispose();
      hv_ColorsResults.Dispose();
      hv_GroundTruthIDs.Dispose();
      hv_ResultIDs.Dispose();
      hv_StringSegExcludeClassIDs.Dispose();
      hv_StringIndex.Dispose();
      hv_Min.Dispose();
      hv_Max.Dispose();
      hv_Range.Dispose();
      hv_MinWeight.Dispose();
      hv_WeightsColors.Dispose();
      hv_ConfidenceColors.Dispose();
      hv_Indices.Dispose();
      hv_WindowHandleKeysNew.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Anomaly Detection
  // Short Description: Display the ground truth anomaly regions of the given DLSample. 
  public void dev_display_ground_truth_anomaly_regions (HTuple hv_SampleKeys, HTuple hv_DLSample, 
      HTuple hv_CurrentWindowHandle, HTuple hv_LineWidth, HTuple hv_AnomalyRegionLabelColor, 
      HTuple hv_AnomalyColorTransparency, out HTuple hv_AnomalyRegionExists)
  {



    // Local iconic variables 

    HObject ho_AnomalyImage=null, ho_AnomalyRegion=null;

    // Local control variables 

    HTuple hv_Red = new HTuple(), hv_Green = new HTuple();
    HTuple hv_Blue = new HTuple(), hv_Alpha = new HTuple();
    HTuple hv_InitialColor = new HTuple(), hv_IndexColor = new HTuple();
    HTuple hv_Color_RGBA = new HTuple(), hv_Area = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_AnomalyImage);
    HOperatorSet.GenEmptyObj(out ho_AnomalyRegion);
    hv_AnomalyRegionExists = new HTuple();
    try
    {
      //
      //This procedure visualizes the ground truth anomalies
      //if there is an anomaly_ground_truth in DLSample.
      //
      //Get current set color.
      hv_Red.Dispose();hv_Green.Dispose();hv_Blue.Dispose();hv_Alpha.Dispose();
      HOperatorSet.GetRgba(hv_CurrentWindowHandle, out hv_Red, out hv_Green, out hv_Blue, 
          out hv_Alpha);
      hv_InitialColor.Dispose();
      hv_InitialColor = new HTuple();
      for (hv_IndexColor=0; (int)hv_IndexColor<=(int)((new HTuple(hv_Red.TupleLength()
          ))-1); hv_IndexColor = (int)hv_IndexColor + 1)
      {
        hv_Color_RGBA.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Color_RGBA = ((("#"+(((hv_Red.TupleSelect(
            hv_IndexColor))).TupleString("2x")))+(((hv_Green.TupleSelect(hv_IndexColor))).TupleString(
            "2x")))+(((hv_Blue.TupleSelect(hv_IndexColor))).TupleString("2x")))+(((hv_Alpha.TupleSelect(
            hv_IndexColor))).TupleString("2x"));
        }
        {
        HTuple ExpTmpOutVar_0;
        HOperatorSet.TupleRegexpReplace(hv_Color_RGBA, (new HTuple(" ")).TupleConcat(
            "replace_all"), "0", out ExpTmpOutVar_0);
        hv_Color_RGBA.Dispose();
        hv_Color_RGBA = ExpTmpOutVar_0;
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_InitialColor = hv_InitialColor.TupleConcat(
            hv_Color_RGBA);
        hv_InitialColor.Dispose();
        hv_InitialColor = ExpTmpLocalVar_InitialColor;
        }
        }
      }
      //
      if ((int)(new HTuple(((hv_SampleKeys.TupleFind("anomaly_ground_truth"))).TupleNotEqual(
          -1))) != 0)
      {
        ho_AnomalyImage.Dispose();
        HOperatorSet.GetDictObject(out ho_AnomalyImage, hv_DLSample, "anomaly_ground_truth");
        ho_AnomalyRegion.Dispose();
        HOperatorSet.Threshold(ho_AnomalyImage, out ho_AnomalyRegion, 1, 255);
        //Get non-empty regions.
        hv_Area.Dispose();
        HOperatorSet.RegionFeatures(ho_AnomalyRegion, "area", out hv_Area);
        if ((int)(new HTuple(hv_Area.TupleGreater(0))) != 0)
        {
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_AnomalyRegionLabelColor+hv_AnomalyColorTransparency);
            }
          }
          //Display the anomaly region.
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_AnomalyRegion, HDevWindowStack.GetActive());
          }
        }
        hv_AnomalyRegionExists.Dispose();
        hv_AnomalyRegionExists = "true";
      }
      else
      {
        hv_AnomalyRegionExists.Dispose();
        hv_AnomalyRegionExists = "false";
      }
      //
      //Reset colors.
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_InitialColor);
      }
      //
      ho_AnomalyImage.Dispose();
      ho_AnomalyRegion.Dispose();

      hv_Red.Dispose();
      hv_Green.Dispose();
      hv_Blue.Dispose();
      hv_Alpha.Dispose();
      hv_InitialColor.Dispose();
      hv_IndexColor.Dispose();
      hv_Color_RGBA.Dispose();
      hv_Area.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_AnomalyImage.Dispose();
      ho_AnomalyRegion.Dispose();

      hv_Red.Dispose();
      hv_Green.Dispose();
      hv_Blue.Dispose();
      hv_Alpha.Dispose();
      hv_InitialColor.Dispose();
      hv_IndexColor.Dispose();
      hv_Color_RGBA.Dispose();
      hv_Area.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Graphics / Output
  // Short Description: Display the ground truth bounding boxes of DLSample. 
  public void dev_display_ground_truth_detection (HTuple hv_DLSample, HTuple hv_SampleKeys, 
      HTuple hv_LineWidthBbox, HTuple hv_ClassIDs, HTuple hv_BboxColors, HTuple hv_BboxLabelColor, 
      HTuple hv_TextColor, HTuple hv_ShowLabels, HTuple hv_ShowDirection, HTuple hv_WindowHandle, 
      out HTuple hv_BboxIDs)
  {



    // Local iconic variables 

    HObject ho_BboxRectangle=null, ho_OrientationArrows=null;
    HObject ho_RectangleSelected=null, ho_ArrowSelected=null;

    // Local control variables 

    HTuple hv_InstanceType = new HTuple(), hv_BboxRow1 = new HTuple();
    HTuple hv_BboxCol1 = new HTuple(), hv_BboxRow2 = new HTuple();
    HTuple hv_BboxCol2 = new HTuple(), hv_BboxLabels = new HTuple();
    HTuple hv_BboxRow = new HTuple(), hv_BboxCol = new HTuple();
    HTuple hv_BboxLength1 = new HTuple(), hv_BboxLength2 = new HTuple();
    HTuple hv_BboxPhi = new HTuple(), hv_LabelRow = new HTuple();
    HTuple hv_LabelCol = new HTuple(), hv_HeadSize = new HTuple();
    HTuple hv_BboxClassIDs = new HTuple(), hv_ContourStyle = new HTuple();
    HTuple hv_IndexBbox = new HTuple(), hv_ClassID = new HTuple();
    HTuple hv_TxtColor = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_BboxRectangle);
    HOperatorSet.GenEmptyObj(out ho_OrientationArrows);
    HOperatorSet.GenEmptyObj(out ho_RectangleSelected);
    HOperatorSet.GenEmptyObj(out ho_ArrowSelected);
    hv_BboxIDs = new HTuple();
    try
    {
      //
      //This procedure displays the ground truth bounding boxes of DLSample.
      //
      hv_InstanceType.Dispose();
      hv_InstanceType = "rectangle1";
      if ((int)(new HTuple(((hv_SampleKeys.TupleFind("bbox_row1"))).TupleNotEqual(
          -1))) != 0)
      {
        hv_BboxRow1.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row1", out hv_BboxRow1);
        hv_BboxCol1.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col1", out hv_BboxCol1);
        hv_BboxRow2.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row2", out hv_BboxRow2);
        hv_BboxCol2.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col2", out hv_BboxCol2);
        hv_BboxLabels.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_label_id", out hv_BboxLabels);
      }
      else if ((int)(new HTuple(((hv_SampleKeys.TupleFind("bbox_phi"))).TupleNotEqual(
          -1))) != 0)
      {
        hv_BboxRow.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row", out hv_BboxRow);
        hv_BboxCol.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col", out hv_BboxCol);
        hv_BboxLength1.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_length1", out hv_BboxLength1);
        hv_BboxLength2.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_length2", out hv_BboxLength2);
        hv_BboxPhi.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_phi", out hv_BboxPhi);
        hv_BboxLabels.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_label_id", out hv_BboxLabels);
        hv_InstanceType.Dispose();
        hv_InstanceType = "rectangle2";
      }
      else
      {
        throw new HalconException("Ground truth bounding box data could not be found in DLSample.");
      }
      if ((int)(new HTuple((new HTuple(hv_BboxLabels.TupleLength())).TupleGreater(
          0))) != 0)
      {
        //Generate bounding box XLDs.
        if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_BboxPhi.Dispose();
          HOperatorSet.TupleGenConst(new HTuple(hv_BboxRow1.TupleLength()), 0.0, 
              out hv_BboxPhi);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_BboxRectangle.Dispose();
          HOperatorSet.GenRectangle2ContourXld(out ho_BboxRectangle, 0.5*(hv_BboxRow1+hv_BboxRow2), 
              0.5*(hv_BboxCol1+hv_BboxCol2), hv_BboxPhi, 0.5*(hv_BboxCol2-hv_BboxCol1), 
              0.5*(hv_BboxRow2-hv_BboxRow1));
          }
          hv_LabelRow.Dispose();
          hv_LabelRow = new HTuple(hv_BboxRow1);
          hv_LabelCol.Dispose();
          hv_LabelCol = new HTuple(hv_BboxCol1);
        }
        else
        {
          ho_BboxRectangle.Dispose();
          HOperatorSet.GenRectangle2ContourXld(out ho_BboxRectangle, hv_BboxRow, 
              hv_BboxCol, hv_BboxPhi, hv_BboxLength1, hv_BboxLength2);
          hv_LabelRow.Dispose();
          hv_LabelRow = new HTuple(hv_BboxRow);
          hv_LabelCol.Dispose();
          hv_LabelCol = new HTuple(hv_BboxCol);
          if ((int)(hv_ShowDirection) != 0)
          {
            hv_HeadSize.Dispose();
            hv_HeadSize = 20.0;
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_OrientationArrows.Dispose();
            gen_arrow_contour_xld(out ho_OrientationArrows, hv_BboxRow, hv_BboxCol, 
                hv_BboxRow-((hv_BboxLength1+hv_HeadSize)*(hv_BboxPhi.TupleSin())), 
                hv_BboxCol+((hv_BboxLength1+hv_HeadSize)*(hv_BboxPhi.TupleCos())), 
                hv_HeadSize, hv_HeadSize);
            }
          }
        }
        //
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidthBbox);
        }
        //
        //Collect the ClassIDs of the bounding boxes.
        hv_BboxIDs.Dispose();
        hv_BboxIDs = new HTuple();
        hv_BboxClassIDs.Dispose();
        hv_BboxClassIDs = new HTuple();
        //
        //Draw the bounding boxes.
        hv_ContourStyle.Dispose();
        HOperatorSet.GetContourStyle(hv_WindowHandle, out hv_ContourStyle);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetContourStyle(HDevWindowStack.GetActive(), "stroke_and_fill");
        }
        for (hv_IndexBbox=0; (int)hv_IndexBbox<=(int)((new HTuple(hv_BboxLabels.TupleLength()
            ))-1); hv_IndexBbox = (int)hv_IndexBbox + 1)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_RectangleSelected.Dispose();
          HOperatorSet.SelectObj(ho_BboxRectangle, out ho_RectangleSelected, hv_IndexBbox+1);
          }
          hv_ClassID.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ClassID = hv_ClassIDs.TupleFind(
              hv_BboxLabels.TupleSelect(hv_IndexBbox));
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_BboxClassIDs = hv_BboxClassIDs.TupleConcat(
              hv_ClassID);
          hv_BboxClassIDs.Dispose();
          hv_BboxClassIDs = ExpTmpLocalVar_BboxClassIDs;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_BboxIDs = hv_BboxIDs.TupleConcat(
              hv_ClassID);
          hv_BboxIDs.Dispose();
          hv_BboxIDs = ExpTmpLocalVar_BboxIDs;
          }
          }
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetColor(HDevWindowStack.GetActive(), (hv_BboxColors.TupleSelect(
                hv_ClassID))+"60");
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_RectangleSelected, HDevWindowStack.GetActive()
                );
          }
          if ((int)((new HTuple(hv_InstanceType.TupleEqual("rectangle2"))).TupleAnd(
              hv_ShowDirection)) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_ArrowSelected.Dispose();
            HOperatorSet.SelectObj(ho_OrientationArrows, out ho_ArrowSelected, hv_IndexBbox+1);
            }
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetColor(HDevWindowStack.GetActive(), (hv_BboxColors.TupleSelect(
                  hv_ClassID))+"FF");
              }
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_ArrowSelected, HDevWindowStack.GetActive());
            }
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetColor(HDevWindowStack.GetActive(), (hv_BboxColors.TupleSelect(
                  hv_ClassID))+"60");
              }
            }
          }
        }
        //
        //Write text to the bounding boxes.
        if ((int)(hv_ShowLabels) != 0)
        {
          //For better visibility the text is displayed after all bounding boxes are drawn.
          for (hv_IndexBbox=0; (int)hv_IndexBbox<=(int)((new HTuple(hv_BboxLabels.TupleLength()
              ))-1); hv_IndexBbox = (int)hv_IndexBbox + 1)
          {
            hv_ClassID.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ClassID = hv_BboxClassIDs.TupleSelect(
                hv_IndexBbox);
            }
            if ((int)(new HTuple(hv_TextColor.TupleEqual(""))) != 0)
            {
              hv_TxtColor.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_TxtColor = hv_BboxColors.TupleSelect(
                  hv_ClassID);
              }
            }
            else
            {
              hv_TxtColor.Dispose();
              hv_TxtColor = new HTuple(hv_TextColor);
            }
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_BboxLabels.TupleSelect(
                  hv_IndexBbox), "image", hv_LabelRow.TupleSelect(hv_IndexBbox), 
                  hv_LabelCol.TupleSelect(hv_IndexBbox), hv_TextColor, ((new HTuple("box_color")).TupleConcat(
                  "shadow")).TupleConcat("border_radius"), hv_BboxLabelColor.TupleConcat(
                  (new HTuple("false")).TupleConcat(0)));
              }
            }
          }
        }
        //
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetContourStyle(HDevWindowStack.GetActive(), hv_ContourStyle);
        }
      }
      else
      {
        //Do nothing if there are no ground truth bounding boxes.
        hv_BboxIDs.Dispose();
        hv_BboxIDs = new HTuple();
      }
      //
      ho_BboxRectangle.Dispose();
      ho_OrientationArrows.Dispose();
      ho_RectangleSelected.Dispose();
      ho_ArrowSelected.Dispose();

      hv_InstanceType.Dispose();
      hv_BboxRow1.Dispose();
      hv_BboxCol1.Dispose();
      hv_BboxRow2.Dispose();
      hv_BboxCol2.Dispose();
      hv_BboxLabels.Dispose();
      hv_BboxRow.Dispose();
      hv_BboxCol.Dispose();
      hv_BboxLength1.Dispose();
      hv_BboxLength2.Dispose();
      hv_BboxPhi.Dispose();
      hv_LabelRow.Dispose();
      hv_LabelCol.Dispose();
      hv_HeadSize.Dispose();
      hv_BboxClassIDs.Dispose();
      hv_ContourStyle.Dispose();
      hv_IndexBbox.Dispose();
      hv_ClassID.Dispose();
      hv_TxtColor.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_BboxRectangle.Dispose();
      ho_OrientationArrows.Dispose();
      ho_RectangleSelected.Dispose();
      ho_ArrowSelected.Dispose();

      hv_InstanceType.Dispose();
      hv_BboxRow1.Dispose();
      hv_BboxCol1.Dispose();
      hv_BboxRow2.Dispose();
      hv_BboxCol2.Dispose();
      hv_BboxLabels.Dispose();
      hv_BboxRow.Dispose();
      hv_BboxCol.Dispose();
      hv_BboxLength1.Dispose();
      hv_BboxLength2.Dispose();
      hv_BboxPhi.Dispose();
      hv_LabelRow.Dispose();
      hv_LabelCol.Dispose();
      hv_HeadSize.Dispose();
      hv_BboxClassIDs.Dispose();
      hv_ContourStyle.Dispose();
      hv_IndexBbox.Dispose();
      hv_ClassID.Dispose();
      hv_TxtColor.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Graphics / Output
  // Short Description: Display a color bar next to an image. 
  public void dev_display_map_color_bar (HTuple hv_ImageWidth, HTuple hv_ImageHeight, 
      HTuple hv_MapColorBarWidth, HTuple hv_Colors, HTuple hv_MaxValue, HTuple hv_WindowImageRatio, 
      HTuple hv_WindowHandle)
  {



    // Local iconic variables 

    HObject ho_Rectangle=null;

    // Local control variables 

    HTuple hv_ClipRegion = new HTuple(), hv_ColorIndex = new HTuple();
    HTuple hv_RectHeight = new HTuple(), hv_DrawMode = new HTuple();
    HTuple hv_Row = new HTuple(), hv_Row1 = new HTuple(), hv_Column1 = new HTuple();
    HTuple hv_Row2 = new HTuple(), hv_Column2 = new HTuple();
    HTuple hv__ = new HTuple(), hv_TextHeight = new HTuple();
    HTuple hv_Index = new HTuple(), hv_Text = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Rectangle);
    try
    {
      //
      //This procedure displays a color bar next to the image
      //specified with ImageWidth and ImageHeight.
      //
      hv_ClipRegion.Dispose();
      HOperatorSet.GetSystem("clip_region", out hv_ClipRegion);
      HOperatorSet.SetSystem("clip_region", "false");
      //
      //Display the color bar.
      hv_ColorIndex.Dispose();
      hv_ColorIndex = 0;
      hv_RectHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_RectHeight = (1.0*hv_ImageHeight)/(new HTuple(hv_Colors.TupleLength()
          ));
      }
      //Set draw mode to fill
      hv_DrawMode.Dispose();
      HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
      }
      HTuple end_val13 = 0;
      HTuple step_val13 = -hv_RectHeight;
      for (hv_Row=hv_ImageHeight-1; hv_Row.Continue(end_val13, step_val13); hv_Row = hv_Row.TupleAdd(step_val13))
      {
        //The color bar consists of multiple rectangle1.
        hv_Row1.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Row1 = hv_Row-hv_RectHeight;
        }
        hv_Column1.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Column1 = hv_ImageWidth+(20/hv_WindowImageRatio);
        }
        hv_Row2.Dispose();
        hv_Row2 = new HTuple(hv_Row);
        hv_Column2.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Column2 = (hv_ImageWidth+20)+(hv_MapColorBarWidth/hv_WindowImageRatio);
        }
        ho_Rectangle.Dispose();
        HOperatorSet.GenRectangle1(out ho_Rectangle, hv_Row1, hv_Column1, hv_Row2, 
            hv_Column2);
        if (HDevWindowStack.IsOpen())
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Colors.TupleSelect(
              hv_ColorIndex));
          }
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_Rectangle, HDevWindowStack.GetActive());
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ColorIndex = hv_ColorIndex+1;
        hv_ColorIndex.Dispose();
        hv_ColorIndex = ExpTmpLocalVar_ColorIndex;
        }
        }
      }
      //
      //Display labels for color bar.
      hv__.Dispose();hv__.Dispose();hv__.Dispose();hv_TextHeight.Dispose();
      HOperatorSet.GetStringExtents(hv_WindowHandle, "0123456789", out hv__, out hv__, 
          out hv__, out hv_TextHeight);
      for (hv_Index=(double)(0); (double)hv_Index<=1; hv_Index = (double)hv_Index + 0.2)
      {
        hv_Text.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Text = ((hv_MaxValue-(hv_Index*hv_MaxValue))).TupleString(
            ".1f");
        }
        if (HDevWindowStack.IsOpen())
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "image", hv_Index*(hv_ImageHeight-(2*(hv_TextHeight/hv_WindowImageRatio))), 
              hv_ImageWidth+(40/hv_WindowImageRatio), "black", "box", "false");
          }
        }
      }
      //
      HOperatorSet.SetSystem("clip_region", hv_ClipRegion);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
      }
      ho_Rectangle.Dispose();

      hv_ClipRegion.Dispose();
      hv_ColorIndex.Dispose();
      hv_RectHeight.Dispose();
      hv_DrawMode.Dispose();
      hv_Row.Dispose();
      hv_Row1.Dispose();
      hv_Column1.Dispose();
      hv_Row2.Dispose();
      hv_Column2.Dispose();
      hv__.Dispose();
      hv_TextHeight.Dispose();
      hv_Index.Dispose();
      hv_Text.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Rectangle.Dispose();

      hv_ClipRegion.Dispose();
      hv_ColorIndex.Dispose();
      hv_RectHeight.Dispose();
      hv_DrawMode.Dispose();
      hv_Row.Dispose();
      hv_Row1.Dispose();
      hv_Column1.Dispose();
      hv_Row2.Dispose();
      hv_Column2.Dispose();
      hv__.Dispose();
      hv_TextHeight.Dispose();
      hv_Index.Dispose();
      hv_Text.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Graphics / Output
  // Short Description: This procedure draws a pie chart into the active window handle. 
  public void dev_display_pie_chart (HTuple hv_WindowHandle, HTuple hv_Ratios, HTuple hv_Row, 
      HTuple hv_Column, HTuple hv_Radius, HTuple hv_Colors, HTuple hv_GenParam)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_Sectors, ho_Arc=null, ho_Sector=null;

    // Local control variables 

    HTuple hv_Tolerance = new HTuple(), hv_InitialWindowHandle = new HTuple();
    HTuple hv_NoInitialWindow = new HTuple(), hv_Red = new HTuple();
    HTuple hv_Green = new HTuple(), hv_Blue = new HTuple();
    HTuple hv_Alpha = new HTuple(), hv_InitialColor = new HTuple();
    HTuple hv_IndexColor = new HTuple(), hv_Color_RGBA = new HTuple();
    HTuple hv_Title = new HTuple(), hv_TitleColor = new HTuple();
    HTuple hv_TitleKeyExists = new HTuple(), hv_TitleColorKeyExists = new HTuple();
    HTuple hv_GivenTitle = new HTuple(), hv_GivenTitleColor = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_FullCircleAngle = new HTuple();
    HTuple hv_StartAngle = new HTuple(), hv_DrawColors = new HTuple();
    HTuple hv_K = new HTuple(), hv_EndAngle = new HTuple();
    HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
    HTuple hv_HomMat2DIdentity = new HTuple(), hv_HomMat2DRotate = new HTuple();
    HTuple hv_ContourStyle = new HTuple(), hv_Ascent = new HTuple();
    HTuple hv_Descent = new HTuple(), hv_Width = new HTuple();
    HTuple hv_Height = new HTuple();
    HTuple   hv_Colors_COPY_INP_TMP = new HTuple(hv_Colors);
    HTuple   hv_Ratios_COPY_INP_TMP = new HTuple(hv_Ratios);

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Sectors);
    HOperatorSet.GenEmptyObj(out ho_Arc);
    HOperatorSet.GenEmptyObj(out ho_Sector);
    try
    {
      //
      //Draw a pie-chart into the active window.
      //
      //Check input Ratios.
      if ((int)(new HTuple(((((hv_Ratios_COPY_INP_TMP.TupleLessElem(0.0))).TupleSum()
          )).TupleGreater(0))) != 0)
      {
        throw new HalconException("Values of parameter Ratios must be positive.");
      }
      hv_Tolerance.Dispose();
      hv_Tolerance = 0.1;
      if ((int)(new HTuple(((((1-(hv_Ratios_COPY_INP_TMP.TupleSum()))).TupleAbs()
          )).TupleGreaterEqual(hv_Tolerance))) != 0)
      {
        throw new HalconException("Sum of Ratios differs too much from 1.");
      }
      //
      //Get current window handle.
      if (HDevWindowStack.IsOpen())
      {
        hv_InitialWindowHandle = HDevWindowStack.GetActive();
      }
      //In case there is no open window, no initial values are to be reset.
      hv_NoInitialWindow.Dispose();
      hv_NoInitialWindow = 0;
      if ((int)(new HTuple(hv_InitialWindowHandle.TupleEqual(-1))) != 0)
      {
        hv_NoInitialWindow.Dispose();
        hv_NoInitialWindow = 1;
      }
      else
      {
        //Get current set color.
        hv_Red.Dispose();hv_Green.Dispose();hv_Blue.Dispose();hv_Alpha.Dispose();
        HOperatorSet.GetRgba(hv_InitialWindowHandle, out hv_Red, out hv_Green, out hv_Blue, 
            out hv_Alpha);
        hv_InitialColor.Dispose();
        hv_InitialColor = new HTuple();
        for (hv_IndexColor=0; (int)hv_IndexColor<=(int)((new HTuple(hv_Red.TupleLength()
            ))-1); hv_IndexColor = (int)hv_IndexColor + 1)
        {
          hv_Color_RGBA.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Color_RGBA = ((("#"+(((hv_Red.TupleSelect(
              hv_IndexColor))).TupleString("2x")))+(((hv_Green.TupleSelect(hv_IndexColor))).TupleString(
              "2x")))+(((hv_Blue.TupleSelect(hv_IndexColor))).TupleString("2x")))+(((hv_Alpha.TupleSelect(
              hv_IndexColor))).TupleString("2x"));
          }
          {
          HTuple ExpTmpOutVar_0;
          HOperatorSet.TupleRegexpReplace(hv_Color_RGBA, (new HTuple(" ")).TupleConcat(
              "replace_all"), "0", out ExpTmpOutVar_0);
          hv_Color_RGBA.Dispose();
          hv_Color_RGBA = ExpTmpOutVar_0;
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_InitialColor = hv_InitialColor.TupleConcat(
              hv_Color_RGBA);
          hv_InitialColor.Dispose();
          hv_InitialColor = ExpTmpLocalVar_InitialColor;
          }
          }
        }
      }
      HDevWindowStack.SetActive(hv_WindowHandle);
      //
      //In case no segment colors are specified, generate random colors.
      if ((int)(new HTuple((new HTuple(hv_Colors_COPY_INP_TMP.TupleLength())).TupleEqual(
          0))) != 0)
      {
        //Generate random colors.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Colors_COPY_INP_TMP.Dispose();
        get_distinct_colors_dev_display_pie_chart(new HTuple(hv_Ratios_COPY_INP_TMP.TupleLength()
            ), 1, 0, 220, out hv_Colors_COPY_INP_TMP);
        }
      }
      //
      //Set default parameters.
      hv_Title.Dispose();
      hv_Title = new HTuple();
      hv_TitleColor.Dispose();
      hv_TitleColor = "white";
      //Get generic parameters.
      if ((int)(new HTuple((new HTuple(hv_GenParam.TupleLength())).TupleGreater(0))) != 0)
      {
        hv_TitleKeyExists.Dispose();
        HOperatorSet.GetDictParam(hv_GenParam, "key_exists", "title", out hv_TitleKeyExists);
        hv_TitleColorKeyExists.Dispose();
        HOperatorSet.GetDictParam(hv_GenParam, "key_exists", "title_color", out hv_TitleColorKeyExists);
        //
        //Title text.
        if ((int)(hv_TitleKeyExists) != 0)
        {
          hv_GivenTitle.Dispose();
          HOperatorSet.GetDictTuple(hv_GenParam, "title", out hv_GivenTitle);
          if ((int)((new HTuple(((hv_GivenTitle.TupleIsString())).TupleNot())).TupleOr(
              new HTuple(((hv_GivenTitle.TupleStrlen())).TupleLess(1)))) != 0)
          {
            throw new HalconException("Invalid value for key 'title'");
          }
          hv_Title.Dispose();
          hv_Title = new HTuple(hv_GivenTitle);
        }
        //Title color.
        if ((int)(hv_TitleColorKeyExists) != 0)
        {
          hv_GivenTitleColor.Dispose();
          HOperatorSet.GetDictTuple(hv_GenParam, "title_color", out hv_GivenTitleColor);
          if ((int)(((hv_GivenTitleColor.TupleIsString())).TupleNot()) != 0)
          {
            throw new HalconException("Invalid value for key 'title_color'");
          }
          try
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_GivenTitleColor);
            }
          }
          // catch (Exception) 
          catch (HalconException HDevExpDefaultException1)
          {
            HDevExpDefaultException1.ToHTuple(out hv_Exception);
            throw new HalconException("Invalid value for key 'title_color'");
          }
          hv_TitleColor.Dispose();
          hv_TitleColor = new HTuple(hv_GivenTitleColor);
        }
      }
      hv_FullCircleAngle.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_FullCircleAngle = 2*3.14159;
      }
      hv_StartAngle.Dispose();
      hv_StartAngle = 0;
      //
      //Generate circle-sectors.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Ratios = hv_Ratios_COPY_INP_TMP/(hv_Ratios_COPY_INP_TMP.TupleSum()
          );
      hv_Ratios_COPY_INP_TMP.Dispose();
      hv_Ratios_COPY_INP_TMP = ExpTmpLocalVar_Ratios;
      }
      }
      hv_DrawColors.Dispose();
      hv_DrawColors = new HTuple();
      ho_Sectors.Dispose();
      HOperatorSet.GenEmptyObj(out ho_Sectors);
      for (hv_K=0; (int)hv_K<=(int)((new HTuple(hv_Ratios_COPY_INP_TMP.TupleLength()
          ))-1); hv_K = (int)hv_K + 1)
      {
        if ((int)(new HTuple(((hv_Ratios_COPY_INP_TMP.TupleSelect(hv_K))).TupleGreater(
            0))) != 0)
        {
          hv_EndAngle.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_EndAngle = hv_StartAngle+((hv_Ratios_COPY_INP_TMP.TupleSelect(
              hv_K))*hv_FullCircleAngle);
          }
          ho_Arc.Dispose();
          HOperatorSet.GenCircleContourXld(out ho_Arc, hv_Row, hv_Column, hv_Radius, 
              hv_StartAngle, hv_EndAngle, "positive", 1);
          hv_Rows.Dispose();hv_Columns.Dispose();
          HOperatorSet.GetContourXld(ho_Arc, out hv_Rows, out hv_Columns);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_Sector.Dispose();
          HOperatorSet.GenContourPolygonXld(out ho_Sector, ((hv_Row.TupleConcat(hv_Rows))).TupleConcat(
              hv_Row), ((hv_Column.TupleConcat(hv_Columns))).TupleConcat(hv_Column));
          }
          hv_StartAngle.Dispose();
          hv_StartAngle = new HTuple(hv_EndAngle);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_DrawColors = hv_DrawColors.TupleConcat(
              hv_Colors_COPY_INP_TMP.TupleSelect(hv_K));
          hv_DrawColors.Dispose();
          hv_DrawColors = ExpTmpLocalVar_DrawColors;
          }
          }
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.ConcatObj(ho_Sectors, ho_Sector, out ExpTmpOutVar_0);
          ho_Sectors.Dispose();
          ho_Sectors = ExpTmpOutVar_0;
          }
        }
      }
      //Rotate 90 degrees such that the first sector starts at the top.
      hv_HomMat2DIdentity.Dispose();
      HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_HomMat2DRotate.Dispose();
      HOperatorSet.HomMat2dRotate(hv_HomMat2DIdentity, 0.25*hv_FullCircleAngle, hv_Row, 
          hv_Column, out hv_HomMat2DRotate);
      }
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.AffineTransContourXld(ho_Sectors, out ExpTmpOutVar_0, hv_HomMat2DRotate);
      ho_Sectors.Dispose();
      ho_Sectors = ExpTmpOutVar_0;
      }
      //
      //Display sectors.
      HDevWindowStack.SetActive(hv_WindowHandle);
      hv_ContourStyle.Dispose();
      HOperatorSet.GetContourStyle(hv_WindowHandle, out hv_ContourStyle);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetContourStyle(HDevWindowStack.GetActive(), "stroke_and_fill");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_DrawColors);
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_Sectors, HDevWindowStack.GetActive());
      }
      //(Optional) title.
      if ((int)(new HTuple(hv_Title.TupleNotEqual(new HTuple()))) != 0)
      {
        hv_Ascent.Dispose();hv_Descent.Dispose();hv_Width.Dispose();hv_Height.Dispose();
        HOperatorSet.GetStringExtents(hv_WindowHandle, hv_Title, out hv_Ascent, out hv_Descent, 
            out hv_Width, out hv_Height);
        if (HDevWindowStack.IsOpen())
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Title, "image", (((hv_Row-hv_Radius)-hv_Height)-hv_Ascent)-hv_Descent, 
              hv_Column-(hv_Width/2), hv_TitleColor, "box", "false");
          }
        }
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetContourStyle(HDevWindowStack.GetActive(), hv_ContourStyle);
      }
      //
      //Reset original window and colors (and close the window in case there was none open).
      if ((int)(hv_NoInitialWindow) != 0)
      {
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.CloseWindow(HDevWindowStack.Pop());
        }
      }
      else
      {
        HDevWindowStack.SetActive(hv_InitialWindowHandle);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_InitialColor);
        }
      }
      ho_Sectors.Dispose();
      ho_Arc.Dispose();
      ho_Sector.Dispose();

      hv_Colors_COPY_INP_TMP.Dispose();
      hv_Ratios_COPY_INP_TMP.Dispose();
      hv_Tolerance.Dispose();
      hv_InitialWindowHandle.Dispose();
      hv_NoInitialWindow.Dispose();
      hv_Red.Dispose();
      hv_Green.Dispose();
      hv_Blue.Dispose();
      hv_Alpha.Dispose();
      hv_InitialColor.Dispose();
      hv_IndexColor.Dispose();
      hv_Color_RGBA.Dispose();
      hv_Title.Dispose();
      hv_TitleColor.Dispose();
      hv_TitleKeyExists.Dispose();
      hv_TitleColorKeyExists.Dispose();
      hv_GivenTitle.Dispose();
      hv_GivenTitleColor.Dispose();
      hv_Exception.Dispose();
      hv_FullCircleAngle.Dispose();
      hv_StartAngle.Dispose();
      hv_DrawColors.Dispose();
      hv_K.Dispose();
      hv_EndAngle.Dispose();
      hv_Rows.Dispose();
      hv_Columns.Dispose();
      hv_HomMat2DIdentity.Dispose();
      hv_HomMat2DRotate.Dispose();
      hv_ContourStyle.Dispose();
      hv_Ascent.Dispose();
      hv_Descent.Dispose();
      hv_Width.Dispose();
      hv_Height.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Sectors.Dispose();
      ho_Arc.Dispose();
      ho_Sector.Dispose();

      hv_Colors_COPY_INP_TMP.Dispose();
      hv_Ratios_COPY_INP_TMP.Dispose();
      hv_Tolerance.Dispose();
      hv_InitialWindowHandle.Dispose();
      hv_NoInitialWindow.Dispose();
      hv_Red.Dispose();
      hv_Green.Dispose();
      hv_Blue.Dispose();
      hv_Alpha.Dispose();
      hv_InitialColor.Dispose();
      hv_IndexColor.Dispose();
      hv_Color_RGBA.Dispose();
      hv_Title.Dispose();
      hv_TitleColor.Dispose();
      hv_TitleKeyExists.Dispose();
      hv_TitleColorKeyExists.Dispose();
      hv_GivenTitle.Dispose();
      hv_GivenTitleColor.Dispose();
      hv_Exception.Dispose();
      hv_FullCircleAngle.Dispose();
      hv_StartAngle.Dispose();
      hv_DrawColors.Dispose();
      hv_K.Dispose();
      hv_EndAngle.Dispose();
      hv_Rows.Dispose();
      hv_Columns.Dispose();
      hv_HomMat2DIdentity.Dispose();
      hv_HomMat2DRotate.Dispose();
      hv_ContourStyle.Dispose();
      hv_Ascent.Dispose();
      hv_Descent.Dispose();
      hv_Width.Dispose();
      hv_Height.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Anomaly Detection
  // Short Description: Display the detected anomaly regions. 
  public void dev_display_result_anomaly_regions (HObject ho_AnomalyImage, out HObject ho_AnomalyRegion, 
      HTuple hv_CurrentWindowHandle, HTuple hv_AnomalyRegionThreshold, HTuple hv_LineWidth, 
      HTuple hv_AnomalyRegionResultColor)
  {




    // Local iconic variables 

    // Local control variables 

    HTuple hv_Red = new HTuple(), hv_Green = new HTuple();
    HTuple hv_Blue = new HTuple(), hv_Alpha = new HTuple();
    HTuple hv_InitialColor = new HTuple(), hv_IndexColor = new HTuple();
    HTuple hv_Color_RGBA = new HTuple(), hv_Area = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_AnomalyRegion);
    try
    {
      //
      //This procedure displays the result anomaly regions
      //given in DLResult as anomaly_image.
      //
      //Get current set color.
      hv_Red.Dispose();hv_Green.Dispose();hv_Blue.Dispose();hv_Alpha.Dispose();
      HOperatorSet.GetRgba(hv_CurrentWindowHandle, out hv_Red, out hv_Green, out hv_Blue, 
          out hv_Alpha);
      hv_InitialColor.Dispose();
      hv_InitialColor = new HTuple();
      for (hv_IndexColor=0; (int)hv_IndexColor<=(int)((new HTuple(hv_Red.TupleLength()
          ))-1); hv_IndexColor = (int)hv_IndexColor + 1)
      {
        hv_Color_RGBA.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Color_RGBA = ((("#"+(((hv_Red.TupleSelect(
            hv_IndexColor))).TupleString("2x")))+(((hv_Green.TupleSelect(hv_IndexColor))).TupleString(
            "2x")))+(((hv_Blue.TupleSelect(hv_IndexColor))).TupleString("2x")))+(((hv_Alpha.TupleSelect(
            hv_IndexColor))).TupleString("2x"));
        }
        {
        HTuple ExpTmpOutVar_0;
        HOperatorSet.TupleRegexpReplace(hv_Color_RGBA, (new HTuple(" ")).TupleConcat(
            "replace_all"), "0", out ExpTmpOutVar_0);
        hv_Color_RGBA.Dispose();
        hv_Color_RGBA = ExpTmpOutVar_0;
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_InitialColor = hv_InitialColor.TupleConcat(
            hv_Color_RGBA);
        hv_InitialColor.Dispose();
        hv_InitialColor = ExpTmpLocalVar_InitialColor;
        }
        }
      }
      //
      if ((int)((new HTuple(hv_AnomalyRegionThreshold.TupleGreater(1))).TupleOr(new HTuple(hv_AnomalyRegionThreshold.TupleLess(
          0)))) != 0)
      {
        throw new HalconException("Selected 'anomaly_region_threshold' out of range. It must be between 0 and 1.");
      }
      ho_AnomalyRegion.Dispose();
      HOperatorSet.Threshold(ho_AnomalyImage, out ho_AnomalyRegion, hv_AnomalyRegionThreshold, 
          1);
      //
      //Display anomaly regions.
      //Get non-empty regions.
      hv_Area.Dispose();
      HOperatorSet.RegionFeatures(ho_AnomalyRegion, "area", out hv_Area);
      //
      //Display all non-empty class regions in distinct colors.
      if ((int)(new HTuple(hv_Area.TupleGreater(0))) != 0)
      {
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_AnomalyRegionResultColor);
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidth);
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_AnomalyRegion, HDevWindowStack.GetActive());
        }
      }
      //
      //Reset colors.
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_InitialColor);
      }
      //

      hv_Red.Dispose();
      hv_Green.Dispose();
      hv_Blue.Dispose();
      hv_Alpha.Dispose();
      hv_InitialColor.Dispose();
      hv_IndexColor.Dispose();
      hv_Color_RGBA.Dispose();
      hv_Area.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_Red.Dispose();
      hv_Green.Dispose();
      hv_Blue.Dispose();
      hv_Alpha.Dispose();
      hv_InitialColor.Dispose();
      hv_IndexColor.Dispose();
      hv_Color_RGBA.Dispose();
      hv_Area.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Graphics / Output
  // Short Description: Display result bounding boxes. 
  public void dev_display_result_detection (HTuple hv_DLResult, HTuple hv_ResultKeys, 
      HTuple hv_LineWidthBbox, HTuple hv_ClassIDs, HTuple hv_TextConf, HTuple hv_Colors, 
      HTuple hv_BoxLabelColor, HTuple hv_WindowImageRatio, HTuple hv_TextPositionRow, 
      HTuple hv_TextColor, HTuple hv_ShowLabels, HTuple hv_ShowDirection, HTuple hv_WindowHandle, 
      out HTuple hv_BboxIDs)
  {



    // Local iconic variables 

    HObject ho_BboxRectangle=null, ho_OrientationArrows=null;
    HObject ho_RectangleSelected=null, ho_ArrowSelected=null;

    // Local control variables 

    HTuple hv_InstanceType = new HTuple(), hv_BboxRow1 = new HTuple();
    HTuple hv_BboxCol1 = new HTuple(), hv_BboxRow2 = new HTuple();
    HTuple hv_BboxCol2 = new HTuple(), hv_BboxClasses = new HTuple();
    HTuple hv_BboxRow = new HTuple(), hv_BboxCol = new HTuple();
    HTuple hv_BboxLength1 = new HTuple(), hv_BboxLength2 = new HTuple();
    HTuple hv_BboxPhi = new HTuple(), hv_LabelRow1 = new HTuple();
    HTuple hv_LabelRow2 = new HTuple(), hv_LabelCol = new HTuple();
    HTuple hv_HeadSize = new HTuple(), hv_DrawMode = new HTuple();
    HTuple hv_Style = new HTuple(), hv_BboxClassIDs = new HTuple();
    HTuple hv_IndexBbox = new HTuple(), hv_ClassID = new HTuple();
    HTuple hv_LineWidth = new HTuple(), hv_Text = new HTuple();
    HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
    HTuple hv__ = new HTuple(), hv_TextRow = new HTuple();
    HTuple hv_TxtColor = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_BboxRectangle);
    HOperatorSet.GenEmptyObj(out ho_OrientationArrows);
    HOperatorSet.GenEmptyObj(out ho_RectangleSelected);
    HOperatorSet.GenEmptyObj(out ho_ArrowSelected);
    hv_BboxIDs = new HTuple();
    try
    {
      //
      //This procedure displays the bounding boxes defined by DLResult.
      //The ClassIDs are necessary to display bounding boxes from the same class
      //always with the same color.
      //
      hv_InstanceType.Dispose();
      hv_InstanceType = "rectangle1";
      if ((int)(new HTuple(((hv_ResultKeys.TupleFind("bbox_row1"))).TupleNotEqual(
          -1))) != 0)
      {
        hv_BboxRow1.Dispose();
        HOperatorSet.GetDictTuple(hv_DLResult, "bbox_row1", out hv_BboxRow1);
        hv_BboxCol1.Dispose();
        HOperatorSet.GetDictTuple(hv_DLResult, "bbox_col1", out hv_BboxCol1);
        hv_BboxRow2.Dispose();
        HOperatorSet.GetDictTuple(hv_DLResult, "bbox_row2", out hv_BboxRow2);
        hv_BboxCol2.Dispose();
        HOperatorSet.GetDictTuple(hv_DLResult, "bbox_col2", out hv_BboxCol2);
        hv_BboxClasses.Dispose();
        HOperatorSet.GetDictTuple(hv_DLResult, "bbox_class_id", out hv_BboxClasses);
      }
      else if ((int)(new HTuple(((hv_ResultKeys.TupleFind("bbox_phi"))).TupleNotEqual(
          -1))) != 0)
      {
        hv_BboxRow.Dispose();
        HOperatorSet.GetDictTuple(hv_DLResult, "bbox_row", out hv_BboxRow);
        hv_BboxCol.Dispose();
        HOperatorSet.GetDictTuple(hv_DLResult, "bbox_col", out hv_BboxCol);
        hv_BboxLength1.Dispose();
        HOperatorSet.GetDictTuple(hv_DLResult, "bbox_length1", out hv_BboxLength1);
        hv_BboxLength2.Dispose();
        HOperatorSet.GetDictTuple(hv_DLResult, "bbox_length2", out hv_BboxLength2);
        hv_BboxPhi.Dispose();
        HOperatorSet.GetDictTuple(hv_DLResult, "bbox_phi", out hv_BboxPhi);
        hv_BboxClasses.Dispose();
        HOperatorSet.GetDictTuple(hv_DLResult, "bbox_class_id", out hv_BboxClasses);
        hv_InstanceType.Dispose();
        hv_InstanceType = "rectangle2";
      }
      else
      {
        throw new HalconException("Result bounding box data could not be found in DLResult.");
      }
      if ((int)(new HTuple((new HTuple(hv_BboxClasses.TupleLength())).TupleGreater(
          0))) != 0)
      {
        //Generate bounding box XLDs.
        if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_BboxPhi.Dispose();
          HOperatorSet.TupleGenConst(new HTuple(hv_BboxRow1.TupleLength()), 0.0, 
              out hv_BboxPhi);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_BboxRectangle.Dispose();
          HOperatorSet.GenRectangle2ContourXld(out ho_BboxRectangle, 0.5*(hv_BboxRow1+hv_BboxRow2), 
              0.5*(hv_BboxCol1+hv_BboxCol2), hv_BboxPhi, 0.5*(hv_BboxCol2-hv_BboxCol1), 
              0.5*(hv_BboxRow2-hv_BboxRow1));
          }
          hv_LabelRow1.Dispose();
          hv_LabelRow1 = new HTuple(hv_BboxRow1);
          hv_LabelRow2.Dispose();
          hv_LabelRow2 = new HTuple(hv_BboxRow2);
          hv_LabelCol.Dispose();
          hv_LabelCol = new HTuple(hv_BboxCol1);
        }
        else
        {
          ho_BboxRectangle.Dispose();
          HOperatorSet.GenRectangle2ContourXld(out ho_BboxRectangle, hv_BboxRow, 
              hv_BboxCol, hv_BboxPhi, hv_BboxLength1, hv_BboxLength2);
          hv_LabelRow1.Dispose();
          hv_LabelRow1 = new HTuple(hv_BboxRow);
          hv_LabelRow2.Dispose();
          hv_LabelRow2 = new HTuple(hv_BboxRow);
          hv_LabelCol.Dispose();
          hv_LabelCol = new HTuple(hv_BboxCol);
          if ((int)(hv_ShowDirection) != 0)
          {
            hv_HeadSize.Dispose();
            hv_HeadSize = 20.0;
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_OrientationArrows.Dispose();
            gen_arrow_contour_xld(out ho_OrientationArrows, hv_BboxRow, hv_BboxCol, 
                hv_BboxRow-((hv_BboxLength1+hv_HeadSize)*(hv_BboxPhi.TupleSin())), 
                hv_BboxCol+((hv_BboxLength1+hv_HeadSize)*(hv_BboxPhi.TupleCos())), 
                hv_HeadSize, hv_HeadSize);
            }
          }
        }
        //
        hv_DrawMode.Dispose();
        HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
        }
        hv_Style.Dispose();
        HOperatorSet.GetLineStyle(hv_WindowHandle, out hv_Style);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidthBbox);
        }
        //
        //Collect ClassIDs of the bounding boxes.
        hv_BboxIDs.Dispose();
        hv_BboxIDs = new HTuple();
        hv_BboxClassIDs.Dispose();
        hv_BboxClassIDs = new HTuple();
        //
        //Draw bounding boxes.
        for (hv_IndexBbox=0; (int)hv_IndexBbox<=(int)((new HTuple(hv_BboxClasses.TupleLength()
            ))-1); hv_IndexBbox = (int)hv_IndexBbox + 1)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_RectangleSelected.Dispose();
          HOperatorSet.SelectObj(ho_BboxRectangle, out ho_RectangleSelected, hv_IndexBbox+1);
          }
          hv_ClassID.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ClassID = hv_ClassIDs.TupleFind(
              hv_BboxClasses.TupleSelect(hv_IndexBbox));
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_BboxClassIDs = hv_BboxClassIDs.TupleConcat(
              hv_ClassID);
          hv_BboxClassIDs.Dispose();
          hv_BboxClassIDs = ExpTmpLocalVar_BboxClassIDs;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_BboxIDs = hv_BboxIDs.TupleConcat(
              hv_ClassID);
          hv_BboxIDs.Dispose();
          hv_BboxIDs = ExpTmpLocalVar_BboxIDs;
          }
          }
          hv_LineWidth.Dispose();
          HOperatorSet.GetLineWidth(hv_WindowHandle, out hv_LineWidth);
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), ((hv_LineWidth+2)).TupleInt()
                );
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.SetColor(HDevWindowStack.GetActive(), "black");
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_RectangleSelected, HDevWindowStack.GetActive()
                );
          }
          if ((int)((new HTuple(hv_InstanceType.TupleEqual("rectangle2"))).TupleAnd(
              hv_ShowDirection)) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_ArrowSelected.Dispose();
            HOperatorSet.SelectObj(ho_OrientationArrows, out ho_ArrowSelected, hv_IndexBbox+1);
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_ArrowSelected, HDevWindowStack.GetActive());
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidth.TupleInt()
                );
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Colors.TupleSelect(
                hv_ClassID));
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_RectangleSelected, HDevWindowStack.GetActive()
                );
          }
          if ((int)((new HTuple(hv_InstanceType.TupleEqual("rectangle2"))).TupleAnd(
              hv_ShowDirection)) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_ArrowSelected, HDevWindowStack.GetActive());
            }
          }
        }
        //
        //Draw text of bounding boxes.
        if ((int)(hv_ShowLabels) != 0)
        {
          //For better visibility the text is displayed after all bounding boxes are drawn.
          for (hv_IndexBbox=0; (int)hv_IndexBbox<=(int)((new HTuple(hv_BboxClasses.TupleLength()
              ))-1); hv_IndexBbox = (int)hv_IndexBbox + 1)
          {
            hv_ClassID.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ClassID = hv_BboxClassIDs.TupleSelect(
                hv_IndexBbox);
            }
            hv_Text.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Text = (hv_BboxClasses.TupleSelect(
                hv_IndexBbox))+(hv_TextConf.TupleSelect(hv_IndexBbox));
            }
            hv_Ascent.Dispose();hv_Descent.Dispose();hv__.Dispose();hv__.Dispose();
            HOperatorSet.GetStringExtents(hv_WindowHandle, hv_Text, out hv_Ascent, 
                out hv_Descent, out hv__, out hv__);
            if ((int)(new HTuple(hv_TextPositionRow.TupleEqual("bottom"))) != 0)
            {
              hv_TextRow.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_TextRow = (hv_LabelRow2.TupleSelect(
                  hv_IndexBbox))-((hv_Ascent+hv_Descent)/hv_WindowImageRatio);
              }
            }
            else
            {
              hv_TextRow.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_TextRow = hv_LabelRow1.TupleSelect(
                  hv_IndexBbox);
              }
            }
            if ((int)(new HTuple(hv_TextColor.TupleEqual(""))) != 0)
            {
              hv_TxtColor.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_TxtColor = hv_Colors.TupleSelect(
                  hv_ClassID);
              }
            }
            else
            {
              hv_TxtColor.Dispose();
              hv_TxtColor = new HTuple(hv_TextColor);
            }
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "image", 
                  hv_TextRow, hv_LabelCol.TupleSelect(hv_IndexBbox), hv_TxtColor, 
                  ((new HTuple("box_color")).TupleConcat("shadow")).TupleConcat("border_radius"), 
                  hv_BoxLabelColor.TupleConcat((new HTuple("false")).TupleConcat(
                  0)));
              }
            }
          }
        }
        //
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
        }
        HOperatorSet.SetLineStyle(hv_WindowHandle, hv_Style);
      }
      else
      {
        //Do nothing if no results are present.
        hv_BboxIDs.Dispose();
        hv_BboxIDs = new HTuple();
      }
      //
      ho_BboxRectangle.Dispose();
      ho_OrientationArrows.Dispose();
      ho_RectangleSelected.Dispose();
      ho_ArrowSelected.Dispose();

      hv_InstanceType.Dispose();
      hv_BboxRow1.Dispose();
      hv_BboxCol1.Dispose();
      hv_BboxRow2.Dispose();
      hv_BboxCol2.Dispose();
      hv_BboxClasses.Dispose();
      hv_BboxRow.Dispose();
      hv_BboxCol.Dispose();
      hv_BboxLength1.Dispose();
      hv_BboxLength2.Dispose();
      hv_BboxPhi.Dispose();
      hv_LabelRow1.Dispose();
      hv_LabelRow2.Dispose();
      hv_LabelCol.Dispose();
      hv_HeadSize.Dispose();
      hv_DrawMode.Dispose();
      hv_Style.Dispose();
      hv_BboxClassIDs.Dispose();
      hv_IndexBbox.Dispose();
      hv_ClassID.Dispose();
      hv_LineWidth.Dispose();
      hv_Text.Dispose();
      hv_Ascent.Dispose();
      hv_Descent.Dispose();
      hv__.Dispose();
      hv_TextRow.Dispose();
      hv_TxtColor.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_BboxRectangle.Dispose();
      ho_OrientationArrows.Dispose();
      ho_RectangleSelected.Dispose();
      ho_ArrowSelected.Dispose();

      hv_InstanceType.Dispose();
      hv_BboxRow1.Dispose();
      hv_BboxCol1.Dispose();
      hv_BboxRow2.Dispose();
      hv_BboxCol2.Dispose();
      hv_BboxClasses.Dispose();
      hv_BboxRow.Dispose();
      hv_BboxCol.Dispose();
      hv_BboxLength1.Dispose();
      hv_BboxLength2.Dispose();
      hv_BboxPhi.Dispose();
      hv_LabelRow1.Dispose();
      hv_LabelRow2.Dispose();
      hv_LabelCol.Dispose();
      hv_HeadSize.Dispose();
      hv_DrawMode.Dispose();
      hv_Style.Dispose();
      hv_BboxClassIDs.Dispose();
      hv_IndexBbox.Dispose();
      hv_ClassID.Dispose();
      hv_LineWidth.Dispose();
      hv_Text.Dispose();
      hv_Ascent.Dispose();
      hv_Descent.Dispose();
      hv__.Dispose();
      hv_TextRow.Dispose();
      hv_TxtColor.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Graphics / Output
  // Short Description: Display the ground truth/result segmentation as regions. 
  public void dev_display_segmentation_regions (HObject ho_SegmentationImage, HTuple hv_ClassIDs, 
      HTuple hv_ColorsSegmentation, HTuple hv_ExcludeClassIDs, out HTuple hv_ImageClassIDs)
  {




    // Local iconic variables 

    HObject ho_Regions, ho_SelectedRegion=null;

    // Local control variables 

    HTuple hv_IncludedClassIDs = new HTuple();
    HTuple hv_Area = new HTuple(), hv_Index = new HTuple();
    HTuple hv_ClassID = new HTuple(), hv_IndexColor = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Regions);
    HOperatorSet.GenEmptyObj(out ho_SelectedRegion);
    hv_ImageClassIDs = new HTuple();
    try
    {
      //
      //This procedure displays the ground truth/result segmentation
      //given in SegmentationImage as regions. The ClassIDs are necessary to
      //display ground truth/result segmentations from the same class
      //always with the same color. It is possible to exclude certain ClassIDs
      //from being displayed. The displayed classes are returned in ImageClassIDs.
      //
      //
      //Remove excluded class IDs from the list.
      hv_IncludedClassIDs.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_IncludedClassIDs = hv_ClassIDs.TupleDifference(
          hv_ExcludeClassIDs);
      }
      //
      //Get a region for each class ID.
      ho_Regions.Dispose();
      HOperatorSet.Threshold(ho_SegmentationImage, out ho_Regions, hv_IncludedClassIDs, 
          hv_IncludedClassIDs);
      //
      //Get classes with non-empty regions.
      hv_Area.Dispose();
      HOperatorSet.RegionFeatures(ho_Regions, "area", out hv_Area);
      hv_ImageClassIDs.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ImageClassIDs = hv_IncludedClassIDs.TupleSelectMask(
          hv_Area.TupleGreaterElem(0));
      }
      //
      //Display all non-empty class regions in distinct colors.
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_IncludedClassIDs.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        if ((int)(new HTuple(((hv_Area.TupleSelect(hv_Index))).TupleGreater(0))) != 0)
        {
          //Use class ID to determine region color.
          hv_ClassID.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ClassID = hv_IncludedClassIDs.TupleSelect(
              hv_Index);
          }
          hv_IndexColor.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_IndexColor = hv_ClassIDs.TupleFindFirst(
              hv_ClassID);
          }
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_ColorsSegmentation.TupleSelect(
                hv_IndexColor));
            }
          }
          //Display the segmentation region.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_SelectedRegion.Dispose();
          HOperatorSet.SelectObj(ho_Regions, out ho_SelectedRegion, hv_Index+1);
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_SelectedRegion, HDevWindowStack.GetActive());
          }
        }
      }
      ho_Regions.Dispose();
      ho_SelectedRegion.Dispose();

      hv_IncludedClassIDs.Dispose();
      hv_Area.Dispose();
      hv_Index.Dispose();
      hv_ClassID.Dispose();
      hv_IndexColor.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Regions.Dispose();
      ho_SelectedRegion.Dispose();

      hv_IncludedClassIDs.Dispose();
      hv_Area.Dispose();
      hv_Index.Dispose();
      hv_ClassID.Dispose();
      hv_IndexColor.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Graphics / Output
  // Short Description: Display a map of weights. 
  public void dev_display_weight_regions (HObject ho_ImageWeight, HTuple hv_DrawTransparency, 
      HTuple hv_SegMaxWeight, out HTuple hv_Colors)
  {




    // Local iconic variables 

    HObject ho_Domain, ho_WeightsRegion=null;

    // Local control variables 

    HTuple hv_NumColors = new HTuple(), hv_WeightsColorsAlpha = new HTuple();
    HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
    HTuple hv_GrayVal = new HTuple(), hv_GrayValWeight = new HTuple();
    HTuple hv_ColorIndex = new HTuple(), hv_ClassColor = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Domain);
    HOperatorSet.GenEmptyObj(out ho_WeightsRegion);
    hv_Colors = new HTuple();
    try
    {
      //
      //This procedure displays a map of the weights
      //given in ImageWeight as regions.
      //The transparency can be adjusted.
      //The used colors are returned.
      //
      //Define colors.
      hv_NumColors.Dispose();
      hv_NumColors = 20;
      hv_Colors.Dispose();
      get_distinct_colors_dl_visualization(hv_NumColors, 0, 0, 160, out hv_Colors);
      {
      HTuple ExpTmpOutVar_0;
      HOperatorSet.TupleInverse(hv_Colors, out ExpTmpOutVar_0);
      hv_Colors.Dispose();
      hv_Colors = ExpTmpOutVar_0;
      }
      hv_WeightsColorsAlpha.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WeightsColorsAlpha = hv_Colors+hv_DrawTransparency;
      }
      //
      //Get gay values of ImageWeight.
      ho_Domain.Dispose();
      HOperatorSet.GetDomain(ho_ImageWeight, out ho_Domain);
      hv_Rows.Dispose();hv_Columns.Dispose();
      HOperatorSet.GetRegionPoints(ho_Domain, out hv_Rows, out hv_Columns);
      hv_GrayVal.Dispose();
      HOperatorSet.GetGrayval(ho_ImageWeight, hv_Rows, hv_Columns, out hv_GrayVal);
      //
      //Check that the gray values of the image
      //are below the specified maximum.
      if ((int)(new HTuple(((hv_GrayVal.TupleMax())).TupleGreater(hv_SegMaxWeight))) != 0)
      {
        throw new HalconException(((("The maximum weight ("+(hv_GrayVal.TupleMax()
            ))+") in the weight image is greater than the given SegMaxWeight (")+hv_SegMaxWeight)+").");
      }
      //
      while ((int)(new HTuple(hv_GrayVal.TupleNotEqual(new HTuple()))) != 0)
      {
        //Go through all gray value 'groups',
        //starting from the maximum.
        hv_GrayValWeight.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_GrayValWeight = hv_GrayVal.TupleMax()
            ;
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_GrayVal = hv_GrayVal.TupleRemove(
            hv_GrayVal.TupleFind(hv_GrayValWeight));
        hv_GrayVal.Dispose();
        hv_GrayVal = ExpTmpLocalVar_GrayVal;
        }
        }
        ho_WeightsRegion.Dispose();
        HOperatorSet.Threshold(ho_ImageWeight, out ho_WeightsRegion, hv_GrayValWeight, 
            hv_GrayValWeight);
        //
        //Visualize the respective group.
        hv_ColorIndex.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ColorIndex = (((((hv_GrayValWeight/hv_SegMaxWeight)*(hv_NumColors-1))).TupleCeil()
            )).TupleInt();
        }
        hv_ClassColor.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ClassColor = hv_WeightsColorsAlpha.TupleSelect(
            hv_ColorIndex);
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_ClassColor);
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_WeightsRegion, HDevWindowStack.GetActive());
        }
      }
      ho_Domain.Dispose();
      ho_WeightsRegion.Dispose();

      hv_NumColors.Dispose();
      hv_WeightsColorsAlpha.Dispose();
      hv_Rows.Dispose();
      hv_Columns.Dispose();
      hv_GrayVal.Dispose();
      hv_GrayValWeight.Dispose();
      hv_ColorIndex.Dispose();
      hv_ClassColor.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Domain.Dispose();
      ho_WeightsRegion.Dispose();

      hv_NumColors.Dispose();
      hv_WeightsColorsAlpha.Dispose();
      hv_Rows.Dispose();
      hv_Columns.Dispose();
      hv_GrayVal.Dispose();
      hv_GrayValWeight.Dispose();
      hv_ColorIndex.Dispose();
      hv_ClassColor.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Develop
  // Short Description: Open a new graphics window that preserves the aspect ratio of the given image size. 
  public void dev_open_window_fit_size (HTuple hv_Row, HTuple hv_Column, HTuple hv_Width, 
      HTuple hv_Height, HTuple hv_WidthLimit, HTuple hv_HeightLimit, out HTuple hv_WindowHandle)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_MinWidth = new HTuple(), hv_MaxWidth = new HTuple();
    HTuple hv_MinHeight = new HTuple(), hv_MaxHeight = new HTuple();
    HTuple hv_ResizeFactor = new HTuple(), hv_TempWidth = new HTuple();
    HTuple hv_TempHeight = new HTuple(), hv_WindowWidth = new HTuple();
    HTuple hv_WindowHeight = new HTuple();
    // Initialize local and output iconic variables 
    hv_WindowHandle = new HTuple();
    try
    {
      //This procedure open a new graphic window
      //such that it fits into the limits specified by WidthLimit
      //and HeightLimit, but also maintains the correct aspect ratio
      //given by Width and Height.
      //
      //If it is impossible to match the minimum and maximum extent requirements
      //at the same time (f.e. if the image is very long but narrow),
      //the maximum value gets a higher priority.
      //
      //Parse input tuple WidthLimit
      if ((int)((new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
          0))).TupleOr(new HTuple(hv_WidthLimit.TupleLess(0)))) != 0)
      {
        hv_MinWidth.Dispose();
        hv_MinWidth = 500;
        hv_MaxWidth.Dispose();
        hv_MaxWidth = 800;
      }
      else if ((int)(new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
          1))) != 0)
      {
        hv_MinWidth.Dispose();
        hv_MinWidth = 0;
        hv_MaxWidth.Dispose();
        hv_MaxWidth = new HTuple(hv_WidthLimit);
      }
      else
      {
        hv_MinWidth.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MinWidth = hv_WidthLimit.TupleSelect(
            0);
        }
        hv_MaxWidth.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MaxWidth = hv_WidthLimit.TupleSelect(
            1);
        }
      }
      //Parse input tuple HeightLimit
      if ((int)((new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
          0))).TupleOr(new HTuple(hv_HeightLimit.TupleLess(0)))) != 0)
      {
        hv_MinHeight.Dispose();
        hv_MinHeight = 400;
        hv_MaxHeight.Dispose();
        hv_MaxHeight = 600;
      }
      else if ((int)(new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
          1))) != 0)
      {
        hv_MinHeight.Dispose();
        hv_MinHeight = 0;
        hv_MaxHeight.Dispose();
        hv_MaxHeight = new HTuple(hv_HeightLimit);
      }
      else
      {
        hv_MinHeight.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MinHeight = hv_HeightLimit.TupleSelect(
            0);
        }
        hv_MaxHeight.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MaxHeight = hv_HeightLimit.TupleSelect(
            1);
        }
      }
      //
      //Test, if window size has to be changed.
      hv_ResizeFactor.Dispose();
      hv_ResizeFactor = 1;
      //First, expand window to the minimum extents (if necessary).
      if ((int)((new HTuple(hv_MinWidth.TupleGreater(hv_Width))).TupleOr(new HTuple(hv_MinHeight.TupleGreater(
          hv_Height)))) != 0)
      {
        hv_ResizeFactor.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ResizeFactor = (((((hv_MinWidth.TupleReal()
            )/hv_Width)).TupleConcat((hv_MinHeight.TupleReal())/hv_Height))).TupleMax()
            ;
        }
      }
      hv_TempWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TempWidth = hv_Width*hv_ResizeFactor;
      }
      hv_TempHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TempHeight = hv_Height*hv_ResizeFactor;
      }
      //Then, shrink window to maximum extents (if necessary).
      if ((int)((new HTuple(hv_MaxWidth.TupleLess(hv_TempWidth))).TupleOr(new HTuple(hv_MaxHeight.TupleLess(
          hv_TempHeight)))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ResizeFactor = hv_ResizeFactor*((((((hv_MaxWidth.TupleReal()
            )/hv_TempWidth)).TupleConcat((hv_MaxHeight.TupleReal())/hv_TempHeight))).TupleMin()
            );
        hv_ResizeFactor.Dispose();
        hv_ResizeFactor = ExpTmpLocalVar_ResizeFactor;
        }
        }
      }
      hv_WindowWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WindowWidth = hv_Width*hv_ResizeFactor;
      }
      hv_WindowHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WindowHeight = hv_Height*hv_ResizeFactor;
      }
      //Resize window
      HOperatorSet.SetWindowAttr("background_color","black");
      HOperatorSet.OpenWindow(hv_Row,hv_Column,hv_WindowWidth,hv_WindowHeight,0,"visible","",out hv_WindowHandle);
      HDevWindowStack.Push(hv_WindowHandle);
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_Height-1, hv_Width-1);
        }
      }

      hv_MinWidth.Dispose();
      hv_MaxWidth.Dispose();
      hv_MinHeight.Dispose();
      hv_MaxHeight.Dispose();
      hv_ResizeFactor.Dispose();
      hv_TempWidth.Dispose();
      hv_TempHeight.Dispose();
      hv_WindowWidth.Dispose();
      hv_WindowHeight.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_MinWidth.Dispose();
      hv_MaxWidth.Dispose();
      hv_MinHeight.Dispose();
      hv_MaxHeight.Dispose();
      hv_ResizeFactor.Dispose();
      hv_TempWidth.Dispose();
      hv_TempHeight.Dispose();
      hv_WindowWidth.Dispose();
      hv_WindowHeight.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Develop
  // Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
  public void dev_update_off ()
  {

    // Initialize local and output iconic variables 
    //This procedure sets different update settings to 'off'.
    //This is useful to get the best performance and reduce overhead.
    //
    // dev_update_pc(...); only in hdevelop
    // dev_update_var(...); only in hdevelop
    // dev_update_window(...); only in hdevelop


    return;
  }

  // Chapter: Time
  // Short Description: Estimate the remaining time for a task given the current progress. 
  public void estimate_progress (HTuple hv_SecondsStart, HTuple hv_ProgressMin, HTuple hv_ProgressCurrent, 
      HTuple hv_ProgressMax, out HTuple hv_SecondsElapsed, out HTuple hv_SecondsRemaining, 
      out HTuple hv_ProgressPercent, out HTuple hv_ProgressPerSecond)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_SecondsNow = new HTuple(), hv_Epsilon = new HTuple();
    HTuple hv_ProgressRemaining = new HTuple();
    // Initialize local and output iconic variables 
    hv_SecondsElapsed = new HTuple();
    hv_SecondsRemaining = new HTuple();
    hv_ProgressPercent = new HTuple();
    hv_ProgressPerSecond = new HTuple();
    try
    {
      //
      //This procedure estimates the remaining time in seconds,
      //given a start time and a progress value.
      //
      //Get current time.
      hv_SecondsNow.Dispose();
      HOperatorSet.CountSeconds(out hv_SecondsNow);
      //
      //Get elapsed time span.
      hv_SecondsElapsed.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_SecondsElapsed = hv_SecondsNow-hv_SecondsStart;
      }
      //
      //A very small additive constant to avoid division by zero.
      hv_Epsilon.Dispose();
      hv_Epsilon = 1e-6;
      //
      //Estimate remaining time based on elapsed time.
      hv_ProgressRemaining.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ProgressRemaining = hv_ProgressMax-hv_ProgressCurrent;
      }
      hv_ProgressPerSecond.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ProgressPerSecond = (((hv_ProgressCurrent-hv_ProgressMin)).TupleReal()
          )/((hv_SecondsElapsed.TupleReal())+hv_Epsilon);
      }
      hv_SecondsRemaining.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_SecondsRemaining = hv_ProgressRemaining/(hv_ProgressPerSecond+hv_Epsilon);
      }
      //
      //Get current progress in percent.
      hv_ProgressPercent.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ProgressPercent = (100*(((hv_ProgressCurrent-hv_ProgressMin)).TupleReal()
          ))/((((hv_ProgressMax-hv_ProgressMin)).TupleReal())+hv_Epsilon);
      }

      hv_SecondsNow.Dispose();
      hv_Epsilon.Dispose();
      hv_ProgressRemaining.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_SecondsNow.Dispose();
      hv_Epsilon.Dispose();
      hv_ProgressRemaining.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: Retrieve the indices of Samples that contain KeyName matching KeyValue according to the Mode set. 
  public void find_dl_samples (HTuple hv_Samples, HTuple hv_KeyName, HTuple hv_KeyValue, 
      HTuple hv_Mode, out HTuple hv_SampleIndices)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_NumKeyValues = new HTuple(), hv_SampleIndex = new HTuple();
    HTuple hv_Sample = new HTuple(), hv_KeyExists = new HTuple();
    HTuple hv_Tuple = new HTuple(), hv_Hit = new HTuple();
    HTuple hv_ValueIndex = new HTuple(), hv_Value = new HTuple();
    // Initialize local and output iconic variables 
    hv_SampleIndices = new HTuple();
    try
    {
      //
      //This procedure gets the indices of the samples that contain the
      //requested KeyName matching the requested KeyValue according to the Mode.
      //If there is no match, an empty tuple [] will be returned.
      //
      //Check input parameters.
      if ((int)(new HTuple((new HTuple(hv_KeyName.TupleLength())).TupleNotEqual(1))) != 0)
      {
        throw new HalconException(new HTuple("Invalid KeyName size: ")+(new HTuple(hv_KeyName.TupleLength()
            )));
      }
      if ((int)(new HTuple((new HTuple(hv_Mode.TupleLength())).TupleNotEqual(1))) != 0)
      {
        throw new HalconException(new HTuple("Invalid Mode size: ")+(new HTuple(hv_Mode.TupleLength()
            )));
      }
      if ((int)((new HTuple((new HTuple(hv_Mode.TupleNotEqual("match"))).TupleAnd(
          new HTuple(hv_Mode.TupleNotEqual("or"))))).TupleAnd(new HTuple(hv_Mode.TupleNotEqual(
          "contain")))) != 0)
      {
        throw new HalconException("Invalid Mode value: "+hv_Mode);
      }
      hv_NumKeyValues.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NumKeyValues = new HTuple(hv_KeyValue.TupleLength()
          );
      }
      if ((int)((new HTuple(hv_Mode.TupleEqual("contain"))).TupleAnd(new HTuple(hv_NumKeyValues.TupleLess(
          1)))) != 0)
      {
        throw new HalconException("Invalid KeyValue size for contain Mode: "+hv_NumKeyValues);
      }
      //
      //Find the indices.
      hv_SampleIndices.Dispose();
      hv_SampleIndices = new HTuple();
      for (hv_SampleIndex=0; (int)hv_SampleIndex<=(int)((new HTuple(hv_Samples.TupleLength()
          ))-1); hv_SampleIndex = (int)hv_SampleIndex + 1)
      {
        hv_Sample.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Sample = hv_Samples.TupleSelect(
            hv_SampleIndex);
        }
        hv_KeyExists.Dispose();
        HOperatorSet.GetDictParam(hv_Sample, "key_exists", hv_KeyName, out hv_KeyExists);
        if ((int)(hv_KeyExists) != 0)
        {
          hv_Tuple.Dispose();
          HOperatorSet.GetDictTuple(hv_Sample, hv_KeyName, out hv_Tuple);
          if ((int)(new HTuple(hv_Mode.TupleEqual("match"))) != 0)
          {
            //Mode 'match': Tuple must be equal KeyValue.
            hv_Hit.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Hit = new HTuple(hv_Tuple.TupleEqual(
                hv_KeyValue));
            }
          }
          else if ((int)((new HTuple(hv_Mode.TupleEqual("or"))).TupleAnd(
              new HTuple((new HTuple(hv_Tuple.TupleLength())).TupleEqual(1)))) != 0)
          {
            //Mode 'or': Tuple must have only 1 element and it has to be equal to any of KeyValues elements.
            hv_Hit.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Hit = new HTuple(((hv_KeyValue.TupleFindFirst(
                hv_Tuple))).TupleGreaterEqual(0));
            }
          }
          else if ((int)(new HTuple(hv_Mode.TupleEqual("contain"))) != 0)
          {
            //Mode 'contain': Tuple must contain any of the elements in KeyValue.
            HTuple end_val35 = hv_NumKeyValues-1;
            HTuple step_val35 = 1;
            for (hv_ValueIndex=0; hv_ValueIndex.Continue(end_val35, step_val35); hv_ValueIndex = hv_ValueIndex.TupleAdd(step_val35))
            {
              hv_Value.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_Value = hv_KeyValue.TupleSelect(
                  hv_ValueIndex);
              }
              hv_Hit.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_Hit = new HTuple(((hv_Tuple.TupleFindFirst(
                  hv_Value))).TupleGreaterEqual(0));
              }
              if ((int)(hv_Hit) != 0)
              {
                break;
              }
            }
          }
          else
          {
            //Unsupported configuration.
            hv_Hit.Dispose();
            hv_Hit = 0;
          }
          if ((int)(hv_Hit) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_SampleIndices = hv_SampleIndices.TupleConcat(
                hv_SampleIndex);
            hv_SampleIndices.Dispose();
            hv_SampleIndices = ExpTmpLocalVar_SampleIndices;
            }
            }
          }
        }
      }

      hv_NumKeyValues.Dispose();
      hv_SampleIndex.Dispose();
      hv_Sample.Dispose();
      hv_KeyExists.Dispose();
      hv_Tuple.Dispose();
      hv_Hit.Dispose();
      hv_ValueIndex.Dispose();
      hv_Value.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_NumKeyValues.Dispose();
      hv_SampleIndex.Dispose();
      hv_Sample.Dispose();
      hv_KeyExists.Dispose();
      hv_Tuple.Dispose();
      hv_Hit.Dispose();
      hv_ValueIndex.Dispose();
      hv_Value.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: XLD / Creation
  // Short Description: Creates an arrow shaped XLD contour. 
  public void gen_arrow_contour_xld (out HObject ho_Arrow, HTuple hv_Row1, HTuple hv_Column1, 
      HTuple hv_Row2, HTuple hv_Column2, HTuple hv_HeadLength, HTuple hv_HeadWidth)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_TempArrow=null;

    // Local control variables 

    HTuple hv_Length = new HTuple(), hv_ZeroLengthIndices = new HTuple();
    HTuple hv_DR = new HTuple(), hv_DC = new HTuple(), hv_HalfHeadWidth = new HTuple();
    HTuple hv_RowP1 = new HTuple(), hv_ColP1 = new HTuple();
    HTuple hv_RowP2 = new HTuple(), hv_ColP2 = new HTuple();
    HTuple hv_Index = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Arrow);
    HOperatorSet.GenEmptyObj(out ho_TempArrow);
    try
    {
      //This procedure generates arrow shaped XLD contours,
      //pointing from (Row1, Column1) to (Row2, Column2).
      //If starting and end point are identical, a contour consisting
      //of a single point is returned.
      //
      //input parameteres:
      //Row1, Column1: Coordinates of the arrows' starting points
      //Row2, Column2: Coordinates of the arrows' end points
      //HeadLength, HeadWidth: Size of the arrow heads in pixels
      //
      //output parameter:
      //Arrow: The resulting XLD contour
      //
      //The input tuples Row1, Column1, Row2, and Column2 have to be of
      //the same length.
      //HeadLength and HeadWidth either have to be of the same length as
      //Row1, Column1, Row2, and Column2 or have to be a single element.
      //If one of the above restrictions is violated, an error will occur.
      //
      //
      //Init
      ho_Arrow.Dispose();
      HOperatorSet.GenEmptyObj(out ho_Arrow);
      //
      //Calculate the arrow length
      hv_Length.Dispose();
      HOperatorSet.DistancePp(hv_Row1, hv_Column1, hv_Row2, hv_Column2, out hv_Length);
      //
      //Mark arrows with identical start and end point
      //(set Length to -1 to avoid division-by-zero exception)
      hv_ZeroLengthIndices.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ZeroLengthIndices = hv_Length.TupleFind(
          0);
      }
      if ((int)(new HTuple(hv_ZeroLengthIndices.TupleNotEqual(-1))) != 0)
      {
        if (hv_Length == null)
          hv_Length = new HTuple();
        hv_Length[hv_ZeroLengthIndices] = -1;
      }
      //
      //Calculate auxiliary variables.
      hv_DR.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_DR = (1.0*(hv_Row2-hv_Row1))/hv_Length;
      }
      hv_DC.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_DC = (1.0*(hv_Column2-hv_Column1))/hv_Length;
      }
      hv_HalfHeadWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_HalfHeadWidth = hv_HeadWidth/2.0;
      }
      //
      //Calculate end points of the arrow head.
      hv_RowP1.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_RowP1 = (hv_Row1+((hv_Length-hv_HeadLength)*hv_DR))+(hv_HalfHeadWidth*hv_DC);
      }
      hv_ColP1.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ColP1 = (hv_Column1+((hv_Length-hv_HeadLength)*hv_DC))-(hv_HalfHeadWidth*hv_DR);
      }
      hv_RowP2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_RowP2 = (hv_Row1+((hv_Length-hv_HeadLength)*hv_DR))-(hv_HalfHeadWidth*hv_DC);
      }
      hv_ColP2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ColP2 = (hv_Column1+((hv_Length-hv_HeadLength)*hv_DC))+(hv_HalfHeadWidth*hv_DR);
      }
      //
      //Finally create output XLD contour for each input point pair
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_Length.TupleLength()))-1); hv_Index = (int)hv_Index + 1)
      {
        if ((int)(new HTuple(((hv_Length.TupleSelect(hv_Index))).TupleEqual(-1))) != 0)
        {
          //Create_ single points for arrows with identical start and end point
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_TempArrow.Dispose();
          HOperatorSet.GenContourPolygonXld(out ho_TempArrow, hv_Row1.TupleSelect(
              hv_Index), hv_Column1.TupleSelect(hv_Index));
          }
        }
        else
        {
          //Create arrow contour
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_TempArrow.Dispose();
          HOperatorSet.GenContourPolygonXld(out ho_TempArrow, ((((((((((hv_Row1.TupleSelect(
              hv_Index))).TupleConcat(hv_Row2.TupleSelect(hv_Index)))).TupleConcat(
              hv_RowP1.TupleSelect(hv_Index)))).TupleConcat(hv_Row2.TupleSelect(hv_Index)))).TupleConcat(
              hv_RowP2.TupleSelect(hv_Index)))).TupleConcat(hv_Row2.TupleSelect(hv_Index)), 
              ((((((((((hv_Column1.TupleSelect(hv_Index))).TupleConcat(hv_Column2.TupleSelect(
              hv_Index)))).TupleConcat(hv_ColP1.TupleSelect(hv_Index)))).TupleConcat(
              hv_Column2.TupleSelect(hv_Index)))).TupleConcat(hv_ColP2.TupleSelect(
              hv_Index)))).TupleConcat(hv_Column2.TupleSelect(hv_Index)));
          }
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConcatObj(ho_Arrow, ho_TempArrow, out ExpTmpOutVar_0);
        ho_Arrow.Dispose();
        ho_Arrow = ExpTmpOutVar_0;
        }
      }
      ho_TempArrow.Dispose();

      hv_Length.Dispose();
      hv_ZeroLengthIndices.Dispose();
      hv_DR.Dispose();
      hv_DC.Dispose();
      hv_HalfHeadWidth.Dispose();
      hv_RowP1.Dispose();
      hv_ColP1.Dispose();
      hv_RowP2.Dispose();
      hv_ColP2.Dispose();
      hv_Index.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_TempArrow.Dispose();

      hv_Length.Dispose();
      hv_ZeroLengthIndices.Dispose();
      hv_DR.Dispose();
      hv_DC.Dispose();
      hv_HalfHeadWidth.Dispose();
      hv_RowP1.Dispose();
      hv_ColP1.Dispose();
      hv_RowP2.Dispose();
      hv_ColP2.Dispose();
      hv_Index.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: The procedure returns DLSample dicts for given sample indices of a DLDataset. 
  public void gen_dl_samples (HTuple hv_DLDataset, HTuple hv_SampleIndices, HTuple hv_RestrictKeysDLSample, 
      HTuple hv_GenParam, out HTuple hv_DLSampleBatch)
  {



    // Local iconic variables 

    HObject ho_ImageRaw=null, ho_ImageAnomaly=null;
    HObject ho_RegionAnomaly=null, ho_ImageSegmentation=null;

    // Local control variables 

    HTuple hv_ImageDir = new HTuple(), hv_DLSamples = new HTuple();
    HTuple hv_MinIndex = new HTuple(), hv_MaxIndex = new HTuple();
    HTuple hv_InstanceType = new HTuple(), hv_IgnoreMissing = new HTuple();
    HTuple hv_GenParamName = new HTuple(), hv_IndexGenParam = new HTuple();
    HTuple hv_DLSamplesProc = new HTuple(), hv_BboxKeyList = new HTuple();
    HTuple hv_ImageIndex = new HTuple(), hv_DLSample = new HTuple();
    HTuple hv_ImageID = new HTuple(), hv_ImageName = new HTuple();
    HTuple hv_FileName = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_AnomalyLabelExists = new HTuple(), hv_AnomalyLabel = new HTuple();
    HTuple hv_AnomalyFileNameExists = new HTuple(), hv_AnomalyDir = new HTuple();
    HTuple hv_AnomalyFileName = new HTuple(), hv_ExceptionImageAnomaly = new HTuple();
    HTuple hv_ExceptionRegionAnomaly = new HTuple(), hv_Width = new HTuple();
    HTuple hv_Height = new HTuple(), hv_ImageLabelIDExists = new HTuple();
    HTuple hv_ImageLabelID = new HTuple(), hv_BboxExists = new HTuple();
    HTuple hv_BboxLabels = new HTuple(), hv_KeysExist = new HTuple();
    HTuple hv_MissingKeyIndices = new HTuple(), hv_IndexParam = new HTuple();
    HTuple hv_BboxCoord = new HTuple(), hv_SegKeyExists = new HTuple();
    HTuple hv_SegmentationDir = new HTuple(), hv_SegmentationName = new HTuple();
    HTuple hv_ExceptionSegmentation = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImageRaw);
    HOperatorSet.GenEmptyObj(out ho_ImageAnomaly);
    HOperatorSet.GenEmptyObj(out ho_RegionAnomaly);
    HOperatorSet.GenEmptyObj(out ho_ImageSegmentation);
    hv_DLSampleBatch = new HTuple();
    try
    {
      //
      //This procedure creates DLSampleBatch, a tuple of DLSample dictionaries, with
      //the image data for each DLDataset sample, that was selected through SampleIndices.
      //The keys to be transferred can be restricted using RestrictKeysDLSample,
      //which is switched off ('off') by default.
      //The procedure returns all generated DLSample dictionaries in the tuple
      //DLSampleBatch.
      //Setting the GenParam 'ignore_missing_labels' controls whether an error is thrown,
      //if no ground truth annotation information is available for a given image.
      //
      //Get the image directory.
      hv_ImageDir.Dispose();
      HOperatorSet.GetDictTuple(hv_DLDataset, "image_dir", out hv_ImageDir);
      //
      //Get the samples from the DLDataset.
      hv_DLSamples.Dispose();
      HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLSamples);
      //
      //Check the input values.
      //
      //Check that the given indices are valid.
      hv_MinIndex.Dispose();
      HOperatorSet.TupleMin(hv_SampleIndices, out hv_MinIndex);
      hv_MaxIndex.Dispose();
      HOperatorSet.TupleMax(hv_SampleIndices, out hv_MaxIndex);
      if ((int)((new HTuple(hv_MinIndex.TupleLess(0))).TupleOr(new HTuple(hv_MaxIndex.TupleGreater(
          (new HTuple(hv_DLSamples.TupleLength()))-1)))) != 0)
      {
        throw new HalconException("The given SampleIndices are not within the range of available samples in DLDataset.");
      }
      //
      //Check if the given method is valid.
      if ((int)(new HTuple((new HTuple(hv_RestrictKeysDLSample.TupleLength())).TupleEqual(
          1))) != 0)
      {
        if ((int)(new HTuple((new HTuple((new HTuple(((((((new HTuple("anomaly_detection")).TupleConcat(
            "detection")).TupleConcat("segmentation")).TupleConcat("classification")).TupleConcat(
            "image_only")).TupleConcat("off")).TupleFind(hv_RestrictKeysDLSample))).TupleMax()
            )).TupleEqual(-1))) != 0)
        {
          throw new HalconException("Unknown RestrictKeysDLSample : "+hv_RestrictKeysDLSample);
        }
      }
      else
      {
        throw new HalconException("RestrictKeysDLSample must be specified by one string.");
      }
      //
      //Generic Parameters.
      //Set default values.
      hv_InstanceType.Dispose();
      hv_InstanceType = "rectangle1";
      //For missing labels an error is thrown.
      if ((int)(new HTuple(hv_RestrictKeysDLSample.TupleEqual("off"))) != 0)
      {
        hv_IgnoreMissing.Dispose();
        hv_IgnoreMissing = 1;
      }
      else
      {
        hv_IgnoreMissing.Dispose();
        hv_IgnoreMissing = 0;
      }
      //
      //Transfer generic parameters.
      if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
      {
        hv_GenParamName.Dispose();
        HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_GenParamName);
        for (hv_IndexGenParam=0; (int)hv_IndexGenParam<=(int)((new HTuple(hv_GenParamName.TupleLength()
            ))-1); hv_IndexGenParam = (int)hv_IndexGenParam + 1)
        {
          if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_IndexGenParam))).TupleEqual(
              "ignore_missing_labels"))) != 0)
          {
            hv_IgnoreMissing.Dispose();
            HOperatorSet.GetDictTuple(hv_GenParam, "ignore_missing_labels", out hv_IgnoreMissing);
            if ((int)((new HTuple((new HTuple(hv_IgnoreMissing.TupleEqual(1))).TupleOr(
                new HTuple(hv_IgnoreMissing.TupleEqual(0))))).TupleNot()) != 0)
            {
              throw new HalconException("The GenParam ignore_missing_labels must be true or false.");
            }
          }
          else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_IndexGenParam))).TupleEqual(
              "instance_type"))) != 0)
          {
            if ((int)(new HTuple((new HTuple((new HTuple(((new HTuple("detection")).TupleConcat(
                "off")).TupleFind(hv_RestrictKeysDLSample))).TupleMax())).TupleEqual(
                -1))) != 0)
            {
              throw new HalconException("The GenParam instance_type can only be set for RestrictKeysDLSample detection or off.");
            }
            hv_InstanceType.Dispose();
            HOperatorSet.GetDictTuple(hv_GenParam, "instance_type", out hv_InstanceType);
            if ((int)(new HTuple((new HTuple((new HTuple(((new HTuple("rectangle1")).TupleConcat(
                "rectangle2")).TupleFind(hv_InstanceType))).TupleMax())).TupleEqual(
                -1))) != 0)
            {
              throw new HalconException("The GenParam instance_type must be either 'rectangle1' or 'rectangle2'.");
            }
          }
          else
          {
            throw new HalconException("Unknown GenParam key : "+(hv_GenParamName.TupleSelect(
                hv_IndexGenParam)));
          }
        }
      }
      //
      //Get the samples to be processed.
      hv_DLSamplesProc.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_DLSamplesProc = hv_DLSamples.TupleSelect(
          hv_SampleIndices);
      }
      //
      //Initialize the tuple for collection the DLSample dictionaries.
      hv_DLSampleBatch.Dispose();
      hv_DLSampleBatch = new HTuple();
      //
      //Set the BboxKeyList according to the InstanceType.
      if ((int)(new HTuple((new HTuple((new HTuple(((new HTuple("detection")).TupleConcat(
          "off")).TupleFind(hv_RestrictKeysDLSample))).TupleMax())).TupleNotEqual(
          -1))) != 0)
      {
        hv_BboxKeyList.Dispose();
        hv_BboxKeyList = new HTuple();
        hv_BboxKeyList[0] = "bbox_col1";
        hv_BboxKeyList[1] = "bbox_row1";
        hv_BboxKeyList[2] = "bbox_col2";
        hv_BboxKeyList[3] = "bbox_row2";
        if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
        {
          hv_BboxKeyList.Dispose();
          hv_BboxKeyList = new HTuple();
          hv_BboxKeyList[0] = "bbox_row";
          hv_BboxKeyList[1] = "bbox_col";
          hv_BboxKeyList[2] = "bbox_length1";
          hv_BboxKeyList[3] = "bbox_length2";
          hv_BboxKeyList[4] = "bbox_phi";
        }
      }
      //Loop over all selected samples and create a DLSample dictionary
      //for each dictionary in the DLDataset samples.
      for (hv_ImageIndex=0; (int)hv_ImageIndex<=(int)((new HTuple(hv_SampleIndices.TupleLength()
          ))-1); hv_ImageIndex = (int)hv_ImageIndex + 1)
      {
        //
        //Create the DLSample dictionary
        hv_DLSample.Dispose();
        HOperatorSet.CreateDict(out hv_DLSample);
        //
        //Set the image key.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ImageID.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex), "image_id", 
            out hv_ImageID);
        }
        HOperatorSet.SetDictTuple(hv_DLSample, "image_id", hv_ImageID);
        //
        //Read image.
        //The relative file path of the image is specified in image_name.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ImageName.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex), "image_file_name", 
            out hv_ImageName);
        }
        //
        if ((int)(new HTuple(((hv_ImageDir.TupleStrlen())).TupleEqual(0))) != 0)
        {
          hv_FileName.Dispose();
          hv_FileName = new HTuple(hv_ImageName);
        }
        else
        {
          hv_FileName.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_FileName = (hv_ImageDir+"/")+hv_ImageName;
          }
        }
        try
        {
          ho_ImageRaw.Dispose();
          HOperatorSet.ReadImage(out ho_ImageRaw, hv_FileName);
          //Insert image into dictionary.
          HOperatorSet.SetDictObject(ho_ImageRaw, hv_DLSample, "image");

          //ADD FOR DISPLAY
          DispImageAdaptively(ref hv_HWindowControl, ho_ImageRaw);
          if (hv_Progress_ForDisplay.Length != 0)
          {
              hv_Progress_ForDisplay[3] = "Images Count:" + loopCount + "/" + imageCount;
              HOperatorSet.DispText(hv_HWindowControl.HalconWindow, hv_Progress_ForDisplay, "window", "top", "left", "red", "box", "true");
          }
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException1)
        {
          HDevExpDefaultException1.ToHTuple(out hv_Exception);
          throw new HalconException((((("Error for reading/setting image "+hv_FileName)+" with ID ")+hv_ImageID)+" : Error code ")+(hv_Exception.TupleSelect(
              0)));
        }
        //
        //Read specific data.
        //
        if ((int)(new HTuple(hv_RestrictKeysDLSample.TupleNotEqual("image_only"))) != 0)
        {
          //
          //Transfer anomaly detection relevant data.
          if ((int)(new HTuple((new HTuple((new HTuple(((new HTuple("anomaly_detection")).TupleConcat(
              "off")).TupleFind(hv_RestrictKeysDLSample))).TupleMax())).TupleNotEqual(
              -1))) != 0)
          {
            //Check the existence of the label key.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_AnomalyLabelExists.Dispose();
            HOperatorSet.GetDictParam(hv_DLSamplesProc.TupleSelect(hv_ImageIndex), 
                "key_exists", "anomaly_label", out hv_AnomalyLabelExists);
            }
            if ((int)(hv_AnomalyLabelExists) != 0)
            {
              //Get the image label.
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_AnomalyLabel.Dispose();
              HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex), 
                  "anomaly_label", out hv_AnomalyLabel);
              }
              //Check the existence of the anomaly file name key. If not found it is just ignored.
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_AnomalyFileNameExists.Dispose();
              HOperatorSet.GetDictParam(hv_DLSamplesProc.TupleSelect(hv_ImageIndex), 
                  "key_exists", "anomaly_file_name", out hv_AnomalyFileNameExists);
              }
              if ((int)(hv_AnomalyFileNameExists) != 0)
              {
                //Get the ground truth anomaly directory.
                hv_AnomalyDir.Dispose();
                HOperatorSet.GetDictTuple(hv_DLDataset, "anomaly_dir", out hv_AnomalyDir);
                //Get the image file name.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_AnomalyFileName.Dispose();
                HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex), 
                    "anomaly_file_name", out hv_AnomalyFileName);
                }
                //Read the ground truth anomaly image.
                try
                {
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  ho_ImageAnomaly.Dispose();
                  HOperatorSet.ReadImage(out ho_ImageAnomaly, (hv_AnomalyDir+"/")+hv_AnomalyFileName);
                  }
                }
                // catch (ExceptionImageAnomaly) 
                catch (HalconException HDevExpDefaultException1)
                {
                  HDevExpDefaultException1.ToHTuple(out hv_ExceptionImageAnomaly);
                  //If the file is not an image, try to read the ground truth anomaly region.
                  //Then, convert this region to a ground truth anomaly image.
                  try
                  {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                    ho_RegionAnomaly.Dispose();
                    HOperatorSet.ReadRegion(out ho_RegionAnomaly, (hv_AnomalyDir+"/")+hv_AnomalyFileName);
                    }
                  }
                  // catch (ExceptionRegionAnomaly) 
                  catch (HalconException HDevExpDefaultException2)
                  {
                    HDevExpDefaultException2.ToHTuple(out hv_ExceptionRegionAnomaly);
                    throw new HalconException((("Error: Could not read the anomaly ground truth information of image_id "+hv_ImageID)+" : Error code ")+(hv_ExceptionImageAnomaly.TupleSelect(
                        0)));
                  }
                  hv_Width.Dispose();hv_Height.Dispose();
                  HOperatorSet.GetImageSize(ho_ImageRaw, out hv_Width, out hv_Height);
                  ho_ImageAnomaly.Dispose();
                  HOperatorSet.GenImageConst(out ho_ImageAnomaly, "byte", hv_Width, 
                      hv_Height);
                  HOperatorSet.OverpaintRegion(ho_ImageAnomaly, ho_ImageAnomaly, 
                      0, "fill");
                  HOperatorSet.OverpaintRegion(ho_ImageAnomaly, ho_RegionAnomaly, 
                      1, "fill");
                }
                //Insert anomaly image into DLSample dictionary.
                HOperatorSet.SetDictObject(ho_ImageAnomaly, hv_DLSample, "anomaly_ground_truth");
              }
              //
              //Insert anomaly label into DLSample dictionary.
              HOperatorSet.SetDictTuple(hv_DLSample, "anomaly_label", hv_AnomalyLabel);
              //Insert anomaly label id into DLSample dictionary.
              if ((int)(new HTuple(hv_AnomalyLabel.TupleEqual("nok"))) != 0)
              {
                HOperatorSet.SetDictTuple(hv_DLSample, "anomaly_label_id", 1);
              }
              else
              {
                HOperatorSet.SetDictTuple(hv_DLSample, "anomaly_label_id", 0);
              }
            }
            else if ((int)((new HTuple(hv_AnomalyLabelExists.TupleNot()
                )).TupleAnd(hv_IgnoreMissing.TupleNot())) != 0)
            {
              throw new HalconException(("For image_id "+hv_ImageID)+" the key 'anomaly_label' is missing. Missing keys can be ignored using the GenParam ignore_missing_labels.");
            }
          }
          //
          //Transfer classification relevant data.
          if ((int)(new HTuple((new HTuple((new HTuple(((new HTuple("classification")).TupleConcat(
              "off")).TupleFind(hv_RestrictKeysDLSample))).TupleMax())).TupleNotEqual(
              -1))) != 0)
          {
            //Check the existence of the required key.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ImageLabelIDExists.Dispose();
            HOperatorSet.GetDictParam(hv_DLSamplesProc.TupleSelect(hv_ImageIndex), 
                "key_exists", "image_label_id", out hv_ImageLabelIDExists);
            }
            if ((int)(hv_ImageLabelIDExists) != 0)
            {
              //Transfer the image label.
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_ImageLabelID.Dispose();
              HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex), 
                  "image_label_id", out hv_ImageLabelID);
              }
              HOperatorSet.SetDictTuple(hv_DLSample, "image_label_id", hv_ImageLabelID);
            }
            else if ((int)((new HTuple(hv_ImageLabelIDExists.TupleNot()
                )).TupleAnd(hv_IgnoreMissing.TupleNot())) != 0)
            {
              throw new HalconException(("For image_id "+hv_ImageID)+" the key 'image_label_id' is missing. Missing keys can be ignored using the GenParam ignore_missing_labels.");
            }
          }
          //
          //Transfer detection relevant data.
          if ((int)(new HTuple((new HTuple((new HTuple(((new HTuple("detection")).TupleConcat(
              "off")).TupleFind(hv_RestrictKeysDLSample))).TupleMax())).TupleNotEqual(
              -1))) != 0)
          {
            //Check the existence of the required key.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_BboxExists.Dispose();
            HOperatorSet.GetDictParam(hv_DLSamplesProc.TupleSelect(hv_ImageIndex), 
                "key_exists", "bbox_label_id", out hv_BboxExists);
            }
            if ((int)(hv_BboxExists) != 0)
            {
              //Transfer the bounding box labels.
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_BboxLabels.Dispose();
              HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex), 
                  "bbox_label_id", out hv_BboxLabels);
              }
              HOperatorSet.SetDictTuple(hv_DLSample, "bbox_label_id", hv_BboxLabels);
              //Transfer the bounding box coordinates.
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_KeysExist.Dispose();
              HOperatorSet.GetDictParam(hv_DLSamplesProc.TupleSelect(hv_ImageIndex), 
                  "key_exists", hv_BboxKeyList, out hv_KeysExist);
              }
              if ((int)((new HTuple(((hv_KeysExist.TupleSum())).TupleNotEqual(new HTuple(hv_KeysExist.TupleLength()
                  )))).TupleAnd(hv_IgnoreMissing.TupleNot())) != 0)
              {
                hv_MissingKeyIndices.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_MissingKeyIndices = ((hv_KeysExist.TupleEqualElem(
                    0))).TupleFind(1);
                }
                throw new HalconException((("For image_id "+hv_ImageID)+new HTuple(", an error has occurred when transferring the key "))+(hv_BboxKeyList.TupleSelect(
                    hv_MissingKeyIndices)));
              }
              for (hv_IndexParam=0; (int)hv_IndexParam<=(int)((new HTuple(hv_BboxKeyList.TupleLength()
                  ))-1); hv_IndexParam = (int)hv_IndexParam + 1)
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_BboxCoord.Dispose();
                HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex), 
                    hv_BboxKeyList.TupleSelect(hv_IndexParam), out hv_BboxCoord);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.SetDictTuple(hv_DLSample, hv_BboxKeyList.TupleSelect(
                    hv_IndexParam), hv_BboxCoord);
                }
              }
            }
            else if ((int)(hv_IgnoreMissing.TupleNot()) != 0)
            {
              throw new HalconException(("For image_id "+hv_ImageID)+" there is no key bbox_label_id. Missing keys can be ignored using the GenParam ignore_missing_labels.");
            }
          }
          //
          //Transfer segmentation relevant data.
          if ((int)(new HTuple((new HTuple((new HTuple(((new HTuple("segmentation")).TupleConcat(
              "off")).TupleFind(hv_RestrictKeysDLSample))).TupleMax())).TupleNotEqual(
              -1))) != 0)
          {
            //Check the existence of the required keys.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_SegKeyExists.Dispose();
            HOperatorSet.GetDictParam(hv_DLSamplesProc.TupleSelect(hv_ImageIndex), 
                "key_exists", "segmentation_file_name", out hv_SegKeyExists);
            }
            if ((int)(hv_SegKeyExists) != 0)
            {
              //Get the ground truth segmentation directory.
              hv_SegmentationDir.Dispose();
              HOperatorSet.GetDictTuple(hv_DLDataset, "segmentation_dir", out hv_SegmentationDir);
              //Get the image file name.
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_SegmentationName.Dispose();
              HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex), 
                  "segmentation_file_name", out hv_SegmentationName);
              }
              //Read the ground truth segmentation image.
              try
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                ho_ImageSegmentation.Dispose();
                HOperatorSet.ReadImage(out ho_ImageSegmentation, (hv_SegmentationDir+"/")+hv_SegmentationName);
                }
              }
              // catch (ExceptionSegmentation) 
              catch (HalconException HDevExpDefaultException1)
              {
                HDevExpDefaultException1.ToHTuple(out hv_ExceptionSegmentation);
                throw new HalconException((("Error for reading segmentation file of image_id "+hv_ImageID)+" : Error code ")+(hv_ExceptionSegmentation.TupleSelect(
                    0)));
              }
              //Insert image into DLSample dictionary.
              HOperatorSet.SetDictObject(ho_ImageSegmentation, hv_DLSample, "segmentation_image");
            }
            else if ((int)(hv_IgnoreMissing.TupleNot()) != 0)
            {
              throw new HalconException(("For image_id "+hv_ImageID)+" there is no key segmentation_file_name. Missing keys can be ignored using the GenParam ignore_missing_labels.");
            }
          }
        }
        //
        //Collect all data dictionaries of all processed indices.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_DLSampleBatch = hv_DLSampleBatch.TupleConcat(
            hv_DLSample);
        hv_DLSampleBatch.Dispose();
        hv_DLSampleBatch = ExpTmpLocalVar_DLSampleBatch;
        }
        }
      }
      ho_ImageRaw.Dispose();
      ho_ImageAnomaly.Dispose();
      ho_RegionAnomaly.Dispose();
      ho_ImageSegmentation.Dispose();

      hv_ImageDir.Dispose();
      hv_DLSamples.Dispose();
      hv_MinIndex.Dispose();
      hv_MaxIndex.Dispose();
      hv_InstanceType.Dispose();
      hv_IgnoreMissing.Dispose();
      hv_GenParamName.Dispose();
      hv_IndexGenParam.Dispose();
      hv_DLSamplesProc.Dispose();
      hv_BboxKeyList.Dispose();
      hv_ImageIndex.Dispose();
      hv_DLSample.Dispose();
      hv_ImageID.Dispose();
      hv_ImageName.Dispose();
      hv_FileName.Dispose();
      hv_Exception.Dispose();
      hv_AnomalyLabelExists.Dispose();
      hv_AnomalyLabel.Dispose();
      hv_AnomalyFileNameExists.Dispose();
      hv_AnomalyDir.Dispose();
      hv_AnomalyFileName.Dispose();
      hv_ExceptionImageAnomaly.Dispose();
      hv_ExceptionRegionAnomaly.Dispose();
      hv_Width.Dispose();
      hv_Height.Dispose();
      hv_ImageLabelIDExists.Dispose();
      hv_ImageLabelID.Dispose();
      hv_BboxExists.Dispose();
      hv_BboxLabels.Dispose();
      hv_KeysExist.Dispose();
      hv_MissingKeyIndices.Dispose();
      hv_IndexParam.Dispose();
      hv_BboxCoord.Dispose();
      hv_SegKeyExists.Dispose();
      hv_SegmentationDir.Dispose();
      hv_SegmentationName.Dispose();
      hv_ExceptionSegmentation.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_ImageRaw.Dispose();
      ho_ImageAnomaly.Dispose();
      ho_RegionAnomaly.Dispose();
      ho_ImageSegmentation.Dispose();

      hv_ImageDir.Dispose();
      hv_DLSamples.Dispose();
      hv_MinIndex.Dispose();
      hv_MaxIndex.Dispose();
      hv_InstanceType.Dispose();
      hv_IgnoreMissing.Dispose();
      hv_GenParamName.Dispose();
      hv_IndexGenParam.Dispose();
      hv_DLSamplesProc.Dispose();
      hv_BboxKeyList.Dispose();
      hv_ImageIndex.Dispose();
      hv_DLSample.Dispose();
      hv_ImageID.Dispose();
      hv_ImageName.Dispose();
      hv_FileName.Dispose();
      hv_Exception.Dispose();
      hv_AnomalyLabelExists.Dispose();
      hv_AnomalyLabel.Dispose();
      hv_AnomalyFileNameExists.Dispose();
      hv_AnomalyDir.Dispose();
      hv_AnomalyFileName.Dispose();
      hv_ExceptionImageAnomaly.Dispose();
      hv_ExceptionRegionAnomaly.Dispose();
      hv_Width.Dispose();
      hv_Height.Dispose();
      hv_ImageLabelIDExists.Dispose();
      hv_ImageLabelID.Dispose();
      hv_BboxExists.Dispose();
      hv_BboxLabels.Dispose();
      hv_KeysExist.Dispose();
      hv_MissingKeyIndices.Dispose();
      hv_IndexParam.Dispose();
      hv_BboxCoord.Dispose();
      hv_SegKeyExists.Dispose();
      hv_SegmentationDir.Dispose();
      hv_SegmentationName.Dispose();
      hv_ExceptionSegmentation.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Semantic Segmentation
  // Short Description: Generates weight images for the training dataset. 
  public void gen_dl_segmentation_weight_images (HTuple hv_DLDataset, HTuple hv_DLPreprocessParam, 
      HTuple hv_ClassWeights, HTuple hv_GenParam)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_SegmentationImage=null, ho_WeightImage=null;
    HObject ho_IgnoreRegion=null, ho_IgnoreRegionTmp=null, ho_ClassRegion=null;

    // Local control variables 

    HTuple hv_KeyExists = new HTuple(), hv_ClassIDs = new HTuple();
    HTuple hv_OverwriteFiles = new HTuple(), hv_GenParamKeys = new HTuple();
    HTuple hv_GenParamIndex = new HTuple(), hv_IgnoreClassIDs = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_DLSamples = new HTuple();
    HTuple hv_SampleIndices = new HTuple(), hv_InitNewImage = new HTuple();
    HTuple hv_SampleIndex = new HTuple(), hv_DLSample = new HTuple();
    HTuple hv_WeightImageExists = new HTuple(), hv_SampleImageID = new HTuple();
    HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
    HTuple hv_IgnoreIndex = new HTuple(), hv_IgnoreClassID = new HTuple();
    HTuple hv_ClassIndex = new HTuple(), hv_ClassID = new HTuple();
    HTuple hv_Weight = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_SegmentationImage);
    HOperatorSet.GenEmptyObj(out ho_WeightImage);
    HOperatorSet.GenEmptyObj(out ho_IgnoreRegion);
    HOperatorSet.GenEmptyObj(out ho_IgnoreRegionTmp);
    HOperatorSet.GenEmptyObj(out ho_ClassRegion);
    try
    {
      //
      //This procedure generates for each training sample in DLDataset a weight image,
      //that is used as input to the loss in a segmentation model.
      //The dictionary DLDataset needs a key 'dlsample_dir', assigning a directory
      //in which for every sample a dictionary DLSample has to exist.
      //The procedure reads for each training sample the dictionary DLSample,
      //generates a weight image according to the specified ClassWeights
      //and overwrites the DLSample with the updated sample including the weight image.
      //
      //Check input data.
      hv_KeyExists.Dispose();
      HOperatorSet.GetDictParam(hv_DLDataset, "key_exists", ((new HTuple("dlsample_dir")).TupleConcat(
          "samples")).TupleConcat("class_ids"), out hv_KeyExists);
      if ((int)(((hv_KeyExists.TupleSelect(0))).TupleNot()) != 0)
      {
        throw new HalconException("DLDataset needs a key-value pair for 'dlsample_dir'");
      }
      if ((int)(((hv_KeyExists.TupleSelect(1))).TupleNot()) != 0)
      {
        throw new HalconException("DLDataset needs a key-value pair for 'samples'");
      }
      if ((int)(((hv_KeyExists.TupleSelect(2))).TupleNot()) != 0)
      {
        throw new HalconException("DLDataset needs a key-value pair for 'class_ids'");
      }
      //
      hv_ClassIDs.Dispose();
      HOperatorSet.GetDictTuple(hv_DLDataset, "class_ids", out hv_ClassIDs);
      if ((int)(new HTuple(hv_ClassWeights.TupleEqual(new HTuple()))) != 0)
      {
        throw new HalconException("ClassWeights is empty");
      }
      else if ((int)((new HTuple((new HTuple(hv_ClassWeights.TupleLength()
          )).TupleNotEqual(new HTuple(hv_ClassIDs.TupleLength())))).TupleAnd(new HTuple((new HTuple(hv_ClassWeights.TupleLength()
          )).TupleNotEqual(1)))) != 0)
      {
        throw new HalconException("ClassWeights must be either a single value or of the same length as the DLDataset ClassIDs.");
      }
      //
      if ((int)(new HTuple(((((hv_ClassWeights.TupleLessElem(0))).TupleFind(1))).TupleGreater(
          -1))) != 0)
      {
        throw new HalconException("ClassWeights must be greater or equal zero.");
      }
      else if ((int)((new HTuple((new HTuple(hv_ClassWeights.TupleLength()
          )).TupleEqual(1))).TupleAnd(new HTuple(hv_ClassWeights.TupleLessEqual(0)))) != 0)
      {
        throw new HalconException(new HTuple("If only a single weight is given as ClassWeights, this must be greater than zero."));
      }
      //
      //Check the validity of the preprocessing parameters.
      check_dl_preprocess_param(hv_DLPreprocessParam);
      //
      //Set defaults.
      hv_OverwriteFiles.Dispose();
      hv_OverwriteFiles = 0;
      //
      //Overwrite defaults specified in GenParam.
      if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
      {
        hv_GenParamKeys.Dispose();
        HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_GenParamKeys);
        for (hv_GenParamIndex=0; (int)hv_GenParamIndex<=(int)((new HTuple(hv_GenParamKeys.TupleLength()
            ))-1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
        {
          if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
              "overwrite_files"))) != 0)
          {
            //Set parameter for overwriting files.
            hv_OverwriteFiles.Dispose();
            HOperatorSet.GetDictTuple(hv_GenParam, "overwrite_files", out hv_OverwriteFiles);
            if ((int)((new HTuple(hv_OverwriteFiles.TupleNotEqual(0))).TupleAnd(new HTuple(hv_OverwriteFiles.TupleNotEqual(
                1)))) != 0)
            {
              throw new HalconException("'overwrite_files' must be either true or false");
            }
          }
          else
          {
            throw new HalconException(("Unknown parameter: '"+(hv_GenParamKeys.TupleSelect(
                hv_GenParamIndex)))+"'");
          }
        }
      }
      //
      //Get the IDs of the classes to be ignored.
      try
      {
        hv_IgnoreClassIDs.Dispose();
        HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "ignore_class_ids", out hv_IgnoreClassIDs);
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        hv_IgnoreClassIDs.Dispose();
        hv_IgnoreClassIDs = new HTuple();
      }
      //
      //Get the samples from the dataset.
      hv_DLSamples.Dispose();
      HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLSamples);
      //
      //Get the indices of the samples belonging to the defined split.
      hv_SampleIndices.Dispose();
      find_dl_samples(hv_DLSamples, "split", "train", "or", out hv_SampleIndices);
      //
      //Get system info on init_new_image.
      hv_InitNewImage.Dispose();
      HOperatorSet.GetSystem("init_new_image", out hv_InitNewImage);
      //
      //Loop over training samples.
      for (hv_SampleIndex=0; (int)hv_SampleIndex<=(int)((new HTuple(hv_SampleIndices.TupleLength()
          ))-1); hv_SampleIndex = (int)hv_SampleIndex + 1)
      {
        //
        //Read the DLSample.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DLSample.Dispose();
        read_dl_samples(hv_DLDataset, hv_SampleIndices.TupleSelect(hv_SampleIndex), 
            out hv_DLSample);
        }
        //
        //Check if there is already a weight image in the DLSample.
        hv_WeightImageExists.Dispose();
        HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "weight_image", out hv_WeightImageExists);
        if ((int)(hv_WeightImageExists.TupleAnd(hv_OverwriteFiles.TupleNot())) != 0)
        {
          hv_SampleImageID.Dispose();
          HOperatorSet.GetDictTuple(hv_DLSample, "image_id", out hv_SampleImageID);
          throw new HalconException(("The DLSample with image_id "+hv_SampleImageID)+" already contains a weight image. Force overwriting using the parameter 'overwrite_files' to true.");
        }
        //
        //Get the segmentation image.
        ho_SegmentationImage.Dispose();
        HOperatorSet.GetDictObject(out ho_SegmentationImage, hv_DLSample, "segmentation_image");
        //
        //Generate the weight image.
        //
        //Initialize the weight image with 0.
        hv_ImageWidth.Dispose();hv_ImageHeight.Dispose();
        HOperatorSet.GetImageSize(ho_SegmentationImage, out hv_ImageWidth, out hv_ImageHeight);
        ho_WeightImage.Dispose();
        HOperatorSet.GenImageConst(out ho_WeightImage, "real", hv_ImageWidth, hv_ImageHeight);
        //Clear image.
        if ((int)(new HTuple(hv_InitNewImage.TupleEqual("false"))) != 0)
        {
          HOperatorSet.OverpaintRegion(ho_WeightImage, ho_WeightImage, 0, "fill");
        }
        //
        if ((int)(new HTuple((new HTuple(hv_ClassWeights.TupleLength())).TupleEqual(
            1))) != 0)
        {
          //Constant class weight.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.OverpaintRegion(ho_WeightImage, ho_WeightImage, hv_ClassWeights.TupleSelect(
              0), "fill");
          }
          //
          if ((int)(new HTuple((new HTuple(hv_IgnoreClassIDs.TupleLength())).TupleGreater(
              0))) != 0)
          {
            //Set ignore region to 0.
            ho_IgnoreRegion.Dispose();
            HOperatorSet.GenEmptyRegion(out ho_IgnoreRegion);
            for (hv_IgnoreIndex=0; (int)hv_IgnoreIndex<=(int)((new HTuple(hv_IgnoreClassIDs.TupleLength()
                ))-1); hv_IgnoreIndex = (int)hv_IgnoreIndex + 1)
            {
              hv_IgnoreClassID.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_IgnoreClassID = hv_IgnoreClassIDs.TupleSelect(
                  hv_IgnoreIndex);
              }
              ho_IgnoreRegionTmp.Dispose();
              HOperatorSet.Threshold(ho_SegmentationImage, out ho_IgnoreRegionTmp, 
                  hv_IgnoreClassID, hv_IgnoreClassID);
              {
              HObject ExpTmpOutVar_0;
              HOperatorSet.Union2(ho_IgnoreRegion, ho_IgnoreRegionTmp, out ExpTmpOutVar_0
                  );
              ho_IgnoreRegion.Dispose();
              ho_IgnoreRegion = ExpTmpOutVar_0;
              }
            }
            HOperatorSet.OverpaintRegion(ho_WeightImage, ho_IgnoreRegion, 0.0, "fill");
          }
        }
        else
        {
          //Loop over model ClassIDs.
          for (hv_ClassIndex=0; (int)hv_ClassIndex<=(int)((new HTuple(hv_ClassIDs.TupleLength()
              ))-1); hv_ClassIndex = (int)hv_ClassIndex + 1)
          {
            if ((int)((new HTuple(hv_IgnoreClassIDs.TupleEqual(new HTuple()))).TupleOr(
                new HTuple(((hv_IgnoreClassIDs.TupleFind(hv_ClassIDs.TupleSelect(
                hv_ClassIndex)))).TupleEqual(-1)))) != 0)
            {
              //Set the pixel values of the weight image according to ClassWeights.
              hv_ClassID.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_ClassID = hv_ClassIDs.TupleSelect(
                  hv_ClassIndex);
              }
              hv_Weight.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_Weight = hv_ClassWeights.TupleSelect(
                  hv_ClassIndex);
              }
              ho_ClassRegion.Dispose();
              HOperatorSet.Threshold(ho_SegmentationImage, out ho_ClassRegion, hv_ClassID, 
                  hv_ClassID);
              HOperatorSet.OverpaintRegion(ho_WeightImage, ho_ClassRegion, hv_Weight, 
                  "fill");
            }
            else
            {
              //Ignore class has weight 0 which is already set.
            }
          }
        }
        //
        //Add the weight image to DLSample.
        HOperatorSet.SetDictObject(ho_WeightImage, hv_DLSample, "weight_image");
        //
        //Write the updated DLSample.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        write_dl_samples(hv_DLDataset, hv_SampleIndices.TupleSelect(hv_SampleIndex), 
            hv_DLSample, new HTuple(), new HTuple());
        }
      }
      //
      //On success we store the class weights for later reference in the DLDataset.
      HOperatorSet.SetDictTuple(hv_DLDataset, "class_weights", hv_ClassWeights);
      //
      ho_SegmentationImage.Dispose();
      ho_WeightImage.Dispose();
      ho_IgnoreRegion.Dispose();
      ho_IgnoreRegionTmp.Dispose();
      ho_ClassRegion.Dispose();

      hv_KeyExists.Dispose();
      hv_ClassIDs.Dispose();
      hv_OverwriteFiles.Dispose();
      hv_GenParamKeys.Dispose();
      hv_GenParamIndex.Dispose();
      hv_IgnoreClassIDs.Dispose();
      hv_Exception.Dispose();
      hv_DLSamples.Dispose();
      hv_SampleIndices.Dispose();
      hv_InitNewImage.Dispose();
      hv_SampleIndex.Dispose();
      hv_DLSample.Dispose();
      hv_WeightImageExists.Dispose();
      hv_SampleImageID.Dispose();
      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_IgnoreIndex.Dispose();
      hv_IgnoreClassID.Dispose();
      hv_ClassIndex.Dispose();
      hv_ClassID.Dispose();
      hv_Weight.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_SegmentationImage.Dispose();
      ho_WeightImage.Dispose();
      ho_IgnoreRegion.Dispose();
      ho_IgnoreRegionTmp.Dispose();
      ho_ClassRegion.Dispose();

      hv_KeyExists.Dispose();
      hv_ClassIDs.Dispose();
      hv_OverwriteFiles.Dispose();
      hv_GenParamKeys.Dispose();
      hv_GenParamIndex.Dispose();
      hv_IgnoreClassIDs.Dispose();
      hv_Exception.Dispose();
      hv_DLSamples.Dispose();
      hv_SampleIndices.Dispose();
      hv_InitNewImage.Dispose();
      hv_SampleIndex.Dispose();
      hv_DLSample.Dispose();
      hv_WeightImageExists.Dispose();
      hv_SampleImageID.Dispose();
      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_IgnoreIndex.Dispose();
      hv_IgnoreClassID.Dispose();
      hv_ClassIndex.Dispose();
      hv_ClassID.Dispose();
      hv_Weight.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Anomaly Detection
  // Short Description: Get the ground truth anomaly label and label ID. 
  public void get_anomaly_ground_truth_label (HTuple hv_SampleKeys, HTuple hv_DLSample, 
      out HTuple hv_AnomalyLabelGroundTruth, out HTuple hv_AnomalyLabelIDGroundTruth)
  {


    // Initialize local and output iconic variables 
    hv_AnomalyLabelGroundTruth = new HTuple();
    hv_AnomalyLabelIDGroundTruth = new HTuple();
    //
    //This procedure returns the anomaly ground truth label.
    //
    if ((int)(new HTuple(((hv_SampleKeys.TupleFind("anomaly_label"))).TupleNotEqual(
        -1))) != 0)
    {
      hv_AnomalyLabelGroundTruth.Dispose();
      HOperatorSet.GetDictTuple(hv_DLSample, "anomaly_label", out hv_AnomalyLabelGroundTruth);
    }
    else
    {
      throw new HalconException("Ground truth class label cannot be found in DLSample.");
    }
    if ((int)(new HTuple(((hv_SampleKeys.TupleFind("anomaly_label_id"))).TupleNotEqual(
        -1))) != 0)
    {
      hv_AnomalyLabelIDGroundTruth.Dispose();
      HOperatorSet.GetDictTuple(hv_DLSample, "anomaly_label_id", out hv_AnomalyLabelIDGroundTruth);
    }
    else
    {
      throw new HalconException("Ground truth class label id cannot be found in DLSample.");
    }
    //


    return;
  }

  // Chapter: Deep Learning / Anomaly Detection
  // Short Description: Get the anomaly image out of DLResult. 
  public void get_anomaly_result (out HObject ho_AnomalyImage, HTuple hv_ResultKeys, 
      HTuple hv_DLResult, out HTuple hv_AnomalyScore, out HTuple hv_AnomalyClassID)
  {



    // Local control variables 

    HTuple hv_AnomalyImageExists = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_AnomalyImage);
    hv_AnomalyScore = new HTuple();
    hv_AnomalyClassID = new HTuple();
    try
    {
      //
      //This procedure returns the anomaly image of DLResult.
      //
      if ((int)(new HTuple(((hv_ResultKeys.TupleFind("anomaly_image"))).TupleNotEqual(
          -1))) != 0)
      {
        hv_AnomalyImageExists.Dispose();
        HOperatorSet.GetDictParam(hv_DLResult, "key_exists", "anomaly_image", out hv_AnomalyImageExists);
        if ((int)(hv_AnomalyImageExists) != 0)
        {
          ho_AnomalyImage.Dispose();
          HOperatorSet.GetDictObject(out ho_AnomalyImage, hv_DLResult, "anomaly_image");
        }
        else
        {
          throw new HalconException("Result anomaly image could not be found in DLResult.");
        }
      }
      else
      {
        throw new HalconException("Result anomaly image could not be found in DLResult.");
      }
      //
      //This procedure returns the anomaly score of DLResult.
      //
      if ((int)(new HTuple(((hv_ResultKeys.TupleFind("anomaly_score"))).TupleNotEqual(
          -1))) != 0)
      {
        hv_AnomalyScore.Dispose();
        HOperatorSet.GetDictTuple(hv_DLResult, "anomaly_score", out hv_AnomalyScore);
      }
      else
      {
        throw new HalconException("Result anomaly score could not be found in DLResult.");
      }
      //
      //This procedure returns the anomaly class id of DLResult.
      //
      if ((int)(new HTuple(((hv_ResultKeys.TupleFind("anomaly_class_id"))).TupleNotEqual(
          -1))) != 0)
      {
        hv_AnomalyClassID.Dispose();
        HOperatorSet.GetDictTuple(hv_DLResult, "anomaly_class_id", out hv_AnomalyClassID);
      }
      else
      {
        throw new HalconException("Result anomaly class ID could not be found in DLResult.");
      }

      hv_AnomalyImageExists.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_AnomalyImageExists.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Graphics / Window
  // Short Description: Get the next child window that can be used for visualization. 
  public void get_child_window (HTuple hv_HeightImage, HTuple hv_Font, HTuple hv_FontSize, 
      HTuple hv_Text, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict, 
      HTuple hv_WindowHandleKey, out HTuple hv_WindowImageRatio, out HTuple hv_PrevWindowCoordinatesOut)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_OpenNewWindow = new HTuple(), hv_WindowHandles = new HTuple();
    HTuple hv_ParentWindowHandle = new HTuple(), hv_ChildWindowHandle = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_MetaInfo = new HTuple();
    HTuple hv_WindowRow = new HTuple(), hv_WindowColumn = new HTuple();
    HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
    // Initialize local and output iconic variables 
    hv_WindowImageRatio = new HTuple();
    hv_PrevWindowCoordinatesOut = new HTuple();
    try
    {
      //
      //This procedure returns the next child window that
      //is used for visualization. If ReuseWindows is true
      //and WindowHandleList is suitable, the window handles
      //that are passed over are used. Else, this procedure
      //opens a new window, either next to the last ones, or
      //in a new row.
      //
      //First, check if the requested window is already available.
      hv_OpenNewWindow.Dispose();
      hv_OpenNewWindow = 0;
      try
      {
        hv_WindowHandles.Dispose();
        HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, out hv_WindowHandles);
        hv_ParentWindowHandle.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ParentWindowHandle = hv_WindowHandles.TupleSelect(
            0);
        }
        hv_ChildWindowHandle.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ChildWindowHandle = hv_WindowHandles.TupleSelect(
            1);
        }
        //Check if window handle is valid.
        try
        {
          HOperatorSet.FlushBuffer(hv_ChildWindowHandle);
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException2)
        {
          HDevExpDefaultException2.ToHTuple(out hv_Exception);
          //Since there is something wrong with the current window, create a new one.
          hv_OpenNewWindow.Dispose();
          hv_OpenNewWindow = 1;
        }
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        hv_OpenNewWindow.Dispose();
        hv_OpenNewWindow = 1;
      }
      //
      //Get next child window.
      if ((int)(hv_OpenNewWindow.TupleNot()) != 0)
      {
        //
        //If possible, reuse existing window handles.
        HDevWindowStack.SetActive(hv_ChildWindowHandle);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
        }
        set_display_font(hv_ChildWindowHandle, hv_FontSize, hv_Font, "true", "false");
        //
        hv_MetaInfo.Dispose();
        HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
        //
        //Get previous window coordinates.
        hv_WindowRow.Dispose();hv_WindowColumn.Dispose();hv_WindowWidth.Dispose();hv_WindowHeight.Dispose();
        HOperatorSet.GetWindowExtents(hv_ParentWindowHandle, out hv_WindowRow, out hv_WindowColumn, 
            out hv_WindowWidth, out hv_WindowHeight);
        hv_WindowImageRatio.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_WindowImageRatio = hv_WindowHeight/(hv_HeightImage*1.0);
        }
        //
        try
        {
          //
          //Get WindowImageRatio from parent window.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_WindowImageRatio.Dispose();
          HOperatorSet.GetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_window_image_ratio_height", 
              out hv_WindowImageRatio);
          }
          //
          //Get previous window coordinates.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_PrevWindowCoordinatesOut.Dispose();
          HOperatorSet.GetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_child_window_coordinates", 
              out hv_PrevWindowCoordinatesOut);
          }
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException1)
        {
          HDevExpDefaultException1.ToHTuple(out hv_Exception);
          //
          //Set WindowImageRatio from parent window.
          hv_WindowRow.Dispose();hv_WindowColumn.Dispose();hv_WindowWidth.Dispose();hv_WindowHeight.Dispose();
          HOperatorSet.GetWindowExtents(hv_ParentWindowHandle, out hv_WindowRow, 
              out hv_WindowColumn, out hv_WindowWidth, out hv_WindowHeight);
          hv_WindowImageRatio.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_WindowImageRatio = hv_WindowHeight/(hv_HeightImage*1.0);
          }
          //
          //Set previous window coordinates.
          if (hv_PrevWindowCoordinatesOut == null)
            hv_PrevWindowCoordinatesOut = new HTuple();
          hv_PrevWindowCoordinatesOut[0] = hv_WindowRow;
          if (hv_PrevWindowCoordinatesOut == null)
            hv_PrevWindowCoordinatesOut = new HTuple();
          hv_PrevWindowCoordinatesOut[1] = hv_WindowColumn;
          if (hv_PrevWindowCoordinatesOut == null)
            hv_PrevWindowCoordinatesOut = new HTuple();
          hv_PrevWindowCoordinatesOut[2] = hv_WindowWidth;
          if (hv_PrevWindowCoordinatesOut == null)
            hv_PrevWindowCoordinatesOut = new HTuple();
          hv_PrevWindowCoordinatesOut[3] = hv_WindowHeight;
        }
      }
      else
      {
        //
        //Open a new child window.
        hv_ChildWindowHandle.Dispose();hv_PrevWindowCoordinatesOut.Dispose();
        open_child_window(hv_ParentWindowHandle, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates, 
            hv_WindowHandleDict, hv_WindowHandleKey, out hv_ChildWindowHandle, out hv_PrevWindowCoordinatesOut);
        HOperatorSet.SetWindowParam(hv_ChildWindowHandle, "flush", "false");
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, hv_ParentWindowHandle.TupleConcat(
            hv_ChildWindowHandle));
        }
      }
      //

      hv_OpenNewWindow.Dispose();
      hv_WindowHandles.Dispose();
      hv_ParentWindowHandle.Dispose();
      hv_ChildWindowHandle.Dispose();
      hv_Exception.Dispose();
      hv_MetaInfo.Dispose();
      hv_WindowRow.Dispose();
      hv_WindowColumn.Dispose();
      hv_WindowWidth.Dispose();
      hv_WindowHeight.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_OpenNewWindow.Dispose();
      hv_WindowHandles.Dispose();
      hv_ParentWindowHandle.Dispose();
      hv_ChildWindowHandle.Dispose();
      hv_Exception.Dispose();
      hv_MetaInfo.Dispose();
      hv_WindowRow.Dispose();
      hv_WindowColumn.Dispose();
      hv_WindowWidth.Dispose();
      hv_WindowHeight.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Classification
  // Short Description: Get the ground truth classification label id. 
  public void get_classification_ground_truth (HTuple hv_SampleKeys, HTuple hv_DLSample, 
      out HTuple hv_ClassificationLabelIDGroundTruth)
  {


    // Initialize local and output iconic variables 
    hv_ClassificationLabelIDGroundTruth = new HTuple();
    //
    //This procedure returns the classification ground truth label ID.
    //
    if ((int)(new HTuple(((hv_SampleKeys.TupleFind("image_label_id"))).TupleNotEqual(
        -1))) != 0)
    {
      hv_ClassificationLabelIDGroundTruth.Dispose();
      HOperatorSet.GetDictTuple(hv_DLSample, "image_label_id", out hv_ClassificationLabelIDGroundTruth);
    }
    else
    {
      throw new HalconException("Ground truth class label cannot be found in DLSample.");
    }
    //


    return;
  }

  // Chapter: Deep Learning / Classification
  // Short Description: Get the predicted classification class ID. 
  public void get_classification_result (HTuple hv_ResultKeys, HTuple hv_DLResult, 
      out HTuple hv_ClassificationClassID)
  {



    // Local iconic variables 
    // Initialize local and output iconic variables 
    hv_ClassificationClassID = new HTuple();
    //
    //This procedure returns the predicted classification class ID.
    //
    if ((int)(new HTuple(((hv_ResultKeys.TupleFind("classification_class_ids"))).TupleNotEqual(
        -1))) != 0)
    {
      hv_ClassificationClassID.Dispose();
      HOperatorSet.GetDictTuple(hv_DLResult, "classification_class_ids", out hv_ClassificationClassID);
      if ((int)(new HTuple((new HTuple(hv_ClassificationClassID.TupleLength())).TupleGreater(
          0))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ClassificationClassID = hv_ClassificationClassID.TupleSelect(
            0);
        hv_ClassificationClassID.Dispose();
        hv_ClassificationClassID = ExpTmpLocalVar_ClassificationClassID;
        }
        }
      }
    }
    else
    {
      throw new HalconException("Key entry 'classification_class_ids' could not be found in DLResult.");
    }
    //


    return;
  }

  // Chapter: Deep Learning / Semantic Segmentation
  // Short Description: Get the confidences of the segmentation result. 
  public void get_confidence_image (out HObject ho_ImageConfidence, HTuple hv_ResultKeys, 
      HTuple hv_DLResult)
  {


    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImageConfidence);
    //
    //This procedure returns confidences of the segmentation result.
    //
    if ((int)(new HTuple(((hv_ResultKeys.TupleFind("segmentation_confidence"))).TupleNotEqual(
        -1))) != 0)
    {
      ho_ImageConfidence.Dispose();
      HOperatorSet.GetDictObject(out ho_ImageConfidence, hv_DLResult, "segmentation_confidence");
    }
    else if ((int)(new HTuple(((hv_ResultKeys.TupleFind("segmentation_confidences"))).TupleNotEqual(
        -1))) != 0)
    {
      ho_ImageConfidence.Dispose();
      HOperatorSet.GetDictObject(out ho_ImageConfidence, hv_DLResult, "segmentation_confidences");
    }
    else
    {
      throw new HalconException("Confidence image could not be found in DLSample.");
    }


    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: Generate NumColors distinct colors 
  public void get_distinct_colors_dl_visualization (HTuple hv_NumColors, HTuple hv_Random, 
      HTuple hv_StartColor, HTuple hv_EndColor, out HTuple hv_Colors)
  {



      // Local iconic variables 

      HObject ho_HLSImageH, ho_HLSImageL, ho_HLSImageS;
      HObject ho_ImageR, ho_ImageG, ho_ImageB;

      // Local control variables 

      HTuple hv_IsString = new HTuple(), hv_Hue = new HTuple();
      HTuple hv_Lightness = new HTuple(), hv_Saturation = new HTuple();
      HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
      HTuple hv_Red = new HTuple(), hv_Green = new HTuple();
      HTuple hv_Blue = new HTuple();
      HTuple   hv_EndColor_COPY_INP_TMP = new HTuple(hv_EndColor);
      HTuple   hv_Random_COPY_INP_TMP = new HTuple(hv_Random);

      // Initialize local and output iconic variables 
      HOperatorSet.GenEmptyObj(out ho_HLSImageH);
      HOperatorSet.GenEmptyObj(out ho_HLSImageL);
      HOperatorSet.GenEmptyObj(out ho_HLSImageS);
      HOperatorSet.GenEmptyObj(out ho_ImageR);
      HOperatorSet.GenEmptyObj(out ho_ImageG);
      HOperatorSet.GenEmptyObj(out ho_ImageB);
      hv_Colors = new HTuple();
      try
      {
      //
      //We get distinct color-values first in HLS color-space.
      //Assumes hue [0, EndColor), lightness [0, 1), saturation [0, 1).
      //
      //Parameter checks.
      //NumColors.
      if ((int)(new HTuple(hv_NumColors.TupleLess(1))) != 0)
      {
        throw new HalconException("NumColors should be at least 1");
      }
      if ((int)(((hv_NumColors.TupleIsInt())).TupleNot()) != 0)
      {
        throw new HalconException("NumColors should be of type int");
      }
      if ((int)(new HTuple((new HTuple(hv_NumColors.TupleLength())).TupleNotEqual(
          1))) != 0)
      {
        throw new HalconException("NumColors should have length 1");
      }
      //Random.
      if ((int)((new HTuple(hv_Random_COPY_INP_TMP.TupleNotEqual(0))).TupleAnd(new HTuple(hv_Random_COPY_INP_TMP.TupleNotEqual(
          1)))) != 0)
      {
        hv_IsString.Dispose();
        HOperatorSet.TupleIsString(hv_Random_COPY_INP_TMP, out hv_IsString);
        if ((int)(hv_IsString) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_Random = (new HTuple(hv_Random_COPY_INP_TMP.TupleEqual(
              "true"))).TupleOr("false");
          hv_Random_COPY_INP_TMP.Dispose();
          hv_Random_COPY_INP_TMP = ExpTmpLocalVar_Random;
          }
          }
        }
        else
        {
          throw new HalconException("Random should be either true or false");
        }
      }
      //StartColor.
      if ((int)(new HTuple((new HTuple(hv_StartColor.TupleLength())).TupleNotEqual(
          1))) != 0)
      {
        throw new HalconException("StartColor should have length 1");
      }
      if ((int)((new HTuple(hv_StartColor.TupleLess(0))).TupleOr(new HTuple(hv_StartColor.TupleGreater(
          255)))) != 0)
      {
        throw new HalconException(new HTuple("StartColor should be in the range [0, 255]"));
      }
      if ((int)(((hv_StartColor.TupleIsInt())).TupleNot()) != 0)
      {
        throw new HalconException("StartColor should be of type int");
      }
      //EndColor.
      if ((int)(new HTuple((new HTuple(hv_EndColor_COPY_INP_TMP.TupleLength())).TupleNotEqual(
          1))) != 0)
      {
        throw new HalconException("EndColor should have length 1");
      }
      if ((int)((new HTuple(hv_EndColor_COPY_INP_TMP.TupleLess(0))).TupleOr(new HTuple(hv_EndColor_COPY_INP_TMP.TupleGreater(
          255)))) != 0)
      {
        throw new HalconException(new HTuple("EndColor should be in the range [0, 255]"));
      }
      if ((int)(((hv_EndColor_COPY_INP_TMP.TupleIsInt())).TupleNot()) != 0)
      {
        throw new HalconException("EndColor should be of type int");
      }
      //
      //Color generation.
      if ((int)(new HTuple(hv_StartColor.TupleGreater(hv_EndColor_COPY_INP_TMP))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_EndColor = hv_EndColor_COPY_INP_TMP+255;
        hv_EndColor_COPY_INP_TMP.Dispose();
        hv_EndColor_COPY_INP_TMP = ExpTmpLocalVar_EndColor;
        }
        }
      }
      if ((int)(new HTuple(hv_NumColors.TupleNotEqual(1))) != 0)
      {
        hv_Hue.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Hue = (hv_StartColor+(((((hv_EndColor_COPY_INP_TMP-hv_StartColor)*((HTuple.TupleGenSequence(
            0,hv_NumColors-1,1)).TupleReal()))/(((hv_NumColors-1)).TupleReal()))).TupleInt()
            ))%255;
        }
      }
      else
      {
        hv_Hue.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Hue = ((hv_StartColor.TupleConcat(
            hv_EndColor_COPY_INP_TMP))).TupleMean();
        }
      }
      if ((int)(hv_Random_COPY_INP_TMP) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Hue = hv_Hue.TupleSelect(
            (HTuple.TupleRand(hv_NumColors)).TupleSortIndex());
        hv_Hue.Dispose();
        hv_Hue = ExpTmpLocalVar_Hue;
        }
        }
        hv_Lightness.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Lightness = ((((5.0+HTuple.TupleRand(
            hv_NumColors))*255.0)/10.0)).TupleInt();
        }
        hv_Saturation.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Saturation = ((((9.0+HTuple.TupleRand(
            hv_NumColors))*255.0)/10.0)).TupleInt();
        }
      }
      else
      {
        hv_Lightness.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Lightness = ((HTuple.TupleGenConst(
            hv_NumColors,0.55)*255.0)).TupleInt();
        }
        hv_Saturation.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Saturation = ((HTuple.TupleGenConst(
            hv_NumColors,0.95)*255.0)).TupleInt();
        }
      }
      //
      //Write colors to a 3-channel image in order to transform easier.
      ho_HLSImageH.Dispose();
      HOperatorSet.GenImageConst(out ho_HLSImageH, "byte", 1, hv_NumColors);
      ho_HLSImageL.Dispose();
      HOperatorSet.GenImageConst(out ho_HLSImageL, "byte", 1, hv_NumColors);
      ho_HLSImageS.Dispose();
      HOperatorSet.GenImageConst(out ho_HLSImageS, "byte", 1, hv_NumColors);
      hv_Rows.Dispose();hv_Columns.Dispose();
      HOperatorSet.GetRegionPoints(ho_HLSImageH, out hv_Rows, out hv_Columns);
      HOperatorSet.SetGrayval(ho_HLSImageH, hv_Rows, hv_Columns, hv_Hue);
      HOperatorSet.SetGrayval(ho_HLSImageL, hv_Rows, hv_Columns, hv_Lightness);
      HOperatorSet.SetGrayval(ho_HLSImageS, hv_Rows, hv_Columns, hv_Saturation);
      //
      //Convert from HLS to RGB.
      ho_ImageR.Dispose();ho_ImageG.Dispose();ho_ImageB.Dispose();
      HOperatorSet.TransToRgb(ho_HLSImageH, ho_HLSImageL, ho_HLSImageS, out ho_ImageR, 
          out ho_ImageG, out ho_ImageB, "hls");
      //
      //Get RGB-values and transform to Hex.
      hv_Red.Dispose();
      HOperatorSet.GetGrayval(ho_ImageR, hv_Rows, hv_Columns, out hv_Red);
      hv_Green.Dispose();
      HOperatorSet.GetGrayval(ho_ImageG, hv_Rows, hv_Columns, out hv_Green);
      hv_Blue.Dispose();
      HOperatorSet.GetGrayval(ho_ImageB, hv_Rows, hv_Columns, out hv_Blue);
      hv_Colors.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Colors = (("#"+(hv_Red.TupleString(
          "02x")))+(hv_Green.TupleString("02x")))+(hv_Blue.TupleString("02x"));
      }
      ho_HLSImageH.Dispose();
      ho_HLSImageL.Dispose();
      ho_HLSImageS.Dispose();
      ho_ImageR.Dispose();
      ho_ImageG.Dispose();
      ho_ImageB.Dispose();

      hv_EndColor_COPY_INP_TMP.Dispose();
      hv_Random_COPY_INP_TMP.Dispose();
      hv_IsString.Dispose();
      hv_Hue.Dispose();
      hv_Lightness.Dispose();
      hv_Saturation.Dispose();
      hv_Rows.Dispose();
      hv_Columns.Dispose();
      hv_Red.Dispose();
      hv_Green.Dispose();
      hv_Blue.Dispose();

      return;
      //
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_HLSImageH.Dispose();
      ho_HLSImageL.Dispose();
      ho_HLSImageS.Dispose();
      ho_ImageR.Dispose();
      ho_ImageG.Dispose();
      ho_ImageB.Dispose();

      hv_EndColor_COPY_INP_TMP.Dispose();
      hv_Random_COPY_INP_TMP.Dispose();
      hv_IsString.Dispose();
      hv_Hue.Dispose();
      hv_Lightness.Dispose();
      hv_Saturation.Dispose();
      hv_Rows.Dispose();
      hv_Columns.Dispose();
      hv_Red.Dispose();
      hv_Green.Dispose();
      hv_Blue.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: Generate NumColors distinct colors 
  public void get_distinct_colors_dev_display_pie_chart (HTuple hv_NumColors, HTuple hv_Random, 
      HTuple hv_StartColor, HTuple hv_EndColor, out HTuple hv_Colors)
  {



      // Local iconic variables 

      HObject ho_HLSImageH, ho_HLSImageL, ho_HLSImageS;
      HObject ho_ImageR, ho_ImageG, ho_ImageB;

      // Local control variables 

      HTuple hv_IsString = new HTuple(), hv_Hue = new HTuple();
      HTuple hv_Lightness = new HTuple(), hv_Saturation = new HTuple();
      HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
      HTuple hv_Red = new HTuple(), hv_Green = new HTuple();
      HTuple hv_Blue = new HTuple();
      HTuple   hv_EndColor_COPY_INP_TMP = new HTuple(hv_EndColor);
      HTuple   hv_Random_COPY_INP_TMP = new HTuple(hv_Random);

      // Initialize local and output iconic variables 
      HOperatorSet.GenEmptyObj(out ho_HLSImageH);
      HOperatorSet.GenEmptyObj(out ho_HLSImageL);
      HOperatorSet.GenEmptyObj(out ho_HLSImageS);
      HOperatorSet.GenEmptyObj(out ho_ImageR);
      HOperatorSet.GenEmptyObj(out ho_ImageG);
      HOperatorSet.GenEmptyObj(out ho_ImageB);
      hv_Colors = new HTuple();
      try
      {
      //
      //We get distinct color-values first in HLS color-space.
      //Assumes hue [0, EndColor), lightness [0, 1), saturation [0, 1).
      //
      //Parameter checks.
      //NumColors.
      if ((int)(new HTuple(hv_NumColors.TupleLess(1))) != 0)
      {
        throw new HalconException("NumColors should be at least 1");
      }
      if ((int)(((hv_NumColors.TupleIsInt())).TupleNot()) != 0)
      {
        throw new HalconException("NumColors should be of type int");
      }
      if ((int)(new HTuple((new HTuple(hv_NumColors.TupleLength())).TupleNotEqual(
          1))) != 0)
      {
        throw new HalconException("NumColors should have length 1");
      }
      //Random.
      if ((int)((new HTuple(hv_Random_COPY_INP_TMP.TupleNotEqual(0))).TupleAnd(new HTuple(hv_Random_COPY_INP_TMP.TupleNotEqual(
          1)))) != 0)
      {
        hv_IsString.Dispose();
        HOperatorSet.TupleIsString(hv_Random_COPY_INP_TMP, out hv_IsString);
        if ((int)(hv_IsString) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_Random = (new HTuple(hv_Random_COPY_INP_TMP.TupleEqual(
              "true"))).TupleOr("false");
          hv_Random_COPY_INP_TMP.Dispose();
          hv_Random_COPY_INP_TMP = ExpTmpLocalVar_Random;
          }
          }
        }
        else
        {
          throw new HalconException("Random should be either true or false");
        }
      }
      //StartColor.
      if ((int)(new HTuple((new HTuple(hv_StartColor.TupleLength())).TupleNotEqual(
          1))) != 0)
      {
        throw new HalconException("StartColor should have length 1");
      }
      if ((int)((new HTuple(hv_StartColor.TupleLess(0))).TupleOr(new HTuple(hv_StartColor.TupleGreater(
          255)))) != 0)
      {
        throw new HalconException(new HTuple("StartColor should be in the range [0, 255]"));
      }
      if ((int)(((hv_StartColor.TupleIsInt())).TupleNot()) != 0)
      {
        throw new HalconException("StartColor should be of type int");
      }
      //EndColor.
      if ((int)(new HTuple((new HTuple(hv_EndColor_COPY_INP_TMP.TupleLength())).TupleNotEqual(
          1))) != 0)
      {
        throw new HalconException("EndColor should have length 1");
      }
      if ((int)((new HTuple(hv_EndColor_COPY_INP_TMP.TupleLess(0))).TupleOr(new HTuple(hv_EndColor_COPY_INP_TMP.TupleGreater(
          255)))) != 0)
      {
        throw new HalconException(new HTuple("EndColor should be in the range [0, 255]"));
      }
      if ((int)(((hv_EndColor_COPY_INP_TMP.TupleIsInt())).TupleNot()) != 0)
      {
        throw new HalconException("EndColor should be of type int");
      }
      //
      //Color generation.
      if ((int)(new HTuple(hv_StartColor.TupleGreater(hv_EndColor_COPY_INP_TMP))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_EndColor = hv_EndColor_COPY_INP_TMP+255;
        hv_EndColor_COPY_INP_TMP.Dispose();
        hv_EndColor_COPY_INP_TMP = ExpTmpLocalVar_EndColor;
        }
        }
      }
      if ((int)(new HTuple(hv_NumColors.TupleNotEqual(1))) != 0)
      {
        hv_Hue.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Hue = (hv_StartColor+(((((hv_EndColor_COPY_INP_TMP-hv_StartColor)*((HTuple.TupleGenSequence(
            0,hv_NumColors-1,1)).TupleReal()))/(((hv_NumColors-1)).TupleReal()))).TupleInt()
            ))%255;
        }
      }
      else
      {
        hv_Hue.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Hue = ((hv_StartColor.TupleConcat(
            hv_EndColor_COPY_INP_TMP))).TupleMean();
        }
      }
      if ((int)(hv_Random_COPY_INP_TMP) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Hue = hv_Hue.TupleSelect(
            (HTuple.TupleRand(hv_NumColors)).TupleSortIndex());
        hv_Hue.Dispose();
        hv_Hue = ExpTmpLocalVar_Hue;
        }
        }
        hv_Lightness.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Lightness = ((((5.0+HTuple.TupleRand(
            hv_NumColors))*255.0)/10.0)).TupleInt();
        }
        hv_Saturation.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Saturation = ((((9.0+HTuple.TupleRand(
            hv_NumColors))*255.0)/10.0)).TupleInt();
        }
      }
      else
      {
        hv_Lightness.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Lightness = ((HTuple.TupleGenConst(
            hv_NumColors,0.55)*255.0)).TupleInt();
        }
        hv_Saturation.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Saturation = ((HTuple.TupleGenConst(
            hv_NumColors,0.95)*255.0)).TupleInt();
        }
      }
      //
      //Write colors to a 3-channel image in order to transform easier.
      ho_HLSImageH.Dispose();
      HOperatorSet.GenImageConst(out ho_HLSImageH, "byte", 1, hv_NumColors);
      ho_HLSImageL.Dispose();
      HOperatorSet.GenImageConst(out ho_HLSImageL, "byte", 1, hv_NumColors);
      ho_HLSImageS.Dispose();
      HOperatorSet.GenImageConst(out ho_HLSImageS, "byte", 1, hv_NumColors);
      hv_Rows.Dispose();hv_Columns.Dispose();
      HOperatorSet.GetRegionPoints(ho_HLSImageH, out hv_Rows, out hv_Columns);
      HOperatorSet.SetGrayval(ho_HLSImageH, hv_Rows, hv_Columns, hv_Hue);
      HOperatorSet.SetGrayval(ho_HLSImageL, hv_Rows, hv_Columns, hv_Lightness);
      HOperatorSet.SetGrayval(ho_HLSImageS, hv_Rows, hv_Columns, hv_Saturation);
      //
      //Convert from HLS to RGB.
      ho_ImageR.Dispose();ho_ImageG.Dispose();ho_ImageB.Dispose();
      HOperatorSet.TransToRgb(ho_HLSImageH, ho_HLSImageL, ho_HLSImageS, out ho_ImageR, 
          out ho_ImageG, out ho_ImageB, "hls");
      //
      //Get RGB-values and transform to Hex.
      hv_Red.Dispose();
      HOperatorSet.GetGrayval(ho_ImageR, hv_Rows, hv_Columns, out hv_Red);
      hv_Green.Dispose();
      HOperatorSet.GetGrayval(ho_ImageG, hv_Rows, hv_Columns, out hv_Green);
      hv_Blue.Dispose();
      HOperatorSet.GetGrayval(ho_ImageB, hv_Rows, hv_Columns, out hv_Blue);
      hv_Colors.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Colors = (("#"+(hv_Red.TupleString(
          "02x")))+(hv_Green.TupleString("02x")))+(hv_Blue.TupleString("02x"));
      }
      ho_HLSImageH.Dispose();
      ho_HLSImageL.Dispose();
      ho_HLSImageS.Dispose();
      ho_ImageR.Dispose();
      ho_ImageG.Dispose();
      ho_ImageB.Dispose();

      hv_EndColor_COPY_INP_TMP.Dispose();
      hv_Random_COPY_INP_TMP.Dispose();
      hv_IsString.Dispose();
      hv_Hue.Dispose();
      hv_Lightness.Dispose();
      hv_Saturation.Dispose();
      hv_Rows.Dispose();
      hv_Columns.Dispose();
      hv_Red.Dispose();
      hv_Green.Dispose();
      hv_Blue.Dispose();

      return;
      //
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_HLSImageH.Dispose();
      ho_HLSImageL.Dispose();
      ho_HLSImageS.Dispose();
      ho_ImageR.Dispose();
      ho_ImageG.Dispose();
      ho_ImageB.Dispose();

      hv_EndColor_COPY_INP_TMP.Dispose();
      hv_Random_COPY_INP_TMP.Dispose();
      hv_IsString.Dispose();
      hv_Hue.Dispose();
      hv_Lightness.Dispose();
      hv_Saturation.Dispose();
      hv_Rows.Dispose();
      hv_Columns.Dispose();
      hv_Red.Dispose();
      hv_Green.Dispose();
      hv_Blue.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: Generates certain colors for different ClassNames 
  public void get_dl_class_colors (HTuple hv_ClassNames, out HTuple hv_Colors)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_NumColors = new HTuple(), hv_ColorsRainbow = new HTuple();
    HTuple hv_ClassNamesGood = new HTuple(), hv_IndexFind = new HTuple();
    HTuple hv_GoodIdx = new HTuple(), hv_CurrentColor = new HTuple();
    HTuple hv_GreenIdx = new HTuple();
    // Initialize local and output iconic variables 
    hv_Colors = new HTuple();
    try
    {
      //
      //This procedure returns for each class a certain color.
      //
      //Define distinct colors for the classes.
      hv_NumColors.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NumColors = new HTuple(hv_ClassNames.TupleLength()
          );
      }
      //Get distinct colors without randomness makes neighboring colors look very similar.
      //We use a workaround to get deterministic colors where subsequent colors are distinguishable.
      hv_ColorsRainbow.Dispose();
      get_distinct_colors_dl_visualization(hv_NumColors, 0, 0, 200, out hv_ColorsRainbow);
      {
      HTuple ExpTmpOutVar_0;
      HOperatorSet.TupleInverse(hv_ColorsRainbow, out ExpTmpOutVar_0);
      hv_ColorsRainbow.Dispose();
      hv_ColorsRainbow = ExpTmpOutVar_0;
      }
      hv_Colors.Dispose();
      make_neighboring_colors_distinguishable(hv_ColorsRainbow, out hv_Colors);
      //If a class 'OK','ok', 'good' or 'GOOD' is present set this class to green.
      //Only the first occurrence found is set to a green shade.
      hv_ClassNamesGood.Dispose();
      hv_ClassNamesGood = new HTuple();
      hv_ClassNamesGood[0] = "good";
      hv_ClassNamesGood[1] = "GOOD";
      hv_ClassNamesGood[2] = "ok";
      hv_ClassNamesGood[3] = "OK";
      for (hv_IndexFind=0; (int)hv_IndexFind<=(int)((new HTuple(hv_ClassNamesGood.TupleLength()
          ))-1); hv_IndexFind = (int)hv_IndexFind + 1)
      {
        hv_GoodIdx.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_GoodIdx = hv_ClassNames.TupleFindFirst(
            hv_ClassNamesGood.TupleSelect(hv_IndexFind));
        }
        if ((int)((new HTuple(hv_GoodIdx.TupleNotEqual(-1))).TupleAnd(new HTuple((new HTuple(hv_ClassNames.TupleLength()
            )).TupleLessEqual(8)))) != 0)
        {
          //If number of classes is <= 8, swap color with a green color.
          hv_CurrentColor.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_CurrentColor = hv_Colors.TupleSelect(
              hv_GoodIdx);
          }
          hv_GreenIdx.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_GreenIdx = (new HTuple((new HTuple(hv_ClassNames.TupleLength()
              ))/2.0)).TupleFloor();
          }
          //Set to pure green.
          if (hv_Colors == null)
            hv_Colors = new HTuple();
          hv_Colors[hv_GoodIdx] = "#00ff00";
          //Write original color to a green entry.
          if (hv_Colors == null)
            hv_Colors = new HTuple();
          hv_Colors[hv_GreenIdx] = hv_CurrentColor;
          break;
        }
        else if ((int)((new HTuple(hv_GoodIdx.TupleNotEqual(-1))).TupleAnd(
            new HTuple((new HTuple(hv_ClassNames.TupleLength())).TupleGreater(8)))) != 0)
        {
          //If number of classes is larger than 8, set the respective color to green.
          if (hv_Colors == null)
            hv_Colors = new HTuple();
          hv_Colors[hv_GoodIdx] = "#00ff00";
          break;
        }
      }

      hv_NumColors.Dispose();
      hv_ColorsRainbow.Dispose();
      hv_ClassNamesGood.Dispose();
      hv_IndexFind.Dispose();
      hv_GoodIdx.Dispose();
      hv_CurrentColor.Dispose();
      hv_GreenIdx.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_NumColors.Dispose();
      hv_ColorsRainbow.Dispose();
      hv_ClassNamesGood.Dispose();
      hv_IndexFind.Dispose();
      hv_GoodIdx.Dispose();
      hv_CurrentColor.Dispose();
      hv_GreenIdx.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: Get the image of a sample. 
  public void get_image (out HObject ho_Image, HTuple hv_SampleKeys, HTuple hv_DLSample)
  {


    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    //
    //This procedure returns the image of a sample.
    //
    if ((int)(new HTuple(((hv_SampleKeys.TupleFind("image"))).TupleNotEqual(-1))) != 0)
    {
      ho_Image.Dispose();
      HOperatorSet.GetDictObject(out ho_Image, hv_DLSample, "image");
    }
    else
    {
      throw new HalconException("Image could not be found in DLSample.");
    }


    return;
  }

  // Chapter: Graphics / Window
  // Short Description: Get the next window that can be used for visualization. 
  public void get_next_window (HTuple hv_Font, HTuple hv_FontSize, HTuple hv_ShowBottomDesc, 
      HTuple hv_WidthImage, HTuple hv_HeightImage, HTuple hv_MapColorBarWidth, HTuple hv_ScaleWindows, 
      HTuple hv_ThresholdWidth, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict, 
      HTuple hv_WindowHandleKey, out HTuple hv_CurrentWindowHandle, out HTuple hv_WindowImageRatioHeight, 
      out HTuple hv_PrevWindowCoordinatesOut)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_OpenNewWindow = new HTuple(), hv_WindowHandles = new HTuple();
    HTuple hv_Value = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
    HTuple hv__ = new HTuple(), hv_MarginBottom = new HTuple();
    HTuple hv_WindowImageRatioWidth = new HTuple(), hv_SetPartRow2 = new HTuple();
    HTuple hv_SetPartColumn2 = new HTuple(), hv_MetaInfo = new HTuple();
    // Initialize local and output iconic variables 
    hv_CurrentWindowHandle = new HTuple();
    hv_WindowImageRatioHeight = new HTuple();
    hv_PrevWindowCoordinatesOut = new HTuple();
    try
    {
      //
      //This procedure returns the next window that
      //is used for visualization. If ReuseWindows is true
      //and WindowHandleList is suitable, the window handles
      //that are passed over are used. Else, this procedure
      //opens a new window, either next to the last ones, or
      //in a new row.
      //
      //First, check if the requested window is already available.
      hv_OpenNewWindow.Dispose();
      hv_OpenNewWindow = 0;
      try
      {
        hv_WindowHandles.Dispose();
        HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, out hv_WindowHandles);
        hv_CurrentWindowHandle.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CurrentWindowHandle = hv_WindowHandles.TupleSelect(
            0);
        }
        //Check if window handle is valid.
        try
        {
          hv_Value.Dispose();
          HOperatorSet.GetWindowParam(hv_CurrentWindowHandle, "flush", out hv_Value);
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException2)
        {
          HDevExpDefaultException2.ToHTuple(out hv_Exception);
          //If there is something wrong with the current window, create a new one.
          hv_OpenNewWindow.Dispose();
          hv_OpenNewWindow = 1;
          HOperatorSet.RemoveDictKey(hv_WindowHandleDict, hv_WindowHandleKey);
        }
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        hv_OpenNewWindow.Dispose();
        hv_OpenNewWindow = 1;
      }
      //
      //Get next window.
      if ((int)(hv_OpenNewWindow.TupleNot()) != 0)
      {
        //
        //If possible, reuse existing window handles.
        HDevWindowStack.SetActive(hv_CurrentWindowHandle);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
        }
        set_display_font(hv_CurrentWindowHandle, hv_FontSize, hv_Font, "true", "false");
        //
        //Calculate MarginBottom.
        if ((int)(hv_ShowBottomDesc) != 0)
        {
          hv_Ascent.Dispose();hv_Descent.Dispose();hv__.Dispose();hv__.Dispose();
          HOperatorSet.GetStringExtents(hv_CurrentWindowHandle, "test_string", out hv_Ascent, 
              out hv_Descent, out hv__, out hv__);
          hv_MarginBottom.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_MarginBottom = ((2*12)+hv_Ascent)+hv_Descent;
          }
        }
        else
        {
          hv_MarginBottom.Dispose();
          hv_MarginBottom = 0;
        }
        //
        //Get and set meta information for current window.
        hv_WindowImageRatioHeight.Dispose();hv_WindowImageRatioWidth.Dispose();hv_SetPartRow2.Dispose();hv_SetPartColumn2.Dispose();hv_PrevWindowCoordinatesOut.Dispose();
        update_window_meta_information(hv_CurrentWindowHandle, hv_WidthImage, hv_HeightImage, 
            0, 0, hv_MapColorBarWidth, hv_MarginBottom, out hv_WindowImageRatioHeight, 
            out hv_WindowImageRatioWidth, out hv_SetPartRow2, out hv_SetPartColumn2, 
            out hv_PrevWindowCoordinatesOut);
        //
        //Update meta information.
        hv_MetaInfo.Dispose();
        HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_window_image_ratio_height", 
            hv_WindowImageRatioHeight);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_window_image_ratio_width", 
            hv_WindowImageRatioWidth);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_set_part_row2", 
            hv_SetPartRow2);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_set_part_column2", 
            hv_SetPartColumn2);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_margin_bottom", 
            hv_MarginBottom);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_map_color_bar_with", 
            hv_MapColorBarWidth);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_window_coordinates", 
            hv_PrevWindowCoordinatesOut);
        }
      }
      else
      {
        //
        //Open a new window.
        hv_CurrentWindowHandle.Dispose();hv_WindowImageRatioHeight.Dispose();hv_PrevWindowCoordinatesOut.Dispose();
        open_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage, 
            hv_HeightImage, hv_MapColorBarWidth, hv_ScaleWindows, hv_ThresholdWidth, 
            hv_PrevWindowCoordinates, hv_WindowHandleDict, hv_WindowHandleKey, out hv_CurrentWindowHandle, 
            out hv_WindowImageRatioHeight, out hv_PrevWindowCoordinatesOut);
        HOperatorSet.SetWindowParam(hv_CurrentWindowHandle, "flush", "false");
      }
      //

      hv_OpenNewWindow.Dispose();
      hv_WindowHandles.Dispose();
      hv_Value.Dispose();
      hv_Exception.Dispose();
      hv_Ascent.Dispose();
      hv_Descent.Dispose();
      hv__.Dispose();
      hv_MarginBottom.Dispose();
      hv_WindowImageRatioWidth.Dispose();
      hv_SetPartRow2.Dispose();
      hv_SetPartColumn2.Dispose();
      hv_MetaInfo.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_OpenNewWindow.Dispose();
      hv_WindowHandles.Dispose();
      hv_Value.Dispose();
      hv_Exception.Dispose();
      hv_Ascent.Dispose();
      hv_Descent.Dispose();
      hv__.Dispose();
      hv_MarginBottom.Dispose();
      hv_WindowImageRatioWidth.Dispose();
      hv_SetPartRow2.Dispose();
      hv_SetPartColumn2.Dispose();
      hv_MetaInfo.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Semantic Segmentation
  // Short Description: Get the ground truth segmentation image. 
  public void get_segmentation_image_ground_truth (out HObject ho_SegmentationImagGroundTruth, 
      HTuple hv_SampleKeys, HTuple hv_DLSample)
  {


    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_SegmentationImagGroundTruth);
    //
    //This procedure returns the ground truth segmentation image.
    //
    if ((int)(new HTuple(((hv_SampleKeys.TupleFind("segmentation_image"))).TupleNotEqual(
        -1))) != 0)
    {
      ho_SegmentationImagGroundTruth.Dispose();
      HOperatorSet.GetDictObject(out ho_SegmentationImagGroundTruth, hv_DLSample, 
          "segmentation_image");
    }
    else
    {
      throw new HalconException("Ground truth segmentation image could not be found in DLSample.");
    }


    return;
  }

  // Chapter: Deep Learning / Semantic Segmentation
  // Short Description: Get the predicted segmentation result image. 
  public void get_segmentation_image_result (out HObject ho_SegmentationImageResult, 
      HTuple hv_ResultKeys, HTuple hv_DLResult)
  {


    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_SegmentationImageResult);
    //
    //This procedure returns the predicted segmentation result image.
    //
    if ((int)(new HTuple(((hv_ResultKeys.TupleFind("segmentation_image"))).TupleNotEqual(
        -1))) != 0)
    {
      ho_SegmentationImageResult.Dispose();
      HOperatorSet.GetDictObject(out ho_SegmentationImageResult, hv_DLResult, "segmentation_image");
    }
    else
    {
      throw new HalconException("Result segmentation data could not be found in DLSample.");
    }


    return;
  }

  // Chapter: Deep Learning / Semantic Segmentation
  // Short Description: Get the weight image of a sample. 
  public void get_weight_image (out HObject ho_ImageWeight, HTuple hv_SampleKeys, 
      HTuple hv_DLSample)
  {


    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImageWeight);
    //
    //This procedure returns the segmentation weight image of a sample.
    //
    if ((int)(new HTuple(((hv_SampleKeys.TupleFind("weight_image"))).TupleNotEqual(
        -1))) != 0)
    {
      ho_ImageWeight.Dispose();
      HOperatorSet.GetDictObject(out ho_ImageWeight, hv_DLSample, "weight_image");
    }
    else
    {
      throw new HalconException("Weight image could not be found in DLSample.");
    }


    return;
  }

  // Chapter: Deep Learning / Model
  // Short Description: shuffles the input colors in a deterministic way 
  public void make_neighboring_colors_distinguishable (HTuple hv_ColorsRainbow, out HTuple hv_Colors)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_NumColors = new HTuple(), hv_NumChunks = new HTuple();
    HTuple hv_NumLeftOver = new HTuple(), hv_ColorsPerChunk = new HTuple();
    HTuple hv_StartIdx = new HTuple(), hv_S = new HTuple();
    HTuple hv_EndIdx = new HTuple(), hv_IdxsLeft = new HTuple();
    HTuple hv_IdxsRight = new HTuple();
    // Initialize local and output iconic variables 
    hv_Colors = new HTuple();
    try
    {
      //
      //Shuffle the input colors in a deterministic way
      //to make adjacent colors more distinguishable.
      //Neighboring colors from the input are distributed to every NumChunks
      //position in the output.
      //Depending on the number of colors, increase NumChunks.
      hv_NumColors.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NumColors = new HTuple(hv_ColorsRainbow.TupleLength()
          );
      }
      if ((int)(new HTuple(hv_NumColors.TupleGreaterEqual(8))) != 0)
      {
        hv_NumChunks.Dispose();
        hv_NumChunks = 3;
        if ((int)(new HTuple(hv_NumColors.TupleGreaterEqual(40))) != 0)
        {
          hv_NumChunks.Dispose();
          hv_NumChunks = 6;
        }
        else if ((int)(new HTuple(hv_NumColors.TupleGreaterEqual(20))) != 0)
        {
          hv_NumChunks.Dispose();
          hv_NumChunks = 4;
        }
        hv_Colors.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Colors = HTuple.TupleGenConst(
            hv_NumColors,-1);
        }
        //Check if the Number of Colors is dividable by NumChunks.
        hv_NumLeftOver.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_NumLeftOver = hv_NumColors%hv_NumChunks;
        }
        hv_ColorsPerChunk.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ColorsPerChunk = ((hv_NumColors/hv_NumChunks)).TupleInt()
            ;
        }
        hv_StartIdx.Dispose();
        hv_StartIdx = 0;
        HTuple end_val19 = hv_NumChunks-1;
        HTuple step_val19 = 1;
        for (hv_S=0; hv_S.Continue(end_val19, step_val19); hv_S = hv_S.TupleAdd(step_val19))
        {
          hv_EndIdx.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_EndIdx = (hv_StartIdx+hv_ColorsPerChunk)-1;
          }
          if ((int)(new HTuple(hv_S.TupleLess(hv_NumLeftOver))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_EndIdx = hv_EndIdx+1;
            hv_EndIdx.Dispose();
            hv_EndIdx = ExpTmpLocalVar_EndIdx;
            }
            }
          }
          hv_IdxsLeft.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_IdxsLeft = HTuple.TupleGenSequence(
              hv_S,hv_NumColors-1,hv_NumChunks);
          }
          hv_IdxsRight.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_IdxsRight = HTuple.TupleGenSequence(
              hv_StartIdx,hv_EndIdx,1);
          }
          if (hv_Colors == null)
            hv_Colors = new HTuple();
          hv_Colors[HTuple.TupleGenSequence(hv_S,hv_NumColors-1,hv_NumChunks)] = hv_ColorsRainbow.TupleSelectRange(
              hv_StartIdx,hv_EndIdx);
          hv_StartIdx.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_StartIdx = hv_EndIdx+1;
          }
        }
      }
      else
      {
        hv_Colors.Dispose();
        hv_Colors = new HTuple(hv_ColorsRainbow);
      }

      hv_NumColors.Dispose();
      hv_NumChunks.Dispose();
      hv_NumLeftOver.Dispose();
      hv_ColorsPerChunk.Dispose();
      hv_StartIdx.Dispose();
      hv_S.Dispose();
      hv_EndIdx.Dispose();
      hv_IdxsLeft.Dispose();
      hv_IdxsRight.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_NumColors.Dispose();
      hv_NumChunks.Dispose();
      hv_NumLeftOver.Dispose();
      hv_ColorsPerChunk.Dispose();
      hv_StartIdx.Dispose();
      hv_S.Dispose();
      hv_EndIdx.Dispose();
      hv_IdxsLeft.Dispose();
      hv_IdxsRight.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Graphics / Window
  // Short Description: Open a window next to the given WindowHandleFather.  
  public void open_child_window (HTuple hv_WindowHandleFather, HTuple hv_Font, HTuple hv_FontSize, 
      HTuple hv_Text, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict, 
      HTuple hv_WindowHandleKey, out HTuple hv_WindowHandleChild, out HTuple hv_PrevWindowCoordinatesOut)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_StringWidth = new HTuple(), hv_IndexText = new HTuple();
    HTuple hv__ = new HTuple(), hv_TextWidth = new HTuple();
    HTuple hv_WindowRow = new HTuple(), hv_WindowColumn = new HTuple();
    HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
    HTuple hv_MetaInfo = new HTuple();
    // Initialize local and output iconic variables 
    hv_WindowHandleChild = new HTuple();
    hv_PrevWindowCoordinatesOut = new HTuple();
    try
    {
      //
      //This procedure opens a window next to the given WindowHandleFather.
      //
      //Get the maximum width of the text to be displayed.
      //The width should be at leat 200.
      hv_StringWidth.Dispose();
      hv_StringWidth = 150;
      for (hv_IndexText=0; (int)hv_IndexText<=(int)((new HTuple(hv_Text.TupleLength()
          ))-1); hv_IndexText = (int)hv_IndexText + 1)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv__.Dispose();hv__.Dispose();hv_TextWidth.Dispose();hv__.Dispose();
        HOperatorSet.GetStringExtents(hv_WindowHandleFather, hv_Text.TupleSelect(
            hv_IndexText), out hv__, out hv__, out hv_TextWidth, out hv__);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_StringWidth = hv_StringWidth.TupleMax2(
            hv_TextWidth);
        hv_StringWidth.Dispose();
        hv_StringWidth = ExpTmpLocalVar_StringWidth;
        }
        }
      }
      //
      //Define window coordinates.
      hv_WindowRow.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WindowRow = hv_PrevWindowCoordinates.TupleSelect(
          0);
      }
      hv_WindowColumn.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WindowColumn = ((hv_PrevWindowCoordinates.TupleSelect(
          1))+(hv_PrevWindowCoordinates.TupleSelect(2)))+5;
      }
      hv_WindowWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WindowWidth = hv_StringWidth+(2*12.0);
      }
      hv_WindowHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WindowHeight = hv_PrevWindowCoordinates.TupleSelect(
          3);
      }
      //
      HOperatorSet.SetWindowAttr("background_color","black");
      HOperatorSet.OpenWindow(hv_WindowRow,hv_WindowColumn,hv_WindowWidth,hv_WindowHeight,0,"visible","",out hv_WindowHandleChild);
      HDevWindowStack.Push(hv_WindowHandleChild);
      set_display_font(hv_WindowHandleChild, hv_FontSize, hv_Font, "true", "false");
      //
      //Return the coordinates of the new window.
      hv_PrevWindowCoordinatesOut.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_PrevWindowCoordinatesOut = new HTuple();
      hv_PrevWindowCoordinatesOut = hv_PrevWindowCoordinatesOut.TupleConcat(hv_WindowRow, hv_WindowColumn, hv_WindowWidth, hv_WindowHeight);
      }
      //
      //Set some meta information about the new child window handle.
      hv_MetaInfo.Dispose();
      HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_child_window_coordinates", 
          hv_PrevWindowCoordinatesOut);
      }
      HOperatorSet.SetDictTuple(hv_WindowHandleDict, "meta_information", hv_MetaInfo);
      //

      hv_StringWidth.Dispose();
      hv_IndexText.Dispose();
      hv__.Dispose();
      hv_TextWidth.Dispose();
      hv_WindowRow.Dispose();
      hv_WindowColumn.Dispose();
      hv_WindowWidth.Dispose();
      hv_WindowHeight.Dispose();
      hv_MetaInfo.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_StringWidth.Dispose();
      hv_IndexText.Dispose();
      hv__.Dispose();
      hv_TextWidth.Dispose();
      hv_WindowRow.Dispose();
      hv_WindowColumn.Dispose();
      hv_WindowWidth.Dispose();
      hv_WindowHeight.Dispose();
      hv_MetaInfo.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Graphics / Window
  // Short Description: Open a new window, either next to the last ones, or in a new row. 
  public void open_next_window (HTuple hv_Font, HTuple hv_FontSize, HTuple hv_ShowBottomDesc, 
      HTuple hv_WidthImage, HTuple hv_HeightImage, HTuple hv_MapColorBarWidth, HTuple hv_ScaleWindows, 
      HTuple hv_ThresholdWidth, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict, 
      HTuple hv_WindowHandleKey, out HTuple hv_WindowHandleNew, out HTuple hv_WindowImageRatioHeight, 
      out HTuple hv_PrevWindowCoordinatesOut)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_PrevWindowRow = new HTuple(), hv_PrevWindowColumn = new HTuple();
    HTuple hv_PrevWindowWidth = new HTuple(), hv_PrevWindowHeight = new HTuple();
    HTuple hv_WindowRow = new HTuple(), hv_WindowColumn = new HTuple();
    HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
    HTuple hv__ = new HTuple(), hv_MarginBottom = new HTuple();
    HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
    HTuple hv_WindowImageRatioWidth = new HTuple(), hv_SetPartRow2 = new HTuple();
    HTuple hv_SetPartColumn2 = new HTuple(), hv_MetaInfo = new HTuple();
    // Initialize local and output iconic variables 
    hv_WindowHandleNew = new HTuple();
    hv_WindowImageRatioHeight = new HTuple();
    hv_PrevWindowCoordinatesOut = new HTuple();
    try
    {
      //
      //This procedure opens a new window, either next to
      //the last ones, or in a new row.
      //
      //Get coordinates of previous window.
      hv_PrevWindowRow.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_PrevWindowRow = hv_PrevWindowCoordinates.TupleSelect(
          0);
      }
      hv_PrevWindowColumn.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_PrevWindowColumn = hv_PrevWindowCoordinates.TupleSelect(
          1);
      }
      hv_PrevWindowWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_PrevWindowWidth = hv_PrevWindowCoordinates.TupleSelect(
          2);
      }
      hv_PrevWindowHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_PrevWindowHeight = hv_PrevWindowCoordinates.TupleSelect(
          3);
      }
      //
      if ((int)(new HTuple(((hv_PrevWindowColumn+hv_PrevWindowWidth)).TupleGreater(
          hv_ThresholdWidth))) != 0)
      {
        //Open window in new row.
        hv_WindowRow.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_WindowRow = (hv_PrevWindowRow+hv_PrevWindowHeight)+55;
        }
        hv_WindowColumn.Dispose();
        hv_WindowColumn = 0;
      }
      else
      {
        //Open window in same row.
        hv_WindowRow.Dispose();
        hv_WindowRow = new HTuple(hv_PrevWindowRow);
        hv_WindowColumn.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_WindowColumn = hv_PrevWindowColumn+hv_PrevWindowWidth;
        }
        if ((int)(new HTuple(hv_WindowColumn.TupleNotEqual(0))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_WindowColumn = hv_WindowColumn+5;
          hv_WindowColumn.Dispose();
          hv_WindowColumn = ExpTmpLocalVar_WindowColumn;
          }
          }
        }
      }
      //
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WindowHandleNew.Dispose();
      dev_open_window_fit_size(hv_WindowRow, hv_WindowColumn, hv_WidthImage, hv_HeightImage, 
          (new HTuple(500)).TupleConcat(800)*hv_ScaleWindows, (new HTuple(400)).TupleConcat(
          600)*hv_ScaleWindows, out hv_WindowHandleNew);
      }
      set_display_font(hv_WindowHandleNew, hv_FontSize, hv_Font, "true", "false");
      //
      //Add MarginBottom and MapColorBarWidth to window.
      if ((int)(hv_ShowBottomDesc) != 0)
      {
        hv_Ascent.Dispose();hv_Descent.Dispose();hv__.Dispose();hv__.Dispose();
        HOperatorSet.GetStringExtents(hv_WindowHandleNew, "Test_string", out hv_Ascent, 
            out hv_Descent, out hv__, out hv__);
        hv_MarginBottom.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MarginBottom = ((2*12)+hv_Ascent)+hv_Descent;
        }
      }
      else
      {
        hv_MarginBottom.Dispose();
        hv_MarginBottom = 0;
      }
      hv__.Dispose();hv__.Dispose();hv_WindowWidth.Dispose();hv_WindowHeight.Dispose();
      HOperatorSet.GetWindowExtents(hv_WindowHandleNew, out hv__, out hv__, out hv_WindowWidth, 
          out hv_WindowHeight);
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_WindowRow, 
            hv_WindowColumn, hv_WindowWidth+hv_MapColorBarWidth, hv_WindowHeight+hv_MarginBottom);
        }
      }
      //
      //Get and set meta information of new window handle.
      hv_WindowImageRatioHeight.Dispose();hv_WindowImageRatioWidth.Dispose();hv_SetPartRow2.Dispose();hv_SetPartColumn2.Dispose();hv_PrevWindowCoordinatesOut.Dispose();
      update_window_meta_information(hv_WindowHandleNew, hv_WidthImage, hv_HeightImage, 
          hv_WindowRow, hv_WindowColumn, hv_MapColorBarWidth, hv_MarginBottom, out hv_WindowImageRatioHeight, 
          out hv_WindowImageRatioWidth, out hv_SetPartRow2, out hv_SetPartColumn2, 
          out hv_PrevWindowCoordinatesOut);
      //
      //Set window handle and some meta information about the new window handle.
      HOperatorSet.SetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, hv_WindowHandleNew);
      hv_MetaInfo.Dispose();
      HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_window_image_ratio_height", 
          hv_WindowImageRatioHeight);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_window_image_ratio_width", 
          hv_WindowImageRatioWidth);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_set_part_row2", 
          hv_SetPartRow2);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_set_part_column2", 
          hv_SetPartColumn2);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_margin_bottom", 
          hv_MarginBottom);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_map_color_bar_with", 
          hv_MapColorBarWidth);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey+"_window_coordinates", 
          hv_PrevWindowCoordinatesOut);
      }
      HOperatorSet.SetDictTuple(hv_WindowHandleDict, "meta_information", hv_MetaInfo);
      //

      hv_PrevWindowRow.Dispose();
      hv_PrevWindowColumn.Dispose();
      hv_PrevWindowWidth.Dispose();
      hv_PrevWindowHeight.Dispose();
      hv_WindowRow.Dispose();
      hv_WindowColumn.Dispose();
      hv_Ascent.Dispose();
      hv_Descent.Dispose();
      hv__.Dispose();
      hv_MarginBottom.Dispose();
      hv_WindowWidth.Dispose();
      hv_WindowHeight.Dispose();
      hv_WindowImageRatioWidth.Dispose();
      hv_SetPartRow2.Dispose();
      hv_SetPartColumn2.Dispose();
      hv_MetaInfo.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_PrevWindowRow.Dispose();
      hv_PrevWindowColumn.Dispose();
      hv_PrevWindowWidth.Dispose();
      hv_PrevWindowHeight.Dispose();
      hv_WindowRow.Dispose();
      hv_WindowColumn.Dispose();
      hv_Ascent.Dispose();
      hv_Descent.Dispose();
      hv__.Dispose();
      hv_MarginBottom.Dispose();
      hv_WindowWidth.Dispose();
      hv_WindowHeight.Dispose();
      hv_WindowImageRatioWidth.Dispose();
      hv_SetPartRow2.Dispose();
      hv_SetPartColumn2.Dispose();
      hv_MetaInfo.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Object Detection
  // Short Description: This procedure generates a histogram out of the input and displays the plot. 
  public void plot_dl_detection_histogram (HTuple hv_DataCollection, HTuple hv_Color, 
      HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple hv_WindowHandle)
  {



    // Local iconic variables 

    HObject ho_PlotBackground;

    // Local control variables 

    HTuple hv_LabelY = new HTuple(), hv_AxesColor = new HTuple();
    HTuple hv_Title = new HTuple(), hv_LabelX = new HTuple();
    HTuple hv_GenParamIndex = new HTuple(), hv_MinHisto = new HTuple();
    HTuple hv_DataHisto = new HTuple(), hv_DataBinSize = new HTuple();
    HTuple hv_PartRow1 = new HTuple(), hv_PartColumn1 = new HTuple();
    HTuple hv_PartRow2 = new HTuple(), hv_PartColumn2 = new HTuple();
    HTuple hv_LeftX = new HTuple(), hv_RightX = new HTuple();
    HTuple hv_StepX = new HTuple(), hv_StepY = new HTuple();
    HTuple hv_LabelXShift = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_PlotBackground);
    try
    {
      //This procedure generates and displays a histogram of the data given
      //in DataCollection.
      //
      //Fixed display parameters.
      hv_LabelY.Dispose();
      hv_LabelY = "Frequency";
      hv_AxesColor.Dispose();
      hv_AxesColor = "#898b8f";
      //
      //Variable display parameters.
      hv_Title.Dispose();
      hv_Title = "";
      hv_LabelX.Dispose();
      hv_LabelX = "";
      //
      for (hv_GenParamIndex=0; (int)hv_GenParamIndex<=(int)((new HTuple(hv_GenParamName.TupleLength()
          ))-1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
      {
        if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "label_x"))) != 0)
        {
          hv_LabelX.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_LabelX = hv_GenParamValue.TupleSelect(
              hv_GenParamIndex);
          }
        }
        else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "title"))) != 0)
        {
          hv_Title.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Title = hv_GenParamValue.TupleSelect(
              hv_GenParamIndex);
          }
        }
        else
        {
          throw new HalconException(("Unknown generic parameter "+(hv_GenParamName.TupleSelect(
              hv_GenParamIndex)))+".");
        }
      }
      //
      //Get data histogram. Set minimum to 0 if it is greater than 0.
      hv_MinHisto.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MinHisto = hv_DataCollection.TupleMin()
          ;
      }
      if ((int)(new HTuple(hv_MinHisto.TupleGreater(0))) != 0)
      {
        hv_MinHisto.Dispose();
        hv_MinHisto = 0;
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_DataHisto.Dispose();hv_DataBinSize.Dispose();
      HOperatorSet.TupleHistoRange(hv_DataCollection, hv_MinHisto, hv_DataCollection.TupleMax()
          , 100, out hv_DataHisto, out hv_DataBinSize);
      }
      //
      //Set some window parameters.
      set_display_font(hv_WindowHandle, 16, "mono", "true", "false");
      HOperatorSet.SetWindowParam(hv_WindowHandle, "flush", "false");
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 2);
      }
      //
      //Plot white background.
      hv_PartRow1.Dispose();hv_PartColumn1.Dispose();hv_PartRow2.Dispose();hv_PartColumn2.Dispose();
      HOperatorSet.GetPart(hv_WindowHandle, out hv_PartRow1, out hv_PartColumn1, 
          out hv_PartRow2, out hv_PartColumn2);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_PlotBackground.Dispose();
      HOperatorSet.GenRectangle1(out ho_PlotBackground, hv_PartRow1+40, hv_PartColumn1+20, 
          hv_PartRow2-20, hv_PartColumn2-20);
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetColor(HDevWindowStack.GetActive(), "white");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_PlotBackground, HDevWindowStack.GetActive());
      }
      //Plot title text.
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Title, "image", hv_PartRow1+10, 
            hv_PartColumn1+20, "black", "box", "false");
        }
      }
      //
      //Set data for x tick.
      hv_LeftX.Dispose();
      hv_LeftX = new HTuple(hv_MinHisto);
      hv_RightX.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_RightX = hv_DataCollection.TupleMax()
          ;
      }
      hv_StepX.Dispose();
      hv_StepX = new HTuple(hv_DataBinSize);
      if ((int)(new HTuple(hv_StepX.TupleGreater(1))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_StepX = hv_StepX.TupleInt()
            ;
        hv_StepX.Dispose();
        hv_StepX = ExpTmpLocalVar_StepX;
        }
        }
      }
      hv_StepY.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_StepY = (((((hv_DataHisto.TupleMax()
          )/7)).TupleConcat(1))).TupleMax();
      }
      //
      //Plot the histogram.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      plot_tuple(hv_WindowHandle, HTuple.TupleGenSequence(hv_LeftX,hv_RightX-(hv_DataBinSize/2.0),
          hv_DataBinSize), hv_DataHisto, "", "", hv_Color, ((((((new HTuple("axes_color")).TupleConcat(
          "ticks_x")).TupleConcat("ticks_y")).TupleConcat("margin_top")).TupleConcat(
          "margin_bottom")).TupleConcat("margin_left")).TupleConcat("margin_right"), 
          ((((hv_AxesColor.TupleConcat(15*hv_StepX))).TupleConcat(hv_StepY))).TupleConcat(
          (((new HTuple(75)).TupleConcat(60)).TupleConcat(70)).TupleConcat(60)));
      }
      //Display the x and y labels.
      hv_LabelXShift.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_LabelXShift = ((hv_LabelX.TupleStrlen()
          )*10)+25;
      }
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_LabelX, "image", hv_PartRow2-42, 
            hv_PartColumn2-hv_LabelXShift, hv_AxesColor, "box", "false");
        }
      }
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_LabelY, "image", hv_PartRow1+45, 
            hv_PartColumn1+25, hv_AxesColor, "box", "false");
        }
      }
      //
      HOperatorSet.FlushBuffer(hv_WindowHandle);
      HOperatorSet.SetWindowParam(hv_WindowHandle, "flush", "true");
      //
      ho_PlotBackground.Dispose();

      hv_LabelY.Dispose();
      hv_AxesColor.Dispose();
      hv_Title.Dispose();
      hv_LabelX.Dispose();
      hv_GenParamIndex.Dispose();
      hv_MinHisto.Dispose();
      hv_DataHisto.Dispose();
      hv_DataBinSize.Dispose();
      hv_PartRow1.Dispose();
      hv_PartColumn1.Dispose();
      hv_PartRow2.Dispose();
      hv_PartColumn2.Dispose();
      hv_LeftX.Dispose();
      hv_RightX.Dispose();
      hv_StepX.Dispose();
      hv_StepY.Dispose();
      hv_LabelXShift.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_PlotBackground.Dispose();

      hv_LabelY.Dispose();
      hv_AxesColor.Dispose();
      hv_Title.Dispose();
      hv_LabelX.Dispose();
      hv_GenParamIndex.Dispose();
      hv_MinHisto.Dispose();
      hv_DataHisto.Dispose();
      hv_DataBinSize.Dispose();
      hv_PartRow1.Dispose();
      hv_PartColumn1.Dispose();
      hv_PartRow2.Dispose();
      hv_PartColumn2.Dispose();
      hv_LeftX.Dispose();
      hv_RightX.Dispose();
      hv_StepX.Dispose();
      hv_StepY.Dispose();
      hv_LabelXShift.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Graphics / Output
  // Short Description:  This procedure plots tuples representing functions or curves in a coordinate system. 
  public void plot_tuple (HTuple hv_WindowHandle, HTuple hv_XValues, HTuple hv_YValues, 
      HTuple hv_XLabel, HTuple hv_YLabel, HTuple hv_Color, HTuple hv_GenParamName, 
      HTuple hv_GenParamValue)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_ContourXGrid=null, ho_ContourYGrid=null;
    HObject ho_XArrow=null, ho_YArrow=null, ho_ContourXTick=null;
    HObject ho_ContourYTick=null, ho_Contour=null, ho_Cross=null;
    HObject ho_Filled=null, ho_Stair=null, ho_StairTmp=null;

    // Local control variables 

    HTuple hv_PreviousWindowHandle = new HTuple();
    HTuple hv_ClipRegion = new HTuple(), hv_Row = new HTuple();
    HTuple hv_Column = new HTuple(), hv_Width = new HTuple();
    HTuple hv_Height = new HTuple(), hv_PartRow1 = new HTuple();
    HTuple hv_PartColumn1 = new HTuple(), hv_PartRow2 = new HTuple();
    HTuple hv_PartColumn2 = new HTuple(), hv_Red = new HTuple();
    HTuple hv_Green = new HTuple(), hv_Blue = new HTuple();
    HTuple hv_DrawMode = new HTuple(), hv_OriginStyle = new HTuple();
    HTuple hv_XAxisEndValue = new HTuple(), hv_YAxisEndValue = new HTuple();
    HTuple hv_XAxisStartValue = new HTuple(), hv_YAxisStartValue = new HTuple();
    HTuple hv_XValuesAreStrings = new HTuple(), hv_XTickValues = new HTuple();
    HTuple hv_XTicks = new HTuple(), hv_YAxisPosition = new HTuple();
    HTuple hv_XAxisPosition = new HTuple(), hv_LeftBorder = new HTuple();
    HTuple hv_RightBorder = new HTuple(), hv_UpperBorder = new HTuple();
    HTuple hv_LowerBorder = new HTuple(), hv_AxesColor = new HTuple();
    HTuple hv_Style = new HTuple(), hv_Clip = new HTuple();
    HTuple hv_YTicks = new HTuple(), hv_XGrid = new HTuple();
    HTuple hv_YGrid = new HTuple(), hv_GridColor = new HTuple();
    HTuple hv_YPosition = new HTuple(), hv_FormatX = new HTuple();
    HTuple hv_FormatY = new HTuple(), hv_NumGenParamNames = new HTuple();
    HTuple hv_NumGenParamValues = new HTuple(), hv_GenParamIndex = new HTuple();
    HTuple hv_XGridTicks = new HTuple(), hv_YTickDirection = new HTuple();
    HTuple hv_XTickDirection = new HTuple(), hv_XAxisWidthPx = new HTuple();
    HTuple hv_XAxisWidth = new HTuple(), hv_XScaleFactor = new HTuple();
    HTuple hv_YAxisHeightPx = new HTuple(), hv_YAxisHeight = new HTuple();
    HTuple hv_YScaleFactor = new HTuple(), hv_YAxisOffsetPx = new HTuple();
    HTuple hv_XAxisOffsetPx = new HTuple(), hv_DotStyle = new HTuple();
    HTuple hv_XGridValues = new HTuple(), hv_XGridStart = new HTuple();
    HTuple hv_XCoord = new HTuple(), hv_IndexGrid = new HTuple();
    HTuple hv_YGridValues = new HTuple(), hv_YGridStart = new HTuple();
    HTuple hv_YCoord = new HTuple(), hv_Ascent = new HTuple();
    HTuple hv_Descent = new HTuple(), hv_TextWidthXLabel = new HTuple();
    HTuple hv_TextHeightXLabel = new HTuple(), hv_TextWidthYLabel = new HTuple();
    HTuple hv_TextHeightYLabel = new HTuple(), hv_XTickStart = new HTuple();
    HTuple hv_Indices = new HTuple(), hv_TypeTicks = new HTuple();
    HTuple hv_IndexTicks = new HTuple(), hv_Ascent1 = new HTuple();
    HTuple hv_Descent1 = new HTuple(), hv_TextWidthXTicks = new HTuple();
    HTuple hv_TextHeightXTicks = new HTuple(), hv_YTickValues = new HTuple();
    HTuple hv_YTickStart = new HTuple(), hv_TextWidthYTicks = new HTuple();
    HTuple hv_TextHeightYTicks = new HTuple(), hv_Num = new HTuple();
    HTuple hv_I = new HTuple(), hv_YSelected = new HTuple();
    HTuple hv_Y1Selected = new HTuple(), hv_X1Selected = new HTuple();
    HTuple hv_Index = new HTuple(), hv_Row1 = new HTuple();
    HTuple hv_Row2 = new HTuple(), hv_Col1 = new HTuple();
    HTuple hv_Col2 = new HTuple();
    HTuple   hv_XValues_COPY_INP_TMP = new HTuple(hv_XValues);
    HTuple   hv_YValues_COPY_INP_TMP = new HTuple(hv_YValues);

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ContourXGrid);
    HOperatorSet.GenEmptyObj(out ho_ContourYGrid);
    HOperatorSet.GenEmptyObj(out ho_XArrow);
    HOperatorSet.GenEmptyObj(out ho_YArrow);
    HOperatorSet.GenEmptyObj(out ho_ContourXTick);
    HOperatorSet.GenEmptyObj(out ho_ContourYTick);
    HOperatorSet.GenEmptyObj(out ho_Contour);
    HOperatorSet.GenEmptyObj(out ho_Cross);
    HOperatorSet.GenEmptyObj(out ho_Filled);
    HOperatorSet.GenEmptyObj(out ho_Stair);
    HOperatorSet.GenEmptyObj(out ho_StairTmp);
    try
    {
      //This procedure plots tuples representing functions
      //or curves in a coordinate system.
      //
      //Input parameters:
      //
      //XValues: X values of the function to be plotted
      //         If XValues is set to [], it is internally set to 0,1,2,...,|YValues|-1.
      //         If XValues is a tuple of strings, the values are taken as categories.
      //
      //YValues: Y values of the function(s) to be plotted
      //         If YValues is set to [], it is internally set to 0,1,2,...,|XValues|-1.
      //         The number of y values must be equal to the number of x values
      //         or an integral multiple. In the latter case,
      //         multiple functions are plotted, that share the same x values.
      //
      //XLabel: X-axis label
      //
      //YLabel: Y-axis label
      //
      //Color: Color of the plotted function
      //       If [] is given, the currently set display color is used.
      //       If 'none is given, the function is not plotted, but only
      //       the coordinate axes as specified.
      //       If more than one color is given, multiple functions
      //       can be displayed in different colors.
      //
      //GenParamName:  Generic parameters to control the presentation
      //               Possible Values:
      //   'axes_color': coordinate system color
      //                 Default: 'white'
      //                 If 'none' is given, no coordinate system is shown.
      //   'style': Graph style
      //            Possible values: 'line' (default), 'cross', 'step', 'filled'
      //   'clip': Clip graph to coordinate system area
      //           Possible values: 'yes', 'no' (default)
      //   'ticks': Control display of ticks on the axes
      //            If 'min_max_origin' is given (default), ticks are shown
      //            at the minimum and maximum values of the axes and at the
      //            intercept point of x- and y-axis.
      //            If 'none' is given, no ticks are shown.
      //            If any number != 0 is given, it is interpreted as distance
      //            between the ticks.
      //   'ticks_x': Control display of ticks on x-axis only
      //   'ticks_y': Control display of ticks on y-axis only
      //   'format_x': Format of the values next to the ticks of the x-axis
      //               (see tuple_string for more details).
      //   'format_y': Format of the values next to the ticks of the y-axis
      //               (see tuple_string for more details).
      //   'grid': Control display of grid lines within the coordinate system
      //           If 'min_max_origin' is given (default), grid lines are shown
      //           at the minimum and maximum values of the axes.
      //           If 'none' is given, no grid lines are shown.
      //           If any number != 0 is given, it is interpreted as distance
      //           between the grid lines.
      //   'grid_x': Control display of grid lines for the x-axis only
      //   'grid_y': Control display of grid lines for the y-axis only
      //   'grid_color': Color of the grid (default: 'dim gray')
      //   'margin': The distance in pixels of the coordinate system area
      //             to all four window borders.
      //   'margin_left': The distance in pixels of the coordinate system area
      //                  to the left window border.
      //   'margin_right': The distance in pixels of the coordinate system area
      //                   to the right window border.
      //   'margin_top': The distance in pixels of the coordinate system area
      //                 to the upper window border.
      //   'margin_bottom': The distance in pixels of the coordinate system area
      //                    to the lower window border.
      //   'start_x': Lowest x value of the x-axis
      //              Default: min(XValues)
      //   'end_x': Highest x value of the x-axis
      //            Default: max(XValues)
      //   'start_y': Lowest y value of the y-axis
      //              Default: min(YValues)
      //   'end_y': Highest y value of the y-axis
      //            Default: max(YValues)
      //   'axis_location_x': Either 'bottom', 'origin', or 'top'
      //               to position the x-axis conveniently,
      //               or the Y coordinate of the intercept point of x- and y-axis.
      //               Default: 'bottom'
      //               (Used to be called 'origin_y')
      //   'axis_location_y': Either 'left', 'origin', or 'right'
      //               to position the y-axis conveniently,
      //               or the X coordinate of the intercept point of x- and y-axis.
      //               Default: 'left'
      //               (Used to be called 'origin_x')
      //
      //GenParamValue: Values of the generic parameters of GenericParamName
      //
      //
      //Store current display settings
      if (HDevWindowStack.IsOpen())
      {
        hv_PreviousWindowHandle = HDevWindowStack.GetActive();
      }
      HDevWindowStack.SetActive(hv_WindowHandle);
      hv_ClipRegion.Dispose();
      HOperatorSet.GetSystem("clip_region", out hv_ClipRegion);
      hv_Row.Dispose();hv_Column.Dispose();hv_Width.Dispose();hv_Height.Dispose();
      HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_Row, out hv_Column, out hv_Width, 
          out hv_Height);
      hv_PartRow1.Dispose();hv_PartColumn1.Dispose();hv_PartRow2.Dispose();hv_PartColumn2.Dispose();
      HOperatorSet.GetPart(hv_WindowHandle, out hv_PartRow1, out hv_PartColumn1, 
          out hv_PartRow2, out hv_PartColumn2);
      hv_Red.Dispose();hv_Green.Dispose();hv_Blue.Dispose();
      HOperatorSet.GetRgb(hv_WindowHandle, out hv_Red, out hv_Green, out hv_Blue);
      hv_DrawMode.Dispose();
      HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
      hv_OriginStyle.Dispose();
      HOperatorSet.GetLineStyle(hv_WindowHandle, out hv_OriginStyle);
      //
      //Set display parameters
      HOperatorSet.SetLineStyle(hv_WindowHandle, new HTuple());
      HOperatorSet.SetSystem("clip_region", "false");
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_Height-1, hv_Width-1);
        }
      }
      //
      //Check input coordinates
      //
      if ((int)((new HTuple(hv_XValues_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleAnd(
          new HTuple(hv_YValues_COPY_INP_TMP.TupleEqual(new HTuple())))) != 0)
      {
        //Neither XValues nor YValues are given:
        //Set axes to interval [0,1]
        hv_XAxisEndValue.Dispose();
        hv_XAxisEndValue = 1;
        hv_YAxisEndValue.Dispose();
        hv_YAxisEndValue = 1;
        hv_XAxisStartValue.Dispose();
        hv_XAxisStartValue = 0;
        hv_YAxisStartValue.Dispose();
        hv_YAxisStartValue = 0;
        hv_XValuesAreStrings.Dispose();
        hv_XValuesAreStrings = 0;
      }
      else
      {
        if ((int)(new HTuple(hv_XValues_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
        {
          //XValues are omitted:
          //Set equidistant XValues
          hv_XValues_COPY_INP_TMP.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_XValues_COPY_INP_TMP = HTuple.TupleGenSequence(
              0,(new HTuple(hv_YValues_COPY_INP_TMP.TupleLength()))-1,1);
          }
          hv_XValuesAreStrings.Dispose();
          hv_XValuesAreStrings = 0;
        }
        else if ((int)(new HTuple(hv_YValues_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
        {
          //YValues are omitted:
          //Set equidistant YValues
          hv_YValues_COPY_INP_TMP.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_YValues_COPY_INP_TMP = HTuple.TupleGenSequence(
              0,(new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()))-1,1);
          }
        }
        if ((int)(new HTuple((new HTuple((new HTuple(hv_YValues_COPY_INP_TMP.TupleLength()
            ))%(new HTuple(hv_XValues_COPY_INP_TMP.TupleLength())))).TupleNotEqual(
            0))) != 0)
        {
          //Number of YValues does not match number of XValues
          throw new HalconException("Number of YValues is no multiple of the number of XValues!");
          ho_ContourXGrid.Dispose();
          ho_ContourYGrid.Dispose();
          ho_XArrow.Dispose();
          ho_YArrow.Dispose();
          ho_ContourXTick.Dispose();
          ho_ContourYTick.Dispose();
          ho_Contour.Dispose();
          ho_Cross.Dispose();
          ho_Filled.Dispose();
          ho_Stair.Dispose();
          ho_StairTmp.Dispose();

          hv_XValues_COPY_INP_TMP.Dispose();
          hv_YValues_COPY_INP_TMP.Dispose();
          hv_PreviousWindowHandle.Dispose();
          hv_ClipRegion.Dispose();
          hv_Row.Dispose();
          hv_Column.Dispose();
          hv_Width.Dispose();
          hv_Height.Dispose();
          hv_PartRow1.Dispose();
          hv_PartColumn1.Dispose();
          hv_PartRow2.Dispose();
          hv_PartColumn2.Dispose();
          hv_Red.Dispose();
          hv_Green.Dispose();
          hv_Blue.Dispose();
          hv_DrawMode.Dispose();
          hv_OriginStyle.Dispose();
          hv_XAxisEndValue.Dispose();
          hv_YAxisEndValue.Dispose();
          hv_XAxisStartValue.Dispose();
          hv_YAxisStartValue.Dispose();
          hv_XValuesAreStrings.Dispose();
          hv_XTickValues.Dispose();
          hv_XTicks.Dispose();
          hv_YAxisPosition.Dispose();
          hv_XAxisPosition.Dispose();
          hv_LeftBorder.Dispose();
          hv_RightBorder.Dispose();
          hv_UpperBorder.Dispose();
          hv_LowerBorder.Dispose();
          hv_AxesColor.Dispose();
          hv_Style.Dispose();
          hv_Clip.Dispose();
          hv_YTicks.Dispose();
          hv_XGrid.Dispose();
          hv_YGrid.Dispose();
          hv_GridColor.Dispose();
          hv_YPosition.Dispose();
          hv_FormatX.Dispose();
          hv_FormatY.Dispose();
          hv_NumGenParamNames.Dispose();
          hv_NumGenParamValues.Dispose();
          hv_GenParamIndex.Dispose();
          hv_XGridTicks.Dispose();
          hv_YTickDirection.Dispose();
          hv_XTickDirection.Dispose();
          hv_XAxisWidthPx.Dispose();
          hv_XAxisWidth.Dispose();
          hv_XScaleFactor.Dispose();
          hv_YAxisHeightPx.Dispose();
          hv_YAxisHeight.Dispose();
          hv_YScaleFactor.Dispose();
          hv_YAxisOffsetPx.Dispose();
          hv_XAxisOffsetPx.Dispose();
          hv_DotStyle.Dispose();
          hv_XGridValues.Dispose();
          hv_XGridStart.Dispose();
          hv_XCoord.Dispose();
          hv_IndexGrid.Dispose();
          hv_YGridValues.Dispose();
          hv_YGridStart.Dispose();
          hv_YCoord.Dispose();
          hv_Ascent.Dispose();
          hv_Descent.Dispose();
          hv_TextWidthXLabel.Dispose();
          hv_TextHeightXLabel.Dispose();
          hv_TextWidthYLabel.Dispose();
          hv_TextHeightYLabel.Dispose();
          hv_XTickStart.Dispose();
          hv_Indices.Dispose();
          hv_TypeTicks.Dispose();
          hv_IndexTicks.Dispose();
          hv_Ascent1.Dispose();
          hv_Descent1.Dispose();
          hv_TextWidthXTicks.Dispose();
          hv_TextHeightXTicks.Dispose();
          hv_YTickValues.Dispose();
          hv_YTickStart.Dispose();
          hv_TextWidthYTicks.Dispose();
          hv_TextHeightYTicks.Dispose();
          hv_Num.Dispose();
          hv_I.Dispose();
          hv_YSelected.Dispose();
          hv_Y1Selected.Dispose();
          hv_X1Selected.Dispose();
          hv_Index.Dispose();
          hv_Row1.Dispose();
          hv_Row2.Dispose();
          hv_Col1.Dispose();
          hv_Col2.Dispose();

          return;
        }
        hv_XValuesAreStrings.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_XValuesAreStrings = hv_XValues_COPY_INP_TMP.TupleIsStringElem()
            ;
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_XValuesAreStrings = new HTuple(((hv_XValuesAreStrings.TupleSum()
            )).TupleEqual(new HTuple(hv_XValuesAreStrings.TupleLength())));
        hv_XValuesAreStrings.Dispose();
        hv_XValuesAreStrings = ExpTmpLocalVar_XValuesAreStrings;
        }
        }
        if ((int)(hv_XValuesAreStrings) != 0)
        {
          //XValues are given as strings:
          //Show XValues as ticks
          hv_XTickValues.Dispose();
          hv_XTickValues = new HTuple(hv_XValues_COPY_INP_TMP);
          hv_XTicks.Dispose();
          hv_XTicks = 1;
          //Set x-axis dimensions
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_XValues = HTuple.TupleGenSequence(
              1,new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()),1);
          hv_XValues_COPY_INP_TMP.Dispose();
          hv_XValues_COPY_INP_TMP = ExpTmpLocalVar_XValues;
          }
          }
        }
        //Set default x-axis dimensions
        if ((int)(new HTuple((new HTuple(hv_XValues_COPY_INP_TMP.TupleLength())).TupleGreater(
            1))) != 0)
        {
          hv_XAxisStartValue.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_XAxisStartValue = hv_XValues_COPY_INP_TMP.TupleMin()
              ;
          }
          hv_XAxisEndValue.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_XAxisEndValue = hv_XValues_COPY_INP_TMP.TupleMax()
              ;
          }
        }
        else
        {
          hv_XAxisEndValue.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_XAxisEndValue = (hv_XValues_COPY_INP_TMP.TupleSelect(
              0))+0.5;
          }
          hv_XAxisStartValue.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_XAxisStartValue = (hv_XValues_COPY_INP_TMP.TupleSelect(
              0))-0.5;
          }
        }
      }
      //Set default y-axis dimensions
      if ((int)(new HTuple((new HTuple(hv_YValues_COPY_INP_TMP.TupleLength())).TupleGreater(
          1))) != 0)
      {
        hv_YAxisStartValue.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_YAxisStartValue = hv_YValues_COPY_INP_TMP.TupleMin()
            ;
        }
        hv_YAxisEndValue.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_YAxisEndValue = hv_YValues_COPY_INP_TMP.TupleMax()
            ;
        }
      }
      else if ((int)(new HTuple((new HTuple(hv_YValues_COPY_INP_TMP.TupleLength()
          )).TupleEqual(1))) != 0)
      {
        hv_YAxisStartValue.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_YAxisStartValue = (hv_YValues_COPY_INP_TMP.TupleSelect(
            0))-0.5;
        }
        hv_YAxisEndValue.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_YAxisEndValue = (hv_YValues_COPY_INP_TMP.TupleSelect(
            0))+0.5;
        }
      }
      else
      {
        hv_YAxisStartValue.Dispose();
        hv_YAxisStartValue = 0;
        hv_YAxisEndValue.Dispose();
        hv_YAxisEndValue = 1;
      }
      //Set default interception point of x- and y- axis
      hv_YAxisPosition.Dispose();
      hv_YAxisPosition = "default";
      hv_XAxisPosition.Dispose();
      hv_XAxisPosition = "default";
      //
      //Set more defaults
      hv_LeftBorder.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_LeftBorder = hv_Width*0.1;
      }
      hv_RightBorder.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_RightBorder = hv_Width*0.1;
      }
      hv_UpperBorder.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_UpperBorder = hv_Height*0.1;
      }
      hv_LowerBorder.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_LowerBorder = hv_Height*0.1;
      }
      hv_AxesColor.Dispose();
      hv_AxesColor = "white";
      hv_Style.Dispose();
      hv_Style = "line";
      hv_Clip.Dispose();
      hv_Clip = "no";
      hv_XTicks.Dispose();
      hv_XTicks = "min_max_origin";
      hv_YTicks.Dispose();
      hv_YTicks = "min_max_origin";
      hv_XGrid.Dispose();
      hv_XGrid = "none";
      hv_YGrid.Dispose();
      hv_YGrid = "none";
      hv_GridColor.Dispose();
      hv_GridColor = "dim gray";
      hv_YPosition.Dispose();
      hv_YPosition = "left";
      hv_FormatX.Dispose();
      hv_FormatX = "default";
      hv_FormatY.Dispose();
      hv_FormatY = "default";
      //
      //Parse generic parameters
      //
      hv_NumGenParamNames.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NumGenParamNames = new HTuple(hv_GenParamName.TupleLength()
          );
      }
      hv_NumGenParamValues.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NumGenParamValues = new HTuple(hv_GenParamValue.TupleLength()
          );
      }
      if ((int)(new HTuple(hv_NumGenParamNames.TupleNotEqual(hv_NumGenParamValues))) != 0)
      {
        throw new HalconException("Number of generic parameter names does not match generic parameter values!");
        ho_ContourXGrid.Dispose();
        ho_ContourYGrid.Dispose();
        ho_XArrow.Dispose();
        ho_YArrow.Dispose();
        ho_ContourXTick.Dispose();
        ho_ContourYTick.Dispose();
        ho_Contour.Dispose();
        ho_Cross.Dispose();
        ho_Filled.Dispose();
        ho_Stair.Dispose();
        ho_StairTmp.Dispose();

        hv_XValues_COPY_INP_TMP.Dispose();
        hv_YValues_COPY_INP_TMP.Dispose();
        hv_PreviousWindowHandle.Dispose();
        hv_ClipRegion.Dispose();
        hv_Row.Dispose();
        hv_Column.Dispose();
        hv_Width.Dispose();
        hv_Height.Dispose();
        hv_PartRow1.Dispose();
        hv_PartColumn1.Dispose();
        hv_PartRow2.Dispose();
        hv_PartColumn2.Dispose();
        hv_Red.Dispose();
        hv_Green.Dispose();
        hv_Blue.Dispose();
        hv_DrawMode.Dispose();
        hv_OriginStyle.Dispose();
        hv_XAxisEndValue.Dispose();
        hv_YAxisEndValue.Dispose();
        hv_XAxisStartValue.Dispose();
        hv_YAxisStartValue.Dispose();
        hv_XValuesAreStrings.Dispose();
        hv_XTickValues.Dispose();
        hv_XTicks.Dispose();
        hv_YAxisPosition.Dispose();
        hv_XAxisPosition.Dispose();
        hv_LeftBorder.Dispose();
        hv_RightBorder.Dispose();
        hv_UpperBorder.Dispose();
        hv_LowerBorder.Dispose();
        hv_AxesColor.Dispose();
        hv_Style.Dispose();
        hv_Clip.Dispose();
        hv_YTicks.Dispose();
        hv_XGrid.Dispose();
        hv_YGrid.Dispose();
        hv_GridColor.Dispose();
        hv_YPosition.Dispose();
        hv_FormatX.Dispose();
        hv_FormatY.Dispose();
        hv_NumGenParamNames.Dispose();
        hv_NumGenParamValues.Dispose();
        hv_GenParamIndex.Dispose();
        hv_XGridTicks.Dispose();
        hv_YTickDirection.Dispose();
        hv_XTickDirection.Dispose();
        hv_XAxisWidthPx.Dispose();
        hv_XAxisWidth.Dispose();
        hv_XScaleFactor.Dispose();
        hv_YAxisHeightPx.Dispose();
        hv_YAxisHeight.Dispose();
        hv_YScaleFactor.Dispose();
        hv_YAxisOffsetPx.Dispose();
        hv_XAxisOffsetPx.Dispose();
        hv_DotStyle.Dispose();
        hv_XGridValues.Dispose();
        hv_XGridStart.Dispose();
        hv_XCoord.Dispose();
        hv_IndexGrid.Dispose();
        hv_YGridValues.Dispose();
        hv_YGridStart.Dispose();
        hv_YCoord.Dispose();
        hv_Ascent.Dispose();
        hv_Descent.Dispose();
        hv_TextWidthXLabel.Dispose();
        hv_TextHeightXLabel.Dispose();
        hv_TextWidthYLabel.Dispose();
        hv_TextHeightYLabel.Dispose();
        hv_XTickStart.Dispose();
        hv_Indices.Dispose();
        hv_TypeTicks.Dispose();
        hv_IndexTicks.Dispose();
        hv_Ascent1.Dispose();
        hv_Descent1.Dispose();
        hv_TextWidthXTicks.Dispose();
        hv_TextHeightXTicks.Dispose();
        hv_YTickValues.Dispose();
        hv_YTickStart.Dispose();
        hv_TextWidthYTicks.Dispose();
        hv_TextHeightYTicks.Dispose();
        hv_Num.Dispose();
        hv_I.Dispose();
        hv_YSelected.Dispose();
        hv_Y1Selected.Dispose();
        hv_X1Selected.Dispose();
        hv_Index.Dispose();
        hv_Row1.Dispose();
        hv_Row2.Dispose();
        hv_Col1.Dispose();
        hv_Col2.Dispose();

        return;
      }
      //
      for (hv_GenParamIndex=0; (int)hv_GenParamIndex<=(int)((new HTuple(hv_GenParamName.TupleLength()
          ))-1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
      {
        //
        //Set 'axes_color'
        if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "axes_color"))) != 0)
        {
          hv_AxesColor.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_AxesColor = hv_GenParamValue.TupleSelect(
              hv_GenParamIndex);
          }
          //
          //Set 'style'
        }
        else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "style"))) != 0)
        {
          hv_Style.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Style = hv_GenParamValue.TupleSelect(
              hv_GenParamIndex);
          }
          //
          //Set 'clip'
        }
        else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "clip"))) != 0)
        {
          hv_Clip.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Clip = hv_GenParamValue.TupleSelect(
              hv_GenParamIndex);
          }
          if ((int)((new HTuple(hv_Clip.TupleNotEqual("yes"))).TupleAnd(new HTuple(hv_Clip.TupleNotEqual(
              "no")))) != 0)
          {
            throw new HalconException(("Unsupported clipping option: '"+hv_Clip)+"'");
          }
          //
          //Set 'ticks'
        }
        else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "ticks"))) != 0)
        {
          hv_XTicks.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_XTicks = hv_GenParamValue.TupleSelect(
              hv_GenParamIndex);
          }
          hv_YTicks.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_YTicks = hv_GenParamValue.TupleSelect(
              hv_GenParamIndex);
          }
          //
          //Set 'ticks_x'
        }
        else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "ticks_x"))) != 0)
        {
          hv_XTicks.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_XTicks = hv_GenParamValue.TupleSelect(
              hv_GenParamIndex);
          }
          //
          //Set 'ticks_y'
        }
        else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "ticks_y"))) != 0)
        {
          hv_YTicks.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_YTicks = hv_GenParamValue.TupleSelect(
              hv_GenParamIndex);
          }
          //
          //Set 'grid'
        }
        else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "grid"))) != 0)
        {
          hv_XGrid.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_XGrid = hv_GenParamValue.TupleSelect(
              hv_GenParamIndex);
          }
          hv_YGrid.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_YGrid = hv_GenParamValue.TupleSelect(
              hv_GenParamIndex);
          }
          hv_XGridTicks.Dispose();
          hv_XGridTicks = new HTuple(hv_XTicks);
          //
          //Set 'grid_x'
        }
        else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "grid_x"))) != 0)
        {
          hv_XGrid.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_XGrid = hv_GenParamValue.TupleSelect(
              hv_GenParamIndex);
          }
          //
          //Set 'grid_y'
        }
        else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "grid_y"))) != 0)
        {
          hv_YGrid.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_YGrid = hv_GenParamValue.TupleSelect(
              hv_GenParamIndex);
          }
          //
          //Set 'grid_color'
        }
        else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "grid_color"))) != 0)
        {
          hv_GridColor.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_GridColor = hv_GenParamValue.TupleSelect(
              hv_GenParamIndex);
          }
          //
          //Set 'start_x'
        }
        else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "start_x"))) != 0)
        {
          hv_XAxisStartValue.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_XAxisStartValue = hv_GenParamValue.TupleSelect(
              hv_GenParamIndex);
          }
          //
          //Set 'end_x'
        }
        else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "end_x"))) != 0)
        {
          hv_XAxisEndValue.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_XAxisEndValue = hv_GenParamValue.TupleSelect(
              hv_GenParamIndex);
          }
          //
          //Set 'start_y'
        }
        else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "start_y"))) != 0)
        {
          hv_YAxisStartValue.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_YAxisStartValue = hv_GenParamValue.TupleSelect(
              hv_GenParamIndex);
          }
          //
          //Set 'end_y'
        }
        else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "end_y"))) != 0)
        {
          hv_YAxisEndValue.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_YAxisEndValue = hv_GenParamValue.TupleSelect(
              hv_GenParamIndex);
          }
          //
          //Set 'axis_location_y' (old name 'origin_x')
        }
        else if ((int)((new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "axis_location_y"))).TupleOr(new HTuple(((hv_GenParamName.TupleSelect(
            hv_GenParamIndex))).TupleEqual("origin_x")))) != 0)
        {
          hv_YAxisPosition.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_YAxisPosition = hv_GenParamValue.TupleSelect(
              hv_GenParamIndex);
          }
          //
          //Set 'axis_location_x' (old name: 'origin_y')
        }
        else if ((int)((new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "axis_location_x"))).TupleOr(new HTuple(((hv_GenParamName.TupleSelect(
            hv_GenParamIndex))).TupleEqual("origin_y")))) != 0)
        {
          hv_XAxisPosition.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_XAxisPosition = hv_GenParamValue.TupleSelect(
              hv_GenParamIndex);
          }
          //
          //Set 'margin'
        }
        else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "margin"))) != 0)
        {
          hv_LeftBorder.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_LeftBorder = hv_GenParamValue.TupleSelect(
              hv_GenParamIndex);
          }
          hv_RightBorder.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_RightBorder = hv_GenParamValue.TupleSelect(
              hv_GenParamIndex);
          }
          hv_UpperBorder.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_UpperBorder = hv_GenParamValue.TupleSelect(
              hv_GenParamIndex);
          }
          hv_LowerBorder.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_LowerBorder = hv_GenParamValue.TupleSelect(
              hv_GenParamIndex);
          }
          //
          //Set 'margin_left'
        }
        else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "margin_left"))) != 0)
        {
          hv_LeftBorder.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_LeftBorder = hv_GenParamValue.TupleSelect(
              hv_GenParamIndex);
          }
          //
          //Set 'margin_right'
        }
        else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "margin_right"))) != 0)
        {
          hv_RightBorder.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_RightBorder = hv_GenParamValue.TupleSelect(
              hv_GenParamIndex);
          }
          //
          //Set 'margin_top'
        }
        else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "margin_top"))) != 0)
        {
          hv_UpperBorder.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_UpperBorder = hv_GenParamValue.TupleSelect(
              hv_GenParamIndex);
          }
          //
          //Set 'margin_bottom'
        }
        else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "margin_bottom"))) != 0)
        {
          hv_LowerBorder.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_LowerBorder = hv_GenParamValue.TupleSelect(
              hv_GenParamIndex);
          }
        }
        else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "format_x"))) != 0)
        {
          hv_FormatX.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_FormatX = hv_GenParamValue.TupleSelect(
              hv_GenParamIndex);
          }
        }
        else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
            "format_y"))) != 0)
        {
          hv_FormatY.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_FormatY = hv_GenParamValue.TupleSelect(
              hv_GenParamIndex);
          }
        }
        else
        {
          throw new HalconException(("Unknown generic parameter: '"+(hv_GenParamName.TupleSelect(
              hv_GenParamIndex)))+"'");
        }
      }
      //
      //Check consistency of start and end values
      //of the axes.
      if ((int)(new HTuple(hv_XAxisStartValue.TupleGreater(hv_XAxisEndValue))) != 0)
      {
        throw new HalconException("Value for 'start_x' is greater than value for 'end_x'");
      }
      if ((int)(new HTuple(hv_YAxisStartValue.TupleGreater(hv_YAxisEndValue))) != 0)
      {
        throw new HalconException("Value for 'start_y' is greater than value for 'end_y'");
      }
      //
      //Set the position of the y-axis.
      if ((int)(new HTuple(hv_YAxisPosition.TupleEqual("default"))) != 0)
      {
        hv_YAxisPosition.Dispose();
        hv_YAxisPosition = new HTuple(hv_XAxisStartValue);
      }
      if ((int)(new HTuple(((hv_YAxisPosition.TupleIsString())).TupleEqual(1))) != 0)
      {
        if ((int)(new HTuple(hv_YAxisPosition.TupleEqual("left"))) != 0)
        {
          hv_YAxisPosition.Dispose();
          hv_YAxisPosition = new HTuple(hv_XAxisStartValue);
        }
        else if ((int)(new HTuple(hv_YAxisPosition.TupleEqual("right"))) != 0)
        {
          hv_YAxisPosition.Dispose();
          hv_YAxisPosition = new HTuple(hv_XAxisEndValue);
        }
        else if ((int)(new HTuple(hv_YAxisPosition.TupleEqual("origin"))) != 0)
        {
          hv_YAxisPosition.Dispose();
          hv_YAxisPosition = 0;
        }
        else
        {
          throw new HalconException(("Unsupported axis_location_y: '"+hv_YAxisPosition)+"'");
        }
      }
      //Set the position of the ticks on the y-axis
      //depending of the location of the y-axis.
      if ((int)(new HTuple((new HTuple(((hv_XAxisStartValue.TupleConcat(hv_XAxisEndValue))).TupleMean()
          )).TupleGreater(hv_YAxisPosition))) != 0)
      {
        hv_YTickDirection.Dispose();
        hv_YTickDirection = "right";
      }
      else
      {
        hv_YTickDirection.Dispose();
        hv_YTickDirection = "left";
      }
      //
      //Set the position of the x-axis.
      if ((int)(new HTuple(hv_XAxisPosition.TupleEqual("default"))) != 0)
      {
        hv_XAxisPosition.Dispose();
        hv_XAxisPosition = new HTuple(hv_YAxisStartValue);
      }
      if ((int)(new HTuple(((hv_XAxisPosition.TupleIsString())).TupleEqual(1))) != 0)
      {
        if ((int)(new HTuple(hv_XAxisPosition.TupleEqual("bottom"))) != 0)
        {
          hv_XAxisPosition.Dispose();
          hv_XAxisPosition = new HTuple(hv_YAxisStartValue);
        }
        else if ((int)(new HTuple(hv_XAxisPosition.TupleEqual("top"))) != 0)
        {
          hv_XAxisPosition.Dispose();
          hv_XAxisPosition = new HTuple(hv_YAxisEndValue);
        }
        else if ((int)(new HTuple(hv_XAxisPosition.TupleEqual("origin"))) != 0)
        {
          hv_XAxisPosition.Dispose();
          hv_XAxisPosition = 0;
        }
        else
        {
          throw new HalconException(("Unsupported axis_location_x: '"+hv_XAxisPosition)+"'");
        }
      }
      //Set the position of the ticks on the y-axis
      //depending of the location of the y-axis.
      if ((int)(new HTuple((new HTuple(((hv_YAxisStartValue.TupleConcat(hv_YAxisEndValue))).TupleMean()
          )).TupleGreater(hv_XAxisPosition))) != 0)
      {
        hv_XTickDirection.Dispose();
        hv_XTickDirection = "up";
      }
      else
      {
        hv_XTickDirection.Dispose();
        hv_XTickDirection = "down";
      }
      //
      //Calculate basic pixel coordinates and scale factors
      //
      hv_XAxisWidthPx.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_XAxisWidthPx = (hv_Width-hv_LeftBorder)-hv_RightBorder;
      }
      hv_XAxisWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_XAxisWidth = hv_XAxisEndValue-hv_XAxisStartValue;
      }
      if ((int)(new HTuple(hv_XAxisWidth.TupleEqual(0))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_XAxisStartValue = hv_XAxisStartValue-0.5;
        hv_XAxisStartValue.Dispose();
        hv_XAxisStartValue = ExpTmpLocalVar_XAxisStartValue;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_XAxisEndValue = hv_XAxisEndValue+0.5;
        hv_XAxisEndValue.Dispose();
        hv_XAxisEndValue = ExpTmpLocalVar_XAxisEndValue;
        }
        }
        hv_XAxisWidth.Dispose();
        hv_XAxisWidth = 1;
      }
      hv_XScaleFactor.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_XScaleFactor = hv_XAxisWidthPx/(hv_XAxisWidth.TupleReal()
          );
      }
      hv_YAxisHeightPx.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_YAxisHeightPx = (hv_Height-hv_LowerBorder)-hv_UpperBorder;
      }
      hv_YAxisHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_YAxisHeight = hv_YAxisEndValue-hv_YAxisStartValue;
      }
      if ((int)(new HTuple(hv_YAxisHeight.TupleEqual(0))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_YAxisStartValue = hv_YAxisStartValue-0.5;
        hv_YAxisStartValue.Dispose();
        hv_YAxisStartValue = ExpTmpLocalVar_YAxisStartValue;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_YAxisEndValue = hv_YAxisEndValue+0.5;
        hv_YAxisEndValue.Dispose();
        hv_YAxisEndValue = ExpTmpLocalVar_YAxisEndValue;
        }
        }
        hv_YAxisHeight.Dispose();
        hv_YAxisHeight = 1;
      }
      hv_YScaleFactor.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_YScaleFactor = hv_YAxisHeightPx/(hv_YAxisHeight.TupleReal()
          );
      }
      hv_YAxisOffsetPx.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_YAxisOffsetPx = (hv_YAxisPosition-hv_XAxisStartValue)*hv_XScaleFactor;
      }
      hv_XAxisOffsetPx.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_XAxisOffsetPx = (hv_XAxisPosition-hv_YAxisStartValue)*hv_YScaleFactor;
      }
      //
      //Display grid lines
      //
      if ((int)(new HTuple(hv_GridColor.TupleNotEqual("none"))) != 0)
      {
        hv_DotStyle.Dispose();
        hv_DotStyle = new HTuple();
        hv_DotStyle[0] = 5;
        hv_DotStyle[1] = 7;
        HOperatorSet.SetLineStyle(hv_WindowHandle, hv_DotStyle);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_GridColor);
        }
        //
        //Display x grid lines
        if ((int)(new HTuple(hv_XGrid.TupleNotEqual("none"))) != 0)
        {
          if ((int)(new HTuple(hv_XGrid.TupleEqual("min_max_origin"))) != 0)
          {
            //Calculate 'min_max_origin' grid line coordinates
            if ((int)(new HTuple(hv_YAxisPosition.TupleEqual(hv_XAxisStartValue))) != 0)
            {
              hv_XGridValues.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_XGridValues = new HTuple();
              hv_XGridValues = hv_XGridValues.TupleConcat(hv_XAxisStartValue, hv_XAxisEndValue);
              }
            }
            else
            {
              hv_XGridValues.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_XGridValues = new HTuple();
              hv_XGridValues = hv_XGridValues.TupleConcat(hv_XAxisStartValue, hv_YAxisPosition, hv_XAxisEndValue);
              }
            }
          }
          else
          {
            //Calculate equidistant grid line coordinates
            hv_XGridStart.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_XGridStart = (((hv_XAxisStartValue/hv_XGrid)).TupleCeil()
                )*hv_XGrid;
            }
            hv_XGridValues.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_XGridValues = HTuple.TupleGenSequence(
                hv_XGridStart,hv_XAxisEndValue,hv_XGrid);
            }
          }
          hv_XCoord.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_XCoord = (hv_XGridValues-hv_XAxisStartValue)*hv_XScaleFactor;
          }
          //Generate and display grid lines
          for (hv_IndexGrid=0; (int)hv_IndexGrid<=(int)((new HTuple(hv_XGridValues.TupleLength()
              ))-1); hv_IndexGrid = (int)hv_IndexGrid + 1)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_ContourXGrid.Dispose();
            HOperatorSet.GenContourPolygonXld(out ho_ContourXGrid, ((hv_Height-hv_LowerBorder)).TupleConcat(
                hv_UpperBorder), ((hv_LeftBorder+(hv_XCoord.TupleSelect(hv_IndexGrid)))).TupleConcat(
                hv_LeftBorder+(hv_XCoord.TupleSelect(hv_IndexGrid))));
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_ContourXGrid, HDevWindowStack.GetActive());
            }
          }
        }
        //
        //Display y grid lines
        if ((int)(new HTuple(hv_YGrid.TupleNotEqual("none"))) != 0)
        {
          if ((int)(new HTuple(hv_YGrid.TupleEqual("min_max_origin"))) != 0)
          {
            //Calculate 'min_max_origin' grid line coordinates
            if ((int)(new HTuple(hv_XAxisPosition.TupleEqual(hv_YAxisStartValue))) != 0)
            {
              hv_YGridValues.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_YGridValues = new HTuple();
              hv_YGridValues = hv_YGridValues.TupleConcat(hv_YAxisStartValue, hv_YAxisEndValue);
              }
            }
            else
            {
              hv_YGridValues.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_YGridValues = new HTuple();
              hv_YGridValues = hv_YGridValues.TupleConcat(hv_YAxisStartValue, hv_XAxisPosition, hv_YAxisEndValue);
              }
            }
          }
          else
          {
            //Calculate equidistant grid line coordinates
            hv_YGridStart.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_YGridStart = (((hv_YAxisStartValue/hv_YGrid)).TupleCeil()
                )*hv_YGrid;
            }
            hv_YGridValues.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_YGridValues = HTuple.TupleGenSequence(
                hv_YGridStart,hv_YAxisEndValue,hv_YGrid);
            }
          }
          hv_YCoord.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_YCoord = (hv_YGridValues-hv_YAxisStartValue)*hv_YScaleFactor;
          }
          //Generate and display grid lines
          for (hv_IndexGrid=0; (int)hv_IndexGrid<=(int)((new HTuple(hv_YGridValues.TupleLength()
              ))-1); hv_IndexGrid = (int)hv_IndexGrid + 1)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_ContourYGrid.Dispose();
            HOperatorSet.GenContourPolygonXld(out ho_ContourYGrid, (((hv_Height-hv_LowerBorder)-(hv_YCoord.TupleSelect(
                hv_IndexGrid)))).TupleConcat((hv_Height-hv_LowerBorder)-(hv_YCoord.TupleSelect(
                hv_IndexGrid))), hv_LeftBorder.TupleConcat(hv_Width-hv_RightBorder));
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_ContourYGrid, HDevWindowStack.GetActive());
            }
          }
        }
      }
      HOperatorSet.SetLineStyle(hv_WindowHandle, new HTuple());
      //
      //
      //Display the coordinate system axes
      if ((int)(new HTuple(hv_AxesColor.TupleNotEqual("none"))) != 0)
      {
        //Display axes
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_AxesColor);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_XArrow.Dispose();
        gen_arrow_contour_xld(out ho_XArrow, (hv_Height-hv_LowerBorder)-hv_XAxisOffsetPx, 
            hv_LeftBorder, (hv_Height-hv_LowerBorder)-hv_XAxisOffsetPx, hv_Width-hv_RightBorder, 
            0, 0);
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_XArrow, HDevWindowStack.GetActive());
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_YArrow.Dispose();
        gen_arrow_contour_xld(out ho_YArrow, hv_Height-hv_LowerBorder, hv_LeftBorder+hv_YAxisOffsetPx, 
            hv_UpperBorder, hv_LeftBorder+hv_YAxisOffsetPx, 0, 0);
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_YArrow, HDevWindowStack.GetActive());
        }
        //Display labels
        hv_Ascent.Dispose();hv_Descent.Dispose();hv_TextWidthXLabel.Dispose();hv_TextHeightXLabel.Dispose();
        HOperatorSet.GetStringExtents(hv_WindowHandle, hv_XLabel, out hv_Ascent, 
            out hv_Descent, out hv_TextWidthXLabel, out hv_TextHeightXLabel);
        hv_Ascent.Dispose();hv_Descent.Dispose();hv_TextWidthYLabel.Dispose();hv_TextHeightYLabel.Dispose();
        HOperatorSet.GetStringExtents(hv_WindowHandle, hv_YLabel, out hv_Ascent, 
            out hv_Descent, out hv_TextWidthYLabel, out hv_TextHeightYLabel);
        if ((int)(new HTuple(hv_YTickDirection.TupleEqual("right"))) != 0)
        {
          if ((int)(new HTuple(hv_XTickDirection.TupleEqual("up"))) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XLabel, "image", 
                  ((hv_Height-hv_LowerBorder)-hv_TextHeightXLabel)-3, ((hv_Width-hv_RightBorder)-hv_TextWidthXLabel)-3, 
                  hv_AxesColor, "box", "false");
              }
            }
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), " "+hv_YLabel, "image", 
                  hv_UpperBorder, (hv_LeftBorder+3)+hv_YAxisOffsetPx, hv_AxesColor, 
                  "box", "false");
              }
            }
          }
          else
          {
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XLabel, "image", 
                  ((hv_Height-hv_LowerBorder)+3)-hv_XAxisOffsetPx, ((hv_Width-hv_RightBorder)-hv_TextWidthXLabel)-3, 
                  hv_AxesColor, "box", "false");
              }
            }
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), " "+hv_YLabel, "image", 
                  ((hv_Height-hv_LowerBorder)-hv_TextHeightXLabel)-3, (hv_LeftBorder+3)+hv_YAxisOffsetPx, 
                  hv_AxesColor, "box", "false");
              }
            }
          }
        }
        else
        {
          if ((int)(new HTuple(hv_XTickDirection.TupleEqual("up"))) != 0)
          {
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XLabel, "image", 
                  ((hv_Height-hv_LowerBorder)-(2*hv_TextHeightXLabel))+3, hv_LeftBorder-3, 
                  hv_AxesColor, "box", "false");
              }
            }
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), " "+hv_YLabel, "image", 
                  hv_UpperBorder, ((hv_Width-hv_RightBorder)-hv_TextWidthYLabel)-13, 
                  hv_AxesColor, "box", "false");
              }
            }
          }
          else
          {
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XLabel, "image", 
                  ((hv_Height-hv_LowerBorder)+3)-hv_XAxisOffsetPx, hv_LeftBorder-3, 
                  hv_AxesColor, "box", "false");
              }
            }
            if (HDevWindowStack.IsOpen())
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.DispText(HDevWindowStack.GetActive(), " "+hv_YLabel, "image", 
                  ((hv_Height-hv_LowerBorder)-hv_TextHeightXLabel)-3, ((hv_Width-hv_RightBorder)-(2*hv_TextWidthYLabel))-3, 
                  hv_AxesColor, "box", "false");
              }
            }
          }
        }
      }
      //
      //Display ticks
      //
      if ((int)(new HTuple(hv_AxesColor.TupleNotEqual("none"))) != 0)
      {
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_AxesColor);
        }
        if ((int)(new HTuple(hv_XTicks.TupleNotEqual("none"))) != 0)
        {
          //
          //Display x ticks
          if ((int)(hv_XValuesAreStrings) != 0)
          {
            //Display string XValues as categories
            hv_XTicks.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_XTicks = (new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()
                ))/(new HTuple(hv_XTickValues.TupleLength()));
            }
            hv_XCoord.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_XCoord = (hv_XValues_COPY_INP_TMP-hv_XAxisStartValue)*hv_XScaleFactor;
            }
          }
          else
          {
            //Display tick values
            if ((int)(new HTuple(hv_XTicks.TupleEqual("min_max_origin"))) != 0)
            {
              //Calculate 'min_max_origin' tick coordinates
              if ((int)(new HTuple(hv_YAxisPosition.TupleEqual(hv_XAxisStartValue))) != 0)
              {
                hv_XTickValues.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_XTickValues = new HTuple();
                hv_XTickValues = hv_XTickValues.TupleConcat(hv_XAxisStartValue, hv_XAxisEndValue);
                }
              }
              else
              {
                hv_XTickValues.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_XTickValues = new HTuple();
                hv_XTickValues = hv_XTickValues.TupleConcat(hv_XAxisStartValue, hv_YAxisPosition, hv_XAxisEndValue);
                }
              }
            }
            else
            {
              //Calculate equidistant tick coordinates
              hv_XTickStart.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_XTickStart = (((hv_XAxisStartValue/hv_XTicks)).TupleCeil()
                  )*hv_XTicks;
              }
              hv_XTickValues.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_XTickValues = HTuple.TupleGenSequence(
                  hv_XTickStart,hv_XAxisEndValue,hv_XTicks);
              }
            }
            //Remove ticks that are smaller than the x-axis start.
            hv_Indices.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Indices = ((hv_XTickValues.TupleLessElem(
                hv_XAxisStartValue))).TupleFind(1);
            }
            hv_XCoord.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_XCoord = (hv_XTickValues-hv_XAxisStartValue)*hv_XScaleFactor;
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_XCoord = hv_XCoord.TupleRemove(
                hv_Indices);
            hv_XCoord.Dispose();
            hv_XCoord = ExpTmpLocalVar_XCoord;
            }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_XTickValues = hv_XTickValues.TupleRemove(
                hv_Indices);
            hv_XTickValues.Dispose();
            hv_XTickValues = ExpTmpLocalVar_XTickValues;
            }
            }
            //
            if ((int)(new HTuple(hv_FormatX.TupleEqual("default"))) != 0)
            {
              hv_TypeTicks.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_TypeTicks = hv_XTicks.TupleType()
                  ;
              }
              if ((int)(new HTuple(hv_TypeTicks.TupleEqual(4))) != 0)
              {
                //String ('min_max_origin')
                //Format depends on actual values
                hv_TypeTicks.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_TypeTicks = hv_XTickValues.TupleType()
                    ;
                }
              }
              if ((int)(new HTuple(hv_TypeTicks.TupleEqual(1))) != 0)
              {
                //Round to integer
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                {
                HTuple 
                  ExpTmpLocalVar_XTickValues = hv_XTickValues.TupleInt()
                    ;
                hv_XTickValues.Dispose();
                hv_XTickValues = ExpTmpLocalVar_XTickValues;
                }
                }
              }
              else
              {
                //Use floating point numbers
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                {
                HTuple 
                  ExpTmpLocalVar_XTickValues = hv_XTickValues.TupleString(
                    ".2f");
                hv_XTickValues.Dispose();
                hv_XTickValues = ExpTmpLocalVar_XTickValues;
                }
                }
              }
            }
            else
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_XTickValues = hv_XTickValues.TupleString(
                  hv_FormatX);
              hv_XTickValues.Dispose();
              hv_XTickValues = ExpTmpLocalVar_XTickValues;
              }
              }
            }
          }
          //Generate and display ticks
          for (hv_IndexTicks=0; (int)hv_IndexTicks<=(int)((new HTuple(hv_XTickValues.TupleLength()
              ))-1); hv_IndexTicks = (int)hv_IndexTicks + 1)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Ascent1.Dispose();hv_Descent1.Dispose();hv_TextWidthXTicks.Dispose();hv_TextHeightXTicks.Dispose();
            HOperatorSet.GetStringExtents(hv_WindowHandle, hv_XTickValues.TupleSelect(
                hv_IndexTicks), out hv_Ascent1, out hv_Descent1, out hv_TextWidthXTicks, 
                out hv_TextHeightXTicks);
            }
            if ((int)(new HTuple(hv_XTickDirection.TupleEqual("up"))) != 0)
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              ho_ContourXTick.Dispose();
              HOperatorSet.GenContourPolygonXld(out ho_ContourXTick, (((hv_Height-hv_LowerBorder)-hv_XAxisOffsetPx)).TupleConcat(
                  ((hv_Height-hv_LowerBorder)-hv_XAxisOffsetPx)-5), ((hv_LeftBorder+(hv_XCoord.TupleSelect(
                  hv_IndexTicks)))).TupleConcat(hv_LeftBorder+(hv_XCoord.TupleSelect(
                  hv_IndexTicks))));
              }
              if (HDevWindowStack.IsOpen())
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XTickValues.TupleSelect(
                    hv_IndexTicks), "image", ((hv_Height-hv_LowerBorder)+2)-hv_XAxisOffsetPx, 
                    hv_LeftBorder+(hv_XCoord.TupleSelect(hv_IndexTicks)), hv_AxesColor, 
                    "box", "false");
                }
              }
            }
            else
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              ho_ContourXTick.Dispose();
              HOperatorSet.GenContourPolygonXld(out ho_ContourXTick, ((((hv_Height-hv_LowerBorder)-hv_XAxisOffsetPx)+5)).TupleConcat(
                  (hv_Height-hv_LowerBorder)-hv_XAxisOffsetPx), ((hv_LeftBorder+(hv_XCoord.TupleSelect(
                  hv_IndexTicks)))).TupleConcat(hv_LeftBorder+(hv_XCoord.TupleSelect(
                  hv_IndexTicks))));
              }
              if (HDevWindowStack.IsOpen())
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XTickValues.TupleSelect(
                    hv_IndexTicks), "image", ((hv_Height-hv_LowerBorder)-(2*hv_TextHeightXTicks))-hv_XAxisOffsetPx, 
                    hv_LeftBorder+(hv_XCoord.TupleSelect(hv_IndexTicks)), hv_AxesColor, 
                    "box", "false");
                }
              }
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_ContourXTick, HDevWindowStack.GetActive());
            }
          }
        }
        //
        if ((int)(new HTuple(hv_YTicks.TupleNotEqual("none"))) != 0)
        {
          //
          //Display y ticks
          if ((int)(new HTuple(hv_YTicks.TupleEqual("min_max_origin"))) != 0)
          {
            //Calculate 'min_max_origin' tick coordinates
            if ((int)(new HTuple(hv_XAxisPosition.TupleEqual(hv_YAxisStartValue))) != 0)
            {
              hv_YTickValues.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_YTickValues = new HTuple();
              hv_YTickValues = hv_YTickValues.TupleConcat(hv_YAxisStartValue, hv_YAxisEndValue);
              }
            }
            else
            {
              hv_YTickValues.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_YTickValues = new HTuple();
              hv_YTickValues = hv_YTickValues.TupleConcat(hv_YAxisStartValue, hv_XAxisPosition, hv_YAxisEndValue);
              }
            }
          }
          else
          {
            //Calculate equidistant tick coordinates
            hv_YTickStart.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_YTickStart = (((hv_YAxisStartValue/hv_YTicks)).TupleCeil()
                )*hv_YTicks;
            }
            hv_YTickValues.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_YTickValues = HTuple.TupleGenSequence(
                hv_YTickStart,hv_YAxisEndValue,hv_YTicks);
            }
          }
          //Remove ticks that are smaller than the y-axis start.
          hv_Indices.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Indices = ((hv_YTickValues.TupleLessElem(
              hv_YAxisStartValue))).TupleFind(1);
          }
          hv_YCoord.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_YCoord = (hv_YTickValues-hv_YAxisStartValue)*hv_YScaleFactor;
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_YCoord = hv_YCoord.TupleRemove(
              hv_Indices);
          hv_YCoord.Dispose();
          hv_YCoord = ExpTmpLocalVar_YCoord;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_YTickValues = hv_YTickValues.TupleRemove(
              hv_Indices);
          hv_YTickValues.Dispose();
          hv_YTickValues = ExpTmpLocalVar_YTickValues;
          }
          }
          //
          if ((int)(new HTuple(hv_FormatY.TupleEqual("default"))) != 0)
          {
            hv_TypeTicks.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_TypeTicks = hv_YTicks.TupleType()
                ;
            }
            if ((int)(new HTuple(hv_TypeTicks.TupleEqual(4))) != 0)
            {
              //String ('min_max_origin')
              //Format depends on actual values
              hv_TypeTicks.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_TypeTicks = hv_YTickValues.TupleType()
                  ;
              }
            }
            if ((int)(new HTuple(hv_TypeTicks.TupleEqual(1))) != 0)
            {
              //Round to integer
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_YTickValues = hv_YTickValues.TupleInt()
                  ;
              hv_YTickValues.Dispose();
              hv_YTickValues = ExpTmpLocalVar_YTickValues;
              }
              }
            }
            else
            {
              //Use floating point numbers
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_YTickValues = hv_YTickValues.TupleString(
                  ".2f");
              hv_YTickValues.Dispose();
              hv_YTickValues = ExpTmpLocalVar_YTickValues;
              }
              }
            }
          }
          else
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_YTickValues = hv_YTickValues.TupleString(
                hv_FormatY);
            hv_YTickValues.Dispose();
            hv_YTickValues = ExpTmpLocalVar_YTickValues;
            }
            }
          }
          //Generate and display ticks
          for (hv_IndexTicks=0; (int)hv_IndexTicks<=(int)((new HTuple(hv_YTickValues.TupleLength()
              ))-1); hv_IndexTicks = (int)hv_IndexTicks + 1)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Ascent1.Dispose();hv_Descent1.Dispose();hv_TextWidthYTicks.Dispose();hv_TextHeightYTicks.Dispose();
            HOperatorSet.GetStringExtents(hv_WindowHandle, hv_YTickValues.TupleSelect(
                hv_IndexTicks), out hv_Ascent1, out hv_Descent1, out hv_TextWidthYTicks, 
                out hv_TextHeightYTicks);
            }
            if ((int)(new HTuple(hv_YTickDirection.TupleEqual("right"))) != 0)
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              ho_ContourYTick.Dispose();
              HOperatorSet.GenContourPolygonXld(out ho_ContourYTick, (((hv_Height-hv_LowerBorder)-(hv_YCoord.TupleSelect(
                  hv_IndexTicks)))).TupleConcat((hv_Height-hv_LowerBorder)-(hv_YCoord.TupleSelect(
                  hv_IndexTicks))), ((hv_LeftBorder+hv_YAxisOffsetPx)).TupleConcat(
                  (hv_LeftBorder+hv_YAxisOffsetPx)+5));
              }
              if (HDevWindowStack.IsOpen())
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_YTickValues.TupleSelect(
                    hv_IndexTicks), "image", (((hv_Height-hv_LowerBorder)-hv_TextHeightYTicks)+3)-(hv_YCoord.TupleSelect(
                    hv_IndexTicks)), ((hv_LeftBorder-hv_TextWidthYTicks)-2)+hv_YAxisOffsetPx, 
                    hv_AxesColor, "box", "false");
                }
              }
            }
            else
            {
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              ho_ContourYTick.Dispose();
              HOperatorSet.GenContourPolygonXld(out ho_ContourYTick, (((hv_Height-hv_LowerBorder)-(hv_YCoord.TupleSelect(
                  hv_IndexTicks)))).TupleConcat((hv_Height-hv_LowerBorder)-(hv_YCoord.TupleSelect(
                  hv_IndexTicks))), (((hv_LeftBorder+hv_YAxisOffsetPx)-5)).TupleConcat(
                  hv_LeftBorder+hv_YAxisOffsetPx));
              }
              if (HDevWindowStack.IsOpen())
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_YTickValues.TupleSelect(
                    hv_IndexTicks), "image", (((hv_Height-hv_LowerBorder)-hv_TextHeightYTicks)+3)-(hv_YCoord.TupleSelect(
                    hv_IndexTicks)), (hv_LeftBorder+2)+hv_YAxisOffsetPx, hv_AxesColor, 
                    "box", "false");
                }
              }
            }
            if (HDevWindowStack.IsOpen())
            {
              HOperatorSet.DispObj(ho_ContourYTick, HDevWindowStack.GetActive());
            }
          }
        }
      }
      //
      //Display function plot
      //
      if ((int)(new HTuple(hv_Color.TupleNotEqual("none"))) != 0)
      {
        if ((int)((new HTuple(hv_XValues_COPY_INP_TMP.TupleNotEqual(new HTuple()))).TupleAnd(
            new HTuple(hv_YValues_COPY_INP_TMP.TupleNotEqual(new HTuple())))) != 0)
        {
          hv_Num.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Num = (new HTuple(hv_YValues_COPY_INP_TMP.TupleLength()
              ))/(new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()));
          }
          //
          //Iterate over all functions to be displayed
          HTuple end_val576 = hv_Num-1;
          HTuple step_val576 = 1;
          for (hv_I=0; hv_I.Continue(end_val576, step_val576); hv_I = hv_I.TupleAdd(step_val576))
          {
            //Select y values for current function
            hv_YSelected.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_YSelected = hv_YValues_COPY_INP_TMP.TupleSelectRange(
                hv_I*(new HTuple(hv_XValues_COPY_INP_TMP.TupleLength())),((hv_I+1)*(new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()
                )))-1);
            }
            //Set color
            if ((int)(new HTuple(hv_Color.TupleEqual(new HTuple()))) != 0)
            {
              HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
            }
            else
            {
              if (HDevWindowStack.IsOpen())
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Color.TupleSelect(
                    hv_I%(new HTuple(hv_Color.TupleLength()))));
                }
              }
            }
            //
            //Display in different styles
            //
            if ((int)((new HTuple(hv_Style.TupleEqual("line"))).TupleOr(new HTuple(hv_Style.TupleEqual(
                new HTuple())))) != 0)
            {
              //Line
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              ho_Contour.Dispose();
              HOperatorSet.GenContourPolygonXld(out ho_Contour, ((hv_Height-hv_LowerBorder)-(hv_YSelected*hv_YScaleFactor))+(hv_YAxisStartValue*hv_YScaleFactor), 
                  ((hv_XValues_COPY_INP_TMP*hv_XScaleFactor)+hv_LeftBorder)-(hv_XAxisStartValue*hv_XScaleFactor));
              }
              //Clip, if necessary
              if ((int)(new HTuple(hv_Clip.TupleEqual("yes"))) != 0)
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HObject ExpTmpOutVar_0;
                HOperatorSet.ClipContoursXld(ho_Contour, out ExpTmpOutVar_0, hv_UpperBorder, 
                    hv_LeftBorder, hv_Height-hv_LowerBorder, hv_Width-hv_RightBorder);
                ho_Contour.Dispose();
                ho_Contour = ExpTmpOutVar_0;
                }
              }
              if (HDevWindowStack.IsOpen())
              {
                HOperatorSet.DispObj(ho_Contour, HDevWindowStack.GetActive());
              }
            }
            else if ((int)(new HTuple(hv_Style.TupleEqual("cross"))) != 0)
            {
              //Cross
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              ho_Cross.Dispose();
              HOperatorSet.GenCrossContourXld(out ho_Cross, ((hv_Height-hv_LowerBorder)-(hv_YSelected*hv_YScaleFactor))+(hv_YAxisStartValue*hv_YScaleFactor), 
                  ((hv_XValues_COPY_INP_TMP*hv_XScaleFactor)+hv_LeftBorder)-(hv_XAxisStartValue*hv_XScaleFactor), 
                  6, 0.785398);
              }
              //Clip, if necessary
              if ((int)(new HTuple(hv_Clip.TupleEqual("yes"))) != 0)
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HObject ExpTmpOutVar_0;
                HOperatorSet.ClipContoursXld(ho_Cross, out ExpTmpOutVar_0, hv_UpperBorder, 
                    hv_LeftBorder, hv_Height-hv_LowerBorder, hv_Width-hv_RightBorder);
                ho_Cross.Dispose();
                ho_Cross = ExpTmpOutVar_0;
                }
              }
              if (HDevWindowStack.IsOpen())
              {
                HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
              }
            }
            else if ((int)(new HTuple(hv_Style.TupleEqual("filled"))) != 0)
            {
              //Filled
              hv_Y1Selected.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_Y1Selected = new HTuple();
              hv_Y1Selected = hv_Y1Selected.TupleConcat(0+hv_XAxisPosition);
              hv_Y1Selected = hv_Y1Selected.TupleConcat(hv_YSelected);
              hv_Y1Selected = hv_Y1Selected.TupleConcat(0+hv_XAxisPosition);
              }
              hv_X1Selected.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_X1Selected = new HTuple();
              hv_X1Selected = hv_X1Selected.TupleConcat(hv_XValues_COPY_INP_TMP.TupleMin()
                  );
              hv_X1Selected = hv_X1Selected.TupleConcat(hv_XValues_COPY_INP_TMP);
              hv_X1Selected = hv_X1Selected.TupleConcat(hv_XValues_COPY_INP_TMP.TupleMax()
                  );
              }
              if (HDevWindowStack.IsOpen())
              {
                HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              ho_Filled.Dispose();
              HOperatorSet.GenRegionPolygonFilled(out ho_Filled, ((hv_Height-hv_LowerBorder)-(hv_Y1Selected*hv_YScaleFactor))+(hv_YAxisStartValue*hv_YScaleFactor), 
                  ((hv_X1Selected*hv_XScaleFactor)+hv_LeftBorder)-(hv_XAxisStartValue*hv_XScaleFactor));
              }
              //Clip, if necessary
              if ((int)(new HTuple(hv_Clip.TupleEqual("yes"))) != 0)
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HObject ExpTmpOutVar_0;
                HOperatorSet.ClipRegion(ho_Filled, out ExpTmpOutVar_0, hv_UpperBorder, 
                    hv_LeftBorder, hv_Height-hv_LowerBorder, hv_Width-hv_RightBorder);
                ho_Filled.Dispose();
                ho_Filled = ExpTmpOutVar_0;
                }
              }
              if (HDevWindowStack.IsOpen())
              {
                HOperatorSet.DispObj(ho_Filled, HDevWindowStack.GetActive());
              }
            }
            else if ((int)(new HTuple(hv_Style.TupleEqual("step"))) != 0)
            {
              ho_Stair.Dispose();
              HOperatorSet.GenEmptyObj(out ho_Stair);
              for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()
                  ))-2); hv_Index = (int)hv_Index + 1)
              {
                hv_Row1.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_Row1 = ((hv_Height-hv_LowerBorder)-((hv_YSelected.TupleSelect(
                    hv_Index))*hv_YScaleFactor))+(hv_YAxisStartValue*hv_YScaleFactor);
                }
                hv_Row2.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_Row2 = ((hv_Height-hv_LowerBorder)-((hv_YSelected.TupleSelect(
                    hv_Index+1))*hv_YScaleFactor))+(hv_YAxisStartValue*hv_YScaleFactor);
                }
                hv_Col1.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_Col1 = (((hv_XValues_COPY_INP_TMP.TupleSelect(
                    hv_Index))*hv_XScaleFactor)+hv_LeftBorder)-(hv_XAxisStartValue*hv_XScaleFactor);
                }
                hv_Col2.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_Col2 = (((hv_XValues_COPY_INP_TMP.TupleSelect(
                    hv_Index+1))*hv_XScaleFactor)+hv_LeftBorder)-(hv_XAxisStartValue*hv_XScaleFactor);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                ho_StairTmp.Dispose();
                HOperatorSet.GenContourPolygonXld(out ho_StairTmp, ((hv_Row1.TupleConcat(
                    hv_Row1))).TupleConcat(hv_Row2), ((hv_Col1.TupleConcat(hv_Col2))).TupleConcat(
                    hv_Col2));
                }
                {
                HObject ExpTmpOutVar_0;
                HOperatorSet.ConcatObj(ho_Stair, ho_StairTmp, out ExpTmpOutVar_0);
                ho_Stair.Dispose();
                ho_Stair = ExpTmpOutVar_0;
                }
              }
              {
              HObject ExpTmpOutVar_0;
              HOperatorSet.UnionAdjacentContoursXld(ho_Stair, out ExpTmpOutVar_0, 
                  0.1, 0.1, "attr_keep");
              ho_Stair.Dispose();
              ho_Stair = ExpTmpOutVar_0;
              }
              if ((int)(new HTuple(hv_Clip.TupleEqual("yes"))) != 0)
              {
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                HObject ExpTmpOutVar_0;
                HOperatorSet.ClipRegion(ho_Stair, out ExpTmpOutVar_0, hv_UpperBorder, 
                    hv_LeftBorder, hv_Height-hv_LowerBorder, hv_Width-hv_RightBorder);
                ho_Stair.Dispose();
                ho_Stair = ExpTmpOutVar_0;
                }
              }
              if (HDevWindowStack.IsOpen())
              {
                HOperatorSet.DispObj(ho_Stair, HDevWindowStack.GetActive());
              }
            }
            else
            {
              throw new HalconException("Unsupported style: "+hv_Style);
            }
          }
        }
      }
      //
      //
      //Reset original display settings
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetPart(HDevWindowStack.GetActive(), hv_PartRow1, hv_PartColumn1, 
            hv_PartRow2, hv_PartColumn2);
      }
      HDevWindowStack.SetActive(hv_PreviousWindowHandle);
      HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
      }
      HOperatorSet.SetLineStyle(hv_WindowHandle, hv_OriginStyle);
      HOperatorSet.SetSystem("clip_region", hv_ClipRegion);
      ho_ContourXGrid.Dispose();
      ho_ContourYGrid.Dispose();
      ho_XArrow.Dispose();
      ho_YArrow.Dispose();
      ho_ContourXTick.Dispose();
      ho_ContourYTick.Dispose();
      ho_Contour.Dispose();
      ho_Cross.Dispose();
      ho_Filled.Dispose();
      ho_Stair.Dispose();
      ho_StairTmp.Dispose();

      hv_XValues_COPY_INP_TMP.Dispose();
      hv_YValues_COPY_INP_TMP.Dispose();
      hv_PreviousWindowHandle.Dispose();
      hv_ClipRegion.Dispose();
      hv_Row.Dispose();
      hv_Column.Dispose();
      hv_Width.Dispose();
      hv_Height.Dispose();
      hv_PartRow1.Dispose();
      hv_PartColumn1.Dispose();
      hv_PartRow2.Dispose();
      hv_PartColumn2.Dispose();
      hv_Red.Dispose();
      hv_Green.Dispose();
      hv_Blue.Dispose();
      hv_DrawMode.Dispose();
      hv_OriginStyle.Dispose();
      hv_XAxisEndValue.Dispose();
      hv_YAxisEndValue.Dispose();
      hv_XAxisStartValue.Dispose();
      hv_YAxisStartValue.Dispose();
      hv_XValuesAreStrings.Dispose();
      hv_XTickValues.Dispose();
      hv_XTicks.Dispose();
      hv_YAxisPosition.Dispose();
      hv_XAxisPosition.Dispose();
      hv_LeftBorder.Dispose();
      hv_RightBorder.Dispose();
      hv_UpperBorder.Dispose();
      hv_LowerBorder.Dispose();
      hv_AxesColor.Dispose();
      hv_Style.Dispose();
      hv_Clip.Dispose();
      hv_YTicks.Dispose();
      hv_XGrid.Dispose();
      hv_YGrid.Dispose();
      hv_GridColor.Dispose();
      hv_YPosition.Dispose();
      hv_FormatX.Dispose();
      hv_FormatY.Dispose();
      hv_NumGenParamNames.Dispose();
      hv_NumGenParamValues.Dispose();
      hv_GenParamIndex.Dispose();
      hv_XGridTicks.Dispose();
      hv_YTickDirection.Dispose();
      hv_XTickDirection.Dispose();
      hv_XAxisWidthPx.Dispose();
      hv_XAxisWidth.Dispose();
      hv_XScaleFactor.Dispose();
      hv_YAxisHeightPx.Dispose();
      hv_YAxisHeight.Dispose();
      hv_YScaleFactor.Dispose();
      hv_YAxisOffsetPx.Dispose();
      hv_XAxisOffsetPx.Dispose();
      hv_DotStyle.Dispose();
      hv_XGridValues.Dispose();
      hv_XGridStart.Dispose();
      hv_XCoord.Dispose();
      hv_IndexGrid.Dispose();
      hv_YGridValues.Dispose();
      hv_YGridStart.Dispose();
      hv_YCoord.Dispose();
      hv_Ascent.Dispose();
      hv_Descent.Dispose();
      hv_TextWidthXLabel.Dispose();
      hv_TextHeightXLabel.Dispose();
      hv_TextWidthYLabel.Dispose();
      hv_TextHeightYLabel.Dispose();
      hv_XTickStart.Dispose();
      hv_Indices.Dispose();
      hv_TypeTicks.Dispose();
      hv_IndexTicks.Dispose();
      hv_Ascent1.Dispose();
      hv_Descent1.Dispose();
      hv_TextWidthXTicks.Dispose();
      hv_TextHeightXTicks.Dispose();
      hv_YTickValues.Dispose();
      hv_YTickStart.Dispose();
      hv_TextWidthYTicks.Dispose();
      hv_TextHeightYTicks.Dispose();
      hv_Num.Dispose();
      hv_I.Dispose();
      hv_YSelected.Dispose();
      hv_Y1Selected.Dispose();
      hv_X1Selected.Dispose();
      hv_Index.Dispose();
      hv_Row1.Dispose();
      hv_Row2.Dispose();
      hv_Col1.Dispose();
      hv_Col2.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_ContourXGrid.Dispose();
      ho_ContourYGrid.Dispose();
      ho_XArrow.Dispose();
      ho_YArrow.Dispose();
      ho_ContourXTick.Dispose();
      ho_ContourYTick.Dispose();
      ho_Contour.Dispose();
      ho_Cross.Dispose();
      ho_Filled.Dispose();
      ho_Stair.Dispose();
      ho_StairTmp.Dispose();

      hv_XValues_COPY_INP_TMP.Dispose();
      hv_YValues_COPY_INP_TMP.Dispose();
      hv_PreviousWindowHandle.Dispose();
      hv_ClipRegion.Dispose();
      hv_Row.Dispose();
      hv_Column.Dispose();
      hv_Width.Dispose();
      hv_Height.Dispose();
      hv_PartRow1.Dispose();
      hv_PartColumn1.Dispose();
      hv_PartRow2.Dispose();
      hv_PartColumn2.Dispose();
      hv_Red.Dispose();
      hv_Green.Dispose();
      hv_Blue.Dispose();
      hv_DrawMode.Dispose();
      hv_OriginStyle.Dispose();
      hv_XAxisEndValue.Dispose();
      hv_YAxisEndValue.Dispose();
      hv_XAxisStartValue.Dispose();
      hv_YAxisStartValue.Dispose();
      hv_XValuesAreStrings.Dispose();
      hv_XTickValues.Dispose();
      hv_XTicks.Dispose();
      hv_YAxisPosition.Dispose();
      hv_XAxisPosition.Dispose();
      hv_LeftBorder.Dispose();
      hv_RightBorder.Dispose();
      hv_UpperBorder.Dispose();
      hv_LowerBorder.Dispose();
      hv_AxesColor.Dispose();
      hv_Style.Dispose();
      hv_Clip.Dispose();
      hv_YTicks.Dispose();
      hv_XGrid.Dispose();
      hv_YGrid.Dispose();
      hv_GridColor.Dispose();
      hv_YPosition.Dispose();
      hv_FormatX.Dispose();
      hv_FormatY.Dispose();
      hv_NumGenParamNames.Dispose();
      hv_NumGenParamValues.Dispose();
      hv_GenParamIndex.Dispose();
      hv_XGridTicks.Dispose();
      hv_YTickDirection.Dispose();
      hv_XTickDirection.Dispose();
      hv_XAxisWidthPx.Dispose();
      hv_XAxisWidth.Dispose();
      hv_XScaleFactor.Dispose();
      hv_YAxisHeightPx.Dispose();
      hv_YAxisHeight.Dispose();
      hv_YScaleFactor.Dispose();
      hv_YAxisOffsetPx.Dispose();
      hv_XAxisOffsetPx.Dispose();
      hv_DotStyle.Dispose();
      hv_XGridValues.Dispose();
      hv_XGridStart.Dispose();
      hv_XCoord.Dispose();
      hv_IndexGrid.Dispose();
      hv_YGridValues.Dispose();
      hv_YGridStart.Dispose();
      hv_YCoord.Dispose();
      hv_Ascent.Dispose();
      hv_Descent.Dispose();
      hv_TextWidthXLabel.Dispose();
      hv_TextHeightXLabel.Dispose();
      hv_TextWidthYLabel.Dispose();
      hv_TextHeightYLabel.Dispose();
      hv_XTickStart.Dispose();
      hv_Indices.Dispose();
      hv_TypeTicks.Dispose();
      hv_IndexTicks.Dispose();
      hv_Ascent1.Dispose();
      hv_Descent1.Dispose();
      hv_TextWidthXTicks.Dispose();
      hv_TextHeightXTicks.Dispose();
      hv_YTickValues.Dispose();
      hv_YTickStart.Dispose();
      hv_TextWidthYTicks.Dispose();
      hv_TextHeightYTicks.Dispose();
      hv_Num.Dispose();
      hv_I.Dispose();
      hv_YSelected.Dispose();
      hv_Y1Selected.Dispose();
      hv_X1Selected.Dispose();
      hv_Index.Dispose();
      hv_Row1.Dispose();
      hv_Row2.Dispose();
      hv_Col1.Dispose();
      hv_Col2.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: Standard preprocessing on the entire dataset declared in DLDataset. 
  public void preprocess_dl_dataset (HTuple hv_DLDataset, HTuple hv_DataDirectory, 
      HTuple hv_DLPreprocessParam, HTuple hv_GenParam, out HTuple hv_DLDatasetFileName)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_OverwriteFiles = new HTuple(), hv_ShowProgress = new HTuple();
    HTuple hv_ClassWeightsSegmentation = new HTuple(), hv_MaxWeight = new HTuple();
    HTuple hv_DLModelType = new HTuple(), hv_GenParamGenDLSamples = new HTuple();
    HTuple hv_ClassIDsDataset = new HTuple(), hv_SetBackgroundID = new HTuple();
    HTuple hv_Indices = new HTuple(), hv_KeyExists = new HTuple();
    HTuple hv_InstanceType = new HTuple(), hv_GenParamName = new HTuple();
    HTuple hv_GenParamIndex = new HTuple(), hv_FileExists = new HTuple();
    HTuple hv_DLSampleDir = new HTuple(), hv_DLDatasetSamples = new HTuple();
    HTuple hv_Progress = new HTuple(), hv_SecondsStart = new HTuple();
    HTuple hv_SampleIndex = new HTuple(), hv_DLSampleBatch = new HTuple();
    HTuple hv_SecondsElapsed = new HTuple(), hv_SecondsRemaining = new HTuple();
    HTuple hv_ProgressPercent = new HTuple(), hv_ProgressPerSecond = new HTuple();
    HTuple hv_TimeElapsedString = new HTuple(), hv_TimeRemainingString = new HTuple();
    HTuple hv_IgnoreClassIDs = new HTuple();
    HTuple   hv_DataDirectory_COPY_INP_TMP = new HTuple(hv_DataDirectory);

    // Initialize local and output iconic variables 
    hv_DLDatasetFileName = new HTuple();
    try
    {
      //
      //This procedure preprocesses the samples in the dictionary DLDataset.
      //
      //** Parameters values: ***
      //
      //Set the default values.
      //Overwrite existing DLDataset file and DLSample directory.
      hv_OverwriteFiles.Dispose();
      hv_OverwriteFiles = 0;
      //By default we show the progress of preprocessing.
      hv_ShowProgress.Dispose();
      hv_ShowProgress = 1;
      //Class weights specified by user (needed for segmentation)
      hv_ClassWeightsSegmentation.Dispose();
      hv_ClassWeightsSegmentation = new HTuple();
      //Set max weight. Parameter for calculating the weights (needed for segmentation).
      hv_MaxWeight.Dispose();
      hv_MaxWeight = 1000;
      //
      //Check the validity of the preprocessing parameters.
      check_dl_preprocess_param(hv_DLPreprocessParam);
      //Get the model type.
      hv_DLModelType.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "model_type", out hv_DLModelType);
      //
      //Initialize the generic parameters for gen_dl_samples.
      hv_GenParamGenDLSamples.Dispose();
      hv_GenParamGenDLSamples = new HTuple();
      //Check if the background class ID is part of the DLDataset class IDs.
      if ((int)(new HTuple(hv_DLModelType.TupleEqual("segmentation"))) != 0)
      {
        hv_ClassIDsDataset.Dispose();
        HOperatorSet.GetDictTuple(hv_DLDataset, "class_ids", out hv_ClassIDsDataset);
        hv_SetBackgroundID.Dispose();
        HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "set_background_id", out hv_SetBackgroundID);
        if ((int)(new HTuple((new HTuple(hv_SetBackgroundID.TupleLength())).TupleGreater(
            0))) != 0)
        {
          hv_Indices.Dispose();
          HOperatorSet.TupleFind(hv_ClassIDsDataset, hv_SetBackgroundID, out hv_Indices);
          if ((int)(new HTuple(hv_Indices.TupleEqual(-1))) != 0)
          {
            throw new HalconException(("The 'set_background_id':'"+hv_SetBackgroundID)+"' needs to be part of the DLDataset 'class_ids' tuple.");
          }
        }
      }
      else if ((int)(new HTuple(hv_DLModelType.TupleEqual("detection"))) != 0)
      {
        hv_GenParamGenDLSamples.Dispose();
        HOperatorSet.CreateDict(out hv_GenParamGenDLSamples);
        hv_KeyExists.Dispose();
        HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", "instance_type", 
            out hv_KeyExists);
        if ((int)(hv_KeyExists) != 0)
        {
          hv_InstanceType.Dispose();
          HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "instance_type", out hv_InstanceType);
          HOperatorSet.SetDictTuple(hv_GenParamGenDLSamples, "instance_type", hv_InstanceType);
        }
        else
        {
          HOperatorSet.SetDictTuple(hv_GenParamGenDLSamples, "instance_type", "rectangle1");
        }
      }
      //
      //Set the parameters for preprocess_dl_samples.
      HOperatorSet.SetDictTuple(hv_DLDataset, "preprocess_param", hv_DLPreprocessParam);
      //
      //Transfer generic parameters.
      if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
      {
        hv_GenParamName.Dispose();
        HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_GenParamName);
        for (hv_GenParamIndex=0; (int)hv_GenParamIndex<=(int)((new HTuple(hv_GenParamName.TupleLength()
            ))-1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
        {
          if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
              "overwrite_files"))) != 0)
          {
            hv_OverwriteFiles.Dispose();
            HOperatorSet.GetDictTuple(hv_GenParam, "overwrite_files", out hv_OverwriteFiles);
          }
          else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
              "show_progress"))) != 0)
          {
            hv_ShowProgress.Dispose();
            HOperatorSet.GetDictTuple(hv_GenParam, "show_progress", out hv_ShowProgress);
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_ShowProgress = (new HTuple(hv_ShowProgress.TupleEqual(
                "true"))).TupleOr(new HTuple(hv_ShowProgress.TupleEqual(1)));
            hv_ShowProgress.Dispose();
            hv_ShowProgress = ExpTmpLocalVar_ShowProgress;
            }
            }
          }
          else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
              "max_weight"))) != 0)
          {
            hv_MaxWeight.Dispose();
            HOperatorSet.GetDictTuple(hv_GenParam, "max_weight", out hv_MaxWeight);
            if ((int)(new HTuple(hv_DLModelType.TupleNotEqual("segmentation"))) != 0)
            {
              throw new HalconException("The preprocessing parameter 'max_weight' only applies for segmentation models.");
            }
          }
          else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
              "class_weights"))) != 0)
          {
            hv_ClassWeightsSegmentation.Dispose();
            HOperatorSet.GetDictTuple(hv_GenParam, "class_weights", out hv_ClassWeightsSegmentation);
            if ((int)(new HTuple(hv_DLModelType.TupleNotEqual("segmentation"))) != 0)
            {
              throw new HalconException("The preprocessing parameter 'class_weights' only applies for segmentation models.");
            }
          }
          else
          {
            throw new HalconException(("Unknown generic parameter: '"+(hv_GenParamName.TupleSelect(
                hv_GenParamIndex)))+"'");
          }
        }
      }
      //
      //** Clean/Create data directory: ***
      {
      HTuple ExpTmpOutVar_0;
      HOperatorSet.TupleRegexpReplace(hv_DataDirectory_COPY_INP_TMP, "/+$", "", out ExpTmpOutVar_0);
      hv_DataDirectory_COPY_INP_TMP.Dispose();
      hv_DataDirectory_COPY_INP_TMP = ExpTmpOutVar_0;
      }
      hv_FileExists.Dispose();
      HOperatorSet.FileExists(hv_DataDirectory_COPY_INP_TMP, out hv_FileExists);
      if ((int)(hv_FileExists.TupleAnd(hv_OverwriteFiles.TupleNot())) != 0)
      {
        throw new HalconException(("The folder "+hv_DataDirectory_COPY_INP_TMP)+" already exists. Either give a different directory or force overwriting using the parameter 'overwrite_files'.");
      }
      if ((int)(hv_FileExists) != 0)
      {
        remove_dir_recursively(hv_DataDirectory_COPY_INP_TMP);
      }
      HOperatorSet.MakeDir(hv_DataDirectory_COPY_INP_TMP);
      //
      //Create the directory for the DLSamples, if it does not exist.
      //
      //Sample directory name.
      hv_DLSampleDir.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_DLSampleDir = hv_DataDirectory_COPY_INP_TMP+"/samples";
      }
      HOperatorSet.MakeDir(hv_DLSampleDir);
      //
      //Set the output path.
      HOperatorSet.SetDictTuple(hv_DLDataset, "dlsample_dir", hv_DLSampleDir);
      //
      //** Preprocess all images in the dataset: ***
      //During training/validation and testing those preprocessed images
      //will be used for performance reasons.
      //
      //Get the samples to be preprocessed.
      hv_DLDatasetSamples.Dispose();
      HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLDatasetSamples);
      //
      //Initialize progress variables.
      if ((int)(hv_ShowProgress) != 0)
      {
        hv_Progress.Dispose();
        hv_Progress = new HTuple();
        hv_Progress[0] = "Procedure: preprocess_dl_dataset";
        hv_Progress[1] = "";
        hv_Progress[2] = "";
        hv_Progress[3] = "";
        if ((int)(new HTuple(hv_DLModelType.TupleEqual("segmentation"))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_Progress = hv_Progress.TupleConcat(
              "Task: 1/2: image preprocessing");
          hv_Progress.Dispose();
          hv_Progress = ExpTmpLocalVar_Progress;
          }
          }
        }
        hv_SecondsStart.Dispose();
        HOperatorSet.CountSeconds(out hv_SecondsStart);
        // dev_inspect_ctrl(...); only in hdevelop
      }
      //
      //Loop over all samples.
      for (hv_SampleIndex=0; (int)hv_SampleIndex<=(int)((new HTuple(hv_DLDatasetSamples.TupleLength()
          ))-1); hv_SampleIndex = (int)hv_SampleIndex + 1)
      {
        //
        //Generate the dictionary DLSample.
        hv_DLSampleBatch.Dispose();

        //ADD FOR DISPLAY
        loopCount = hv_SampleIndex + 1;
        imageCount = new HTuple(hv_DLDatasetSamples.TupleLength());

        gen_dl_samples(hv_DLDataset, hv_SampleIndex, hv_DLModelType, hv_GenParamGenDLSamples, 
            out hv_DLSampleBatch);
        //
        //Preprocess the DLSample.
        preprocess_dl_samples(hv_DLSampleBatch, hv_DLPreprocessParam);
        //
        //Write the preprocessed images.
        write_dl_samples(hv_DLDataset, hv_SampleIndex, hv_DLSampleBatch, new HTuple(), 
            new HTuple());
        //
        //Provide progress information.
        if ((int)(hv_ShowProgress.TupleAnd((new HTuple(((hv_SampleIndex%10)).TupleEqual(
            1))).TupleOr(new HTuple(hv_SampleIndex.TupleEqual((new HTuple(hv_DLDatasetSamples.TupleLength()
            ))-1))))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_SecondsElapsed.Dispose();hv_SecondsRemaining.Dispose();hv_ProgressPercent.Dispose();hv_ProgressPerSecond.Dispose();
          estimate_progress(hv_SecondsStart, 0, hv_SampleIndex, (new HTuple(hv_DLDatasetSamples.TupleLength()
              ))-1, out hv_SecondsElapsed, out hv_SecondsRemaining, out hv_ProgressPercent, 
              out hv_ProgressPerSecond);
          }
          hv_TimeElapsedString.Dispose();
          timespan_string(hv_SecondsElapsed, "auto", out hv_TimeElapsedString);
          hv_TimeRemainingString.Dispose();
          timespan_string(hv_SecondsRemaining, "top2", out hv_TimeRemainingString);
          if (hv_Progress == null)
            hv_Progress = new HTuple();
          hv_Progress[1] = ("Preprocess progress: " + (hv_ProgressPercent.TupleRound())) + " %";
          if (hv_Progress == null)
            hv_Progress = new HTuple();
          hv_Progress[2] = "Time elapsed: "+hv_TimeElapsedString;
          if (hv_Progress == null)
            hv_Progress = new HTuple();
          hv_Progress[3] = "Time left: "+hv_TimeRemainingString;

          //ADD FOR DISPLAY
          hv_Progress_ForDisplay[0] = hv_Progress[1];
          hv_Progress_ForDisplay[1] = hv_Progress[2];
          hv_Progress_ForDisplay[2] = hv_Progress[3];
        }
      }
      //
      //If the model is of type segmentation, generate weight images.
      if ((int)(new HTuple(hv_DLModelType.TupleEqual("segmentation"))) != 0)
      {
        //
        if ((int)(hv_ShowProgress) != 0)
        {
          hv_Progress.Dispose();
          hv_Progress = new HTuple();
          hv_Progress[0] = "Procedure: preprocess_dl_dataset";
          hv_Progress[1] = "";
          hv_Progress[2] = "";
          if (hv_Progress == null)
            hv_Progress = new HTuple();
          hv_Progress[1] = "Please wait...";
          if (hv_Progress == null)
            hv_Progress = new HTuple();
          hv_Progress[2] = "Task: 2/2: calculating class weights";
        }
        if ((int)(new HTuple((new HTuple(hv_ClassWeightsSegmentation.TupleLength()
            )).TupleEqual(0))) != 0)
        {
          //Calculate the class weights for segmentation.
          hv_IgnoreClassIDs.Dispose();
          HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "ignore_class_ids", out hv_IgnoreClassIDs);
          hv_ClassWeightsSegmentation.Dispose();
          calculate_dl_segmentation_class_weights(hv_DLDataset, hv_MaxWeight, hv_IgnoreClassIDs, 
              out hv_ClassWeightsSegmentation);
        }
        //
        //Generate the weight images.
        gen_dl_segmentation_weight_images(hv_DLDataset, hv_DLPreprocessParam, hv_ClassWeightsSegmentation, 
            new HTuple());
      }
      if ((int)(hv_ShowProgress.TupleNot()) != 0)
      {
        hv_Progress.Dispose();
        hv_Progress = "Done.";
        // dev_close_inspect_ctrl(...); only in hdevelop
      }
      //
      //Write the DLDataset dict.
      hv_DLDatasetFileName.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      //MODIFY
      hv_DLDatasetFileName = hv_DataDirectory_COPY_INP_TMP + "\\" + hv_PreprocessResultFileName;
      }
      HOperatorSet.WriteDict(hv_DLDataset, hv_DLDatasetFileName, new HTuple(), new HTuple());

      hv_DataDirectory_COPY_INP_TMP.Dispose();
      hv_OverwriteFiles.Dispose();
      hv_ShowProgress.Dispose();
      hv_ClassWeightsSegmentation.Dispose();
      hv_MaxWeight.Dispose();
      hv_DLModelType.Dispose();
      hv_GenParamGenDLSamples.Dispose();
      hv_ClassIDsDataset.Dispose();
      hv_SetBackgroundID.Dispose();
      hv_Indices.Dispose();
      hv_KeyExists.Dispose();
      hv_InstanceType.Dispose();
      hv_GenParamName.Dispose();
      hv_GenParamIndex.Dispose();
      hv_FileExists.Dispose();
      hv_DLSampleDir.Dispose();
      hv_DLDatasetSamples.Dispose();
      hv_Progress.Dispose();
      hv_SecondsStart.Dispose();
      hv_SampleIndex.Dispose();
      hv_DLSampleBatch.Dispose();
      hv_SecondsElapsed.Dispose();
      hv_SecondsRemaining.Dispose();
      hv_ProgressPercent.Dispose();
      hv_ProgressPerSecond.Dispose();
      hv_TimeElapsedString.Dispose();
      hv_TimeRemainingString.Dispose();
      hv_IgnoreClassIDs.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_DataDirectory_COPY_INP_TMP.Dispose();
      hv_OverwriteFiles.Dispose();
      hv_ShowProgress.Dispose();
      hv_ClassWeightsSegmentation.Dispose();
      hv_MaxWeight.Dispose();
      hv_DLModelType.Dispose();
      hv_GenParamGenDLSamples.Dispose();
      hv_ClassIDsDataset.Dispose();
      hv_SetBackgroundID.Dispose();
      hv_Indices.Dispose();
      hv_KeyExists.Dispose();
      hv_InstanceType.Dispose();
      hv_GenParamName.Dispose();
      hv_GenParamIndex.Dispose();
      hv_FileExists.Dispose();
      hv_DLSampleDir.Dispose();
      hv_DLDatasetSamples.Dispose();
      hv_Progress.Dispose();
      hv_SecondsStart.Dispose();
      hv_SampleIndex.Dispose();
      hv_DLSampleBatch.Dispose();
      hv_SecondsElapsed.Dispose();
      hv_SecondsRemaining.Dispose();
      hv_ProgressPercent.Dispose();
      hv_ProgressPerSecond.Dispose();
      hv_TimeElapsedString.Dispose();
      hv_TimeRemainingString.Dispose();
      hv_IgnoreClassIDs.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: Preprocess anomaly images for evaluation and visualization of the deep-learning-based anomaly detection. 
  public void preprocess_dl_model_anomaly (HObject ho_AnomalyImages, out HObject ho_AnomalyImagesPreprocessed, 
      HTuple hv_DLPreprocessParam)
  {




    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    // Local copy input parameter variables 
    HObject ho_AnomalyImages_COPY_INP_TMP;
    ho_AnomalyImages_COPY_INP_TMP = new HObject(ho_AnomalyImages);



    // Local control variables 

    HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
    HTuple hv_ImageRangeMin = new HTuple(), hv_ImageRangeMax = new HTuple();
    HTuple hv_DomainHandling = new HTuple(), hv_ModelType = new HTuple();
    HTuple hv_ImageNumChannels = new HTuple(), hv_Min = new HTuple();
    HTuple hv_Max = new HTuple(), hv_Range = new HTuple();
    HTuple hv_ImageWidthInput = new HTuple(), hv_ImageHeightInput = new HTuple();
    HTuple hv_EqualWidth = new HTuple(), hv_EqualHeight = new HTuple();
    HTuple hv_Type = new HTuple(), hv_NumMatches = new HTuple();
    HTuple hv_NumImages = new HTuple(), hv_EqualByte = new HTuple();
    HTuple hv_NumChannelsAllImages = new HTuple(), hv_ImageNumChannelsTuple = new HTuple();
    HTuple hv_IndicesWrongChannels = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_AnomalyImagesPreprocessed);
    try
    {
      //
      //This procedure preprocesses the anomaly images given by AnomalyImages
      //according to the parameters in the dictionary DLPreprocessParam.
      //Note that depending on the images,
      //additional preprocessing steps might be beneficial.
      //
      //Check the validity of the preprocessing parameters.
      check_dl_preprocess_param(hv_DLPreprocessParam);
      //
      //Get the preprocessing parameters.
      hv_ImageWidth.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_width", out hv_ImageWidth);
      hv_ImageHeight.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_height", out hv_ImageHeight);
      hv_ImageRangeMin.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_min", out hv_ImageRangeMin);
      hv_ImageRangeMax.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_max", out hv_ImageRangeMax);
      hv_DomainHandling.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "domain_handling", out hv_DomainHandling);
      hv_ModelType.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "model_type", out hv_ModelType);
      //
      hv_ImageNumChannels.Dispose();
      hv_ImageNumChannels = 1;
      //
      //Preprocess the images.
      //
      if ((int)(new HTuple(hv_DomainHandling.TupleEqual("full_domain"))) != 0)
      {
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.FullDomain(ho_AnomalyImages_COPY_INP_TMP, out ExpTmpOutVar_0
            );
        ho_AnomalyImages_COPY_INP_TMP.Dispose();
        ho_AnomalyImages_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      else if ((int)(new HTuple(hv_DomainHandling.TupleEqual("crop_domain"))) != 0)
      {
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.CropDomain(ho_AnomalyImages_COPY_INP_TMP, out ExpTmpOutVar_0
            );
        ho_AnomalyImages_COPY_INP_TMP.Dispose();
        ho_AnomalyImages_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      else if ((int)((new HTuple(hv_DomainHandling.TupleEqual("keep_domain"))).TupleAnd(
          new HTuple(hv_ModelType.TupleEqual("anomaly_detection")))) != 0)
      {
        //Anomaly detection models accept the additional option 'keep_domain'.
      }
      else
      {
        throw new HalconException("Unsupported parameter value for 'domain_handling'");
      }
      //
      hv_Min.Dispose();hv_Max.Dispose();hv_Range.Dispose();
      HOperatorSet.MinMaxGray(ho_AnomalyImages_COPY_INP_TMP, ho_AnomalyImages_COPY_INP_TMP, 
          0, out hv_Min, out hv_Max, out hv_Range);
      if ((int)(new HTuple(hv_Min.TupleLess(0.0))) != 0)
      {
        throw new HalconException("Values of anomaly image must not be smaller than 0.0.");
      }
      //
      //Zoom images only if they have a different size than the specified size.
      hv_ImageWidthInput.Dispose();hv_ImageHeightInput.Dispose();
      HOperatorSet.GetImageSize(ho_AnomalyImages_COPY_INP_TMP, out hv_ImageWidthInput, 
          out hv_ImageHeightInput);
      hv_EqualWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_EqualWidth = hv_ImageWidth.TupleEqualElem(
          hv_ImageWidthInput);
      }
      hv_EqualHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_EqualHeight = hv_ImageHeight.TupleEqualElem(
          hv_ImageHeightInput);
      }
      if ((int)((new HTuple(((hv_EqualWidth.TupleMin())).TupleEqual(0))).TupleOr(
          new HTuple(((hv_EqualHeight.TupleMin())).TupleEqual(0)))) != 0)
      {
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ZoomImageSize(ho_AnomalyImages_COPY_INP_TMP, out ExpTmpOutVar_0, 
            hv_ImageWidth, hv_ImageHeight, "nearest_neighbor");
        ho_AnomalyImages_COPY_INP_TMP.Dispose();
        ho_AnomalyImages_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      //
      //Check the type of the input images.
      hv_Type.Dispose();
      HOperatorSet.GetImageType(ho_AnomalyImages_COPY_INP_TMP, out hv_Type);
      hv_NumMatches.Dispose();
      HOperatorSet.TupleRegexpTest(hv_Type, "byte|real", out hv_NumMatches);
      hv_NumImages.Dispose();
      HOperatorSet.CountObj(ho_AnomalyImages_COPY_INP_TMP, out hv_NumImages);
      if ((int)(new HTuple(hv_NumMatches.TupleNotEqual(hv_NumImages))) != 0)
      {
        throw new HalconException("Please provide only images of type 'byte' or 'real'.");
      }
      //
      //If the type is 'byte', convert it to 'real' and scale it.
      //The gray value scaling does not work on 'byte' images.
      //For 'real' images it is assumed that the range is already correct.
      hv_EqualByte.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_EqualByte = hv_Type.TupleEqualElem(
          "byte");
      }
      if ((int)(new HTuple(((hv_EqualByte.TupleMax())).TupleEqual(1))) != 0)
      {
        if ((int)(new HTuple(((hv_EqualByte.TupleMin())).TupleEqual(0))) != 0)
        {
          throw new HalconException("Passing mixed type images is not supported.");
        }
        //Convert the image type from 'byte' to 'real',
        //because the model expects 'real' images.
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConvertImageType(ho_AnomalyImages_COPY_INP_TMP, out ExpTmpOutVar_0, 
            "real");
        ho_AnomalyImages_COPY_INP_TMP.Dispose();
        ho_AnomalyImages_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      //
      //Check the number of channels.
      hv_NumImages.Dispose();
      HOperatorSet.CountObj(ho_AnomalyImages_COPY_INP_TMP, out hv_NumImages);
      //Check all images for number of channels.
      hv_NumChannelsAllImages.Dispose();
      HOperatorSet.CountChannels(ho_AnomalyImages_COPY_INP_TMP, out hv_NumChannelsAllImages);
      hv_ImageNumChannelsTuple.Dispose();
      HOperatorSet.TupleGenConst(hv_NumImages, hv_ImageNumChannels, out hv_ImageNumChannelsTuple);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_IndicesWrongChannels.Dispose();
      HOperatorSet.TupleFind(hv_NumChannelsAllImages.TupleNotEqualElem(hv_ImageNumChannelsTuple), 
          1, out hv_IndicesWrongChannels);
      }
      //
      //Check for anomaly image channels.
      //Only single channel images are accepted.
      if ((int)(new HTuple(hv_IndicesWrongChannels.TupleNotEqual(-1))) != 0)
      {
        throw new HalconException("Number of channels in anomaly image is not supported. Please check for anomaly images with a number of channels different from 1.");
      }
      //
      //Write preprocessed image to output variable.
      ho_AnomalyImagesPreprocessed.Dispose();
      ho_AnomalyImagesPreprocessed = new HObject(ho_AnomalyImages_COPY_INP_TMP);
      //
      ho_AnomalyImages_COPY_INP_TMP.Dispose();

      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_ImageRangeMin.Dispose();
      hv_ImageRangeMax.Dispose();
      hv_DomainHandling.Dispose();
      hv_ModelType.Dispose();
      hv_ImageNumChannels.Dispose();
      hv_Min.Dispose();
      hv_Max.Dispose();
      hv_Range.Dispose();
      hv_ImageWidthInput.Dispose();
      hv_ImageHeightInput.Dispose();
      hv_EqualWidth.Dispose();
      hv_EqualHeight.Dispose();
      hv_Type.Dispose();
      hv_NumMatches.Dispose();
      hv_NumImages.Dispose();
      hv_EqualByte.Dispose();
      hv_NumChannelsAllImages.Dispose();
      hv_ImageNumChannelsTuple.Dispose();
      hv_IndicesWrongChannels.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_AnomalyImages_COPY_INP_TMP.Dispose();

      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_ImageRangeMin.Dispose();
      hv_ImageRangeMax.Dispose();
      hv_DomainHandling.Dispose();
      hv_ModelType.Dispose();
      hv_ImageNumChannels.Dispose();
      hv_Min.Dispose();
      hv_Max.Dispose();
      hv_Range.Dispose();
      hv_ImageWidthInput.Dispose();
      hv_ImageHeightInput.Dispose();
      hv_EqualWidth.Dispose();
      hv_EqualHeight.Dispose();
      hv_Type.Dispose();
      hv_NumMatches.Dispose();
      hv_NumImages.Dispose();
      hv_EqualByte.Dispose();
      hv_NumChannelsAllImages.Dispose();
      hv_ImageNumChannelsTuple.Dispose();
      hv_IndicesWrongChannels.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Object Detection
  // Short Description: This procedure preprocesses the bounding boxes of type 'rectangle1' for a given sample. 
  public void preprocess_dl_model_bbox_rect1 (HObject ho_ImageRaw, HTuple hv_DLSample, 
      HTuple hv_DLPreprocessParam)
  {




    // Local iconic variables 

    HObject ho_DomainRaw=null;

    // Local control variables 

    HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
    HTuple hv_DomainHandling = new HTuple(), hv_BBoxCol1 = new HTuple();
    HTuple hv_BBoxCol2 = new HTuple(), hv_BBoxRow1 = new HTuple();
    HTuple hv_BBoxRow2 = new HTuple(), hv_BBoxLabel = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_ImageId = new HTuple();
    HTuple hv_ExceptionMessage = new HTuple(), hv_BoxesInvalid = new HTuple();
    HTuple hv_RowDomain1 = new HTuple(), hv_ColumnDomain1 = new HTuple();
    HTuple hv_RowDomain2 = new HTuple(), hv_ColumnDomain2 = new HTuple();
    HTuple hv_WidthRaw = new HTuple(), hv_HeightRaw = new HTuple();
    HTuple hv_Row1 = new HTuple(), hv_Col1 = new HTuple();
    HTuple hv_Row2 = new HTuple(), hv_Col2 = new HTuple();
    HTuple hv_MaskDelete = new HTuple(), hv_MaskNewBbox = new HTuple();
    HTuple hv_BBoxCol1New = new HTuple(), hv_BBoxCol2New = new HTuple();
    HTuple hv_BBoxRow1New = new HTuple(), hv_BBoxRow2New = new HTuple();
    HTuple hv_BBoxLabelNew = new HTuple(), hv_FactorResampleWidth = new HTuple();
    HTuple hv_FactorResampleHeight = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_DomainRaw);
    try
    {
      //
      //This procedure preprocesses the bounding boxes of type 'rectangle1' for a given sample.
      //
      //Check the validity of the preprocessing parameters.
      check_dl_preprocess_param(hv_DLPreprocessParam);
      //
      //Get the preprocessing parameters.
      hv_ImageWidth.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_width", out hv_ImageWidth);
      hv_ImageHeight.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_height", out hv_ImageHeight);
      hv_DomainHandling.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "domain_handling", out hv_DomainHandling);
      //
      //Get bounding box coordinates and labels.
      try
      {
        hv_BBoxCol1.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col1", out hv_BBoxCol1);
        hv_BBoxCol2.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col2", out hv_BBoxCol2);
        hv_BBoxRow1.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row1", out hv_BBoxRow1);
        hv_BBoxRow2.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row2", out hv_BBoxRow2);
        hv_BBoxLabel.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_label_id", out hv_BBoxLabel);
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        hv_ImageId.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "image_id", out hv_ImageId);
        if ((int)(new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(1302))) != 0)
        {
          hv_ExceptionMessage.Dispose();
          hv_ExceptionMessage = "A bounding box coordinate key is missing.";
        }
        else
        {
          hv_ExceptionMessage.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ExceptionMessage = hv_Exception.TupleSelect(
              2);
          }
        }
        throw new HalconException((("An error has occurred during preprocessing image_id "+hv_ImageId)+" when getting bounding box coordinates : ")+hv_ExceptionMessage);
      }
      //
      //Check that there are no invalid boxes.
      if ((int)(new HTuple((new HTuple(hv_BBoxRow1.TupleLength())).TupleGreater(0))) != 0)
      {
        hv_BoxesInvalid.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BoxesInvalid = ((hv_BBoxRow1.TupleGreaterEqualElem(
            hv_BBoxRow2))).TupleOr(hv_BBoxCol1.TupleGreaterEqualElem(hv_BBoxCol2));
        }
        if ((int)(new HTuple(((hv_BoxesInvalid.TupleSum())).TupleGreater(0))) != 0)
        {
          hv_ImageId.Dispose();
          HOperatorSet.GetDictTuple(hv_DLSample, "image_id", out hv_ImageId);
          throw new HalconException(("An error has occurred during preprocessing image_id "+hv_ImageId)+new HTuple(": Sample contains at least one box with zero-area, i.e. bbox_col1 >= bbox_col2 or bbox_row1 >= bbox_row2."));
        }
      }
      else
      {
        //If there are no bounding box coordinates, there is nothing to do.
        ho_DomainRaw.Dispose();

        hv_ImageWidth.Dispose();
        hv_ImageHeight.Dispose();
        hv_DomainHandling.Dispose();
        hv_BBoxCol1.Dispose();
        hv_BBoxCol2.Dispose();
        hv_BBoxRow1.Dispose();
        hv_BBoxRow2.Dispose();
        hv_BBoxLabel.Dispose();
        hv_Exception.Dispose();
        hv_ImageId.Dispose();
        hv_ExceptionMessage.Dispose();
        hv_BoxesInvalid.Dispose();
        hv_RowDomain1.Dispose();
        hv_ColumnDomain1.Dispose();
        hv_RowDomain2.Dispose();
        hv_ColumnDomain2.Dispose();
        hv_WidthRaw.Dispose();
        hv_HeightRaw.Dispose();
        hv_Row1.Dispose();
        hv_Col1.Dispose();
        hv_Row2.Dispose();
        hv_Col2.Dispose();
        hv_MaskDelete.Dispose();
        hv_MaskNewBbox.Dispose();
        hv_BBoxCol1New.Dispose();
        hv_BBoxCol2New.Dispose();
        hv_BBoxRow1New.Dispose();
        hv_BBoxRow2New.Dispose();
        hv_BBoxLabelNew.Dispose();
        hv_FactorResampleWidth.Dispose();
        hv_FactorResampleHeight.Dispose();

        return;
      }
      //
      //If the domain is cropped, crop bounding boxes.
      if ((int)(new HTuple(hv_DomainHandling.TupleEqual("crop_domain"))) != 0)
      {
        //
        //Get domain.
        ho_DomainRaw.Dispose();
        HOperatorSet.GetDomain(ho_ImageRaw, out ho_DomainRaw);
        //
        //Set the size of the raw image to the domain extensions.
        hv_RowDomain1.Dispose();hv_ColumnDomain1.Dispose();hv_RowDomain2.Dispose();hv_ColumnDomain2.Dispose();
        HOperatorSet.SmallestRectangle1(ho_DomainRaw, out hv_RowDomain1, out hv_ColumnDomain1, 
            out hv_RowDomain2, out hv_ColumnDomain2);
        //The domain is always given as a pixel-precise region.
        hv_WidthRaw.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_WidthRaw = (hv_ColumnDomain2-hv_ColumnDomain1)+1.0;
        }
        hv_HeightRaw.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_HeightRaw = (hv_RowDomain2-hv_RowDomain1)+1.0;
        }
        //
        //Crop the bounding boxes.
        hv_Row1.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Row1 = hv_BBoxRow1.TupleMax2(
            hv_RowDomain1-.5);
        }
        hv_Col1.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Col1 = hv_BBoxCol1.TupleMax2(
            hv_ColumnDomain1-.5);
        }
        hv_Row2.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Row2 = hv_BBoxRow2.TupleMin2(
            hv_RowDomain2+.5);
        }
        hv_Col2.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Col2 = hv_BBoxCol2.TupleMin2(
            hv_ColumnDomain2+.5);
        }
        hv_MaskDelete.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MaskDelete = ((hv_Row1.TupleGreaterEqualElem(
            hv_Row2))).TupleOr(hv_Col1.TupleGreaterEqualElem(hv_Col2));
        }
        hv_MaskNewBbox.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MaskNewBbox = 1-hv_MaskDelete;
        }
        //Store the preprocessed bounding box entries.
        hv_BBoxCol1New.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BBoxCol1New = (hv_Col1.TupleSelectMask(
            hv_MaskNewBbox))-hv_ColumnDomain1;
        }
        hv_BBoxCol2New.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BBoxCol2New = (hv_Col2.TupleSelectMask(
            hv_MaskNewBbox))-hv_ColumnDomain1;
        }
        hv_BBoxRow1New.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BBoxRow1New = (hv_Row1.TupleSelectMask(
            hv_MaskNewBbox))-hv_RowDomain1;
        }
        hv_BBoxRow2New.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BBoxRow2New = (hv_Row2.TupleSelectMask(
            hv_MaskNewBbox))-hv_RowDomain1;
        }
        hv_BBoxLabelNew.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BBoxLabelNew = hv_BBoxLabel.TupleSelectMask(
            hv_MaskNewBbox);
        }
        //
      }
      else if ((int)(new HTuple(hv_DomainHandling.TupleEqual("full_domain"))) != 0)
      {
        //If the entire image is used, set the variables accordingly.
        //Get the original size.
        hv_WidthRaw.Dispose();hv_HeightRaw.Dispose();
        HOperatorSet.GetImageSize(ho_ImageRaw, out hv_WidthRaw, out hv_HeightRaw);
        //Set new coordinates to input coordinates.
        hv_BBoxCol1New.Dispose();
        hv_BBoxCol1New = new HTuple(hv_BBoxCol1);
        hv_BBoxCol2New.Dispose();
        hv_BBoxCol2New = new HTuple(hv_BBoxCol2);
        hv_BBoxRow1New.Dispose();
        hv_BBoxRow1New = new HTuple(hv_BBoxRow1);
        hv_BBoxRow2New.Dispose();
        hv_BBoxRow2New = new HTuple(hv_BBoxRow2);
        hv_BBoxLabelNew.Dispose();
        hv_BBoxLabelNew = new HTuple(hv_BBoxLabel);
      }
      else
      {
        throw new HalconException("Unsupported parameter value for 'domain_handling'");
      }
      //
      //Rescale the bounding boxes.
      //
      //Get required images width and height.
      //
      //Only rescale bounding boxes if the required image dimensions are not the raw dimensions.
      if ((int)((new HTuple(hv_ImageHeight.TupleNotEqual(hv_HeightRaw))).TupleOr(
          new HTuple(hv_ImageWidth.TupleNotEqual(hv_WidthRaw)))) != 0)
      {
        //Calculate rescaling factor.
        hv_FactorResampleWidth.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_FactorResampleWidth = (hv_ImageWidth.TupleReal()
            )/hv_WidthRaw;
        }
        hv_FactorResampleHeight.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_FactorResampleHeight = (hv_ImageHeight.TupleReal()
            )/hv_HeightRaw;
        }
        //Rescale the bounding box coordinates.
        //As we use XLD-coordinates we temporarily move the boxes by (.5,.5) for rescaling.
        //Doing so, the center of the XLD-coordinate system (-0.5,-0.5) is used
        //for scaling, hence the scaling is performed w.r.t. the pixel coordinate system.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_BBoxCol1New = ((hv_BBoxCol1New+.5)*hv_FactorResampleWidth)-.5;
        hv_BBoxCol1New.Dispose();
        hv_BBoxCol1New = ExpTmpLocalVar_BBoxCol1New;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_BBoxCol2New = ((hv_BBoxCol2New+.5)*hv_FactorResampleWidth)-.5;
        hv_BBoxCol2New.Dispose();
        hv_BBoxCol2New = ExpTmpLocalVar_BBoxCol2New;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_BBoxRow1New = ((hv_BBoxRow1New+.5)*hv_FactorResampleHeight)-.5;
        hv_BBoxRow1New.Dispose();
        hv_BBoxRow1New = ExpTmpLocalVar_BBoxRow1New;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_BBoxRow2New = ((hv_BBoxRow2New+.5)*hv_FactorResampleHeight)-.5;
        hv_BBoxRow2New.Dispose();
        hv_BBoxRow2New = ExpTmpLocalVar_BBoxRow2New;
        }
        }
        //
      }
      //
      //Make a final check and remove bounding boxes that have zero area.
      if ((int)(new HTuple((new HTuple(hv_BBoxRow1New.TupleLength())).TupleGreater(
          0))) != 0)
      {
        hv_MaskDelete.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MaskDelete = ((hv_BBoxRow1New.TupleGreaterEqualElem(
            hv_BBoxRow2New))).TupleOr(hv_BBoxCol1New.TupleGreaterEqualElem(hv_BBoxCol2New));
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_BBoxCol1New = hv_BBoxCol1New.TupleSelectMask(
            1-hv_MaskDelete);
        hv_BBoxCol1New.Dispose();
        hv_BBoxCol1New = ExpTmpLocalVar_BBoxCol1New;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_BBoxCol2New = hv_BBoxCol2New.TupleSelectMask(
            1-hv_MaskDelete);
        hv_BBoxCol2New.Dispose();
        hv_BBoxCol2New = ExpTmpLocalVar_BBoxCol2New;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_BBoxRow1New = hv_BBoxRow1New.TupleSelectMask(
            1-hv_MaskDelete);
        hv_BBoxRow1New.Dispose();
        hv_BBoxRow1New = ExpTmpLocalVar_BBoxRow1New;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_BBoxRow2New = hv_BBoxRow2New.TupleSelectMask(
            1-hv_MaskDelete);
        hv_BBoxRow2New.Dispose();
        hv_BBoxRow2New = ExpTmpLocalVar_BBoxRow2New;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_BBoxLabelNew = hv_BBoxLabelNew.TupleSelectMask(
            1-hv_MaskDelete);
        hv_BBoxLabelNew.Dispose();
        hv_BBoxLabelNew = ExpTmpLocalVar_BBoxLabelNew;
        }
        }
      }
      //
      //Set new bounding box coordinates in the dictionary.
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col1", hv_BBoxCol1New);
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col2", hv_BBoxCol2New);
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row1", hv_BBoxRow1New);
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row2", hv_BBoxRow2New);
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_label_id", hv_BBoxLabelNew);
      //
      ho_DomainRaw.Dispose();

      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_DomainHandling.Dispose();
      hv_BBoxCol1.Dispose();
      hv_BBoxCol2.Dispose();
      hv_BBoxRow1.Dispose();
      hv_BBoxRow2.Dispose();
      hv_BBoxLabel.Dispose();
      hv_Exception.Dispose();
      hv_ImageId.Dispose();
      hv_ExceptionMessage.Dispose();
      hv_BoxesInvalid.Dispose();
      hv_RowDomain1.Dispose();
      hv_ColumnDomain1.Dispose();
      hv_RowDomain2.Dispose();
      hv_ColumnDomain2.Dispose();
      hv_WidthRaw.Dispose();
      hv_HeightRaw.Dispose();
      hv_Row1.Dispose();
      hv_Col1.Dispose();
      hv_Row2.Dispose();
      hv_Col2.Dispose();
      hv_MaskDelete.Dispose();
      hv_MaskNewBbox.Dispose();
      hv_BBoxCol1New.Dispose();
      hv_BBoxCol2New.Dispose();
      hv_BBoxRow1New.Dispose();
      hv_BBoxRow2New.Dispose();
      hv_BBoxLabelNew.Dispose();
      hv_FactorResampleWidth.Dispose();
      hv_FactorResampleHeight.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_DomainRaw.Dispose();

      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_DomainHandling.Dispose();
      hv_BBoxCol1.Dispose();
      hv_BBoxCol2.Dispose();
      hv_BBoxRow1.Dispose();
      hv_BBoxRow2.Dispose();
      hv_BBoxLabel.Dispose();
      hv_Exception.Dispose();
      hv_ImageId.Dispose();
      hv_ExceptionMessage.Dispose();
      hv_BoxesInvalid.Dispose();
      hv_RowDomain1.Dispose();
      hv_ColumnDomain1.Dispose();
      hv_RowDomain2.Dispose();
      hv_ColumnDomain2.Dispose();
      hv_WidthRaw.Dispose();
      hv_HeightRaw.Dispose();
      hv_Row1.Dispose();
      hv_Col1.Dispose();
      hv_Row2.Dispose();
      hv_Col2.Dispose();
      hv_MaskDelete.Dispose();
      hv_MaskNewBbox.Dispose();
      hv_BBoxCol1New.Dispose();
      hv_BBoxCol2New.Dispose();
      hv_BBoxRow1New.Dispose();
      hv_BBoxRow2New.Dispose();
      hv_BBoxLabelNew.Dispose();
      hv_FactorResampleWidth.Dispose();
      hv_FactorResampleHeight.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Object Detection
  // Short Description: This procedure preprocesses the bounding boxes of type 'rectangle2' for a given sample. 
  public void preprocess_dl_model_bbox_rect2 (HObject ho_ImageRaw, HTuple hv_DLSample, 
      HTuple hv_DLPreprocessParam)
  {




    // Local iconic variables 

    HObject ho_DomainRaw=null, ho_Rectangle2XLD=null;
    HObject ho_Rectangle2XLDSheared=null;

    // Local control variables 

    HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
    HTuple hv_DomainHandling = new HTuple(), hv_IgnoreDirection = new HTuple();
    HTuple hv_ClassIDsNoOrientation = new HTuple(), hv_KeyExists = new HTuple();
    HTuple hv_BBoxRow = new HTuple(), hv_BBoxCol = new HTuple();
    HTuple hv_BBoxLength1 = new HTuple(), hv_BBoxLength2 = new HTuple();
    HTuple hv_BBoxPhi = new HTuple(), hv_BBoxLabel = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_ImageId = new HTuple();
    HTuple hv_ExceptionMessage = new HTuple(), hv_BoxesInvalid = new HTuple();
    HTuple hv_RowDomain1 = new HTuple(), hv_ColumnDomain1 = new HTuple();
    HTuple hv_RowDomain2 = new HTuple(), hv_ColumnDomain2 = new HTuple();
    HTuple hv_WidthRaw = new HTuple(), hv_HeightRaw = new HTuple();
    HTuple hv_MaskDelete = new HTuple(), hv_MaskNewBbox = new HTuple();
    HTuple hv_BBoxRowNew = new HTuple(), hv_BBoxColNew = new HTuple();
    HTuple hv_BBoxLength1New = new HTuple(), hv_BBoxLength2New = new HTuple();
    HTuple hv_BBoxPhiNew = new HTuple(), hv_BBoxLabelNew = new HTuple();
    HTuple hv_ClassIDsNoOrientationIndices = new HTuple();
    HTuple hv_Index = new HTuple(), hv_ClassIDsNoOrientationIndicesTmp = new HTuple();
    HTuple hv_DirectionLength1Row = new HTuple(), hv_DirectionLength1Col = new HTuple();
    HTuple hv_DirectionLength2Row = new HTuple(), hv_DirectionLength2Col = new HTuple();
    HTuple hv_Corner1Row = new HTuple(), hv_Corner1Col = new HTuple();
    HTuple hv_Corner2Row = new HTuple(), hv_Corner2Col = new HTuple();
    HTuple hv_FactorResampleWidth = new HTuple(), hv_FactorResampleHeight = new HTuple();
    HTuple hv_BBoxCol1 = new HTuple(), hv_BBoxCol1New = new HTuple();
    HTuple hv_BBoxCol2 = new HTuple(), hv_BBoxCol2New = new HTuple();
    HTuple hv_BBoxCol3 = new HTuple(), hv_BBoxCol3New = new HTuple();
    HTuple hv_BBoxCol4 = new HTuple(), hv_BBoxCol4New = new HTuple();
    HTuple hv_BBoxRow1 = new HTuple(), hv_BBoxRow1New = new HTuple();
    HTuple hv_BBoxRow2 = new HTuple(), hv_BBoxRow2New = new HTuple();
    HTuple hv_BBoxRow3 = new HTuple(), hv_BBoxRow3New = new HTuple();
    HTuple hv_BBoxRow4 = new HTuple(), hv_BBoxRow4New = new HTuple();
    HTuple hv_HomMat2DIdentity = new HTuple(), hv_HomMat2DScale = new HTuple();
    HTuple hv_BBoxPhiTmp = new HTuple(), hv_PhiDelta = new HTuple();
    HTuple hv_PhiDeltaNegativeIndices = new HTuple(), hv_IndicesRot90 = new HTuple();
    HTuple hv_IndicesRot180 = new HTuple(), hv_IndicesRot270 = new HTuple();
    HTuple hv_SwapIndices = new HTuple(), hv_Tmp = new HTuple();
    HTuple hv_BBoxPhiNewIndices = new HTuple(), hv__ = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_DomainRaw);
    HOperatorSet.GenEmptyObj(out ho_Rectangle2XLD);
    HOperatorSet.GenEmptyObj(out ho_Rectangle2XLDSheared);
    try
    {
      //This procedure preprocesses the bounding boxes of type 'rectangle2' for a given sample.
      //
      check_dl_preprocess_param(hv_DLPreprocessParam);
      //
      //Get preprocess parameters.
      hv_ImageWidth.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_width", out hv_ImageWidth);
      hv_ImageHeight.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_height", out hv_ImageHeight);
      hv_DomainHandling.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "domain_handling", out hv_DomainHandling);
      //The keys 'ignore_direction' and 'class_ids_no_orientation' are optional.
      hv_IgnoreDirection.Dispose();
      hv_IgnoreDirection = 0;
      hv_ClassIDsNoOrientation.Dispose();
      hv_ClassIDsNoOrientation = new HTuple();
      hv_KeyExists.Dispose();
      HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", (new HTuple("ignore_direction")).TupleConcat(
          "class_ids_no_orientation"), out hv_KeyExists);
      if ((int)(hv_KeyExists.TupleSelect(0)) != 0)
      {
        hv_IgnoreDirection.Dispose();
        HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "ignore_direction", out hv_IgnoreDirection);
        if ((int)(new HTuple(hv_IgnoreDirection.TupleEqual("true"))) != 0)
        {
          hv_IgnoreDirection.Dispose();
          hv_IgnoreDirection = 1;
        }
        else if ((int)(new HTuple(hv_IgnoreDirection.TupleEqual("false"))) != 0)
        {
          hv_IgnoreDirection.Dispose();
          hv_IgnoreDirection = 0;
        }
      }
      if ((int)(hv_KeyExists.TupleSelect(1)) != 0)
      {
        hv_ClassIDsNoOrientation.Dispose();
        HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "class_ids_no_orientation", 
            out hv_ClassIDsNoOrientation);
      }
      //
      //Get bounding box coordinates and labels.
      try
      {
        hv_BBoxRow.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row", out hv_BBoxRow);
        hv_BBoxCol.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col", out hv_BBoxCol);
        hv_BBoxLength1.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_length1", out hv_BBoxLength1);
        hv_BBoxLength2.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_length2", out hv_BBoxLength2);
        hv_BBoxPhi.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_phi", out hv_BBoxPhi);
        hv_BBoxLabel.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_label_id", out hv_BBoxLabel);
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        hv_ImageId.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSample, "image_id", out hv_ImageId);
        if ((int)(new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(1302))) != 0)
        {
          hv_ExceptionMessage.Dispose();
          hv_ExceptionMessage = "A bounding box coordinate key is missing.";
        }
        else
        {
          hv_ExceptionMessage.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ExceptionMessage = hv_Exception.TupleSelect(
              2);
          }
        }
        throw new HalconException((("An error has occurred during preprocessing image_id "+hv_ImageId)+" when getting bounding box coordinates : ")+hv_ExceptionMessage);
      }
      //
      //Check that there are no invalid boxes.
      if ((int)(new HTuple((new HTuple(hv_BBoxRow.TupleLength())).TupleGreater(0))) != 0)
      {
        hv_BoxesInvalid.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BoxesInvalid = (((hv_BBoxLength1.TupleEqualElem(
            0))).TupleSum())+(((hv_BBoxLength2.TupleEqualElem(0))).TupleSum());
        }
        if ((int)(new HTuple(hv_BoxesInvalid.TupleGreater(0))) != 0)
        {
          hv_ImageId.Dispose();
          HOperatorSet.GetDictTuple(hv_DLSample, "image_id", out hv_ImageId);
          throw new HalconException(("An error has occurred during preprocessing image_id "+hv_ImageId)+new HTuple(": Sample contains at least one bounding box with zero-area, i.e. bbox_length1 == 0 or bbox_length2 == 0!"));
        }
      }
      //
      //If the domain is cropped, crop bounding boxes.
      if ((int)(new HTuple(hv_DomainHandling.TupleEqual("crop_domain"))) != 0)
      {
        //
        //Get domain.
        ho_DomainRaw.Dispose();
        HOperatorSet.GetDomain(ho_ImageRaw, out ho_DomainRaw);
        //
        //Set the size of the raw image to the domain extensions.
        hv_RowDomain1.Dispose();hv_ColumnDomain1.Dispose();hv_RowDomain2.Dispose();hv_ColumnDomain2.Dispose();
        HOperatorSet.SmallestRectangle1(ho_DomainRaw, out hv_RowDomain1, out hv_ColumnDomain1, 
            out hv_RowDomain2, out hv_ColumnDomain2);
        hv_WidthRaw.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_WidthRaw = (hv_ColumnDomain2-hv_ColumnDomain1)+1;
        }
        hv_HeightRaw.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_HeightRaw = (hv_RowDomain2-hv_RowDomain1)+1;
        }
        //
        //Crop the bounding boxes.
        //Remove the boxes with center outside of the domain.
        hv_MaskDelete.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MaskDelete = (new HTuple((new HTuple(((hv_BBoxRow.TupleLessElem(
            hv_RowDomain1))).TupleOr(hv_BBoxCol.TupleLessElem(hv_ColumnDomain1)))).TupleOr(
            hv_BBoxRow.TupleGreaterElem(hv_RowDomain2)))).TupleOr(hv_BBoxCol.TupleGreaterElem(
            hv_ColumnDomain2));
        }
        hv_MaskNewBbox.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MaskNewBbox = 1-hv_MaskDelete;
        }
        //Store the preprocessed bounding box entries.
        hv_BBoxRowNew.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BBoxRowNew = (hv_BBoxRow.TupleSelectMask(
            hv_MaskNewBbox))-hv_RowDomain1;
        }
        hv_BBoxColNew.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BBoxColNew = (hv_BBoxCol.TupleSelectMask(
            hv_MaskNewBbox))-hv_ColumnDomain1;
        }
        hv_BBoxLength1New.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BBoxLength1New = hv_BBoxLength1.TupleSelectMask(
            hv_MaskNewBbox);
        }
        hv_BBoxLength2New.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BBoxLength2New = hv_BBoxLength2.TupleSelectMask(
            hv_MaskNewBbox);
        }
        hv_BBoxPhiNew.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BBoxPhiNew = hv_BBoxPhi.TupleSelectMask(
            hv_MaskNewBbox);
        }
        hv_BBoxLabelNew.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BBoxLabelNew = hv_BBoxLabel.TupleSelectMask(
            hv_MaskNewBbox);
        }
        //
      }
      else if ((int)(new HTuple(hv_DomainHandling.TupleEqual("full_domain"))) != 0)
      {
        //If the entire image is used, set the variables accordingly.
        //Get the original size.
        hv_WidthRaw.Dispose();hv_HeightRaw.Dispose();
        HOperatorSet.GetImageSize(ho_ImageRaw, out hv_WidthRaw, out hv_HeightRaw);
        //Set new coordinates to input coordinates.
        hv_BBoxRowNew.Dispose();
        hv_BBoxRowNew = new HTuple(hv_BBoxRow);
        hv_BBoxColNew.Dispose();
        hv_BBoxColNew = new HTuple(hv_BBoxCol);
        hv_BBoxLength1New.Dispose();
        hv_BBoxLength1New = new HTuple(hv_BBoxLength1);
        hv_BBoxLength2New.Dispose();
        hv_BBoxLength2New = new HTuple(hv_BBoxLength2);
        hv_BBoxPhiNew.Dispose();
        hv_BBoxPhiNew = new HTuple(hv_BBoxPhi);
        hv_BBoxLabelNew.Dispose();
        hv_BBoxLabelNew = new HTuple(hv_BBoxLabel);
      }
      else
      {
        throw new HalconException("Unsupported parameter value for 'domain_handling'");
      }
      //
      //Generate smallest enclosing axis-aligned bounding box for classes in ClassIDsNoOrientation.
      hv_ClassIDsNoOrientationIndices.Dispose();
      hv_ClassIDsNoOrientationIndices = new HTuple();
      for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_ClassIDsNoOrientation.TupleLength()
          ))-1); hv_Index = (int)hv_Index + 1)
      {
        hv_ClassIDsNoOrientationIndicesTmp.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ClassIDsNoOrientationIndicesTmp = ((hv_BBoxLabelNew.TupleEqualElem(
            hv_ClassIDsNoOrientation.TupleSelect(hv_Index)))).TupleFind(1);
        }
        if ((int)(new HTuple(hv_ClassIDsNoOrientationIndicesTmp.TupleNotEqual(-1))) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_ClassIDsNoOrientationIndices = hv_ClassIDsNoOrientationIndices.TupleConcat(
              hv_ClassIDsNoOrientationIndicesTmp);
          hv_ClassIDsNoOrientationIndices.Dispose();
          hv_ClassIDsNoOrientationIndices = ExpTmpLocalVar_ClassIDsNoOrientationIndices;
          }
          }
        }
      }
      if ((int)(new HTuple((new HTuple(hv_ClassIDsNoOrientationIndices.TupleLength()
          )).TupleGreater(0))) != 0)
      {
        //Calculate length1 and length2 using position of corners.
        hv_DirectionLength1Row.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DirectionLength1Row = -(((hv_BBoxPhiNew.TupleSelect(
            hv_ClassIDsNoOrientationIndices))).TupleSin());
        }
        hv_DirectionLength1Col.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DirectionLength1Col = ((hv_BBoxPhiNew.TupleSelect(
            hv_ClassIDsNoOrientationIndices))).TupleCos();
        }
        hv_DirectionLength2Row.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DirectionLength2Row = -hv_DirectionLength1Col;
        }
        hv_DirectionLength2Col.Dispose();
        hv_DirectionLength2Col = new HTuple(hv_DirectionLength1Row);
        hv_Corner1Row.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Corner1Row = ((hv_BBoxLength1New.TupleSelect(
            hv_ClassIDsNoOrientationIndices))*hv_DirectionLength1Row)+((hv_BBoxLength2New.TupleSelect(
            hv_ClassIDsNoOrientationIndices))*hv_DirectionLength2Row);
        }
        hv_Corner1Col.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Corner1Col = ((hv_BBoxLength1New.TupleSelect(
            hv_ClassIDsNoOrientationIndices))*hv_DirectionLength1Col)+((hv_BBoxLength2New.TupleSelect(
            hv_ClassIDsNoOrientationIndices))*hv_DirectionLength2Col);
        }
        hv_Corner2Row.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Corner2Row = ((hv_BBoxLength1New.TupleSelect(
            hv_ClassIDsNoOrientationIndices))*hv_DirectionLength1Row)-((hv_BBoxLength2New.TupleSelect(
            hv_ClassIDsNoOrientationIndices))*hv_DirectionLength2Row);
        }
        hv_Corner2Col.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Corner2Col = ((hv_BBoxLength1New.TupleSelect(
            hv_ClassIDsNoOrientationIndices))*hv_DirectionLength1Col)-((hv_BBoxLength2New.TupleSelect(
            hv_ClassIDsNoOrientationIndices))*hv_DirectionLength2Col);
        }
        //
        if (hv_BBoxPhiNew == null)
          hv_BBoxPhiNew = new HTuple();
        hv_BBoxPhiNew[hv_ClassIDsNoOrientationIndices] = 0.0;
        if (hv_BBoxLength1New == null)
          hv_BBoxLength1New = new HTuple();
        hv_BBoxLength1New[hv_ClassIDsNoOrientationIndices] = ((hv_Corner1Col.TupleAbs()
            )).TupleMax2(hv_Corner2Col.TupleAbs());
        if (hv_BBoxLength2New == null)
          hv_BBoxLength2New = new HTuple();
        hv_BBoxLength2New[hv_ClassIDsNoOrientationIndices] = ((hv_Corner1Row.TupleAbs()
            )).TupleMax2(hv_Corner2Row.TupleAbs());
      }
      //
      //Rescale bounding boxes.
      //
      //Get required images width and height.
      //
      //Only rescale bounding boxes if the required image dimensions are not the raw dimensions.
      if ((int)((new HTuple(hv_ImageHeight.TupleNotEqual(hv_HeightRaw))).TupleOr(
          new HTuple(hv_ImageWidth.TupleNotEqual(hv_WidthRaw)))) != 0)
      {
        //Calculate rescaling factor.
        hv_FactorResampleWidth.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_FactorResampleWidth = (hv_ImageWidth.TupleReal()
            )/hv_WidthRaw;
        }
        hv_FactorResampleHeight.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_FactorResampleHeight = (hv_ImageHeight.TupleReal()
            )/hv_HeightRaw;
        }
        if ((int)(new HTuple(hv_FactorResampleHeight.TupleNotEqual(hv_FactorResampleWidth))) != 0)
        {
          //In order to preserve the correct orientation we have to transform the points individually.
          //Get the coordinates of the four corner points.
          hv_BBoxRow1.Dispose();hv_BBoxCol1.Dispose();hv_BBoxRow2.Dispose();hv_BBoxCol2.Dispose();hv_BBoxRow3.Dispose();hv_BBoxCol3.Dispose();hv_BBoxRow4.Dispose();hv_BBoxCol4.Dispose();
          convert_rect2_5to8param(hv_BBoxRowNew, hv_BBoxColNew, hv_BBoxLength1New, 
              hv_BBoxLength2New, hv_BBoxPhiNew, out hv_BBoxRow1, out hv_BBoxCol1, 
              out hv_BBoxRow2, out hv_BBoxCol2, out hv_BBoxRow3, out hv_BBoxCol3, 
              out hv_BBoxRow4, out hv_BBoxCol4);
          //
          //Rescale the coordinates.
          hv_BBoxCol1New.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_BBoxCol1New = hv_BBoxCol1*hv_FactorResampleWidth;
          }
          hv_BBoxCol2New.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_BBoxCol2New = hv_BBoxCol2*hv_FactorResampleWidth;
          }
          hv_BBoxCol3New.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_BBoxCol3New = hv_BBoxCol3*hv_FactorResampleWidth;
          }
          hv_BBoxCol4New.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_BBoxCol4New = hv_BBoxCol4*hv_FactorResampleWidth;
          }
          hv_BBoxRow1New.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_BBoxRow1New = hv_BBoxRow1*hv_FactorResampleHeight;
          }
          hv_BBoxRow2New.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_BBoxRow2New = hv_BBoxRow2*hv_FactorResampleHeight;
          }
          hv_BBoxRow3New.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_BBoxRow3New = hv_BBoxRow3*hv_FactorResampleHeight;
          }
          hv_BBoxRow4New.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_BBoxRow4New = hv_BBoxRow4*hv_FactorResampleHeight;
          }
          //
          //The rectangles will get sheared, that is why new rectangles have to be found.
          //Generate homography to scale rectangles.
          hv_HomMat2DIdentity.Dispose();
          HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
          hv_HomMat2DScale.Dispose();
          HOperatorSet.HomMat2dScale(hv_HomMat2DIdentity, hv_FactorResampleHeight, 
              hv_FactorResampleWidth, 0, 0, out hv_HomMat2DScale);
          //Generate XLD contours for the rectangles.
          ho_Rectangle2XLD.Dispose();
          HOperatorSet.GenRectangle2ContourXld(out ho_Rectangle2XLD, hv_BBoxRowNew, 
              hv_BBoxColNew, hv_BBoxPhiNew, hv_BBoxLength1New, hv_BBoxLength2New);
          //Scale the XLD contours --> results in sheared regions.
          ho_Rectangle2XLDSheared.Dispose();
          HOperatorSet.AffineTransContourXld(ho_Rectangle2XLD, out ho_Rectangle2XLDSheared, 
              hv_HomMat2DScale);
          hv_BBoxRowNew.Dispose();hv_BBoxColNew.Dispose();hv_BBoxPhiNew.Dispose();hv_BBoxLength1New.Dispose();hv_BBoxLength2New.Dispose();
          HOperatorSet.SmallestRectangle2Xld(ho_Rectangle2XLDSheared, out hv_BBoxRowNew, 
              out hv_BBoxColNew, out hv_BBoxPhiNew, out hv_BBoxLength1New, out hv_BBoxLength2New);
          //
          //smallest_rectangle2_xld might change the orientation of the bounding box.
          //Hence, take the orientation that is closest to the one obtained out of the 4 corner points.
          hv__.Dispose();hv__.Dispose();hv__.Dispose();hv__.Dispose();hv_BBoxPhiTmp.Dispose();
          convert_rect2_8to5param(hv_BBoxRow1New, hv_BBoxCol1New, hv_BBoxRow2New, 
              hv_BBoxCol2New, hv_BBoxRow3New, hv_BBoxCol3New, hv_BBoxRow4New, hv_BBoxCol4New, 
              hv_IgnoreDirection, out hv__, out hv__, out hv__, out hv__, out hv_BBoxPhiTmp);
          hv_PhiDelta.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_PhiDelta = ((hv_BBoxPhiTmp-hv_BBoxPhiNew)).TupleFmod(
              (new HTuple(360)).TupleRad());
          }
          //Guarantee that angles are positive.
          hv_PhiDeltaNegativeIndices.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_PhiDeltaNegativeIndices = ((hv_PhiDelta.TupleLessElem(
              0.0))).TupleFind(1);
          }
          if ((int)(new HTuple(hv_PhiDeltaNegativeIndices.TupleNotEqual(-1))) != 0)
          {
            if (hv_PhiDelta == null)
              hv_PhiDelta = new HTuple();
            hv_PhiDelta[hv_PhiDeltaNegativeIndices] = (hv_PhiDelta.TupleSelect(hv_PhiDeltaNegativeIndices))+((new HTuple(360)).TupleRad()
                );
          }
          hv_IndicesRot90.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_IndicesRot90 = (new HTuple(((hv_PhiDelta.TupleGreaterElem(
              (new HTuple(45)).TupleRad()))).TupleAnd(hv_PhiDelta.TupleLessEqualElem(
              (new HTuple(135)).TupleRad())))).TupleFind(1);
          }
          hv_IndicesRot180.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_IndicesRot180 = (new HTuple(((hv_PhiDelta.TupleGreaterElem(
              (new HTuple(135)).TupleRad()))).TupleAnd(hv_PhiDelta.TupleLessEqualElem(
              (new HTuple(225)).TupleRad())))).TupleFind(1);
          }
          hv_IndicesRot270.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_IndicesRot270 = (new HTuple(((hv_PhiDelta.TupleGreaterElem(
              (new HTuple(225)).TupleRad()))).TupleAnd(hv_PhiDelta.TupleLessEqualElem(
              (new HTuple(315)).TupleRad())))).TupleFind(1);
          }
          hv_SwapIndices.Dispose();
          hv_SwapIndices = new HTuple();
          if ((int)(new HTuple(hv_IndicesRot90.TupleNotEqual(-1))) != 0)
          {
            if (hv_BBoxPhiNew == null)
              hv_BBoxPhiNew = new HTuple();
            hv_BBoxPhiNew[hv_IndicesRot90] = (hv_BBoxPhiNew.TupleSelect(hv_IndicesRot90))+((new HTuple(90)).TupleRad()
                );
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_SwapIndices = hv_SwapIndices.TupleConcat(
                hv_IndicesRot90);
            hv_SwapIndices.Dispose();
            hv_SwapIndices = ExpTmpLocalVar_SwapIndices;
            }
            }
          }
          if ((int)(new HTuple(hv_IndicesRot180.TupleNotEqual(-1))) != 0)
          {
            if (hv_BBoxPhiNew == null)
              hv_BBoxPhiNew = new HTuple();
            hv_BBoxPhiNew[hv_IndicesRot180] = (hv_BBoxPhiNew.TupleSelect(hv_IndicesRot180))+((new HTuple(180)).TupleRad()
                );
          }
          if ((int)(new HTuple(hv_IndicesRot270.TupleNotEqual(-1))) != 0)
          {
            if (hv_BBoxPhiNew == null)
              hv_BBoxPhiNew = new HTuple();
            hv_BBoxPhiNew[hv_IndicesRot270] = (hv_BBoxPhiNew.TupleSelect(hv_IndicesRot270))+((new HTuple(270)).TupleRad()
                );
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_SwapIndices = hv_SwapIndices.TupleConcat(
                hv_IndicesRot270);
            hv_SwapIndices.Dispose();
            hv_SwapIndices = ExpTmpLocalVar_SwapIndices;
            }
            }
          }
          if ((int)(new HTuple(hv_SwapIndices.TupleNotEqual(new HTuple()))) != 0)
          {
            hv_Tmp.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Tmp = hv_BBoxLength1New.TupleSelect(
                hv_SwapIndices);
            }
            if (hv_BBoxLength1New == null)
              hv_BBoxLength1New = new HTuple();
            hv_BBoxLength1New[hv_SwapIndices] = hv_BBoxLength2New.TupleSelect(hv_SwapIndices);
            if (hv_BBoxLength2New == null)
              hv_BBoxLength2New = new HTuple();
            hv_BBoxLength2New[hv_SwapIndices] = hv_Tmp;
          }
          //Change angles such that they lie in the range (-180°, 180°].
          hv_BBoxPhiNewIndices.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_BBoxPhiNewIndices = ((hv_BBoxPhiNew.TupleGreaterElem(
              (new HTuple(180)).TupleRad()))).TupleFind(1);
          }
          if ((int)(new HTuple(hv_BBoxPhiNewIndices.TupleNotEqual(-1))) != 0)
          {
            if (hv_BBoxPhiNew == null)
              hv_BBoxPhiNew = new HTuple();
            hv_BBoxPhiNew[hv_BBoxPhiNewIndices] = (hv_BBoxPhiNew.TupleSelect(hv_BBoxPhiNewIndices))-((new HTuple(360)).TupleRad()
                );
          }
        }
        else
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_BBoxColNew = hv_BBoxColNew*hv_FactorResampleWidth;
          hv_BBoxColNew.Dispose();
          hv_BBoxColNew = ExpTmpLocalVar_BBoxColNew;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_BBoxRowNew = hv_BBoxRowNew*hv_FactorResampleWidth;
          hv_BBoxRowNew.Dispose();
          hv_BBoxRowNew = ExpTmpLocalVar_BBoxRowNew;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_BBoxLength1New = hv_BBoxLength1New*hv_FactorResampleWidth;
          hv_BBoxLength1New.Dispose();
          hv_BBoxLength1New = ExpTmpLocalVar_BBoxLength1New;
          }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_BBoxLength2New = hv_BBoxLength2New*hv_FactorResampleWidth;
          hv_BBoxLength2New.Dispose();
          hv_BBoxLength2New = ExpTmpLocalVar_BBoxLength2New;
          }
          }
          //Phi stays the same.
        }
        //
      }
      //Check that there are no invalid boxes.
      if ((int)(new HTuple((new HTuple(hv_BBoxRowNew.TupleLength())).TupleGreater(
          0))) != 0)
      {
        hv_BoxesInvalid.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_BoxesInvalid = (((hv_BBoxLength1New.TupleEqualElem(
            0))).TupleSum())+(((hv_BBoxLength2New.TupleEqualElem(0))).TupleSum());
        }
        if ((int)(new HTuple(hv_BoxesInvalid.TupleGreater(0))) != 0)
        {
          hv_ImageId.Dispose();
          HOperatorSet.GetDictTuple(hv_DLSample, "image_id", out hv_ImageId);
          throw new HalconException(("An error has occurred during preprocessing image_id "+hv_ImageId)+new HTuple(": Sample contains at least one box with zero-area, i.e. bbox_length1 == 0 or bbox_length2 == 0!"));
        }
      }
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row", hv_BBoxRowNew);
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col", hv_BBoxColNew);
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_length1", hv_BBoxLength1New);
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_length2", hv_BBoxLength2New);
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_phi", hv_BBoxPhiNew);
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_label_id", hv_BBoxLabelNew);
      //
      ho_DomainRaw.Dispose();
      ho_Rectangle2XLD.Dispose();
      ho_Rectangle2XLDSheared.Dispose();

      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_DomainHandling.Dispose();
      hv_IgnoreDirection.Dispose();
      hv_ClassIDsNoOrientation.Dispose();
      hv_KeyExists.Dispose();
      hv_BBoxRow.Dispose();
      hv_BBoxCol.Dispose();
      hv_BBoxLength1.Dispose();
      hv_BBoxLength2.Dispose();
      hv_BBoxPhi.Dispose();
      hv_BBoxLabel.Dispose();
      hv_Exception.Dispose();
      hv_ImageId.Dispose();
      hv_ExceptionMessage.Dispose();
      hv_BoxesInvalid.Dispose();
      hv_RowDomain1.Dispose();
      hv_ColumnDomain1.Dispose();
      hv_RowDomain2.Dispose();
      hv_ColumnDomain2.Dispose();
      hv_WidthRaw.Dispose();
      hv_HeightRaw.Dispose();
      hv_MaskDelete.Dispose();
      hv_MaskNewBbox.Dispose();
      hv_BBoxRowNew.Dispose();
      hv_BBoxColNew.Dispose();
      hv_BBoxLength1New.Dispose();
      hv_BBoxLength2New.Dispose();
      hv_BBoxPhiNew.Dispose();
      hv_BBoxLabelNew.Dispose();
      hv_ClassIDsNoOrientationIndices.Dispose();
      hv_Index.Dispose();
      hv_ClassIDsNoOrientationIndicesTmp.Dispose();
      hv_DirectionLength1Row.Dispose();
      hv_DirectionLength1Col.Dispose();
      hv_DirectionLength2Row.Dispose();
      hv_DirectionLength2Col.Dispose();
      hv_Corner1Row.Dispose();
      hv_Corner1Col.Dispose();
      hv_Corner2Row.Dispose();
      hv_Corner2Col.Dispose();
      hv_FactorResampleWidth.Dispose();
      hv_FactorResampleHeight.Dispose();
      hv_BBoxCol1.Dispose();
      hv_BBoxCol1New.Dispose();
      hv_BBoxCol2.Dispose();
      hv_BBoxCol2New.Dispose();
      hv_BBoxCol3.Dispose();
      hv_BBoxCol3New.Dispose();
      hv_BBoxCol4.Dispose();
      hv_BBoxCol4New.Dispose();
      hv_BBoxRow1.Dispose();
      hv_BBoxRow1New.Dispose();
      hv_BBoxRow2.Dispose();
      hv_BBoxRow2New.Dispose();
      hv_BBoxRow3.Dispose();
      hv_BBoxRow3New.Dispose();
      hv_BBoxRow4.Dispose();
      hv_BBoxRow4New.Dispose();
      hv_HomMat2DIdentity.Dispose();
      hv_HomMat2DScale.Dispose();
      hv_BBoxPhiTmp.Dispose();
      hv_PhiDelta.Dispose();
      hv_PhiDeltaNegativeIndices.Dispose();
      hv_IndicesRot90.Dispose();
      hv_IndicesRot180.Dispose();
      hv_IndicesRot270.Dispose();
      hv_SwapIndices.Dispose();
      hv_Tmp.Dispose();
      hv_BBoxPhiNewIndices.Dispose();
      hv__.Dispose();

      return;

    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_DomainRaw.Dispose();
      ho_Rectangle2XLD.Dispose();
      ho_Rectangle2XLDSheared.Dispose();

      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_DomainHandling.Dispose();
      hv_IgnoreDirection.Dispose();
      hv_ClassIDsNoOrientation.Dispose();
      hv_KeyExists.Dispose();
      hv_BBoxRow.Dispose();
      hv_BBoxCol.Dispose();
      hv_BBoxLength1.Dispose();
      hv_BBoxLength2.Dispose();
      hv_BBoxPhi.Dispose();
      hv_BBoxLabel.Dispose();
      hv_Exception.Dispose();
      hv_ImageId.Dispose();
      hv_ExceptionMessage.Dispose();
      hv_BoxesInvalid.Dispose();
      hv_RowDomain1.Dispose();
      hv_ColumnDomain1.Dispose();
      hv_RowDomain2.Dispose();
      hv_ColumnDomain2.Dispose();
      hv_WidthRaw.Dispose();
      hv_HeightRaw.Dispose();
      hv_MaskDelete.Dispose();
      hv_MaskNewBbox.Dispose();
      hv_BBoxRowNew.Dispose();
      hv_BBoxColNew.Dispose();
      hv_BBoxLength1New.Dispose();
      hv_BBoxLength2New.Dispose();
      hv_BBoxPhiNew.Dispose();
      hv_BBoxLabelNew.Dispose();
      hv_ClassIDsNoOrientationIndices.Dispose();
      hv_Index.Dispose();
      hv_ClassIDsNoOrientationIndicesTmp.Dispose();
      hv_DirectionLength1Row.Dispose();
      hv_DirectionLength1Col.Dispose();
      hv_DirectionLength2Row.Dispose();
      hv_DirectionLength2Col.Dispose();
      hv_Corner1Row.Dispose();
      hv_Corner1Col.Dispose();
      hv_Corner2Row.Dispose();
      hv_Corner2Col.Dispose();
      hv_FactorResampleWidth.Dispose();
      hv_FactorResampleHeight.Dispose();
      hv_BBoxCol1.Dispose();
      hv_BBoxCol1New.Dispose();
      hv_BBoxCol2.Dispose();
      hv_BBoxCol2New.Dispose();
      hv_BBoxCol3.Dispose();
      hv_BBoxCol3New.Dispose();
      hv_BBoxCol4.Dispose();
      hv_BBoxCol4New.Dispose();
      hv_BBoxRow1.Dispose();
      hv_BBoxRow1New.Dispose();
      hv_BBoxRow2.Dispose();
      hv_BBoxRow2New.Dispose();
      hv_BBoxRow3.Dispose();
      hv_BBoxRow3New.Dispose();
      hv_BBoxRow4.Dispose();
      hv_BBoxRow4New.Dispose();
      hv_HomMat2DIdentity.Dispose();
      hv_HomMat2DScale.Dispose();
      hv_BBoxPhiTmp.Dispose();
      hv_PhiDelta.Dispose();
      hv_PhiDeltaNegativeIndices.Dispose();
      hv_IndicesRot90.Dispose();
      hv_IndicesRot180.Dispose();
      hv_IndicesRot270.Dispose();
      hv_SwapIndices.Dispose();
      hv_Tmp.Dispose();
      hv_BBoxPhiNewIndices.Dispose();
      hv__.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: Preprocess images for deep-learning-based training and inference. 
  public void preprocess_dl_model_images (HObject ho_Images, out HObject ho_ImagesPreprocessed, 
      HTuple hv_DLPreprocessParam)
  {




    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_ImagesNew=null, ho_ImageSelected=null;
    HObject ho_ImagesScaled=null, ho_Channel=null, ho_ImagesScaledMultiChannel=null;
    HObject ho_OutputNormImages=null, ho_Image=null, ho_ImageNormChannels=null;
    HObject ho_ImageNormChannel=null, ho_ObjectSelected=null;
    HObject ho_ThreeChannelImage=null, ho_SingleChannelImage=null;

    // Local copy input parameter variables 
    HObject ho_Images_COPY_INP_TMP;
    ho_Images_COPY_INP_TMP = new HObject(ho_Images);



    // Local control variables 

    HTuple hv_ImageWidth = new HTuple(), hv_ImageHeight = new HTuple();
    HTuple hv_ImageNumChannels = new HTuple(), hv_ImageRangeMin = new HTuple();
    HTuple hv_ImageRangeMax = new HTuple(), hv_DomainHandling = new HTuple();
    HTuple hv_NormalizationType = new HTuple(), hv_ModelType = new HTuple();
    HTuple hv_ImageWidthInput = new HTuple(), hv_ImageHeightInput = new HTuple();
    HTuple hv_EqualWidth = new HTuple(), hv_EqualHeight = new HTuple();
    HTuple hv_Type = new HTuple(), hv_NumMatches = new HTuple();
    HTuple hv_NumImages = new HTuple(), hv_ImageIndex = new HTuple();
    HTuple hv_Channels = new HTuple(), hv_ChannelIndex = new HTuple();
    HTuple hv_MinChannel = new HTuple(), hv_MaxChannel = new HTuple();
    HTuple hv_Range = new HTuple(), hv_Scale = new HTuple();
    HTuple hv_Shift = new HTuple(), hv_Min = new HTuple();
    HTuple hv_Max = new HTuple(), hv_UsePredefinedNormalizationValues = new HTuple();
    HTuple hv_MeanValues = new HTuple(), hv_DeviationValues = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_NumChannels = new HTuple();
    HTuple hv_IndexImage = new HTuple(), hv_IndexChannel = new HTuple();
    HTuple hv_EqualByte = new HTuple(), hv_RescaleRange = new HTuple();
    HTuple hv_NumChannelsAllImages = new HTuple(), hv_ImageNumChannelsTuple = new HTuple();
    HTuple hv_IndicesWrongChannels = new HTuple(), hv_IndexWrongImages = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImagesPreprocessed);
    HOperatorSet.GenEmptyObj(out ho_ImagesNew);
    HOperatorSet.GenEmptyObj(out ho_ImageSelected);
    HOperatorSet.GenEmptyObj(out ho_ImagesScaled);
    HOperatorSet.GenEmptyObj(out ho_Channel);
    HOperatorSet.GenEmptyObj(out ho_ImagesScaledMultiChannel);
    HOperatorSet.GenEmptyObj(out ho_OutputNormImages);
    HOperatorSet.GenEmptyObj(out ho_Image);
    HOperatorSet.GenEmptyObj(out ho_ImageNormChannels);
    HOperatorSet.GenEmptyObj(out ho_ImageNormChannel);
    HOperatorSet.GenEmptyObj(out ho_ObjectSelected);
    HOperatorSet.GenEmptyObj(out ho_ThreeChannelImage);
    HOperatorSet.GenEmptyObj(out ho_SingleChannelImage);
    try
    {
      //
      //This procedure preprocesses the provided Images
      //according to the parameters in the dictionary DLPreprocessParam.
      //Note that depending on the images,
      //additional preprocessing steps might be beneficial.
      //
      //Check the validity of the preprocessing parameters.
      check_dl_preprocess_param(hv_DLPreprocessParam);
      //
      //Get the preprocessing parameters.
      hv_ImageWidth.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_width", out hv_ImageWidth);
      hv_ImageHeight.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_height", out hv_ImageHeight);
      hv_ImageNumChannels.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_num_channels", out hv_ImageNumChannels);
      hv_ImageRangeMin.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_min", out hv_ImageRangeMin);
      hv_ImageRangeMax.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_max", out hv_ImageRangeMax);
      hv_DomainHandling.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "domain_handling", out hv_DomainHandling);
      hv_NormalizationType.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "normalization_type", out hv_NormalizationType);
      hv_ModelType.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "model_type", out hv_ModelType);
      //
      //Preprocess the images.
      //
      if ((int)(new HTuple(hv_DomainHandling.TupleEqual("full_domain"))) != 0)
      {
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.FullDomain(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0);
        ho_Images_COPY_INP_TMP.Dispose();
        ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      else if ((int)(new HTuple(hv_DomainHandling.TupleEqual("crop_domain"))) != 0)
      {
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.CropDomain(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0);
        ho_Images_COPY_INP_TMP.Dispose();
        ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      else if ((int)((new HTuple(hv_DomainHandling.TupleEqual("keep_domain"))).TupleAnd(
          new HTuple(hv_ModelType.TupleEqual("anomaly_detection")))) != 0)
      {
        //Anomaly detection models accept the additional option 'keep_domain'.
      }
      else
      {
        throw new HalconException("Unsupported parameter value for 'domain_handling'");
      }
      //
      //Zoom images only if they have a different size than the specified size.
      hv_ImageWidthInput.Dispose();hv_ImageHeightInput.Dispose();
      HOperatorSet.GetImageSize(ho_Images_COPY_INP_TMP, out hv_ImageWidthInput, out hv_ImageHeightInput);
      hv_EqualWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_EqualWidth = hv_ImageWidth.TupleEqualElem(
          hv_ImageWidthInput);
      }
      hv_EqualHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_EqualHeight = hv_ImageHeight.TupleEqualElem(
          hv_ImageHeightInput);
      }
      if ((int)((new HTuple(((hv_EqualWidth.TupleMin())).TupleEqual(0))).TupleOr(
          new HTuple(((hv_EqualHeight.TupleMin())).TupleEqual(0)))) != 0)
      {
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ZoomImageSize(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0, hv_ImageWidth, 
            hv_ImageHeight, "constant");
        ho_Images_COPY_INP_TMP.Dispose();
        ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      if ((int)(new HTuple(hv_NormalizationType.TupleEqual("all_channels"))) != 0)
      {
        //Check the type of the input images.
        //Channel normalization works here only for byte, integer and real images.
        hv_Type.Dispose();
        HOperatorSet.GetImageType(ho_Images_COPY_INP_TMP, out hv_Type);
        hv_NumMatches.Dispose();
        HOperatorSet.TupleRegexpTest(hv_Type, "byte|int|real", out hv_NumMatches);
        hv_NumImages.Dispose();
        HOperatorSet.CountObj(ho_Images_COPY_INP_TMP, out hv_NumImages);
        if ((int)(new HTuple(hv_NumMatches.TupleNotEqual(hv_NumImages))) != 0)
        {
          throw new HalconException(new HTuple("In case of normalization type 'all_channels', please provide only images of type 'byte', 'int1', 'int2', 'uint2', 'int4', 'int8', or 'real'."));
        }
        //
        //Perform all channels normalization.
        if ((int)(new HTuple(hv_Type.TupleEqual("byte"))) != 0)
        {
          //Scale the gray values to [0-255].
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.ScaleImageMax(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0);
          ho_Images_COPY_INP_TMP.Dispose();
          ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
          }
        }
        else
        {
          //Scale the gray values to [ImageRangeMin-ImageRangeMax].
          //Scaling is performed for each image separately.
          ho_ImagesNew.Dispose();
          HOperatorSet.GenEmptyObj(out ho_ImagesNew);
          HTuple end_val56 = hv_NumImages;
          HTuple step_val56 = 1;
          for (hv_ImageIndex=1; hv_ImageIndex.Continue(end_val56, step_val56); hv_ImageIndex = hv_ImageIndex.TupleAdd(step_val56))
          {
            ho_ImageSelected.Dispose();
            HOperatorSet.SelectObj(ho_Images_COPY_INP_TMP, out ho_ImageSelected, 
                hv_ImageIndex);
            hv_Channels.Dispose();
            HOperatorSet.CountChannels(ho_Images_COPY_INP_TMP, out hv_Channels);
            //
            //Calculate the channel-wise minimum and maximum grey values.
            ho_ImagesScaled.Dispose();
            HOperatorSet.GenEmptyObj(out ho_ImagesScaled);
            HTuple end_val62 = hv_Channels;
            HTuple step_val62 = 1;
            for (hv_ChannelIndex=1; hv_ChannelIndex.Continue(end_val62, step_val62); hv_ChannelIndex = hv_ChannelIndex.TupleAdd(step_val62))
            {
              ho_Channel.Dispose();
              HOperatorSet.AccessChannel(ho_ImageSelected, out ho_Channel, hv_ChannelIndex);
              hv_MinChannel.Dispose();hv_MaxChannel.Dispose();hv_Range.Dispose();
              HOperatorSet.MinMaxGray(ho_Channel, ho_Channel, 0, out hv_MinChannel, 
                  out hv_MaxChannel, out hv_Range);
              //Scale and shift the channel.
              hv_Scale.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_Scale = (hv_ImageRangeMax-hv_ImageRangeMin)/(hv_MaxChannel-hv_MinChannel);
              }
              hv_Shift.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_Shift = ((-hv_Scale)*hv_MinChannel)+hv_ImageRangeMin;
              }
              {
              HObject ExpTmpOutVar_0;
              HOperatorSet.ScaleImage(ho_Channel, out ExpTmpOutVar_0, hv_Scale, hv_Shift);
              ho_Channel.Dispose();
              ho_Channel = ExpTmpOutVar_0;
              }
              {
              HObject ExpTmpOutVar_0;
              HOperatorSet.ConcatObj(ho_ImagesScaled, ho_Channel, out ExpTmpOutVar_0
                  );
              ho_ImagesScaled.Dispose();
              ho_ImagesScaled = ExpTmpOutVar_0;
              }
            }
            ho_ImagesScaledMultiChannel.Dispose();
            HOperatorSet.ChannelsToImage(ho_ImagesScaled, out ho_ImagesScaledMultiChannel
                );
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.ConcatObj(ho_ImagesNew, ho_ImagesScaledMultiChannel, out ExpTmpOutVar_0
                );
            ho_ImagesNew.Dispose();
            ho_ImagesNew = ExpTmpOutVar_0;
            }
          }
          ho_Images_COPY_INP_TMP.Dispose();
          ho_Images_COPY_INP_TMP = new HObject(ho_ImagesNew);
          //Integer image convert to real image
          if ((int)(new HTuple(hv_Type.TupleNotEqual("real"))) != 0)
          {
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.ConvertImageType(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0, 
                "real");
            ho_Images_COPY_INP_TMP.Dispose();
            ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
            }
          }
        }
      }
      else if ((int)(new HTuple(hv_NormalizationType.TupleEqual("first_channel"))) != 0)
      {
        //Check the type of the input images.
        //First channel normalization works here only for byte, integer and real images.
        hv_Type.Dispose();
        HOperatorSet.GetImageType(ho_Images_COPY_INP_TMP, out hv_Type);
        hv_NumMatches.Dispose();
        HOperatorSet.TupleRegexpTest(hv_Type, "byte|int|real", out hv_NumMatches);
        hv_NumImages.Dispose();
        HOperatorSet.CountObj(ho_Images_COPY_INP_TMP, out hv_NumImages);
        if ((int)(new HTuple(hv_NumMatches.TupleNotEqual(hv_NumImages))) != 0)
        {
          throw new HalconException(new HTuple("In case of normalization type 'first_channel', please provide only images of type 'byte', 'int1', 'int2', 'uint2', 'int4', 'int8', or 'real'."));
        }
        //
        //Perform first channel normalization.
        if ((int)(new HTuple(hv_Type.TupleEqual("byte"))) != 0)
        {
          //Scale the gray values to [0-255].
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.ScaleImageMax(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0);
          ho_Images_COPY_INP_TMP.Dispose();
          ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
          }
        }
        else
        {
          //Scale the gray values to [ImageRangeMin-ImageRangeMax].
          //Scaling is performed for each image separately.
          ho_ImagesNew.Dispose();
          HOperatorSet.GenEmptyObj(out ho_ImagesNew);
          HTuple end_val98 = hv_NumImages;
          HTuple step_val98 = 1;
          for (hv_ImageIndex=1; hv_ImageIndex.Continue(end_val98, step_val98); hv_ImageIndex = hv_ImageIndex.TupleAdd(step_val98))
          {
            ho_ImageSelected.Dispose();
            HOperatorSet.SelectObj(ho_Images_COPY_INP_TMP, out ho_ImageSelected, 
                hv_ImageIndex);
            hv_Min.Dispose();hv_Max.Dispose();hv_Range.Dispose();
            HOperatorSet.MinMaxGray(ho_ImageSelected, ho_ImageSelected, 0, out hv_Min, 
                out hv_Max, out hv_Range);
            hv_Scale.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Scale = (hv_ImageRangeMax-hv_ImageRangeMin)/(hv_Max-hv_Min);
            }
            hv_Shift.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Shift = ((-hv_Scale)*hv_Min)+hv_ImageRangeMin;
            }
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.ScaleImage(ho_ImageSelected, out ExpTmpOutVar_0, hv_Scale, 
                hv_Shift);
            ho_ImageSelected.Dispose();
            ho_ImageSelected = ExpTmpOutVar_0;
            }
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.ConcatObj(ho_ImagesNew, ho_ImageSelected, out ExpTmpOutVar_0
                );
            ho_ImagesNew.Dispose();
            ho_ImagesNew = ExpTmpOutVar_0;
            }
          }
          ho_Images_COPY_INP_TMP.Dispose();
          ho_Images_COPY_INP_TMP = new HObject(ho_ImagesNew);
          //Integer image convert to real image
          if ((int)(new HTuple(hv_Type.TupleNotEqual("real"))) != 0)
          {
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.ConvertImageType(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0, 
                "real");
            ho_Images_COPY_INP_TMP.Dispose();
            ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
            }
          }
        }
      }
      else if ((int)(new HTuple(hv_NormalizationType.TupleEqual("constant_values"))) != 0)
      {
        //
        //Constant values normalization works here only for byte, integer and real images.
        hv_Type.Dispose();
        HOperatorSet.GetImageType(ho_Images_COPY_INP_TMP, out hv_Type);
        hv_NumMatches.Dispose();
        HOperatorSet.TupleRegexpTest(hv_Type, "byte|int|real", out hv_NumMatches);
        hv_NumImages.Dispose();
        HOperatorSet.CountObj(ho_Images_COPY_INP_TMP, out hv_NumImages);
        if ((int)(new HTuple(hv_NumMatches.TupleNotEqual(hv_NumImages))) != 0)
        {
          throw new HalconException(new HTuple("In case of normalization type 'constant_values', please provide only images of type 'byte', 'int1', 'int2', 'uint2', 'int4', 'int8', or 'real'."));
        }
        //For a correct normalization we have to use real images.
        if ((int)(new HTuple(hv_Type.TupleNotEqual("real"))) != 0)
        {
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.ConvertImageType(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0, 
              "real");
          ho_Images_COPY_INP_TMP.Dispose();
          ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
          }
        }
        //
        //Get the normalization values set by create_dl_preprocess_param or
        //use predefined values.
        hv_UsePredefinedNormalizationValues.Dispose();
        hv_UsePredefinedNormalizationValues = "false";
        try
        {
          hv_MeanValues.Dispose();
          HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "mean_values_normalization", 
              out hv_MeanValues);
          hv_DeviationValues.Dispose();
          HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "deviation_values_normalization", 
              out hv_DeviationValues);
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException1)
        {
          HDevExpDefaultException1.ToHTuple(out hv_Exception);
          hv_UsePredefinedNormalizationValues.Dispose();
          hv_UsePredefinedNormalizationValues = "true";
        }
        //
        hv_NumChannels.Dispose();
        HOperatorSet.CountChannels(ho_Images_COPY_INP_TMP, out hv_NumChannels);
        if ((int)(new HTuple(hv_UsePredefinedNormalizationValues.TupleEqual("true"))) != 0)
        {
          //This type of normalization works for one-channel images by composing them to three-channel images.
          if ((int)((new HTuple(((hv_NumChannels.TupleMin())).TupleEqual(1))).TupleAnd(
              new HTuple(((hv_NumChannels.TupleMax())).TupleEqual(1)))) != 0)
          {
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.Compose3(ho_Images_COPY_INP_TMP, ho_Images_COPY_INP_TMP, 
                ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0);
            ho_Images_COPY_INP_TMP.Dispose();
            ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
            }
            hv_NumChannels.Dispose();
            HOperatorSet.CountChannels(ho_Images_COPY_INP_TMP, out hv_NumChannels);
          }
          //Use predefined values for normalization.
          if ((int)((new HTuple(((hv_NumChannels.TupleMin())).TupleNotEqual(3))).TupleOr(
              new HTuple(((hv_NumChannels.TupleMax())).TupleNotEqual(3)))) != 0)
          {
            throw new HalconException("Using predefined values for normalization type 'constant_values' is allowed only for one- and three-channel images.");
          }
          //Predefined values.
          hv_MeanValues.Dispose();
          hv_MeanValues = new HTuple();
          hv_MeanValues[0] = 123.675;
          hv_MeanValues[1] = 116.28;
          hv_MeanValues[2] = 103.53;
          hv_DeviationValues.Dispose();
          hv_DeviationValues = new HTuple();
          hv_DeviationValues[0] = 58.395;
          hv_DeviationValues[1] = 57.12;
          hv_DeviationValues[2] = 57.375;
        }
        else
        {
          //Use user-defined values.
          if ((int)((new HTuple((new HTuple(hv_MeanValues.TupleLength())).TupleNotEqual(
              hv_NumChannels))).TupleOr(new HTuple((new HTuple(hv_DeviationValues.TupleLength()
              )).TupleNotEqual(hv_NumChannels)))) != 0)
          {
            throw new HalconException("The length for mean and deviation values for normalization type 'constant_values' have to be the same size as the number of channels of the image");
          }
        }
        //
        ho_OutputNormImages.Dispose();
        HOperatorSet.GenEmptyObj(out ho_OutputNormImages);
        hv_NumImages.Dispose();
        HOperatorSet.CountObj(ho_Images_COPY_INP_TMP, out hv_NumImages);
        HTuple end_val159 = hv_NumImages;
        HTuple step_val159 = 1;
        for (hv_IndexImage=1; hv_IndexImage.Continue(end_val159, step_val159); hv_IndexImage = hv_IndexImage.TupleAdd(step_val159))
        {
          ho_Image.Dispose();
          HOperatorSet.SelectObj(ho_Images_COPY_INP_TMP, out ho_Image, hv_IndexImage);
          ho_ImageNormChannels.Dispose();
          HOperatorSet.GenEmptyObj(out ho_ImageNormChannels);
          HTuple end_val162 = hv_NumChannels;
          HTuple step_val162 = 1;
          for (hv_IndexChannel=1; hv_IndexChannel.Continue(end_val162, step_val162); hv_IndexChannel = hv_IndexChannel.TupleAdd(step_val162))
          {
            ho_Channel.Dispose();
            HOperatorSet.AccessChannel(ho_Image, out ho_Channel, hv_IndexChannel);
            hv_ImageWidth.Dispose();hv_ImageHeight.Dispose();
            HOperatorSet.GetImageSize(ho_Channel, out hv_ImageWidth, out hv_ImageHeight);
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_ImageNormChannel.Dispose();
            HOperatorSet.ScaleImage(ho_Channel, out ho_ImageNormChannel, 1/(((hv_DeviationValues.TupleSelect(
                hv_IndexChannel-1))).TupleReal()), (-(((hv_MeanValues.TupleSelect(
                hv_IndexChannel-1))).TupleReal()))/(hv_DeviationValues.TupleSelect(
                hv_IndexChannel-1)));
            }
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.AppendChannel(ho_ImageNormChannels, ho_ImageNormChannel, 
                out ExpTmpOutVar_0);
            ho_ImageNormChannels.Dispose();
            ho_ImageNormChannels = ExpTmpOutVar_0;
            }
          }
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.ConcatObj(ho_OutputNormImages, ho_ImageNormChannels, out ExpTmpOutVar_0
              );
          ho_OutputNormImages.Dispose();
          ho_OutputNormImages = ExpTmpOutVar_0;
          }
        }
        ho_Images_COPY_INP_TMP.Dispose();
        ho_Images_COPY_INP_TMP = new HObject(ho_OutputNormImages);
      }
      else if ((int)((new HTuple((new HTuple((new HTuple(hv_NormalizationType.TupleNotEqual(
          "all_channels"))).TupleAnd(new HTuple(hv_NormalizationType.TupleNotEqual(
          "first_channel"))))).TupleAnd(new HTuple(hv_NormalizationType.TupleNotEqual(
          "constant_values"))))).TupleAnd(new HTuple(hv_NormalizationType.TupleNotEqual(
          "none")))) != 0)
      {
        throw new HalconException("Unsupported parameter value for 'normalization_type'");
      }
      //
      //Check the type of the input images.
      hv_Type.Dispose();
      HOperatorSet.GetImageType(ho_Images_COPY_INP_TMP, out hv_Type);
      hv_NumMatches.Dispose();
      HOperatorSet.TupleRegexpTest(hv_Type, "byte|real", out hv_NumMatches);
      hv_NumImages.Dispose();
      HOperatorSet.CountObj(ho_Images_COPY_INP_TMP, out hv_NumImages);
      if ((int)(new HTuple(hv_NumMatches.TupleNotEqual(hv_NumImages))) != 0)
      {
        throw new HalconException("Please provide only images of type 'byte' or 'real'.");
      }
      //If the type is 'byte', convert it to 'real' and scale it.
      //The gray value scaling does not work on 'byte' images.
      //For 'real' images it is assumed that the range is already correct.
      hv_EqualByte.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_EqualByte = hv_Type.TupleEqualElem(
          "byte");
      }
      if ((int)(new HTuple(((hv_EqualByte.TupleMax())).TupleEqual(1))) != 0)
      {
        if ((int)(new HTuple(((hv_EqualByte.TupleMin())).TupleEqual(0))) != 0)
        {
          throw new HalconException("Passing mixed type images is not supported.");
        }
        //Convert the image type from 'byte' to 'real',
        //because the model expects 'real' images.
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConvertImageType(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0, 
            "real");
        ho_Images_COPY_INP_TMP.Dispose();
        ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
        }
        //Scale/Shift the gray values from [0-255] to the expected range.
        hv_RescaleRange.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_RescaleRange = (hv_ImageRangeMax-hv_ImageRangeMin)/255.0;
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ScaleImage(ho_Images_COPY_INP_TMP, out ExpTmpOutVar_0, hv_RescaleRange, 
            hv_ImageRangeMin);
        ho_Images_COPY_INP_TMP.Dispose();
        ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      //
      //Check the number of channels.
      hv_NumImages.Dispose();
      HOperatorSet.CountObj(ho_Images_COPY_INP_TMP, out hv_NumImages);
      //Check all images for number of channels.
      hv_NumChannelsAllImages.Dispose();
      HOperatorSet.CountChannels(ho_Images_COPY_INP_TMP, out hv_NumChannelsAllImages);
      hv_ImageNumChannelsTuple.Dispose();
      HOperatorSet.TupleGenConst(hv_NumImages, hv_ImageNumChannels, out hv_ImageNumChannelsTuple);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_IndicesWrongChannels.Dispose();
      HOperatorSet.TupleFind(hv_NumChannelsAllImages.TupleNotEqualElem(hv_ImageNumChannelsTuple), 
          1, out hv_IndicesWrongChannels);
      }
      //
      //Correct images with a wrong number of channels.
      //
      if ((int)(new HTuple(hv_IndicesWrongChannels.TupleNotEqual(-1))) != 0)
      {
        //
        for (hv_IndexWrongImages=0; (int)hv_IndexWrongImages<=(int)((new HTuple(hv_IndicesWrongChannels.TupleLength()
            ))-1); hv_IndexWrongImages = (int)hv_IndexWrongImages + 1)
        {
          //Get the index, the number of channels and the image
          //for each image with wrong number of channels.
          hv_ImageIndex.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ImageIndex = (hv_IndicesWrongChannels.TupleSelect(
              hv_IndexWrongImages))+1;
          }
          hv_NumChannels.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_NumChannels = hv_NumChannelsAllImages.TupleSelect(
              hv_ImageIndex-1);
          }
          ho_ObjectSelected.Dispose();
          HOperatorSet.SelectObj(ho_Images_COPY_INP_TMP, out ho_ObjectSelected, hv_ImageIndex);
          //
          if ((int)((new HTuple(hv_NumChannels.TupleEqual(1))).TupleAnd(new HTuple(hv_ImageNumChannels.TupleEqual(
              3)))) != 0)
          {
            //If the image is a grayscale image, but the model expects a color image:
            //convert it to an image with three channels.
            ho_ThreeChannelImage.Dispose();
            HOperatorSet.Compose3(ho_ObjectSelected, ho_ObjectSelected, ho_ObjectSelected, 
                out ho_ThreeChannelImage);
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.ReplaceObj(ho_Images_COPY_INP_TMP, ho_ThreeChannelImage, 
                out ExpTmpOutVar_0, hv_ImageIndex);
            ho_Images_COPY_INP_TMP.Dispose();
            ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
            }
          }
          else if ((int)((new HTuple(hv_NumChannels.TupleEqual(3))).TupleAnd(
              new HTuple(hv_ImageNumChannels.TupleEqual(1)))) != 0)
          {
            //If the image is a color image, but the model expects a grayscale image:
            //convert it to an image with only one channel.
            ho_SingleChannelImage.Dispose();
            HOperatorSet.Rgb1ToGray(ho_ObjectSelected, out ho_SingleChannelImage);
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.ReplaceObj(ho_Images_COPY_INP_TMP, ho_SingleChannelImage, 
                out ExpTmpOutVar_0, hv_ImageIndex);
            ho_Images_COPY_INP_TMP.Dispose();
            ho_Images_COPY_INP_TMP = ExpTmpOutVar_0;
            }
          }
          else
          {
            throw new HalconException("Number of channels is not supported. Please check for images with a number of channels different to 1 and 3 and perform their preprocessing yourself.");
          }
          //
        }
      }
      //
      //Write preprocessed image to output variable.
      ho_ImagesPreprocessed.Dispose();
      ho_ImagesPreprocessed = new HObject(ho_Images_COPY_INP_TMP);
      //
      ho_Images_COPY_INP_TMP.Dispose();
      ho_ImagesNew.Dispose();
      ho_ImageSelected.Dispose();
      ho_ImagesScaled.Dispose();
      ho_Channel.Dispose();
      ho_ImagesScaledMultiChannel.Dispose();
      ho_OutputNormImages.Dispose();
      ho_Image.Dispose();
      ho_ImageNormChannels.Dispose();
      ho_ImageNormChannel.Dispose();
      ho_ObjectSelected.Dispose();
      ho_ThreeChannelImage.Dispose();
      ho_SingleChannelImage.Dispose();

      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_ImageNumChannels.Dispose();
      hv_ImageRangeMin.Dispose();
      hv_ImageRangeMax.Dispose();
      hv_DomainHandling.Dispose();
      hv_NormalizationType.Dispose();
      hv_ModelType.Dispose();
      hv_ImageWidthInput.Dispose();
      hv_ImageHeightInput.Dispose();
      hv_EqualWidth.Dispose();
      hv_EqualHeight.Dispose();
      hv_Type.Dispose();
      hv_NumMatches.Dispose();
      hv_NumImages.Dispose();
      hv_ImageIndex.Dispose();
      hv_Channels.Dispose();
      hv_ChannelIndex.Dispose();
      hv_MinChannel.Dispose();
      hv_MaxChannel.Dispose();
      hv_Range.Dispose();
      hv_Scale.Dispose();
      hv_Shift.Dispose();
      hv_Min.Dispose();
      hv_Max.Dispose();
      hv_UsePredefinedNormalizationValues.Dispose();
      hv_MeanValues.Dispose();
      hv_DeviationValues.Dispose();
      hv_Exception.Dispose();
      hv_NumChannels.Dispose();
      hv_IndexImage.Dispose();
      hv_IndexChannel.Dispose();
      hv_EqualByte.Dispose();
      hv_RescaleRange.Dispose();
      hv_NumChannelsAllImages.Dispose();
      hv_ImageNumChannelsTuple.Dispose();
      hv_IndicesWrongChannels.Dispose();
      hv_IndexWrongImages.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Images_COPY_INP_TMP.Dispose();
      ho_ImagesNew.Dispose();
      ho_ImageSelected.Dispose();
      ho_ImagesScaled.Dispose();
      ho_Channel.Dispose();
      ho_ImagesScaledMultiChannel.Dispose();
      ho_OutputNormImages.Dispose();
      ho_Image.Dispose();
      ho_ImageNormChannels.Dispose();
      ho_ImageNormChannel.Dispose();
      ho_ObjectSelected.Dispose();
      ho_ThreeChannelImage.Dispose();
      ho_SingleChannelImage.Dispose();

      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_ImageNumChannels.Dispose();
      hv_ImageRangeMin.Dispose();
      hv_ImageRangeMax.Dispose();
      hv_DomainHandling.Dispose();
      hv_NormalizationType.Dispose();
      hv_ModelType.Dispose();
      hv_ImageWidthInput.Dispose();
      hv_ImageHeightInput.Dispose();
      hv_EqualWidth.Dispose();
      hv_EqualHeight.Dispose();
      hv_Type.Dispose();
      hv_NumMatches.Dispose();
      hv_NumImages.Dispose();
      hv_ImageIndex.Dispose();
      hv_Channels.Dispose();
      hv_ChannelIndex.Dispose();
      hv_MinChannel.Dispose();
      hv_MaxChannel.Dispose();
      hv_Range.Dispose();
      hv_Scale.Dispose();
      hv_Shift.Dispose();
      hv_Min.Dispose();
      hv_Max.Dispose();
      hv_UsePredefinedNormalizationValues.Dispose();
      hv_MeanValues.Dispose();
      hv_DeviationValues.Dispose();
      hv_Exception.Dispose();
      hv_NumChannels.Dispose();
      hv_IndexImage.Dispose();
      hv_IndexChannel.Dispose();
      hv_EqualByte.Dispose();
      hv_RescaleRange.Dispose();
      hv_NumChannelsAllImages.Dispose();
      hv_ImageNumChannelsTuple.Dispose();
      hv_IndicesWrongChannels.Dispose();
      hv_IndexWrongImages.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Semantic Segmentation
  // Short Description: Preprocess segmentation and weight images for deep-learning-based segmentation training and inference. 
  public void preprocess_dl_model_segmentations (HObject ho_ImagesRaw, HObject ho_Segmentations, 
      out HObject ho_SegmentationsPreprocessed, HTuple hv_DLPreprocessParam)
  {




    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_Domain=null, ho_SelectedSeg=null;
    HObject ho_SelectedDomain=null;

    // Local copy input parameter variables 
    HObject ho_Segmentations_COPY_INP_TMP;
    ho_Segmentations_COPY_INP_TMP = new HObject(ho_Segmentations);



    // Local control variables 

    HTuple hv_NumberImages = new HTuple(), hv_NumberSegmentations = new HTuple();
    HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
    HTuple hv_WidthSeg = new HTuple(), hv_HeightSeg = new HTuple();
    HTuple hv_DLModelType = new HTuple(), hv_ImageWidth = new HTuple();
    HTuple hv_ImageHeight = new HTuple(), hv_ImageNumChannels = new HTuple();
    HTuple hv_ImageRangeMin = new HTuple(), hv_ImageRangeMax = new HTuple();
    HTuple hv_DomainHandling = new HTuple(), hv_SetBackgroundID = new HTuple();
    HTuple hv_ClassesToBackground = new HTuple(), hv_IgnoreClassIDs = new HTuple();
    HTuple hv_IsInt = new HTuple(), hv_IndexImage = new HTuple();
    HTuple hv_ImageWidthRaw = new HTuple(), hv_ImageHeightRaw = new HTuple();
    HTuple hv_EqualWidth = new HTuple(), hv_EqualHeight = new HTuple();
    HTuple hv_Type = new HTuple(), hv_EqualReal = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_SegmentationsPreprocessed);
    HOperatorSet.GenEmptyObj(out ho_Domain);
    HOperatorSet.GenEmptyObj(out ho_SelectedSeg);
    HOperatorSet.GenEmptyObj(out ho_SelectedDomain);
    try
    {
      //
      //This procedure preprocesses the segmentation or weight images
      //given by Segmentations so that they can be handled by
      //train_dl_model_batch and apply_dl_model.
      //
      //Check input data.
      //Examine number of images.
      hv_NumberImages.Dispose();
      HOperatorSet.CountObj(ho_ImagesRaw, out hv_NumberImages);
      hv_NumberSegmentations.Dispose();
      HOperatorSet.CountObj(ho_Segmentations_COPY_INP_TMP, out hv_NumberSegmentations);
      if ((int)(new HTuple(hv_NumberImages.TupleNotEqual(hv_NumberSegmentations))) != 0)
      {
        throw new HalconException("Equal number of images given in ImagesRaw and Segmentations required");
      }
      //Size of images.
      hv_Width.Dispose();hv_Height.Dispose();
      HOperatorSet.GetImageSize(ho_ImagesRaw, out hv_Width, out hv_Height);
      hv_WidthSeg.Dispose();hv_HeightSeg.Dispose();
      HOperatorSet.GetImageSize(ho_Segmentations_COPY_INP_TMP, out hv_WidthSeg, out hv_HeightSeg);
      if ((int)((new HTuple(hv_Width.TupleNotEqual(hv_WidthSeg))).TupleOr(new HTuple(hv_Height.TupleNotEqual(
          hv_HeightSeg)))) != 0)
      {
        throw new HalconException("Equal size of the images given in ImagesRaw and Segmentations required.");
      }
      //Check the validity of the preprocessing parameters.
      check_dl_preprocess_param(hv_DLPreprocessParam);
      //
      //Get the relevant preprocessing parameters.
      hv_DLModelType.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "model_type", out hv_DLModelType);
      hv_ImageWidth.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_width", out hv_ImageWidth);
      hv_ImageHeight.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_height", out hv_ImageHeight);
      hv_ImageNumChannels.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_num_channels", out hv_ImageNumChannels);
      hv_ImageRangeMin.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_min", out hv_ImageRangeMin);
      hv_ImageRangeMax.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "image_range_max", out hv_ImageRangeMax);
      hv_DomainHandling.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "domain_handling", out hv_DomainHandling);
      //Segmentation specific parameters.
      hv_SetBackgroundID.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "set_background_id", out hv_SetBackgroundID);
      hv_ClassesToBackground.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "class_ids_background", out hv_ClassesToBackground);
      hv_IgnoreClassIDs.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "ignore_class_ids", out hv_IgnoreClassIDs);
      //
      //Check the input parameter for setting the background ID.
      if ((int)(new HTuple(hv_SetBackgroundID.TupleNotEqual(new HTuple()))) != 0)
      {
        //Check that the model is a segmentation model.
        if ((int)(new HTuple(hv_DLModelType.TupleNotEqual("segmentation"))) != 0)
        {
          throw new HalconException("Setting class IDs to background is only implemented for segmentation.");
        }
        //Check the background ID.
        hv_IsInt.Dispose();
        HOperatorSet.TupleIsIntElem(hv_SetBackgroundID, out hv_IsInt);
        if ((int)(new HTuple((new HTuple(hv_SetBackgroundID.TupleLength())).TupleNotEqual(
            1))) != 0)
        {
          throw new HalconException("Only one class_id as 'set_background_id' allowed.");
        }
        else if ((int)(hv_IsInt.TupleNot()) != 0)
        {
          //Given class_id has to be of type int.
          throw new HalconException("The class_id given as 'set_background_id' has to be of type int.");
        }
        //Check the values of ClassesToBackground.
        if ((int)(new HTuple((new HTuple(hv_ClassesToBackground.TupleLength())).TupleEqual(
            0))) != 0)
        {
          //Check that the given classes are of length > 0.
          throw new HalconException(new HTuple("If 'set_background_id' is given, 'class_ids_background' must at least contain this class ID."));
        }
        else if ((int)(new HTuple(((hv_ClassesToBackground.TupleIntersection(
            hv_IgnoreClassIDs))).TupleNotEqual(new HTuple()))) != 0)
        {
          //Check that class_ids_background is not included in the ignore_class_ids of the DLModel.
          throw new HalconException("The given 'class_ids_background' must not be included in the 'ignore_class_ids' of the model.");
        }
      }
      //
      //Domain handling of the image to be preprocessed.
      //
      if ((int)(new HTuple(hv_DomainHandling.TupleEqual("full_domain"))) != 0)
      {
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.FullDomain(ho_Segmentations_COPY_INP_TMP, out ExpTmpOutVar_0
            );
        ho_Segmentations_COPY_INP_TMP.Dispose();
        ho_Segmentations_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      else if ((int)(new HTuple(hv_DomainHandling.TupleEqual("crop_domain"))) != 0)
      {
        //If the domain should be cropped the domain has to be transferred
        //from the raw image to the segmentation image.
        ho_Domain.Dispose();
        HOperatorSet.GetDomain(ho_ImagesRaw, out ho_Domain);
        HTuple end_val66 = hv_NumberImages;
        HTuple step_val66 = 1;
        for (hv_IndexImage=1; hv_IndexImage.Continue(end_val66, step_val66); hv_IndexImage = hv_IndexImage.TupleAdd(step_val66))
        {
          ho_SelectedSeg.Dispose();
          HOperatorSet.SelectObj(ho_Segmentations_COPY_INP_TMP, out ho_SelectedSeg, 
              hv_IndexImage);
          ho_SelectedDomain.Dispose();
          HOperatorSet.SelectObj(ho_Domain, out ho_SelectedDomain, hv_IndexImage);
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.ChangeDomain(ho_SelectedSeg, ho_SelectedDomain, out ExpTmpOutVar_0
              );
          ho_SelectedSeg.Dispose();
          ho_SelectedSeg = ExpTmpOutVar_0;
          }
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.ReplaceObj(ho_Segmentations_COPY_INP_TMP, ho_SelectedSeg, 
              out ExpTmpOutVar_0, hv_IndexImage);
          ho_Segmentations_COPY_INP_TMP.Dispose();
          ho_Segmentations_COPY_INP_TMP = ExpTmpOutVar_0;
          }
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.CropDomain(ho_Segmentations_COPY_INP_TMP, out ExpTmpOutVar_0
            );
        ho_Segmentations_COPY_INP_TMP.Dispose();
        ho_Segmentations_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      else
      {
        throw new HalconException("Unsupported parameter value for 'domain_handling'");
      }
      //
      //Preprocess the segmentation images.
      //
      //Set all background classes to the given background class ID.
      if ((int)(new HTuple(hv_SetBackgroundID.TupleNotEqual(new HTuple()))) != 0)
      {
        {
        HObject ExpTmpOutVar_0;
        reassign_pixel_values(ho_Segmentations_COPY_INP_TMP, out ExpTmpOutVar_0, 
            hv_ClassesToBackground, hv_SetBackgroundID);
        ho_Segmentations_COPY_INP_TMP.Dispose();
        ho_Segmentations_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      //
      //Zoom images only if they have a different size than the specified size.
      hv_ImageWidthRaw.Dispose();hv_ImageHeightRaw.Dispose();
      HOperatorSet.GetImageSize(ho_Segmentations_COPY_INP_TMP, out hv_ImageWidthRaw, 
          out hv_ImageHeightRaw);
      hv_EqualWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_EqualWidth = hv_ImageWidth.TupleEqualElem(
          hv_ImageWidthRaw);
      }
      hv_EqualHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_EqualHeight = hv_ImageHeight.TupleEqualElem(
          hv_ImageHeightRaw);
      }
      if ((int)((new HTuple(((hv_EqualWidth.TupleMin())).TupleEqual(0))).TupleOr(
          new HTuple(((hv_EqualHeight.TupleMin())).TupleEqual(0)))) != 0)
      {
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ZoomImageSize(ho_Segmentations_COPY_INP_TMP, out ExpTmpOutVar_0, 
            hv_ImageWidth, hv_ImageHeight, "nearest_neighbor");
        ho_Segmentations_COPY_INP_TMP.Dispose();
        ho_Segmentations_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      //
      //Check the type of the input images
      //and convert if necessary.
      hv_Type.Dispose();
      HOperatorSet.GetImageType(ho_Segmentations_COPY_INP_TMP, out hv_Type);
      hv_EqualReal.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_EqualReal = hv_Type.TupleEqualElem(
          "real");
      }
      //
      if ((int)(new HTuple(((hv_EqualReal.TupleMin())).TupleEqual(0))) != 0)
      {
        //Convert the image type to 'real',
        //because the model expects 'real' images.
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConvertImageType(ho_Segmentations_COPY_INP_TMP, out ExpTmpOutVar_0, 
            "real");
        ho_Segmentations_COPY_INP_TMP.Dispose();
        ho_Segmentations_COPY_INP_TMP = ExpTmpOutVar_0;
        }
      }
      //
      //Write preprocessed Segmentations to output variable.
      ho_SegmentationsPreprocessed.Dispose();
      ho_SegmentationsPreprocessed = new HObject(ho_Segmentations_COPY_INP_TMP);
      ho_Segmentations_COPY_INP_TMP.Dispose();
      ho_Domain.Dispose();
      ho_SelectedSeg.Dispose();
      ho_SelectedDomain.Dispose();

      hv_NumberImages.Dispose();
      hv_NumberSegmentations.Dispose();
      hv_Width.Dispose();
      hv_Height.Dispose();
      hv_WidthSeg.Dispose();
      hv_HeightSeg.Dispose();
      hv_DLModelType.Dispose();
      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_ImageNumChannels.Dispose();
      hv_ImageRangeMin.Dispose();
      hv_ImageRangeMax.Dispose();
      hv_DomainHandling.Dispose();
      hv_SetBackgroundID.Dispose();
      hv_ClassesToBackground.Dispose();
      hv_IgnoreClassIDs.Dispose();
      hv_IsInt.Dispose();
      hv_IndexImage.Dispose();
      hv_ImageWidthRaw.Dispose();
      hv_ImageHeightRaw.Dispose();
      hv_EqualWidth.Dispose();
      hv_EqualHeight.Dispose();
      hv_Type.Dispose();
      hv_EqualReal.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Segmentations_COPY_INP_TMP.Dispose();
      ho_Domain.Dispose();
      ho_SelectedSeg.Dispose();
      ho_SelectedDomain.Dispose();

      hv_NumberImages.Dispose();
      hv_NumberSegmentations.Dispose();
      hv_Width.Dispose();
      hv_Height.Dispose();
      hv_WidthSeg.Dispose();
      hv_HeightSeg.Dispose();
      hv_DLModelType.Dispose();
      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_ImageNumChannels.Dispose();
      hv_ImageRangeMin.Dispose();
      hv_ImageRangeMax.Dispose();
      hv_DomainHandling.Dispose();
      hv_SetBackgroundID.Dispose();
      hv_ClassesToBackground.Dispose();
      hv_IgnoreClassIDs.Dispose();
      hv_IsInt.Dispose();
      hv_IndexImage.Dispose();
      hv_ImageWidthRaw.Dispose();
      hv_ImageHeightRaw.Dispose();
      hv_EqualWidth.Dispose();
      hv_EqualHeight.Dispose();
      hv_Type.Dispose();
      hv_EqualReal.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: Preprocess given DLSamples according to the preprocessing parameters given in DLPreprocessParam. 
  public void preprocess_dl_samples (HTuple hv_DLSampleBatch, HTuple hv_DLPreprocessParam)
  {



    // Local iconic variables 

    HObject ho_ImageRaw=null, ho_ImagePreprocessed=null;
    HObject ho_AnomalyImageRaw=null, ho_AnomalyImagePreprocessed=null;
    HObject ho_SegmentationRaw=null, ho_SegmentationPreprocessed=null;

    // Local control variables 

    HTuple hv_ModelType = new HTuple(), hv_SampleIndex = new HTuple();
    HTuple hv_ImageExists = new HTuple(), hv_KeysExists = new HTuple();
    HTuple hv_AnomalyParamExist = new HTuple(), hv_Rectangle1ParamExist = new HTuple();
    HTuple hv_Rectangle2ParamExist = new HTuple(), hv_SegmentationParamExist = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImageRaw);
    HOperatorSet.GenEmptyObj(out ho_ImagePreprocessed);
    HOperatorSet.GenEmptyObj(out ho_AnomalyImageRaw);
    HOperatorSet.GenEmptyObj(out ho_AnomalyImagePreprocessed);
    HOperatorSet.GenEmptyObj(out ho_SegmentationRaw);
    HOperatorSet.GenEmptyObj(out ho_SegmentationPreprocessed);
    try
    {
      //
      //This procedure preprocesses all images of the sample dictionaries in the tuple DLSampleBatch.
      //The images are preprocessed according to the parameters provided in DLPreprocessParam.
      //
      //Check the validity of the preprocessing parameters.
      check_dl_preprocess_param(hv_DLPreprocessParam);
      hv_ModelType.Dispose();
      HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "model_type", out hv_ModelType);
      //
      //Preprocess the sample entries.
      //
      for (hv_SampleIndex=0; (int)hv_SampleIndex<=(int)((new HTuple(hv_DLSampleBatch.TupleLength()
          ))-1); hv_SampleIndex = (int)hv_SampleIndex + 1)
      {
        //
        //Check the existence of the sample keys.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ImageExists.Dispose();
        HOperatorSet.GetDictParam(hv_DLSampleBatch.TupleSelect(hv_SampleIndex), "key_exists", 
            "image", out hv_ImageExists);
        }
        //
        //Preprocess the images.
        if ((int)(hv_ImageExists) != 0)
        {
          //
          //Get the image.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_ImageRaw.Dispose();
          HOperatorSet.GetDictObject(out ho_ImageRaw, hv_DLSampleBatch.TupleSelect(
              hv_SampleIndex), "image");
          }
          //
          //Preprocess the image.
          ho_ImagePreprocessed.Dispose();
          preprocess_dl_model_images(ho_ImageRaw, out ho_ImagePreprocessed, hv_DLPreprocessParam);
          //
          //Replace the image in the dictionary.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetDictObject(ho_ImagePreprocessed, hv_DLSampleBatch.TupleSelect(
              hv_SampleIndex), "image");
          }
          //
          //Check existence of model specific sample keys:
          //- bbox_row1 for 'rectangle1'
          //- bbox_phi for 'rectangle2'
          //- segmentation_image for 'semantic segmentation'
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_KeysExists.Dispose();
          HOperatorSet.GetDictParam(hv_DLSampleBatch.TupleSelect(hv_SampleIndex), 
              "key_exists", (((new HTuple("anomaly_ground_truth")).TupleConcat("bbox_row1")).TupleConcat(
              "bbox_phi")).TupleConcat("segmentation_image"), out hv_KeysExists);
          }
          hv_AnomalyParamExist.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_AnomalyParamExist = hv_KeysExists.TupleSelect(
              0);
          }
          hv_Rectangle1ParamExist.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Rectangle1ParamExist = hv_KeysExists.TupleSelect(
              1);
          }
          hv_Rectangle2ParamExist.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Rectangle2ParamExist = hv_KeysExists.TupleSelect(
              2);
          }
          hv_SegmentationParamExist.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_SegmentationParamExist = hv_KeysExists.TupleSelect(
              3);
          }
          //
          //Preprocess the anomaly ground truth if present.
          if ((int)(hv_AnomalyParamExist) != 0)
          {
            //
            //Get the anomaly image.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_AnomalyImageRaw.Dispose();
            HOperatorSet.GetDictObject(out ho_AnomalyImageRaw, hv_DLSampleBatch.TupleSelect(
                hv_SampleIndex), "anomaly_ground_truth");
            }
            //
            //Preprocess the anomaly image.
            ho_AnomalyImagePreprocessed.Dispose();
            preprocess_dl_model_anomaly(ho_AnomalyImageRaw, out ho_AnomalyImagePreprocessed, 
                hv_DLPreprocessParam);
            //
            //Set preprocessed anomaly image.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetDictObject(ho_AnomalyImagePreprocessed, hv_DLSampleBatch.TupleSelect(
                hv_SampleIndex), "anomaly_ground_truth");
            }
          }
          //
          //Preprocess depending on the model type.
          //If bounding boxes are given, rescale them as well.
          if ((int)(hv_Rectangle1ParamExist) != 0)
          {
            //
            //Preprocess the bounding boxes of type 'rectangle1'.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            preprocess_dl_model_bbox_rect1(ho_ImageRaw, hv_DLSampleBatch.TupleSelect(
                hv_SampleIndex), hv_DLPreprocessParam);
            }
          }
          else if ((int)(hv_Rectangle2ParamExist) != 0)
          {
            //
            //Preprocess the bounding boxes of type 'rectangle2'.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            preprocess_dl_model_bbox_rect2(ho_ImageRaw, hv_DLSampleBatch.TupleSelect(
                hv_SampleIndex), hv_DLPreprocessParam);
            }
          }
          //
          //Preprocess the segmentation image if present.
          if ((int)(hv_SegmentationParamExist) != 0)
          {
            //
            //Get the segmentation image.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_SegmentationRaw.Dispose();
            HOperatorSet.GetDictObject(out ho_SegmentationRaw, hv_DLSampleBatch.TupleSelect(
                hv_SampleIndex), "segmentation_image");
            }
            //
            //Preprocess the segmentation image.
            ho_SegmentationPreprocessed.Dispose();
            preprocess_dl_model_segmentations(ho_ImageRaw, ho_SegmentationRaw, out ho_SegmentationPreprocessed, 
                hv_DLPreprocessParam);
            //
            //Set preprocessed segmentation image.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetDictObject(ho_SegmentationPreprocessed, hv_DLSampleBatch.TupleSelect(
                hv_SampleIndex), "segmentation_image");
            }
          }
        }
        else
        {
          throw new HalconException((new HTuple("All samples processed need to include an image, but the sample with index ")+hv_SampleIndex)+" does not.");
        }
      }
      //
      ho_ImageRaw.Dispose();
      ho_ImagePreprocessed.Dispose();
      ho_AnomalyImageRaw.Dispose();
      ho_AnomalyImagePreprocessed.Dispose();
      ho_SegmentationRaw.Dispose();
      ho_SegmentationPreprocessed.Dispose();

      hv_ModelType.Dispose();
      hv_SampleIndex.Dispose();
      hv_ImageExists.Dispose();
      hv_KeysExists.Dispose();
      hv_AnomalyParamExist.Dispose();
      hv_Rectangle1ParamExist.Dispose();
      hv_Rectangle2ParamExist.Dispose();
      hv_SegmentationParamExist.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_ImageRaw.Dispose();
      ho_ImagePreprocessed.Dispose();
      ho_AnomalyImageRaw.Dispose();
      ho_AnomalyImagePreprocessed.Dispose();
      ho_SegmentationRaw.Dispose();
      ho_SegmentationPreprocessed.Dispose();

      hv_ModelType.Dispose();
      hv_SampleIndex.Dispose();
      hv_ImageExists.Dispose();
      hv_KeysExists.Dispose();
      hv_AnomalyParamExist.Dispose();
      hv_Rectangle1ParamExist.Dispose();
      hv_Rectangle2ParamExist.Dispose();
      hv_SegmentationParamExist.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: Read the dictionaries DLSamples from files. 
  public void read_dl_samples (HTuple hv_DLDataset, HTuple hv_SampleIndices, out HTuple hv_DLSampleBatch)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_DatasetSamples = new HTuple(), hv_MinIndex = new HTuple();
    HTuple hv_MaxIndex = new HTuple(), hv_KeyDirExists = new HTuple();
    HTuple hv_DictDir = new HTuple(), hv_DLSamplesProc = new HTuple();
    HTuple hv_ImageIndex = new HTuple(), hv_KeyFileExists = new HTuple();
    HTuple hv_ImageID = new HTuple(), hv_FileNameRelative = new HTuple();
    HTuple hv_FileNameSample = new HTuple(), hv_FileExists = new HTuple();
    HTuple hv_DictPath = new HTuple(), hv_DLSample = new HTuple();
    HTuple hv_Exception = new HTuple();
    // Initialize local and output iconic variables 
    hv_DLSampleBatch = new HTuple();
    try
    {
      //
      //This procedure reads a batch of DLSample dictionaries from disk.
      //The wanted samples are selected from a DLDataset by their indices.
      //The indices of the wanted samples are handed over in SampleIndices.
      //It returns the tuple of read-in dictionaries in DLSampleBatch.
      //
      //Sanity checks of inputs.
      //
      if ((int)(new HTuple((new HTuple(hv_SampleIndices.TupleLength())).TupleLessEqual(
          0))) != 0)
      {
        //Check the length of selected indices.
        throw new HalconException(new HTuple("Invalid length of SelectedIndices: ")+(new HTuple(hv_SampleIndices.TupleLength()
            )));
      }
      else
      {
        //Get the samples from the DLDataset.
        hv_DatasetSamples.Dispose();
        HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DatasetSamples);
        //Get min and max value of given indices.
        hv_MinIndex.Dispose();
        HOperatorSet.TupleMin(hv_SampleIndices, out hv_MinIndex);
        hv_MaxIndex.Dispose();
        HOperatorSet.TupleMax(hv_SampleIndices, out hv_MaxIndex);
        if ((int)((new HTuple(hv_MinIndex.TupleLess(0))).TupleOr(new HTuple(hv_MaxIndex.TupleGreater(
            (new HTuple(hv_DatasetSamples.TupleLength()))-1)))) != 0)
        {
          //Check the value range of the provided indices.
          throw new HalconException("The given SampleIndices are not within the range of available samples in DLDataset.");
        }
      }
      //
      //Check if the key dlsample_dir is given.
      hv_KeyDirExists.Dispose();
      HOperatorSet.GetDictParam(hv_DLDataset, "key_exists", "dlsample_dir", out hv_KeyDirExists);
      //
      if ((int)(hv_KeyDirExists) != 0)
      {
        //
        //Get the dlsample_dir.
        hv_DictDir.Dispose();
        HOperatorSet.GetDictTuple(hv_DLDataset, "dlsample_dir", out hv_DictDir);
        //Get the samples to be processed.
        hv_DLSamplesProc.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DLSamplesProc = hv_DatasetSamples.TupleSelect(
            hv_SampleIndices);
        }
        //
        //Initialize DLSampleBatch tuple.
        hv_DLSampleBatch.Dispose();
        hv_DLSampleBatch = new HTuple();
        //
        //Read in all DLSamples into the batch.
        for (hv_ImageIndex=0; (int)hv_ImageIndex<=(int)((new HTuple(hv_SampleIndices.TupleLength()
            ))-1); hv_ImageIndex = (int)hv_ImageIndex + 1)
        {
          //Check if dlsample key exist.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_KeyFileExists.Dispose();
          HOperatorSet.GetDictParam(hv_DLSamplesProc.TupleSelect(hv_ImageIndex), 
              "key_exists", "dlsample_file_name", out hv_KeyFileExists);
          }
          //
          if ((int)(hv_KeyFileExists.TupleNot()) != 0)
          {
            //
            //If the key does not exist, check if a corresponding file exists.
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ImageID.Dispose();
            HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex), 
                "image_id", out hv_ImageID);
            }
            hv_FileNameRelative.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_FileNameRelative = hv_ImageID+"_dlsample.hdict";
            }
            hv_FileNameSample.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_FileNameSample = (hv_DictDir+"/")+hv_FileNameRelative;
            }
            //
            hv_FileExists.Dispose();
            HOperatorSet.FileExists(hv_FileNameSample, out hv_FileExists);
            if ((int)(hv_FileExists) != 0)
            {
              //If it exists, create corresponding key.
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex), 
                  "dlsample_file_name", hv_FileNameRelative);
              }
            }
            else
            {
              //If not, throw an error.
              throw new HalconException("No 'dlsample_file_name' and hdict file available for image ID "+hv_ImageID);
            }
            //
          }
          //
          //If dlsample dictionary is available for reading, read it.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_DictPath.Dispose();
          HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex), 
              "dlsample_file_name", out hv_DictPath);
          }
          try
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_DLSample.Dispose();
            HOperatorSet.ReadDict((hv_DictDir+"/")+hv_DictPath, new HTuple(), new HTuple(), 
                out hv_DLSample);
            }
          }
          // catch (Exception) 
          catch (HalconException HDevExpDefaultException1)
          {
            HDevExpDefaultException1.ToHTuple(out hv_Exception);
            throw new HalconException((((("An error has occurred while reading "+hv_DictDir)+"/")+hv_DictPath)+new HTuple(" , HALCON error # "))+(hv_Exception.TupleSelect(
                0)));
          }
          //Add it to the DLSampleBatch.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_DLSampleBatch = hv_DLSampleBatch.TupleConcat(
              hv_DLSample);
          hv_DLSampleBatch.Dispose();
          hv_DLSampleBatch = ExpTmpLocalVar_DLSampleBatch;
          }
          }
          //
        }
      }
      else
      {
        throw new HalconException("The dataset needs to include the key 'dlsample_dir' for reading a DLSample from file.");
      }


      hv_DatasetSamples.Dispose();
      hv_MinIndex.Dispose();
      hv_MaxIndex.Dispose();
      hv_KeyDirExists.Dispose();
      hv_DictDir.Dispose();
      hv_DLSamplesProc.Dispose();
      hv_ImageIndex.Dispose();
      hv_KeyFileExists.Dispose();
      hv_ImageID.Dispose();
      hv_FileNameRelative.Dispose();
      hv_FileNameSample.Dispose();
      hv_FileExists.Dispose();
      hv_DictPath.Dispose();
      hv_DLSample.Dispose();
      hv_Exception.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_DatasetSamples.Dispose();
      hv_MinIndex.Dispose();
      hv_MaxIndex.Dispose();
      hv_KeyDirExists.Dispose();
      hv_DictDir.Dispose();
      hv_DLSamplesProc.Dispose();
      hv_ImageIndex.Dispose();
      hv_KeyFileExists.Dispose();
      hv_ImageID.Dispose();
      hv_FileNameRelative.Dispose();
      hv_FileNameSample.Dispose();
      hv_FileExists.Dispose();
      hv_DictPath.Dispose();
      hv_DLSample.Dispose();
      hv_Exception.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Image / Manipulation
  // Short Description: Changes a value of ValuesToChange in Image to NewValue. 
  public void reassign_pixel_values (HObject ho_Image, out HObject ho_ImageOut, HTuple hv_ValuesToChange, 
      HTuple hv_NewValue)
  {




    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_RegionToChange, ho_RegionClass=null;

    // Local control variables 

    HTuple hv_IndexReset = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_ImageOut);
    HOperatorSet.GenEmptyObj(out ho_RegionToChange);
    HOperatorSet.GenEmptyObj(out ho_RegionClass);
    try
    {
      //
      //This procedure sets all pixels of Image
      //with the values given in ValuesToChange to the given value NewValue.
      //
      ho_RegionToChange.Dispose();
      HOperatorSet.GenEmptyRegion(out ho_RegionToChange);
      for (hv_IndexReset=0; (int)hv_IndexReset<=(int)((new HTuple(hv_ValuesToChange.TupleLength()
          ))-1); hv_IndexReset = (int)hv_IndexReset + 1)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_RegionClass.Dispose();
        HOperatorSet.Threshold(ho_Image, out ho_RegionClass, hv_ValuesToChange.TupleSelect(
            hv_IndexReset), hv_ValuesToChange.TupleSelect(hv_IndexReset));
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.Union2(ho_RegionToChange, ho_RegionClass, out ExpTmpOutVar_0
            );
        ho_RegionToChange.Dispose();
        ho_RegionToChange = ExpTmpOutVar_0;
        }
      }
      HOperatorSet.OverpaintRegion(ho_Image, ho_RegionToChange, hv_NewValue, "fill");
      ho_ImageOut.Dispose();
      ho_ImageOut = new HObject(ho_Image);
      ho_RegionToChange.Dispose();
      ho_RegionClass.Dispose();

      hv_IndexReset.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_RegionToChange.Dispose();
      ho_RegionClass.Dispose();

      hv_IndexReset.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: File / Misc
  // Short Description: This procedure removes a directory recursively. 
  public void remove_dir_recursively (HTuple hv_DirName)
  {



    // Local control variables 

    HTuple hv_Dirs = new HTuple(), hv_I = new HTuple();
    HTuple hv_Files = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //Recursively delete all subdirectories.
      hv_Dirs.Dispose();
      HOperatorSet.ListFiles(hv_DirName, "directories", out hv_Dirs);
      for (hv_I=0; (int)hv_I<=(int)((new HTuple(hv_Dirs.TupleLength()))-1); hv_I = (int)hv_I + 1)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        remove_dir_recursively(hv_Dirs.TupleSelect(hv_I));
        }
      }
      //Delete all files.
      hv_Files.Dispose();
      HOperatorSet.ListFiles(hv_DirName, "files", out hv_Files);
      for (hv_I=0; (int)hv_I<=(int)((new HTuple(hv_Files.TupleLength()))-1); hv_I = (int)hv_I + 1)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.DeleteFile(hv_Files.TupleSelect(hv_I));
        }
      }
      //Remove empty directory.
      HOperatorSet.RemoveDir(hv_DirName);

      hv_Dirs.Dispose();
      hv_I.Dispose();
      hv_Files.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_Dirs.Dispose();
      hv_I.Dispose();
      hv_Files.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Object Detection
  // Short Description: This procedure removes a given ratio of the smallest and largest data points in the data collection DataCollection. 
  public void remove_dl_data_outliers (HTuple hv_DataCollection, out HTuple hv_DataCollectionReduced)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_OutliersRatio = new HTuple(), hv_MinNumData = new HTuple();
    HTuple hv_NumData = new HTuple(), hv_DataSorted = new HTuple();
    HTuple hv_DataOutliers = new HTuple();
    // Initialize local and output iconic variables 
    hv_DataCollectionReduced = new HTuple();
    try
    {
      //This procedure removes a given ratio of the smallest and largest data
      //points in the input DataCollection in order to remove possible outliers.
      //
      //The ratio of the data collections to be considered as outliers.
      hv_OutliersRatio.Dispose();
      hv_OutliersRatio = 0.0025;
      hv_MinNumData.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MinNumData = (1/hv_OutliersRatio)-1;
      }
      //
      //Remove outliers in the given data collection.
      hv_NumData.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NumData = new HTuple(hv_DataCollection.TupleLength()
          );
      }
      if ((int)(new HTuple(hv_NumData.TupleGreater(hv_MinNumData))) != 0)
      {
        hv_DataSorted.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DataSorted = hv_DataCollection.TupleSort()
            ;
        }
        hv_DataOutliers.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DataOutliers = ((hv_OutliersRatio*hv_NumData)).TupleInt()
            ;
        }
        hv_DataCollectionReduced.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DataCollectionReduced = hv_DataSorted.TupleSelectRange(
            hv_DataOutliers,(hv_NumData-hv_DataOutliers)-1);
        }
      }
      else
      {
        hv_DataCollectionReduced.Dispose();
        hv_DataCollectionReduced = new HTuple(hv_DataCollection);
      }
      //

      hv_OutliersRatio.Dispose();
      hv_MinNumData.Dispose();
      hv_NumData.Dispose();
      hv_DataSorted.Dispose();
      hv_DataOutliers.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_OutliersRatio.Dispose();
      hv_MinNumData.Dispose();
      hv_NumData.Dispose();
      hv_DataSorted.Dispose();
      hv_DataOutliers.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: This procedure replaces legacy preprocessing parameters. 
  public void replace_legacy_preprocessing_parameters (HTuple hv_DLPreprocessParam)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Exception = new HTuple(), hv_NormalizationTypeExists = new HTuple();
    HTuple hv_NormalizationType = new HTuple(), hv_LegacyNormalizationKeyExists = new HTuple();
    HTuple hv_ContrastNormalization = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //
      //This procedure adapts the dictionary DLPreprocessParam
      //if a legacy preprocessing parameter is set.
      //
      //Map legacy value set to new parameter.
      hv_Exception.Dispose();
      hv_Exception = 0;
      try
      {
        hv_NormalizationTypeExists.Dispose();
        HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", "normalization_type", 
            out hv_NormalizationTypeExists);
        //
        if ((int)(hv_NormalizationTypeExists) != 0)
        {
          hv_NormalizationType.Dispose();
          HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "normalization_type", out hv_NormalizationType);
          if ((int)(new HTuple(hv_NormalizationType.TupleEqual("true"))) != 0)
          {
            hv_NormalizationType.Dispose();
            hv_NormalizationType = "first_channel";
          }
          else if ((int)(new HTuple(hv_NormalizationType.TupleEqual("false"))) != 0)
          {
            hv_NormalizationType.Dispose();
            hv_NormalizationType = "none";
          }
          HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "normalization_type", hv_NormalizationType);
        }
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
      }
      //
      //Map legacy parameter to new parameter and corresponding value.
      hv_Exception.Dispose();
      hv_Exception = 0;
      try
      {
        hv_LegacyNormalizationKeyExists.Dispose();
        HOperatorSet.GetDictParam(hv_DLPreprocessParam, "key_exists", "contrast_normalization", 
            out hv_LegacyNormalizationKeyExists);
        if ((int)(hv_LegacyNormalizationKeyExists) != 0)
        {
          hv_ContrastNormalization.Dispose();
          HOperatorSet.GetDictTuple(hv_DLPreprocessParam, "contrast_normalization", 
              out hv_ContrastNormalization);
          //Replace 'contrast_normalization' by 'normalization_type'.
          if ((int)(new HTuple(hv_ContrastNormalization.TupleEqual("false"))) != 0)
          {
            HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "normalization_type", 
                "none");
          }
          else if ((int)(new HTuple(hv_ContrastNormalization.TupleEqual(
              "true"))) != 0)
          {
            HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "normalization_type", 
                "first_channel");
          }
          HOperatorSet.RemoveDictKey(hv_DLPreprocessParam, "contrast_normalization");
        }
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
      }

      hv_Exception.Dispose();
      hv_NormalizationTypeExists.Dispose();
      hv_NormalizationType.Dispose();
      hv_LegacyNormalizationKeyExists.Dispose();
      hv_ContrastNormalization.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_Exception.Dispose();
      hv_NormalizationTypeExists.Dispose();
      hv_NormalizationType.Dispose();
      hv_LegacyNormalizationKeyExists.Dispose();
      hv_ContrastNormalization.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Filters / Arithmetic
  // Short Description: Scale the gray values of an image from the interval [Min,Max] to [0,255] 
  public void scale_image_range (HObject ho_Image, out HObject ho_ImageScaled, HTuple hv_Min, 
      HTuple hv_Max)
  {




      // Stack for temporary objects 
      HObject[] OTemp = new HObject[20];

      // Local iconic variables 

      HObject ho_ImageSelected=null, ho_SelectedChannel=null;
      HObject ho_LowerRegion=null, ho_UpperRegion=null, ho_ImageSelectedScaled=null;

      // Local copy input parameter variables 
      HObject ho_Image_COPY_INP_TMP;
      ho_Image_COPY_INP_TMP = new HObject(ho_Image);



      // Local control variables 

      HTuple hv_LowerLimit = new HTuple(), hv_UpperLimit = new HTuple();
      HTuple hv_Mult = new HTuple(), hv_Add = new HTuple(), hv_NumImages = new HTuple();
      HTuple hv_ImageIndex = new HTuple(), hv_Channels = new HTuple();
      HTuple hv_ChannelIndex = new HTuple(), hv_MinGray = new HTuple();
      HTuple hv_MaxGray = new HTuple(), hv_Range = new HTuple();
      HTuple   hv_Max_COPY_INP_TMP = new HTuple(hv_Max);
      HTuple   hv_Min_COPY_INP_TMP = new HTuple(hv_Min);

      // Initialize local and output iconic variables 
      HOperatorSet.GenEmptyObj(out ho_ImageScaled);
      HOperatorSet.GenEmptyObj(out ho_ImageSelected);
      HOperatorSet.GenEmptyObj(out ho_SelectedChannel);
      HOperatorSet.GenEmptyObj(out ho_LowerRegion);
      HOperatorSet.GenEmptyObj(out ho_UpperRegion);
      HOperatorSet.GenEmptyObj(out ho_ImageSelectedScaled);
      try
      {
      //Convenience procedure to scale the gray values of the
      //input image Image from the interval [Min,Max]
      //to the interval [0,255] (default).
      //Gray values < 0 or > 255 (after scaling) are clipped.
      //
      //If the image shall be scaled to an interval different from [0,255],
      //this can be achieved by passing tuples with 2 values [From, To]
      //as Min and Max.
      //Example:
      //scale_image_range(Image:ImageScaled:[100,50],[200,250])
      //maps the gray values of Image from the interval [100,200] to [50,250].
      //All other gray values will be clipped.
      //
      //input parameters:
      //Image: the input image
      //Min: the minimum gray value which will be mapped to 0
      //     If a tuple with two values is given, the first value will
      //     be mapped to the second value.
      //Max: The maximum gray value which will be mapped to 255
      //     If a tuple with two values is given, the first value will
      //     be mapped to the second value.
      //
      //Output parameter:
      //ImageScale: the resulting scaled image.
      //
      if ((int)(new HTuple((new HTuple(hv_Min_COPY_INP_TMP.TupleLength())).TupleEqual(
          2))) != 0)
      {
        hv_LowerLimit.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_LowerLimit = hv_Min_COPY_INP_TMP.TupleSelect(
            1);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Min = hv_Min_COPY_INP_TMP.TupleSelect(
            0);
        hv_Min_COPY_INP_TMP.Dispose();
        hv_Min_COPY_INP_TMP = ExpTmpLocalVar_Min;
        }
        }
      }
      else
      {
        hv_LowerLimit.Dispose();
        hv_LowerLimit = 0.0;
      }
      if ((int)(new HTuple((new HTuple(hv_Max_COPY_INP_TMP.TupleLength())).TupleEqual(
          2))) != 0)
      {
        hv_UpperLimit.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_UpperLimit = hv_Max_COPY_INP_TMP.TupleSelect(
            1);
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Max = hv_Max_COPY_INP_TMP.TupleSelect(
            0);
        hv_Max_COPY_INP_TMP.Dispose();
        hv_Max_COPY_INP_TMP = ExpTmpLocalVar_Max;
        }
        }
      }
      else
      {
        hv_UpperLimit.Dispose();
        hv_UpperLimit = 255.0;
      }
      //
      //Calculate scaling parameters.
      hv_Mult.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Mult = (((hv_UpperLimit-hv_LowerLimit)).TupleReal()
          )/(hv_Max_COPY_INP_TMP-hv_Min_COPY_INP_TMP);
      }
      hv_Add.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Add = ((-hv_Mult)*hv_Min_COPY_INP_TMP)+hv_LowerLimit;
      }
      //
      //Scale image.
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ScaleImage(ho_Image_COPY_INP_TMP, out ExpTmpOutVar_0, hv_Mult, 
          hv_Add);
      ho_Image_COPY_INP_TMP.Dispose();
      ho_Image_COPY_INP_TMP = ExpTmpOutVar_0;
      }
      //
      //Clip gray values if necessary.
      //This must be done for each image and channel separately.
      ho_ImageScaled.Dispose();
      HOperatorSet.GenEmptyObj(out ho_ImageScaled);
      hv_NumImages.Dispose();
      HOperatorSet.CountObj(ho_Image_COPY_INP_TMP, out hv_NumImages);
      HTuple end_val49 = hv_NumImages;
      HTuple step_val49 = 1;
      for (hv_ImageIndex=1; hv_ImageIndex.Continue(end_val49, step_val49); hv_ImageIndex = hv_ImageIndex.TupleAdd(step_val49))
      {
        ho_ImageSelected.Dispose();
        HOperatorSet.SelectObj(ho_Image_COPY_INP_TMP, out ho_ImageSelected, hv_ImageIndex);
        hv_Channels.Dispose();
        HOperatorSet.CountChannels(ho_ImageSelected, out hv_Channels);
        HTuple end_val52 = hv_Channels;
        HTuple step_val52 = 1;
        for (hv_ChannelIndex=1; hv_ChannelIndex.Continue(end_val52, step_val52); hv_ChannelIndex = hv_ChannelIndex.TupleAdd(step_val52))
        {
          ho_SelectedChannel.Dispose();
          HOperatorSet.AccessChannel(ho_ImageSelected, out ho_SelectedChannel, hv_ChannelIndex);
          hv_MinGray.Dispose();hv_MaxGray.Dispose();hv_Range.Dispose();
          HOperatorSet.MinMaxGray(ho_SelectedChannel, ho_SelectedChannel, 0, out hv_MinGray, 
              out hv_MaxGray, out hv_Range);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_LowerRegion.Dispose();
          HOperatorSet.Threshold(ho_SelectedChannel, out ho_LowerRegion, ((hv_MinGray.TupleConcat(
              hv_LowerLimit))).TupleMin(), hv_LowerLimit);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_UpperRegion.Dispose();
          HOperatorSet.Threshold(ho_SelectedChannel, out ho_UpperRegion, hv_UpperLimit, 
              ((hv_UpperLimit.TupleConcat(hv_MaxGray))).TupleMax());
          }
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.PaintRegion(ho_LowerRegion, ho_SelectedChannel, out ExpTmpOutVar_0, 
              hv_LowerLimit, "fill");
          ho_SelectedChannel.Dispose();
          ho_SelectedChannel = ExpTmpOutVar_0;
          }
          {
          HObject ExpTmpOutVar_0;
          HOperatorSet.PaintRegion(ho_UpperRegion, ho_SelectedChannel, out ExpTmpOutVar_0, 
              hv_UpperLimit, "fill");
          ho_SelectedChannel.Dispose();
          ho_SelectedChannel = ExpTmpOutVar_0;
          }
          if ((int)(new HTuple(hv_ChannelIndex.TupleEqual(1))) != 0)
          {
            ho_ImageSelectedScaled.Dispose();
            HOperatorSet.CopyObj(ho_SelectedChannel, out ho_ImageSelectedScaled, 
                1, 1);
          }
          else
          {
            {
            HObject ExpTmpOutVar_0;
            HOperatorSet.AppendChannel(ho_ImageSelectedScaled, ho_SelectedChannel, 
                out ExpTmpOutVar_0);
            ho_ImageSelectedScaled.Dispose();
            ho_ImageSelectedScaled = ExpTmpOutVar_0;
            }
          }
        }
        {
        HObject ExpTmpOutVar_0;
        HOperatorSet.ConcatObj(ho_ImageScaled, ho_ImageSelectedScaled, out ExpTmpOutVar_0
            );
        ho_ImageScaled.Dispose();
        ho_ImageScaled = ExpTmpOutVar_0;
        }
      }
      ho_Image_COPY_INP_TMP.Dispose();
      ho_ImageSelected.Dispose();
      ho_SelectedChannel.Dispose();
      ho_LowerRegion.Dispose();
      ho_UpperRegion.Dispose();
      ho_ImageSelectedScaled.Dispose();

      hv_Max_COPY_INP_TMP.Dispose();
      hv_Min_COPY_INP_TMP.Dispose();
      hv_LowerLimit.Dispose();
      hv_UpperLimit.Dispose();
      hv_Mult.Dispose();
      hv_Add.Dispose();
      hv_NumImages.Dispose();
      hv_ImageIndex.Dispose();
      hv_Channels.Dispose();
      hv_ChannelIndex.Dispose();
      hv_MinGray.Dispose();
      hv_MaxGray.Dispose();
      hv_Range.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Image_COPY_INP_TMP.Dispose();
      ho_ImageSelected.Dispose();
      ho_SelectedChannel.Dispose();
      ho_LowerRegion.Dispose();
      ho_UpperRegion.Dispose();
      ho_ImageSelectedScaled.Dispose();

      hv_Max_COPY_INP_TMP.Dispose();
      hv_Min_COPY_INP_TMP.Dispose();
      hv_LowerLimit.Dispose();
      hv_UpperLimit.Dispose();
      hv_Mult.Dispose();
      hv_Add.Dispose();
      hv_NumImages.Dispose();
      hv_ImageIndex.Dispose();
      hv_Channels.Dispose();
      hv_ChannelIndex.Dispose();
      hv_MinGray.Dispose();
      hv_MaxGray.Dispose();
      hv_Range.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Object Detection
  // Short Description: This procedure calculates the scaled bounding box parameters for a bounding box of type rectangle2. 
  public void scale_rectangle2_bbox (HTuple hv_Row, HTuple hv_Col, HTuple hv_Length1, 
      HTuple hv_Length2, HTuple hv_Phi, HTuple hv_FactorHeight, HTuple hv_FactorWidth, 
      out HTuple hv_NewRow, out HTuple hv_NewCol, out HTuple hv_NewLength1, out HTuple hv_NewLength2, 
      out HTuple hv_NewPhi)
  {



    // Local iconic variables 

    HObject ho_Rectangle2XLD, ho_Rectangle2XLDSheared;

    // Local control variables 

    HTuple hv_HomMat2DIdentity = new HTuple();
    HTuple hv_HomMat2DScale = new HTuple(), hv_NewPhi1 = new HTuple();
    HTuple hv_NewPhi2 = new HTuple(), hv_NewPhi3 = new HTuple();
    HTuple hv_NewPhi4 = new HTuple(), hv_Pi = new HTuple();
    HTuple hv_MaskPhi2 = new HTuple(), hv_MaskPhi3 = new HTuple();
    HTuple hv_MaskPhi4 = new HTuple(), hv_Diff1 = new HTuple();
    HTuple hv_Diff2 = new HTuple(), hv_Diff3 = new HTuple();
    HTuple hv_Diff4 = new HTuple(), hv_MinDiff12 = new HTuple();
    HTuple hv_MinIndex12 = new HTuple(), hv_MinDiff34 = new HTuple();
    HTuple hv_MinIndex34 = new HTuple(), hv_MinDiff1234 = new HTuple();
    HTuple hv_MinIndex12Mask = new HTuple(), hv_MinIndex34Mask = new HTuple();
    HTuple hv_MinIndex12Masked = new HTuple(), hv_MinIndex34Masked = new HTuple();
    HTuple hv_MinIndex1234 = new HTuple(), hv_NewPhi1Masked = new HTuple();
    HTuple hv_NewPhi2Masked = new HTuple(), hv_NewPhi3Masked = new HTuple();
    HTuple hv_NewPhi4Masked = new HTuple(), hv_SwapMask = new HTuple();
    HTuple hv_SwapMaskInverted = new HTuple(), hv_Length1Tmp = new HTuple();
    HTuple hv_Length2Tmp = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Rectangle2XLD);
    HOperatorSet.GenEmptyObj(out ho_Rectangle2XLDSheared);
    hv_NewRow = new HTuple();
    hv_NewCol = new HTuple();
    hv_NewLength1 = new HTuple();
    hv_NewLength2 = new HTuple();
    hv_NewPhi = new HTuple();
    try
    {
      //This procedure computes the parameters of a given bounding box of type
      //rectangle2 for an image scaling by FactorHeight and FactorWidth.
      //
      //Generate XLD contour for the rectangle.
      ho_Rectangle2XLD.Dispose();
      HOperatorSet.GenRectangle2ContourXld(out ho_Rectangle2XLD, hv_Row, hv_Col, 
          hv_Phi, hv_Length1, hv_Length2);
      //Create scaling matrix.
      hv_HomMat2DIdentity.Dispose();
      HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
      hv_HomMat2DScale.Dispose();
      HOperatorSet.HomMat2dScale(hv_HomMat2DIdentity, hv_FactorHeight, hv_FactorWidth, 
          0, 0, out hv_HomMat2DScale);
      //
      //Scale the XLD contours --> results in sheared regions.
      ho_Rectangle2XLDSheared.Dispose();
      HOperatorSet.AffineTransContourXld(ho_Rectangle2XLD, out ho_Rectangle2XLDSheared, 
          hv_HomMat2DScale);
      hv_NewRow.Dispose();hv_NewCol.Dispose();hv_NewPhi.Dispose();hv_NewLength1.Dispose();hv_NewLength2.Dispose();
      HOperatorSet.SmallestRectangle2Xld(ho_Rectangle2XLDSheared, out hv_NewRow, 
          out hv_NewCol, out hv_NewPhi, out hv_NewLength1, out hv_NewLength2);
      //
      //Since the angle Phi can point to 4 different directions for the same rectangle2,
      //it is possible that the new Phi returned by smallest_rectangle2_xld is not the one
      //corresponding to the original Phi. Hence we need to get all 4 possible Phis and
      //find the one closest to the original.
      //
      //At first, get the 4 angles.
      hv_NewPhi1.Dispose();
      hv_NewPhi1 = new HTuple(hv_NewPhi);
      hv_NewPhi2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NewPhi2 = hv_NewPhi+((new HTuple(90)).TupleRad()
          );
      }
      hv_NewPhi3.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NewPhi3 = hv_NewPhi+((new HTuple(180)).TupleRad()
          );
      }
      hv_NewPhi4.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NewPhi4 = hv_NewPhi+((new HTuple(270)).TupleRad()
          );
      }
      //Clip the angles to the range -Pi to Pi.
      hv_Pi.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Pi = (new HTuple(180)).TupleRad()
          ;
      }
      hv_MaskPhi2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MaskPhi2 = ((hv_NewPhi2.TupleGreaterElem(
          hv_Pi))*2)*hv_Pi;
      }
      hv_MaskPhi3.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MaskPhi3 = ((hv_NewPhi3.TupleGreaterElem(
          hv_Pi))*2)*hv_Pi;
      }
      hv_MaskPhi4.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MaskPhi4 = ((hv_NewPhi4.TupleGreaterElem(
          hv_Pi))*2)*hv_Pi;
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_NewPhi2 = hv_NewPhi2-hv_MaskPhi2;
      hv_NewPhi2.Dispose();
      hv_NewPhi2 = ExpTmpLocalVar_NewPhi2;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_NewPhi3 = hv_NewPhi3-hv_MaskPhi3;
      hv_NewPhi3.Dispose();
      hv_NewPhi3 = ExpTmpLocalVar_NewPhi3;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_NewPhi4 = hv_NewPhi4-hv_MaskPhi4;
      hv_NewPhi4.Dispose();
      hv_NewPhi4 = ExpTmpLocalVar_NewPhi4;
      }
      }
      //Calculate the distance between the new angles and the original one.
      hv_Diff1.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Diff1 = ((hv_NewPhi1-hv_Phi)).TupleAbs()
          ;
      }
      hv_Diff2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Diff2 = ((hv_NewPhi2-hv_Phi)).TupleAbs()
          ;
      }
      hv_Diff3.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Diff3 = ((hv_NewPhi3-hv_Phi)).TupleAbs()
          ;
      }
      hv_Diff4.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Diff4 = ((hv_NewPhi4-hv_Phi)).TupleAbs()
          ;
      }
      //Get the angles with the minimum distances. Therefore we compare the angle tuples pairwise.
      //At first, NewPhi1 and NewPhi2 ...
      hv_MinDiff12.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MinDiff12 = hv_Diff1.TupleMin2(
          hv_Diff2);
      }
      //... and store the tuple index of the minimum.
      hv_MinIndex12.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MinIndex12 = (hv_Diff1.TupleGreaterEqualElem(
          hv_Diff2))+1;
      }
      //Now, compare NewPhi3 and NewPhi4 ...
      hv_MinDiff34.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MinDiff34 = hv_Diff3.TupleMin2(
          hv_Diff4);
      }
      //... and also store the tuple index of the minimum.
      hv_MinIndex34.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MinIndex34 = (hv_Diff3.TupleGreaterEqualElem(
          hv_Diff4))+3;
      }
      //At last, compare the results from previous comparisons ...
      hv_MinDiff1234.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MinDiff1234 = hv_MinDiff12.TupleMin2(
          hv_MinDiff34);
      }
      //... and store the final indices.
      hv_MinIndex12Mask.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MinIndex12Mask = hv_MinDiff12.TupleLessElem(
          hv_MinDiff34);
      }
      hv_MinIndex34Mask.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MinIndex34Mask = 1-hv_MinIndex12Mask;
      }
      hv_MinIndex12Masked.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MinIndex12Masked = hv_MinIndex12*hv_MinIndex12Mask;
      }
      hv_MinIndex34Masked.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MinIndex34Masked = hv_MinIndex34*hv_MinIndex34Mask;
      }
      hv_MinIndex1234.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MinIndex1234 = hv_MinIndex12Masked+hv_MinIndex34Masked;
      }
      //
      //Using the final indices, we can create a mask for each of the angle tuples.
      hv_NewPhi1Masked.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NewPhi1Masked = (hv_MinIndex1234.TupleEqualElem(
          1))*hv_NewPhi1;
      }
      hv_NewPhi2Masked.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NewPhi2Masked = (hv_MinIndex1234.TupleEqualElem(
          2))*hv_NewPhi2;
      }
      hv_NewPhi3Masked.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NewPhi3Masked = (hv_MinIndex1234.TupleEqualElem(
          3))*hv_NewPhi3;
      }
      hv_NewPhi4Masked.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NewPhi4Masked = (hv_MinIndex1234.TupleEqualElem(
          4))*hv_NewPhi4;
      }
      hv_NewPhi.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NewPhi = ((hv_NewPhi1Masked+hv_NewPhi2Masked)+hv_NewPhi3Masked)+hv_NewPhi4Masked;
      }
      //In case the correct angle is the angle returned by smallest_rectangle2 + 90 or
      //+ 270 degrees, we need to swap length1 and length2.
      hv_SwapMask.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_SwapMask = (hv_MinIndex1234.TupleEqualElem(
          2))+(hv_MinIndex1234.TupleEqualElem(4));
      }
      hv_SwapMaskInverted.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_SwapMaskInverted = 1-hv_SwapMask;
      }
      hv_Length1Tmp.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Length1Tmp = hv_NewLength1*hv_SwapMask;
      }
      hv_Length2Tmp.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Length2Tmp = hv_NewLength2*hv_SwapMask;
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_NewLength1 = (hv_NewLength1*hv_SwapMaskInverted)+hv_Length2Tmp;
      hv_NewLength1.Dispose();
      hv_NewLength1 = ExpTmpLocalVar_NewLength1;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_NewLength2 = (hv_NewLength2*hv_SwapMaskInverted)+hv_Length1Tmp;
      hv_NewLength2.Dispose();
      hv_NewLength2 = ExpTmpLocalVar_NewLength2;
      }
      }
      //
      ho_Rectangle2XLD.Dispose();
      ho_Rectangle2XLDSheared.Dispose();

      hv_HomMat2DIdentity.Dispose();
      hv_HomMat2DScale.Dispose();
      hv_NewPhi1.Dispose();
      hv_NewPhi2.Dispose();
      hv_NewPhi3.Dispose();
      hv_NewPhi4.Dispose();
      hv_Pi.Dispose();
      hv_MaskPhi2.Dispose();
      hv_MaskPhi3.Dispose();
      hv_MaskPhi4.Dispose();
      hv_Diff1.Dispose();
      hv_Diff2.Dispose();
      hv_Diff3.Dispose();
      hv_Diff4.Dispose();
      hv_MinDiff12.Dispose();
      hv_MinIndex12.Dispose();
      hv_MinDiff34.Dispose();
      hv_MinIndex34.Dispose();
      hv_MinDiff1234.Dispose();
      hv_MinIndex12Mask.Dispose();
      hv_MinIndex34Mask.Dispose();
      hv_MinIndex12Masked.Dispose();
      hv_MinIndex34Masked.Dispose();
      hv_MinIndex1234.Dispose();
      hv_NewPhi1Masked.Dispose();
      hv_NewPhi2Masked.Dispose();
      hv_NewPhi3Masked.Dispose();
      hv_NewPhi4Masked.Dispose();
      hv_SwapMask.Dispose();
      hv_SwapMaskInverted.Dispose();
      hv_Length1Tmp.Dispose();
      hv_Length2Tmp.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Rectangle2XLD.Dispose();
      ho_Rectangle2XLDSheared.Dispose();

      hv_HomMat2DIdentity.Dispose();
      hv_HomMat2DScale.Dispose();
      hv_NewPhi1.Dispose();
      hv_NewPhi2.Dispose();
      hv_NewPhi3.Dispose();
      hv_NewPhi4.Dispose();
      hv_Pi.Dispose();
      hv_MaskPhi2.Dispose();
      hv_MaskPhi3.Dispose();
      hv_MaskPhi4.Dispose();
      hv_Diff1.Dispose();
      hv_Diff2.Dispose();
      hv_Diff3.Dispose();
      hv_Diff4.Dispose();
      hv_MinDiff12.Dispose();
      hv_MinIndex12.Dispose();
      hv_MinDiff34.Dispose();
      hv_MinIndex34.Dispose();
      hv_MinDiff1234.Dispose();
      hv_MinIndex12Mask.Dispose();
      hv_MinIndex34Mask.Dispose();
      hv_MinIndex12Masked.Dispose();
      hv_MinIndex34Masked.Dispose();
      hv_MinIndex1234.Dispose();
      hv_NewPhi1Masked.Dispose();
      hv_NewPhi2Masked.Dispose();
      hv_NewPhi3Masked.Dispose();
      hv_NewPhi4Masked.Dispose();
      hv_SwapMask.Dispose();
      hv_SwapMaskInverted.Dispose();
      hv_Length1Tmp.Dispose();
      hv_Length2Tmp.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Object Detection
  // Short Description: This procedure suggests the minimum and maximum level as well as the number of anchor subscales for an object detection model. 
  public void select_dl_detection_levels (HTuple hv_Areas, HTuple hv_MinLevel, HTuple hv_MaxLevel, 
      HTuple hv_AnchorNumSubscales, out HTuple hv_MinLevelToUse, out HTuple hv_MaxLevelToUse, 
      out HTuple hv_AnchorNumSubscalesToUse)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_GoodIoU = new HTuple(), hv_GoodIoURatio = new HTuple();
    HTuple hv_AnchorScale = new HTuple(), hv_LevelScales = new HTuple();
    HTuple hv_LevelHalfStrides = new HTuple(), hv_LevelHalfStridesSq = new HTuple();
    HTuple hv_GTBWidths = new HTuple(), hv_Subscales = new HTuple();
    HTuple hv_SubscaleFactors = new HTuple(), hv_SubLevelWidths = new HTuple();
    HTuple hv_Lvl = new HTuple(), hv_AnchorWidths = new HTuple();
    HTuple hv_SubLevelAreas = new HTuple(), hv_Cs_1 = new HTuple();
    HTuple hv_Cs_2 = new HTuple(), hv_C_1 = new HTuple(), hv_C_2 = new HTuple();
    HTuple hv_SmallWidth = new HTuple(), hv_SubLevelWidthMinusC1 = new HTuple();
    HTuple hv_LargeWidth = new HTuple(), hv_CheckResult = new HTuple();
    HTuple hv_MinSmallWidth = new HTuple(), hv_Sublvl = new HTuple();
    HTuple hv_ZeroIndices = new HTuple(), hv_MinWidth = new HTuple();
    HTuple hv_MinSubLevel = new HTuple(), hv_SmallWidthDistances = new HTuple();
    HTuple hv_MaxWidth = new HTuple(), hv_MaxSubLevel = new HTuple();
    HTuple hv_LargeWidthDistances = new HTuple();
    // Initialize local and output iconic variables 
    hv_MinLevelToUse = new HTuple();
    hv_MaxLevelToUse = new HTuple();
    hv_AnchorNumSubscalesToUse = new HTuple();
    try
    {
      //This procedure suggests levels and number of anchor subscales
      //suiting best for a deep-learning-based object detection model
      //based on the input Areas.
      //
      //Check that the input Areas has at least one value.
      if ((int)(new HTuple((new HTuple(hv_Areas.TupleLength())).TupleLess(1))) != 0)
      {
        throw new HalconException("No bounding box areas to process.");
      }
      //
      //Try to find the minimum number of subscales required to get
      //a good IoU for all bounding box sizes.
      //
      //As long as the IoU is above the following threshold value, it is
      //considered to be good.
      hv_GoodIoU.Dispose();
      hv_GoodIoU = 0.5;
      //Minimum ratio of all ground truth bounding boxes which need to have
      //the good IoU stated above.
      hv_GoodIoURatio.Dispose();
      hv_GoodIoURatio = 0.99;
      //
      //Scaling constants and strides for anchor boxes of different levels.
      hv_AnchorScale.Dispose();
      hv_AnchorScale = 4.0;
      hv_LevelScales.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_LevelScales = hv_AnchorScale*((new HTuple(2.0)).TuplePow(
          HTuple.TupleGenSequence(hv_MinLevel,hv_MaxLevel,1)));
      }
      hv_LevelHalfStrides.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_LevelHalfStrides = ((new HTuple(2.0)).TuplePow(
          HTuple.TupleGenSequence(hv_MinLevel,hv_MaxLevel,1)))/2;
      }
      hv_LevelHalfStridesSq.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_LevelHalfStridesSq = hv_LevelHalfStrides*hv_LevelHalfStrides;
      }
      //
      //Ground truth bounding box widths.
      hv_GTBWidths.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_GTBWidths = hv_Areas.TupleSqrt()
          ;
      }
      //
      //Loop over the subscales (starting at 1) until a value is found for
      //which all IoUs are good or the upper bound (given by AnchorNumSubscales)
      //is reached.
      hv_AnchorNumSubscalesToUse.Dispose();
      hv_AnchorNumSubscalesToUse = new HTuple(hv_AnchorNumSubscales);
      HTuple end_val32 = hv_AnchorNumSubscales;
      HTuple step_val32 = 1;
      for (hv_Subscales=1; hv_Subscales.Continue(end_val32, step_val32); hv_Subscales = hv_Subscales.TupleAdd(step_val32))
      {
        //Calculate scaling factors for the subscales.
        hv_SubscaleFactors.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SubscaleFactors = (new HTuple(2)).TuplePow(
            HTuple.TupleGenSequence(0,hv_Subscales-1,1)/(hv_Subscales.TupleReal()
            ));
        }
        //Calculate the widths of each sublevel (level + subscales).
        hv_SubLevelWidths.Dispose();
        hv_SubLevelWidths = new HTuple();
        HTuple end_val37 = hv_MaxLevel;
        HTuple step_val37 = 1;
        for (hv_Lvl=hv_MinLevel; hv_Lvl.Continue(end_val37, step_val37); hv_Lvl = hv_Lvl.TupleAdd(step_val37))
        {
          hv_AnchorWidths.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_AnchorWidths = hv_SubscaleFactors*(hv_LevelScales.TupleSelect(
              hv_Lvl-hv_MinLevel));
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_SubLevelWidths = hv_SubLevelWidths.TupleConcat(
              hv_AnchorWidths);
          hv_SubLevelWidths.Dispose();
          hv_SubLevelWidths = ExpTmpLocalVar_SubLevelWidths;
          }
          }
        }
        hv_SubLevelAreas.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SubLevelAreas = hv_SubLevelWidths*hv_SubLevelWidths;
        }
        //
        //For each sublevel one can determine the range of possible bounding
        //box widths leading to a good IoU. Therewith we can check, if every
        //ground truth bounding box width is between a minimum and a maximum
        //value.
        //
        //The minimum and maximum can be derived from the formula of the
        //IoU. To calculate the IoU, we need to consider the stride
        //length of the level. With a stride of d, the worst case
        //(minimum overlap) between the ground truth bounding box and
        //anchor bounding box looks like follows
        //
        //       ---------
        //      |         |< d/2
        //      |    -----|--------
        //      |   |     |        |
        //      |   |     |        |
        //       ---------         |
        //       ^  |              |
        //      d/2 |              |
        //          |              |
        //           --------------
        //
        //With X = width of the smaller bounding box and Y = width of the larger
        //bounding box, r = GoodIoU, the IoU is calculated by
        //
        //            X^2 - 2*d/2*X + d^2/4
        //         -------------------------- >= r
        //           Y^2 + (2*d/2*X - d^2/4)
        //
        //              X^2 - d*X + d^2/4
        //         -------------------------- >= r
        //              Y^2 + d*X - d^2/4
        //
        //                  X^2 - d*X + d^2/4 >= r * (Y^2 + d*X - d^2/4)
        //      X^2 - (1+r)*d*X + (1+r)*d^2/4 >= r*Y^2
        //(X - (1+r)*d/2)^2 - (r^2 + r)*d^2/4 >= r*Y^2
        //
        //By substituting the constants
        //C_1 = (1+r)*d/2
        //C_2 = (r^2 + r)*d^2/4,
        //we get
        //(X - C_1)^2 - C_2 >= r*Y^2
        //
        hv_Cs_1.Dispose();
        hv_Cs_1 = new HTuple();
        hv_Cs_2.Dispose();
        hv_Cs_2 = new HTuple();
        HTuple end_val88 = hv_MaxLevel;
        HTuple step_val88 = 1;
        for (hv_Lvl=hv_MinLevel; hv_Lvl.Continue(end_val88, step_val88); hv_Lvl = hv_Lvl.TupleAdd(step_val88))
        {
          hv_C_1.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_C_1 = (1+hv_GoodIoU)*(hv_LevelHalfStrides.TupleSelect(
              hv_Lvl-hv_MinLevel));
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_Cs_1 = hv_Cs_1.TupleConcat(
              HTuple.TupleGenConst(hv_Subscales,hv_C_1));
          hv_Cs_1.Dispose();
          hv_Cs_1 = ExpTmpLocalVar_Cs_1;
          }
          }
          hv_C_2.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_C_2 = ((hv_GoodIoU.TuplePow(
              2))+hv_GoodIoU)*(hv_LevelHalfStridesSq.TupleSelect(hv_Lvl-hv_MinLevel));
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_Cs_2 = hv_Cs_2.TupleConcat(
              HTuple.TupleGenConst(hv_Subscales,hv_C_2));
          hv_Cs_2.Dispose();
          hv_Cs_2 = ExpTmpLocalVar_Cs_2;
          }
          }
        }
        //
        //In case the ground truth bounding box is smaller than the anchor bounding box
        //=> ground truth bounding box width = X:
        //X >= sqrt(r*Y^2 + C_2) + C_1
        hv_SmallWidth.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SmallWidth = ((((hv_GoodIoU*hv_SubLevelAreas)+hv_Cs_2)).TupleSqrt()
            )+hv_Cs_1;
        }
        //
        //In case the ground truth boudning box is larger than the anchor bounding box
        //=> ground truth bounding box width = Y:
        //Y <= sqrt(((X - C_1)^2 - C_2) * 1/r)
        hv_SubLevelWidthMinusC1.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SubLevelWidthMinusC1 = hv_SubLevelWidths-hv_Cs_1;
        }
        hv_LargeWidth.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_LargeWidth = ((((hv_SubLevelWidthMinusC1*hv_SubLevelWidthMinusC1)-hv_Cs_2)/hv_GoodIoU)).TupleSqrt()
            ;
        }
        //
        //Check whether all ground truth bounding box widths lie within the above
        //calculated minimum and maximum widths of one sublevel.
        hv_CheckResult.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_CheckResult = HTuple.TupleGenConst(
            new HTuple(hv_GTBWidths.TupleLength()),0);
        }
        //Set CheckResult for ground truth bounding boxes smaller than the minimum
        //to 1 since these do not fit regardless of anchor_num_subscales.
        hv_MinSmallWidth.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MinSmallWidth = hv_SmallWidth.TupleMin()
            ;
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_CheckResult = hv_CheckResult+(hv_GTBWidths.TupleLessElem(
            hv_MinSmallWidth));
        hv_CheckResult.Dispose();
        hv_CheckResult = ExpTmpLocalVar_CheckResult;
        }
        }
        //Check for each sublevel whether the ground truth widths fit in.
        for (hv_Sublvl=0; (int)hv_Sublvl<=(int)((new HTuple(hv_SubLevelWidths.TupleLength()
            ))-1); hv_Sublvl = (int)hv_Sublvl + 1)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_CheckResult = hv_CheckResult+(((hv_GTBWidths.TupleGreaterEqualElem(
              hv_SmallWidth.TupleSelect(hv_Sublvl)))).TupleAnd(hv_GTBWidths.TupleLessEqualElem(
              hv_LargeWidth.TupleSelect(hv_Sublvl))));
          hv_CheckResult.Dispose();
          hv_CheckResult = ExpTmpLocalVar_CheckResult;
          }
          }
        }
        //
        hv_ZeroIndices.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ZeroIndices = hv_CheckResult.TupleFind(
            0);
        }
        //In case there is only an insignificant number of ground truth widths which
        //do not fit in any of the sublevels, the current number of subscales is chosen.
        if ((int)((new HTuple(hv_ZeroIndices.TupleEqual(-1))).TupleOr(new HTuple((new HTuple(hv_ZeroIndices.TupleLength()
            )).TupleLess((1-hv_GoodIoURatio)*(new HTuple(hv_GTBWidths.TupleLength()
            )))))) != 0)
        {
          hv_AnchorNumSubscalesToUse.Dispose();
          hv_AnchorNumSubscalesToUse = new HTuple(hv_Subscales);
          break;
        }
      }
      //
      //Get minimum ground truth bounding box width.
      hv_MinWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MinWidth = hv_GTBWidths.TupleMin()
          ;
      }
      //Get last sublevel where the smallest object fits in.
      hv_MinSubLevel.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MinSubLevel = (new HTuple(((hv_SmallWidth.TupleLessEqualElem(
          hv_MinWidth))).TupleAnd(hv_LargeWidth.TupleGreaterEqualElem(hv_MinWidth)))).TupleFindLast(
          1);
      }
      //If no sublevel could be found, take the sublevel with the SmallWidth
      //closest to MinWidth.
      if ((int)(new HTuple(hv_MinSubLevel.TupleEqual(-1))) != 0)
      {
        hv_SmallWidthDistances.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SmallWidthDistances = ((hv_SmallWidth-hv_MinWidth)).TupleAbs()
            ;
        }
        hv_MinSubLevel.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MinSubLevel = hv_SmallWidthDistances.TupleFindLast(
            hv_SmallWidthDistances.TupleMin());
        }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_MinSubLevel = (((new HTuple(0)).TupleConcat(
          hv_MinSubLevel))).TupleMax();
      hv_MinSubLevel.Dispose();
      hv_MinSubLevel = ExpTmpLocalVar_MinSubLevel;
      }
      }
      //
      //Get maximum ground truth bounding box width.
      hv_MaxWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MaxWidth = hv_GTBWidths.TupleMax()
          ;
      }
      //Get first sublevel where the largest object fits in.
      hv_MaxSubLevel.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MaxSubLevel = (new HTuple(((hv_SmallWidth.TupleLessEqualElem(
          hv_MaxWidth))).TupleAnd(hv_LargeWidth.TupleGreaterEqualElem(hv_MaxWidth)))).TupleFindFirst(
          1);
      }
      //If no sublevel could be found, take the sublevel with the LargeWidth
      //closest to MaxWidth.
      if ((int)(new HTuple(hv_MaxSubLevel.TupleEqual(-1))) != 0)
      {
        hv_LargeWidthDistances.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_LargeWidthDistances = ((hv_LargeWidth-hv_MaxWidth)).TupleAbs()
            ;
        }
        hv_MaxSubLevel.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_MaxSubLevel = hv_LargeWidthDistances.TupleFindFirst(
            hv_LargeWidthDistances.TupleMin());
        }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_MaxSubLevel = ((hv_MinSubLevel.TupleConcat(
          hv_MaxSubLevel))).TupleMax();
      hv_MaxSubLevel.Dispose();
      hv_MaxSubLevel = ExpTmpLocalVar_MaxSubLevel;
      }
      }
      //
      //Get the levels from the sublevels.
      hv_MinLevelToUse.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MinLevelToUse = (hv_MinSubLevel/hv_AnchorNumSubscalesToUse)+hv_MinLevel;
      }
      hv_MaxLevelToUse.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_MaxLevelToUse = (hv_MaxSubLevel/hv_AnchorNumSubscalesToUse)+hv_MinLevel;
      }
      //

      hv_GoodIoU.Dispose();
      hv_GoodIoURatio.Dispose();
      hv_AnchorScale.Dispose();
      hv_LevelScales.Dispose();
      hv_LevelHalfStrides.Dispose();
      hv_LevelHalfStridesSq.Dispose();
      hv_GTBWidths.Dispose();
      hv_Subscales.Dispose();
      hv_SubscaleFactors.Dispose();
      hv_SubLevelWidths.Dispose();
      hv_Lvl.Dispose();
      hv_AnchorWidths.Dispose();
      hv_SubLevelAreas.Dispose();
      hv_Cs_1.Dispose();
      hv_Cs_2.Dispose();
      hv_C_1.Dispose();
      hv_C_2.Dispose();
      hv_SmallWidth.Dispose();
      hv_SubLevelWidthMinusC1.Dispose();
      hv_LargeWidth.Dispose();
      hv_CheckResult.Dispose();
      hv_MinSmallWidth.Dispose();
      hv_Sublvl.Dispose();
      hv_ZeroIndices.Dispose();
      hv_MinWidth.Dispose();
      hv_MinSubLevel.Dispose();
      hv_SmallWidthDistances.Dispose();
      hv_MaxWidth.Dispose();
      hv_MaxSubLevel.Dispose();
      hv_LargeWidthDistances.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_GoodIoU.Dispose();
      hv_GoodIoURatio.Dispose();
      hv_AnchorScale.Dispose();
      hv_LevelScales.Dispose();
      hv_LevelHalfStrides.Dispose();
      hv_LevelHalfStridesSq.Dispose();
      hv_GTBWidths.Dispose();
      hv_Subscales.Dispose();
      hv_SubscaleFactors.Dispose();
      hv_SubLevelWidths.Dispose();
      hv_Lvl.Dispose();
      hv_AnchorWidths.Dispose();
      hv_SubLevelAreas.Dispose();
      hv_Cs_1.Dispose();
      hv_Cs_2.Dispose();
      hv_C_1.Dispose();
      hv_C_2.Dispose();
      hv_SmallWidth.Dispose();
      hv_SubLevelWidthMinusC1.Dispose();
      hv_LargeWidth.Dispose();
      hv_CheckResult.Dispose();
      hv_MinSmallWidth.Dispose();
      hv_Sublvl.Dispose();
      hv_ZeroIndices.Dispose();
      hv_MinWidth.Dispose();
      hv_MinSubLevel.Dispose();
      hv_SmallWidthDistances.Dispose();
      hv_MaxWidth.Dispose();
      hv_MaxSubLevel.Dispose();
      hv_LargeWidthDistances.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Graphics / Text
  // Short Description: Set font independent of OS 
  public void set_display_font (HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font, 
      HTuple hv_Bold, HTuple hv_Slant)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_OS = new HTuple(), hv_Fonts = new HTuple();
    HTuple hv_Style = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_AvailableFonts = new HTuple(), hv_Fdx = new HTuple();
    HTuple hv_Indices = new HTuple();
    HTuple   hv_Font_COPY_INP_TMP = new HTuple(hv_Font);
    HTuple   hv_Size_COPY_INP_TMP = new HTuple(hv_Size);

    // Initialize local and output iconic variables 
    try
    {
      //This procedure sets the text font of the current window with
      //the specified attributes.
      //
      //Input parameters:
      //WindowHandle: The graphics window for which the font will be set
      //Size: The font size. If Size=-1, the default of 16 is used.
      //Bold: If set to 'true', a bold font is used
      //Slant: If set to 'true', a slanted font is used
      //
      hv_OS.Dispose();
      HOperatorSet.GetSystem("operating_system", out hv_OS);
      if ((int)((new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
          new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(-1)))) != 0)
      {
        hv_Size_COPY_INP_TMP.Dispose();
        hv_Size_COPY_INP_TMP = 16;
      }
      if ((int)(new HTuple(((hv_OS.TupleSubstr(0,2))).TupleEqual("Win"))) != 0)
      {
        //Restore previous behaviour
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Size = ((1.13677*hv_Size_COPY_INP_TMP)).TupleInt()
            ;
        hv_Size_COPY_INP_TMP.Dispose();
        hv_Size_COPY_INP_TMP = ExpTmpLocalVar_Size;
        }
        }
      }
      else
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Size = hv_Size_COPY_INP_TMP.TupleInt()
            ;
        hv_Size_COPY_INP_TMP.Dispose();
        hv_Size_COPY_INP_TMP = ExpTmpLocalVar_Size;
        }
        }
      }
      if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("Courier"))) != 0)
      {
        hv_Fonts.Dispose();
        hv_Fonts = new HTuple();
        hv_Fonts[0] = "Courier";
        hv_Fonts[1] = "Courier 10 Pitch";
        hv_Fonts[2] = "Courier New";
        hv_Fonts[3] = "CourierNew";
        hv_Fonts[4] = "Liberation Mono";
      }
      else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("mono"))) != 0)
      {
        hv_Fonts.Dispose();
        hv_Fonts = new HTuple();
        hv_Fonts[0] = "Consolas";
        hv_Fonts[1] = "Menlo";
        hv_Fonts[2] = "Courier";
        hv_Fonts[3] = "Courier 10 Pitch";
        hv_Fonts[4] = "FreeMono";
        hv_Fonts[5] = "Liberation Mono";
      }
      else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("sans"))) != 0)
      {
        hv_Fonts.Dispose();
        hv_Fonts = new HTuple();
        hv_Fonts[0] = "Luxi Sans";
        hv_Fonts[1] = "DejaVu Sans";
        hv_Fonts[2] = "FreeSans";
        hv_Fonts[3] = "Arial";
        hv_Fonts[4] = "Liberation Sans";
      }
      else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("serif"))) != 0)
      {
        hv_Fonts.Dispose();
        hv_Fonts = new HTuple();
        hv_Fonts[0] = "Times New Roman";
        hv_Fonts[1] = "Luxi Serif";
        hv_Fonts[2] = "DejaVu Serif";
        hv_Fonts[3] = "FreeSerif";
        hv_Fonts[4] = "Utopia";
        hv_Fonts[5] = "Liberation Serif";
      }
      else
      {
        hv_Fonts.Dispose();
        hv_Fonts = new HTuple(hv_Font_COPY_INP_TMP);
      }
      hv_Style.Dispose();
      hv_Style = "";
      if ((int)(new HTuple(hv_Bold.TupleEqual("true"))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Style = hv_Style+"Bold";
        hv_Style.Dispose();
        hv_Style = ExpTmpLocalVar_Style;
        }
        }
      }
      else if ((int)(new HTuple(hv_Bold.TupleNotEqual("false"))) != 0)
      {
        hv_Exception.Dispose();
        hv_Exception = "Wrong value of control parameter Bold";
        throw new HalconException(hv_Exception);
      }
      if ((int)(new HTuple(hv_Slant.TupleEqual("true"))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Style = hv_Style+"Italic";
        hv_Style.Dispose();
        hv_Style = ExpTmpLocalVar_Style;
        }
        }
      }
      else if ((int)(new HTuple(hv_Slant.TupleNotEqual("false"))) != 0)
      {
        hv_Exception.Dispose();
        hv_Exception = "Wrong value of control parameter Slant";
        throw new HalconException(hv_Exception);
      }
      if ((int)(new HTuple(hv_Style.TupleEqual(""))) != 0)
      {
        hv_Style.Dispose();
        hv_Style = "Normal";
      }
      hv_AvailableFonts.Dispose();
      HOperatorSet.QueryFont(hv_WindowHandle, out hv_AvailableFonts);
      hv_Font_COPY_INP_TMP.Dispose();
      hv_Font_COPY_INP_TMP = "";
      for (hv_Fdx=0; (int)hv_Fdx<=(int)((new HTuple(hv_Fonts.TupleLength()))-1); hv_Fdx = (int)hv_Fdx + 1)
      {
        hv_Indices.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Indices = hv_AvailableFonts.TupleFind(
            hv_Fonts.TupleSelect(hv_Fdx));
        }
        if ((int)(new HTuple((new HTuple(hv_Indices.TupleLength())).TupleGreater(
            0))) != 0)
        {
          if ((int)(new HTuple(((hv_Indices.TupleSelect(0))).TupleGreaterEqual(0))) != 0)
          {
            hv_Font_COPY_INP_TMP.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Font_COPY_INP_TMP = hv_Fonts.TupleSelect(
                hv_Fdx);
            }
            break;
          }
        }
      }
      if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual(""))) != 0)
      {
        throw new HalconException("Wrong value of control parameter Font");
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Font = (((hv_Font_COPY_INP_TMP+"-")+hv_Style)+"-")+hv_Size_COPY_INP_TMP;
      hv_Font_COPY_INP_TMP.Dispose();
      hv_Font_COPY_INP_TMP = ExpTmpLocalVar_Font;
      }
      }
      HOperatorSet.SetFont(hv_WindowHandle, hv_Font_COPY_INP_TMP);

      hv_Font_COPY_INP_TMP.Dispose();
      hv_Size_COPY_INP_TMP.Dispose();
      hv_OS.Dispose();
      hv_Fonts.Dispose();
      hv_Style.Dispose();
      hv_Exception.Dispose();
      hv_AvailableFonts.Dispose();
      hv_Fdx.Dispose();
      hv_Indices.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_Font_COPY_INP_TMP.Dispose();
      hv_Size_COPY_INP_TMP.Dispose();
      hv_OS.Dispose();
      hv_Fonts.Dispose();
      hv_Style.Dispose();
      hv_Exception.Dispose();
      hv_AvailableFonts.Dispose();
      hv_Fdx.Dispose();
      hv_Indices.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: Split the samples into training, validation, and test subsets. 
  public void split_dl_dataset (HTuple hv_DLDataset, HTuple hv_TrainingPercent, HTuple hv_ValidationPercent, 
      HTuple hv_GenParam)
  {



    // Local iconic variables 

    HObject ho_SegmImage=null;

    // Local control variables 

    HTuple hv_OverwriteSplit = new HTuple(), hv_ModelType = new HTuple();
    HTuple hv_SplitNames = new HTuple(), hv_GenParamName = new HTuple();
    HTuple hv_GenParamIndex = new HTuple(), hv_Type = new HTuple();
    HTuple hv_DLSamples = new HTuple(), hv_DLSample = new HTuple();
    HTuple hv_AnomalyDetectionLabelExists = new HTuple(), hv_BBoxLabelIdExists = new HTuple();
    HTuple hv_ImageLabelIdExists = new HTuple(), hv_SegmFileExists = new HTuple();
    HTuple hv_ClassIDs = new HTuple(), hv_ClassNames = new HTuple();
    HTuple hv_ClassIDToClassIndex = new HTuple(), hv_TrainingRatio = new HTuple();
    HTuple hv_ValidationRatio = new HTuple(), hv_SplitRatios = new HTuple();
    HTuple hv_SplitRatiosInvSortIndices = new HTuple(), hv_SplitKeys = new HTuple();
    HTuple hv_IndexSample = new HTuple(), hv_SplitExists = new HTuple();
    HTuple hv_SampleSplit = new HTuple(), hv_NotYetSplit = new HTuple();
    HTuple hv_ImageIDsPerClass = new HTuple(), hv_ClassIndex = new HTuple();
    HTuple hv_NumImagesPerClass = new HTuple(), hv_ImageIDList = new HTuple();
    HTuple hv_ImageID = new HTuple(), hv_AnomalyLabel = new HTuple();
    HTuple hv_Labels = new HTuple(), hv_ImageLabelID = new HTuple();
    HTuple hv_BboxLabels = new HTuple(), hv_SegmDir = new HTuple();
    HTuple hv_SegmFileName = new HTuple(), hv_AbsoluteHisto = new HTuple();
    HTuple hv_LabelIndices = new HTuple(), hv_Index = new HTuple();
    HTuple hv_ImgIDsClass = new HTuple(), hv_SplitImageIDs = new HTuple();
    HTuple hv_AssignedImageIDs = new HTuple(), hv_ClassSortIndices = new HTuple();
    HTuple hv_ImageIDsClass = new HTuple(), hv_ImageIDsClassToBeAssigned = new HTuple();
    HTuple hv_SplitIndex = new HTuple(), hv_NumToBeAssignedToThisSplit = new HTuple();
    HTuple hv_AssignedImageIDsToThisSplit = new HTuple(), hv_NumAlreadyAssignedToThisSplit = new HTuple();
    HTuple hv_NumStillToBeAssigned = new HTuple(), hv_ImageIndex = new HTuple();
    HTuple hv_Rand = new HTuple(), hv_RatioIndex = new HTuple();
    HTuple hv_CurrentSplitIndex = new HTuple(), hv_CurrentSplitRatio = new HTuple();
    HTuple hv_ImageIDsWithoutLabel = new HTuple(), hv_NumImageIDsWithoutLabel = new HTuple();
    HTuple hv_NumToBeAssigned = new HTuple(), hv_MaxRatioIndex = new HTuple();
    HTuple hv_SplitNameIndex = new HTuple(), hv_SplitName = new HTuple();
    HTuple hv_SplitIDs = new HTuple(), hv_SplitIDIndex = new HTuple();
    HTuple hv_SampleSplitIDs = new HTuple(), hv_DLSampleIndex = new HTuple();
    HTuple hv_ErrorDict = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_SegmImage);
    try
    {
      //
      //This procedure divides the samples in DLDataset
      //into three disjoint subsets: train, validation, and test.
      //The number of samples in each subset is defined
      //by the given percentages TrainingPercent and ValidationPercent.
      //As a result, every sample has a new key named 'split'
      //with an associated value 'train', 'validation', or 'test'.
      //Thereby the classes of every image are taken
      //into consideration, in order to avoid accidental predominance
      //of certain classes in one of the subsets. In the case of a
      //dataset used for anomaly detection, all images of type 'nok'
      //are sorted into the 'test' split.
      //
      //Check input data.
      if ((int)(new HTuple(hv_TrainingPercent.TupleLess(0))) != 0)
      {
        throw new HalconException("TrainingPercent must not be smaller than zero.");
      }
      if ((int)(new HTuple(hv_ValidationPercent.TupleLess(0))) != 0)
      {
        throw new HalconException("ValidationPercent must not be smaller than zero.");
      }
      if ((int)(new HTuple(((hv_TrainingPercent+hv_ValidationPercent)).TupleGreater(
          100))) != 0)
      {
        throw new HalconException("The sum of TrainingPercent and ValidationPercent must not be greater than 100.");
      }
      //
      //** Set the default values ***
      //
      //Overwrite an existing split?
      hv_OverwriteSplit.Dispose();
      hv_OverwriteSplit = 0;
      //Initialize model_type of the DLDataset.
      hv_ModelType.Dispose();
      hv_ModelType = "";
      //Names for split subsets.
      hv_SplitNames.Dispose();
      hv_SplitNames = new HTuple();
      hv_SplitNames[0] = "train";
      hv_SplitNames[1] = "validation";
      hv_SplitNames[2] = "test";
      //
      //Get input for generic parameters.
      if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
      {
        hv_GenParamName.Dispose();
        HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_GenParamName);
        for (hv_GenParamIndex=0; (int)hv_GenParamIndex<=(int)((new HTuple(hv_GenParamName.TupleLength()
            ))-1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
        {
          if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
              "overwrite_split"))) != 0)
          {
            hv_OverwriteSplit.Dispose();
            HOperatorSet.GetDictTuple(hv_GenParam, "overwrite_split", out hv_OverwriteSplit);
            hv_Type.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Type = hv_OverwriteSplit.TupleType()
                ;
            }
            if ((int)((new HTuple(hv_Type.TupleEqual(4))).TupleAnd(new HTuple(hv_OverwriteSplit.TupleEqual(
                "true")))) != 0)
            {
              hv_OverwriteSplit.Dispose();
              hv_OverwriteSplit = 1;
            }
            if ((int)((new HTuple(hv_Type.TupleEqual(4))).TupleAnd(new HTuple(hv_OverwriteSplit.TupleEqual(
                "false")))) != 0)
            {
              hv_OverwriteSplit.Dispose();
              hv_OverwriteSplit = 0;
            }
          }
          else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
              "model_type"))) != 0)
          {
            hv_ModelType.Dispose();
            HOperatorSet.GetDictTuple(hv_GenParam, "model_type", out hv_ModelType);
          }
          else
          {
            throw new HalconException("Unknown GenParam entry: "+(hv_GenParamName.TupleSelect(
                hv_GenParamIndex)));
          }
        }
      }
      //
      //Try to guess the ModelType if not set by GenParam.
      if ((int)(new HTuple(hv_ModelType.TupleEqual(""))) != 0)
      {
        hv_DLSamples.Dispose();
        HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLSamples);
        hv_DLSample.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DLSample = hv_DLSamples.TupleSelect(
            0);
        }
        //Check for relevant keys.
        hv_AnomalyDetectionLabelExists.Dispose();
        HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "anomaly_label", out hv_AnomalyDetectionLabelExists);
        hv_BBoxLabelIdExists.Dispose();
        HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "bbox_label_id", out hv_BBoxLabelIdExists);
        hv_ImageLabelIdExists.Dispose();
        HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "image_label_id", out hv_ImageLabelIdExists);
        hv_SegmFileExists.Dispose();
        HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "segmentation_file_name", 
            out hv_SegmFileExists);
        //
        if ((int)(hv_AnomalyDetectionLabelExists) != 0)
        {
          hv_ModelType.Dispose();
          hv_ModelType = "anomaly_detection";
        }
        else if ((int)(hv_ImageLabelIdExists) != 0)
        {
          hv_ModelType.Dispose();
          hv_ModelType = "classification";
        }
        else if ((int)(hv_BBoxLabelIdExists) != 0)
        {
          hv_ModelType.Dispose();
          hv_ModelType = "detection";
        }
        else if ((int)(hv_SegmFileExists) != 0)
        {
          hv_ModelType.Dispose();
          hv_ModelType = "segmentation";
        }
        else
        {
          throw new HalconException("Parameter 'model_type' cannot be determined.");
        }
      }
      //
      //Get data from DLDataset.
      if ((int)(new HTuple(hv_ModelType.TupleNotEqual("anomaly_detection"))) != 0)
      {
        hv_ClassIDs.Dispose();
        HOperatorSet.GetDictTuple(hv_DLDataset, "class_ids", out hv_ClassIDs);
        hv_ClassNames.Dispose();
        HOperatorSet.GetDictTuple(hv_DLDataset, "class_names", out hv_ClassNames);
      }
      else
      {
        hv_ClassIDs.Dispose();
        hv_ClassIDs = new HTuple();
        hv_ClassIDs[0] = 0;
        hv_ClassIDs[1] = 1;
        hv_ClassNames.Dispose();
        hv_ClassNames = new HTuple();
        hv_ClassNames[0] = "ok";
        hv_ClassNames[1] = "nok";
      }
      hv_ClassIDToClassIndex.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ClassIDToClassIndex = HTuple.TupleGenConst(
          (hv_ClassIDs.TupleMax())+1,-1);
      }
      if (hv_ClassIDToClassIndex == null)
        hv_ClassIDToClassIndex = new HTuple();
      hv_ClassIDToClassIndex[hv_ClassIDs] = HTuple.TupleGenSequence(0,(new HTuple(hv_ClassIDs.TupleLength()
          ))-1,1);
      //
      //Calculate ratios of training and validation datasets.
      hv_TrainingRatio.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TrainingRatio = hv_TrainingPercent*0.01;
      }
      hv_ValidationRatio.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ValidationRatio = hv_ValidationPercent*0.01;
      }
      hv_SplitRatios.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_SplitRatios = new HTuple();
      hv_SplitRatios = hv_SplitRatios.TupleConcat(hv_TrainingRatio, hv_ValidationRatio);
      hv_SplitRatios = hv_SplitRatios.TupleConcat((1.0-hv_TrainingRatio)-hv_ValidationRatio);
      }
      hv_SplitRatiosInvSortIndices.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_SplitRatiosInvSortIndices = (new HTuple(hv_SplitRatios.TupleSortIndex()
          )).TupleInverse();
      }
      //
      //Test whether the dataset is already split.
      hv_SplitKeys.Dispose();
      hv_SplitKeys = new HTuple();
      for (hv_IndexSample=0; (int)hv_IndexSample<=(int)((new HTuple(hv_DLSamples.TupleLength()
          ))-1); hv_IndexSample = (int)hv_IndexSample + 1)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SplitExists.Dispose();
        HOperatorSet.GetDictParam(hv_DLSamples.TupleSelect(hv_IndexSample), "key_exists", 
            "split", out hv_SplitExists);
        }
        if ((int)(hv_SplitExists) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_SampleSplit.Dispose();
          HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_IndexSample), "split", 
              out hv_SampleSplit);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_SplitKeys = hv_SplitKeys.TupleConcat(
              hv_SampleSplit);
          hv_SplitKeys.Dispose();
          hv_SplitKeys = ExpTmpLocalVar_SplitKeys;
          }
          }
        }
      }
      hv_NotYetSplit.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_NotYetSplit = new HTuple(hv_SplitKeys.TupleEqual(
          new HTuple()));
      }
      //
      //Split the dataset if no split is present
      //or split should be overwritten.
      if ((int)(hv_NotYetSplit.TupleOr(hv_OverwriteSplit)) != 0)
      {
        //
        //Initialize a dictionary to collect the IDs
        //of images that contain the class.
        hv_ImageIDsPerClass.Dispose();
        HOperatorSet.CreateDict(out hv_ImageIDsPerClass);
        for (hv_ClassIndex=0; (int)hv_ClassIndex<=(int)((new HTuple(hv_ClassNames.TupleLength()
            ))-1); hv_ClassIndex = (int)hv_ClassIndex + 1)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetDictTuple(hv_ImageIDsPerClass, hv_ClassNames.TupleSelect(
              hv_ClassIndex), new HTuple());
          }
        }
        //
        //Get labels of every sample image
        //and count how many images per class there are.
        //
        hv_NumImagesPerClass.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_NumImagesPerClass = HTuple.TupleGenConst(
            new HTuple(hv_ClassIDs.TupleLength()),0);
        }
        hv_ImageIDList.Dispose();
        hv_ImageIDList = new HTuple();
        for (hv_IndexSample=0; (int)hv_IndexSample<=(int)((new HTuple(hv_DLSamples.TupleLength()
            ))-1); hv_IndexSample = (int)hv_IndexSample + 1)
        {
          hv_DLSample.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_DLSample = hv_DLSamples.TupleSelect(
              hv_IndexSample);
          }
          hv_ImageID.Dispose();
          HOperatorSet.GetDictTuple(hv_DLSample, "image_id", out hv_ImageID);
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_ImageIDList = hv_ImageIDList.TupleConcat(
              hv_ImageID);
          hv_ImageIDList.Dispose();
          hv_ImageIDList = ExpTmpLocalVar_ImageIDList;
          }
          }
          if ((int)(new HTuple(hv_ModelType.TupleEqual("anomaly_detection"))) != 0)
          {
            //Get labels - anomaly detection.
            hv_AnomalyLabel.Dispose();
            HOperatorSet.GetDictTuple(hv_DLSample, "anomaly_label", out hv_AnomalyLabel);
            hv_Labels.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Labels = new HTuple(hv_AnomalyLabel.TupleNotEqual(
                "ok"));
            }
          }
          else if ((int)(new HTuple(hv_ModelType.TupleEqual("classification"))) != 0)
          {
            //Get labels - classification.
            hv_ImageLabelID.Dispose();
            HOperatorSet.GetDictTuple(hv_DLSample, "image_label_id", out hv_ImageLabelID);
            hv_Labels.Dispose();
            hv_Labels = new HTuple(hv_ImageLabelID);
          }
          else if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
          {
            //Get labels - object detection.
            hv_BboxLabels.Dispose();
            HOperatorSet.GetDictTuple(hv_DLSample, "bbox_label_id", out hv_BboxLabels);
            hv_Labels.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Labels = ((hv_BboxLabels.TupleSort()
                )).TupleUniq();
            }
          }
          else if ((int)(new HTuple(hv_ModelType.TupleEqual("segmentation"))) != 0)
          {
            //Get labels - semantic segmentation.
            hv_SegmDir.Dispose();
            HOperatorSet.GetDictTuple(hv_DLDataset, "segmentation_dir", out hv_SegmDir);
            hv_SegmFileName.Dispose();
            HOperatorSet.GetDictTuple(hv_DLSample, "segmentation_file_name", out hv_SegmFileName);
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            ho_SegmImage.Dispose();
            HOperatorSet.ReadImage(out ho_SegmImage, (hv_SegmDir+"/")+hv_SegmFileName);
            }
            //
            hv_AbsoluteHisto.Dispose();
            HOperatorSet.GrayHistoAbs(ho_SegmImage, ho_SegmImage, 1, out hv_AbsoluteHisto);
            hv_Labels.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_Labels = ((hv_AbsoluteHisto.TupleGreaterElem(
                0))).TupleFind(1);
            }
          }
          //
          //Add up images per class.
          hv_LabelIndices.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_LabelIndices = hv_ClassIDToClassIndex.TupleSelect(
              hv_Labels);
          }
          if (hv_NumImagesPerClass == null)
            hv_NumImagesPerClass = new HTuple();
          hv_NumImagesPerClass[hv_LabelIndices] = (hv_NumImagesPerClass.TupleSelect(
              hv_LabelIndices))+1;
          for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_Labels.TupleLength()
              ))-1); hv_Index = (int)hv_Index + 1)
          {
            //Add ImageIDs to ImageIDsPerClass.
            hv_ClassIndex.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ClassIndex = hv_LabelIndices.TupleSelect(
                hv_Index);
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_ImgIDsClass.Dispose();
            HOperatorSet.GetDictTuple(hv_ImageIDsPerClass, hv_ClassNames.TupleSelect(
                hv_ClassIndex), out hv_ImgIDsClass);
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_ImgIDsClass = hv_ImgIDsClass.TupleConcat(
                hv_ImageID);
            hv_ImgIDsClass.Dispose();
            hv_ImgIDsClass = ExpTmpLocalVar_ImgIDsClass;
            }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetDictTuple(hv_ImageIDsPerClass, hv_ClassNames.TupleSelect(
                hv_ClassIndex), hv_ImgIDsClass);
            }
          }
        }
        //
        //** Start splitting. ***
        //
        //Create a dictionary where the ImageIDs
        //for the three subsets are saved.
        hv_SplitImageIDs.Dispose();
        HOperatorSet.CreateDict(out hv_SplitImageIDs);
        for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_SplitNames.TupleLength()
            ))-1); hv_Index = (int)hv_Index + 1)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetDictTuple(hv_SplitImageIDs, hv_SplitNames.TupleSelect(hv_Index), 
              new HTuple());
          }
        }
        //We split based on classes,
        //starting with the smallest class.
        hv_AssignedImageIDs.Dispose();
        hv_AssignedImageIDs = new HTuple();
        hv_ClassSortIndices.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ClassSortIndices = hv_NumImagesPerClass.TupleSortIndex()
            ;
        }
        for (hv_ClassIndex=0; (int)hv_ClassIndex<=(int)((new HTuple(hv_NumImagesPerClass.TupleLength()
            ))-1); hv_ClassIndex = (int)hv_ClassIndex + 1)
        {
          //Get all ImageIDs where this class is present.
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ImageIDsClass.Dispose();
          HOperatorSet.GetDictTuple(hv_ImageIDsPerClass, hv_ClassNames.TupleSelect(
              hv_ClassSortIndices.TupleSelect(hv_ClassIndex)), out hv_ImageIDsClass);
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_ImageIDsClass = hv_ImageIDsClass.TupleUniq()
              ;
          hv_ImageIDsClass.Dispose();
          hv_ImageIDsClass = ExpTmpLocalVar_ImageIDsClass;
          }
          }
          //Remove ImageIDs that have already been assigned.
          hv_ImageIDsClassToBeAssigned.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_ImageIDsClassToBeAssigned = hv_ImageIDsClass.TupleDifference(
              hv_AssignedImageIDs);
          }
          {
          HTuple ExpTmpOutVar_0;
          tuple_shuffle(hv_ImageIDsClassToBeAssigned, out ExpTmpOutVar_0);
          hv_ImageIDsClassToBeAssigned.Dispose();
          hv_ImageIDsClassToBeAssigned = ExpTmpOutVar_0;
          }
          //
          for (hv_SplitIndex=0; (int)hv_SplitIndex<=(int)((new HTuple(hv_SplitNames.TupleLength()
              ))-1); hv_SplitIndex = (int)hv_SplitIndex + 1)
          {
            //Check how many of the IDs have already been assigned
            //and how many should be assigned.
            if ((int)((new HTuple(hv_ModelType.TupleEqual("anomaly_detection"))).TupleAnd(
                new HTuple(((hv_ClassNames.TupleSelect(hv_ClassSortIndices.TupleSelect(
                hv_ClassIndex)))).TupleEqual("nok")))) != 0)
            {
              //All 'nok' images for anomaly detection are sorted into the test set.
              if ((int)(new HTuple(((hv_SplitNames.TupleSelect(hv_SplitIndex))).TupleEqual(
                  "test"))) != 0)
              {
                hv_NumToBeAssignedToThisSplit.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_NumToBeAssignedToThisSplit = new HTuple(hv_ImageIDsClass.TupleLength()
                    );
                }
              }
              else
              {
                hv_NumToBeAssignedToThisSplit.Dispose();
                hv_NumToBeAssignedToThisSplit = 0;
              }
            }
            else
            {
              hv_NumToBeAssignedToThisSplit.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_NumToBeAssignedToThisSplit = (((((hv_SplitRatios.TupleSelect(
                  hv_SplitIndex))*(new HTuple(hv_ImageIDsClass.TupleLength())))).TupleFloor()
                  )).TupleInt();
              }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_AssignedImageIDsToThisSplit.Dispose();
            HOperatorSet.GetDictTuple(hv_SplitImageIDs, hv_SplitNames.TupleSelect(
                hv_SplitIndex), out hv_AssignedImageIDsToThisSplit);
            }
            hv_NumAlreadyAssignedToThisSplit.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_NumAlreadyAssignedToThisSplit = new HTuple(((hv_ImageIDsClass.TupleIntersection(
                hv_AssignedImageIDsToThisSplit))).TupleLength());
            }
            hv_NumStillToBeAssigned.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_NumStillToBeAssigned = hv_NumToBeAssignedToThisSplit-hv_NumAlreadyAssignedToThisSplit;
            }
            //
            if ((int)(new HTuple(hv_NumStillToBeAssigned.TupleGreater(0))) != 0)
            {
              if ((int)(new HTuple(hv_NumStillToBeAssigned.TupleGreater(new HTuple(hv_ImageIDsClassToBeAssigned.TupleLength()
                  )))) != 0)
              {
                hv_NumStillToBeAssigned.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_NumStillToBeAssigned = new HTuple(hv_ImageIDsClassToBeAssigned.TupleLength()
                    );
                }
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_AssignedImageIDsToThisSplit = hv_AssignedImageIDsToThisSplit.TupleConcat(
                  hv_ImageIDsClassToBeAssigned.TupleSelectRange(0,hv_NumStillToBeAssigned-1));
              hv_AssignedImageIDsToThisSplit.Dispose();
              hv_AssignedImageIDsToThisSplit = ExpTmpLocalVar_AssignedImageIDsToThisSplit;
              }
              }
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              HOperatorSet.SetDictTuple(hv_SplitImageIDs, hv_SplitNames.TupleSelect(
                  hv_SplitIndex), hv_AssignedImageIDsToThisSplit);
              }
              //Update the remaining ImageIDs of this class.
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              {
              HTuple 
                ExpTmpLocalVar_ImageIDsClassToBeAssigned = hv_ImageIDsClassToBeAssigned.TupleSelectRange(
                  hv_NumStillToBeAssigned,(new HTuple(hv_ImageIDsClassToBeAssigned.TupleLength()
                  ))-1);
              hv_ImageIDsClassToBeAssigned.Dispose();
              hv_ImageIDsClassToBeAssigned = ExpTmpLocalVar_ImageIDsClassToBeAssigned;
              }
              }
            }
          }
          //The remaining ImageIDs are assigned to random subsets
          //according to the defined ratios.
          if ((int)(new HTuple((new HTuple(hv_ImageIDsClassToBeAssigned.TupleLength()
              )).TupleGreater(0))) != 0)
          {
            for (hv_ImageIndex=0; (int)hv_ImageIndex<=(int)((new HTuple(hv_ImageIDsClassToBeAssigned.TupleLength()
                ))-1); hv_ImageIndex = (int)hv_ImageIndex + 1)
            {
              hv_Rand.Dispose();
              using (HDevDisposeHelper dh = new HDevDisposeHelper())
              {
              hv_Rand = HTuple.TupleRand(
                  1);
              }
              for (hv_RatioIndex=0; (int)hv_RatioIndex<=(int)((new HTuple(hv_SplitRatios.TupleLength()
                  ))-1); hv_RatioIndex = (int)hv_RatioIndex + 1)
              {
                hv_CurrentSplitIndex.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_CurrentSplitIndex = hv_SplitRatiosInvSortIndices.TupleSelect(
                    hv_RatioIndex);
                }
                hv_CurrentSplitRatio.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                hv_CurrentSplitRatio = hv_SplitRatios.TupleSelect(
                    hv_CurrentSplitIndex);
                }
                if ((int)(new HTuple(hv_Rand.TupleLessEqual(hv_CurrentSplitRatio))) != 0)
                {
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  hv_AssignedImageIDsToThisSplit.Dispose();
                  HOperatorSet.GetDictTuple(hv_SplitImageIDs, hv_SplitNames.TupleSelect(
                      hv_CurrentSplitIndex), out hv_AssignedImageIDsToThisSplit);
                  }
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  {
                  HTuple 
                    ExpTmpLocalVar_AssignedImageIDsToThisSplit = hv_AssignedImageIDsToThisSplit.TupleConcat(
                      hv_ImageIDsClassToBeAssigned.TupleSelect(hv_ImageIndex));
                  hv_AssignedImageIDsToThisSplit.Dispose();
                  hv_AssignedImageIDsToThisSplit = ExpTmpLocalVar_AssignedImageIDsToThisSplit;
                  }
                  }
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  HOperatorSet.SetDictTuple(hv_SplitImageIDs, hv_SplitNames.TupleSelect(
                      hv_CurrentSplitIndex), hv_AssignedImageIDsToThisSplit);
                  }
                  break;
                }
                else
                {
                  using (HDevDisposeHelper dh = new HDevDisposeHelper())
                  {
                  {
                  HTuple 
                    ExpTmpLocalVar_Rand = hv_Rand-hv_CurrentSplitRatio;
                  hv_Rand.Dispose();
                  hv_Rand = ExpTmpLocalVar_Rand;
                  }
                  }
                }
              }
            }
          }
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_AssignedImageIDs = ((((hv_AssignedImageIDs.TupleConcat(
              hv_ImageIDsClass))).TupleUniq())).TupleSort();
          hv_AssignedImageIDs.Dispose();
          hv_AssignedImageIDs = ExpTmpLocalVar_AssignedImageIDs;
          }
          }
        }
        //
        //There might be images not having any labels:
        //Assign them based on the ratio.
        hv_ImageIDsWithoutLabel.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ImageIDsWithoutLabel = hv_ImageIDList.TupleDifference(
            hv_AssignedImageIDs);
        }
        hv_NumImageIDsWithoutLabel.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_NumImageIDsWithoutLabel = new HTuple(hv_ImageIDsWithoutLabel.TupleLength()
            );
        }
        if ((int)(new HTuple(hv_NumImageIDsWithoutLabel.TupleGreater(0))) != 0)
        {
          {
          HTuple ExpTmpOutVar_0;
          tuple_shuffle(hv_ImageIDsWithoutLabel, out ExpTmpOutVar_0);
          hv_ImageIDsWithoutLabel.Dispose();
          hv_ImageIDsWithoutLabel = ExpTmpOutVar_0;
          }
          for (hv_Index=0; (int)hv_Index<=(int)((new HTuple(hv_SplitRatios.TupleLength()
              ))-1); hv_Index = (int)hv_Index + 1)
          {
            hv_NumToBeAssigned.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_NumToBeAssigned = (((hv_SplitRatios.TupleSelect(
                hv_Index))*hv_NumImageIDsWithoutLabel)).TupleInt();
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_AssignedImageIDsToThisSplit.Dispose();
            HOperatorSet.GetDictTuple(hv_SplitImageIDs, hv_SplitNames.TupleSelect(
                hv_Index), out hv_AssignedImageIDsToThisSplit);
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_AssignedImageIDsToThisSplit = hv_AssignedImageIDsToThisSplit.TupleConcat(
                hv_ImageIDsWithoutLabel.TupleSelectRange(0,hv_NumToBeAssigned-1));
            hv_AssignedImageIDsToThisSplit.Dispose();
            hv_AssignedImageIDsToThisSplit = ExpTmpLocalVar_AssignedImageIDsToThisSplit;
            }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetDictTuple(hv_SplitImageIDs, hv_SplitNames.TupleSelect(
                hv_Index), hv_AssignedImageIDsToThisSplit.TupleSort());
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_ImageIDsWithoutLabel = hv_ImageIDsWithoutLabel.TupleSelectRange(
                hv_NumToBeAssigned,(new HTuple(hv_ImageIDsWithoutLabel.TupleLength()
                ))-1);
            hv_ImageIDsWithoutLabel.Dispose();
            hv_ImageIDsWithoutLabel = ExpTmpLocalVar_ImageIDsWithoutLabel;
            }
            }
          }
          //If there are still ImageIDs, assign them to split with highest ratio.
          hv_MaxRatioIndex.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_MaxRatioIndex = hv_SplitRatiosInvSortIndices.TupleFind(
              0);
          }
          if ((int)(new HTuple((new HTuple(hv_ImageIDsWithoutLabel.TupleLength())).TupleGreater(
              0))) != 0)
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_AssignedImageIDsToThisSplit.Dispose();
            HOperatorSet.GetDictTuple(hv_SplitImageIDs, hv_SplitNames.TupleSelect(
                hv_MaxRatioIndex), out hv_AssignedImageIDsToThisSplit);
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            {
            HTuple 
              ExpTmpLocalVar_AssignedImageIDsToThisSplit = hv_AssignedImageIDsToThisSplit.TupleConcat(
                hv_ImageIDsWithoutLabel);
            hv_AssignedImageIDsToThisSplit.Dispose();
            hv_AssignedImageIDsToThisSplit = ExpTmpLocalVar_AssignedImageIDsToThisSplit;
            }
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetDictTuple(hv_SplitImageIDs, hv_SplitNames.TupleSelect(
                hv_MaxRatioIndex), hv_AssignedImageIDsToThisSplit.TupleSort());
            }
          }
        }
        //
        //Assign 'split' entries to samples.
        for (hv_SplitNameIndex=0; (int)hv_SplitNameIndex<=(int)((new HTuple(hv_SplitNames.TupleLength()
            ))-1); hv_SplitNameIndex = (int)hv_SplitNameIndex + 1)
        {
          hv_SplitName.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_SplitName = hv_SplitNames.TupleSelect(
              hv_SplitNameIndex);
          }
          hv_SplitIDs.Dispose();
          HOperatorSet.GetDictTuple(hv_SplitImageIDs, hv_SplitName, out hv_SplitIDs);
          for (hv_SplitIDIndex=0; (int)hv_SplitIDIndex<=(int)((new HTuple(hv_SplitIDs.TupleLength()
              ))-1); hv_SplitIDIndex = (int)hv_SplitIDIndex + 1)
          {
            hv_SampleSplitIDs.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_SampleSplitIDs = hv_SplitIDs.TupleSelect(
                hv_SplitIDIndex);
            }
            hv_DLSampleIndex.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_DLSampleIndex = hv_ImageIDList.TupleFind(
                hv_SampleSplitIDs);
            }
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetDictTuple(hv_DLSamples.TupleSelect(hv_DLSampleIndex), 
                "split", hv_SplitName);
            }
          }
        }
      }
      else
      {
        hv_ErrorDict.Dispose();
        hv_ErrorDict = "The dataset is already split. You can overwrite the existing split using the generic parameter 'overwrite_split'.";
        throw new HalconException(hv_ErrorDict);
      }
      ho_SegmImage.Dispose();

      hv_OverwriteSplit.Dispose();
      hv_ModelType.Dispose();
      hv_SplitNames.Dispose();
      hv_GenParamName.Dispose();
      hv_GenParamIndex.Dispose();
      hv_Type.Dispose();
      hv_DLSamples.Dispose();
      hv_DLSample.Dispose();
      hv_AnomalyDetectionLabelExists.Dispose();
      hv_BBoxLabelIdExists.Dispose();
      hv_ImageLabelIdExists.Dispose();
      hv_SegmFileExists.Dispose();
      hv_ClassIDs.Dispose();
      hv_ClassNames.Dispose();
      hv_ClassIDToClassIndex.Dispose();
      hv_TrainingRatio.Dispose();
      hv_ValidationRatio.Dispose();
      hv_SplitRatios.Dispose();
      hv_SplitRatiosInvSortIndices.Dispose();
      hv_SplitKeys.Dispose();
      hv_IndexSample.Dispose();
      hv_SplitExists.Dispose();
      hv_SampleSplit.Dispose();
      hv_NotYetSplit.Dispose();
      hv_ImageIDsPerClass.Dispose();
      hv_ClassIndex.Dispose();
      hv_NumImagesPerClass.Dispose();
      hv_ImageIDList.Dispose();
      hv_ImageID.Dispose();
      hv_AnomalyLabel.Dispose();
      hv_Labels.Dispose();
      hv_ImageLabelID.Dispose();
      hv_BboxLabels.Dispose();
      hv_SegmDir.Dispose();
      hv_SegmFileName.Dispose();
      hv_AbsoluteHisto.Dispose();
      hv_LabelIndices.Dispose();
      hv_Index.Dispose();
      hv_ImgIDsClass.Dispose();
      hv_SplitImageIDs.Dispose();
      hv_AssignedImageIDs.Dispose();
      hv_ClassSortIndices.Dispose();
      hv_ImageIDsClass.Dispose();
      hv_ImageIDsClassToBeAssigned.Dispose();
      hv_SplitIndex.Dispose();
      hv_NumToBeAssignedToThisSplit.Dispose();
      hv_AssignedImageIDsToThisSplit.Dispose();
      hv_NumAlreadyAssignedToThisSplit.Dispose();
      hv_NumStillToBeAssigned.Dispose();
      hv_ImageIndex.Dispose();
      hv_Rand.Dispose();
      hv_RatioIndex.Dispose();
      hv_CurrentSplitIndex.Dispose();
      hv_CurrentSplitRatio.Dispose();
      hv_ImageIDsWithoutLabel.Dispose();
      hv_NumImageIDsWithoutLabel.Dispose();
      hv_NumToBeAssigned.Dispose();
      hv_MaxRatioIndex.Dispose();
      hv_SplitNameIndex.Dispose();
      hv_SplitName.Dispose();
      hv_SplitIDs.Dispose();
      hv_SplitIDIndex.Dispose();
      hv_SampleSplitIDs.Dispose();
      hv_DLSampleIndex.Dispose();
      hv_ErrorDict.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_SegmImage.Dispose();

      hv_OverwriteSplit.Dispose();
      hv_ModelType.Dispose();
      hv_SplitNames.Dispose();
      hv_GenParamName.Dispose();
      hv_GenParamIndex.Dispose();
      hv_Type.Dispose();
      hv_DLSamples.Dispose();
      hv_DLSample.Dispose();
      hv_AnomalyDetectionLabelExists.Dispose();
      hv_BBoxLabelIdExists.Dispose();
      hv_ImageLabelIdExists.Dispose();
      hv_SegmFileExists.Dispose();
      hv_ClassIDs.Dispose();
      hv_ClassNames.Dispose();
      hv_ClassIDToClassIndex.Dispose();
      hv_TrainingRatio.Dispose();
      hv_ValidationRatio.Dispose();
      hv_SplitRatios.Dispose();
      hv_SplitRatiosInvSortIndices.Dispose();
      hv_SplitKeys.Dispose();
      hv_IndexSample.Dispose();
      hv_SplitExists.Dispose();
      hv_SampleSplit.Dispose();
      hv_NotYetSplit.Dispose();
      hv_ImageIDsPerClass.Dispose();
      hv_ClassIndex.Dispose();
      hv_NumImagesPerClass.Dispose();
      hv_ImageIDList.Dispose();
      hv_ImageID.Dispose();
      hv_AnomalyLabel.Dispose();
      hv_Labels.Dispose();
      hv_ImageLabelID.Dispose();
      hv_BboxLabels.Dispose();
      hv_SegmDir.Dispose();
      hv_SegmFileName.Dispose();
      hv_AbsoluteHisto.Dispose();
      hv_LabelIndices.Dispose();
      hv_Index.Dispose();
      hv_ImgIDsClass.Dispose();
      hv_SplitImageIDs.Dispose();
      hv_AssignedImageIDs.Dispose();
      hv_ClassSortIndices.Dispose();
      hv_ImageIDsClass.Dispose();
      hv_ImageIDsClassToBeAssigned.Dispose();
      hv_SplitIndex.Dispose();
      hv_NumToBeAssignedToThisSplit.Dispose();
      hv_AssignedImageIDsToThisSplit.Dispose();
      hv_NumAlreadyAssignedToThisSplit.Dispose();
      hv_NumStillToBeAssigned.Dispose();
      hv_ImageIndex.Dispose();
      hv_Rand.Dispose();
      hv_RatioIndex.Dispose();
      hv_CurrentSplitIndex.Dispose();
      hv_CurrentSplitRatio.Dispose();
      hv_ImageIDsWithoutLabel.Dispose();
      hv_NumImageIDsWithoutLabel.Dispose();
      hv_NumToBeAssigned.Dispose();
      hv_MaxRatioIndex.Dispose();
      hv_SplitNameIndex.Dispose();
      hv_SplitName.Dispose();
      hv_SplitIDs.Dispose();
      hv_SplitIDIndex.Dispose();
      hv_SampleSplitIDs.Dispose();
      hv_DLSampleIndex.Dispose();
      hv_ErrorDict.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Time
  // Short Description: Create a formatted string of a time span. 
  public void timespan_string (HTuple hv_TotalSeconds, HTuple hv_Format, out HTuple hv_TimeString)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_Seconds = new HTuple(), hv_TotalMinutes = new HTuple();
    HTuple hv_Minutes = new HTuple(), hv_TotalHours = new HTuple();
    HTuple hv_Hours = new HTuple(), hv_Days = new HTuple();
    HTuple   hv_TotalSeconds_COPY_INP_TMP = new HTuple(hv_TotalSeconds);

    // Initialize local and output iconic variables 
    hv_TimeString = new HTuple();
    try
    {
      //
      //This procedure creates a readable representation of a time span
      //given the elapsed time in seconds.
      //
      //Ensure that the input is an integer.
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_TotalSeconds = hv_TotalSeconds_COPY_INP_TMP.TupleInt()
          ;
      hv_TotalSeconds_COPY_INP_TMP.Dispose();
      hv_TotalSeconds_COPY_INP_TMP = ExpTmpLocalVar_TotalSeconds;
      }
      }
      //
      hv_Seconds.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Seconds = hv_TotalSeconds_COPY_INP_TMP%60;
      }
      //
      hv_TotalMinutes.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TotalMinutes = hv_TotalSeconds_COPY_INP_TMP/60;
      }
      hv_Minutes.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Minutes = hv_TotalMinutes%60;
      }
      //
      hv_TotalHours.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TotalHours = hv_TotalSeconds_COPY_INP_TMP/3600;
      }
      hv_Hours.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Hours = hv_TotalHours%24;
      }
      //
      hv_Days.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Days = hv_TotalSeconds_COPY_INP_TMP/86400;
      }
      //
      if ((int)(new HTuple(hv_Format.TupleEqual("auto"))) != 0)
      {
        //Print the highest non-zero unit and all remaining sub-units.
        if ((int)(new HTuple(hv_Days.TupleGreater(0))) != 0)
        {
          hv_TimeString.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_TimeString = (((((((hv_Days.TupleString(
              "d"))+"d ")+(hv_Hours.TupleString("d")))+"h ")+(hv_Minutes.TupleString(
              "d")))+"m ")+(hv_Seconds.TupleString("d")))+"s";
          }
        }
        else if ((int)(new HTuple(hv_Hours.TupleGreater(0))) != 0)
        {
          hv_TimeString.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_TimeString = (((((hv_Hours.TupleString(
              "d"))+"h ")+(hv_Minutes.TupleString("d")))+"m ")+(hv_Seconds.TupleString(
              "d")))+"s";
          }
        }
        else if ((int)(new HTuple(hv_Minutes.TupleGreater(0))) != 0)
        {
          hv_TimeString.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_TimeString = (((hv_Minutes.TupleString(
              "d"))+"m ")+(hv_Seconds.TupleString("d")))+"s";
          }
        }
        else
        {
          hv_TimeString.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_TimeString = (hv_Seconds.TupleString(
              "d"))+"s";
          }
        }
      }
      else if ((int)(new HTuple(hv_Format.TupleEqual("top1"))) != 0)
      {
        //Print the highest non-zero unit.
        if ((int)(new HTuple(hv_Days.TupleGreater(0))) != 0)
        {
          hv_TimeString.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_TimeString = (hv_Days.TupleString(
              "d"))+"d";
          }
        }
        else if ((int)(new HTuple(hv_Hours.TupleGreater(0))) != 0)
        {
          hv_TimeString.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_TimeString = (hv_Hours.TupleString(
              "d"))+"h";
          }
        }
        else if ((int)(new HTuple(hv_Minutes.TupleGreater(0))) != 0)
        {
          hv_TimeString.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_TimeString = (hv_Minutes.TupleString(
              "d"))+"m";
          }
        }
        else
        {
          hv_TimeString.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_TimeString = (hv_Seconds.TupleString(
              "d"))+"s";
          }
        }
      }
      else if ((int)(new HTuple(hv_Format.TupleEqual("top2"))) != 0)
      {
        //Print the highest non-zero unit and the following sub-unit.
        if ((int)(new HTuple(hv_Days.TupleGreater(0))) != 0)
        {
          hv_TimeString.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_TimeString = (((hv_Days.TupleString(
              "d"))+"d ")+(hv_Hours.TupleString("d")))+"h";
          }
        }
        else if ((int)(new HTuple(hv_Hours.TupleGreater(0))) != 0)
        {
          hv_TimeString.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_TimeString = (((hv_Hours.TupleString(
              "d"))+"h ")+(hv_Minutes.TupleString("d")))+"m";
          }
        }
        else if ((int)(new HTuple(hv_Minutes.TupleGreater(0))) != 0)
        {
          hv_TimeString.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_TimeString = (((hv_Minutes.TupleString(
              "d"))+"m ")+(hv_Seconds.TupleString("d")))+"s";
          }
        }
        else
        {
          hv_TimeString.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_TimeString = (hv_Seconds.TupleString(
              "d"))+"s";
          }
        }
      }
      else if ((int)(new HTuple(hv_Format.TupleEqual("dhms"))) != 0)
      {
        //Print a Days-Hours-Minutes-Seconds string.
        hv_TimeString.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_TimeString = (((((((hv_Days.TupleString(
            "d"))+"d ")+(hv_Hours.TupleString("d")))+"h ")+(hv_Minutes.TupleString(
            "d")))+"m ")+(hv_Seconds.TupleString("d")))+"s";
        }
      }
      else if ((int)(new HTuple(hv_Format.TupleEqual("hms"))) != 0)
      {
        //Print a Hours-Minutes-Seconds string, where hours can be >= 24.
        hv_TimeString.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_TimeString = (((((hv_TotalHours.TupleString(
            "d"))+"h ")+(hv_Minutes.TupleString("d")))+"m ")+(hv_Seconds.TupleString(
            "d")))+"s";
        }
      }
      else
      {
        throw new HalconException("Unknown format string.");
      }
      //

      hv_TotalSeconds_COPY_INP_TMP.Dispose();
      hv_Seconds.Dispose();
      hv_TotalMinutes.Dispose();
      hv_Minutes.Dispose();
      hv_TotalHours.Dispose();
      hv_Hours.Dispose();
      hv_Days.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_TotalSeconds_COPY_INP_TMP.Dispose();
      hv_Seconds.Dispose();
      hv_TotalMinutes.Dispose();
      hv_Minutes.Dispose();
      hv_TotalHours.Dispose();
      hv_Hours.Dispose();
      hv_Days.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Tuple / Element Order
  // Short Description: Sort the elements of a tuple randomly. 
  public void tuple_shuffle (HTuple hv_Tuple, out HTuple hv_Shuffled)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ShuffleIndices = new HTuple();
    // Initialize local and output iconic variables 
    hv_Shuffled = new HTuple();
    try
    {
      //This procedure sorts the input tuple randomly.
      //
      if ((int)(new HTuple((new HTuple(hv_Tuple.TupleLength())).TupleGreater(0))) != 0)
      {
        //Create a tuple of random numbers,
        //sort this tuple, and return the indices
        //of this sorted tuple.
        hv_ShuffleIndices.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ShuffleIndices = (HTuple.TupleRand(
            new HTuple(hv_Tuple.TupleLength()))).TupleSortIndex();
        }
        //Assign the elements of Tuple
        //to these random positions.
        hv_Shuffled.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Shuffled = hv_Tuple.TupleSelect(
            hv_ShuffleIndices);
        }
      }
      else
      {
        //If the input tuple is empty,
        //an empty tuple should be returned.
        hv_Shuffled.Dispose();
        hv_Shuffled = new HTuple();
      }

      hv_ShuffleIndices.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_ShuffleIndices.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Graphics / Window
  // Short Description: This procedure sets and returns meta information to display images correctly. 
  public void update_window_meta_information (HTuple hv_WindowHandle, HTuple hv_WidthImage, 
      HTuple hv_HeightImage, HTuple hv_WindowRow1, HTuple hv_WindowColumn1, HTuple hv_MapColorBarWidth, 
      HTuple hv_MarginBottom, out HTuple hv_WindowImageRatioHeight, out HTuple hv_WindowImageRatioWidth, 
      out HTuple hv_SetPartRow2, out HTuple hv_SetPartColumn2, out HTuple hv_PrevWindowCoordinatesOut)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv__ = new HTuple(), hv_WindowWidth = new HTuple();
    HTuple hv_WindowHeight = new HTuple(), hv_WindowRow2 = new HTuple();
    HTuple hv_WindowColumn2 = new HTuple(), hv_WindowRatio = new HTuple();
    HTuple hv_ImageRow2 = new HTuple(), hv_ImageColumn2 = new HTuple();
    HTuple hv_ImageRatio = new HTuple(), hv_ImageWindowRatioHeight = new HTuple();
    HTuple hv_ImageRow2InWindow = new HTuple(), hv_ImageCol2InWindow = new HTuple();
    // Initialize local and output iconic variables 
    hv_WindowImageRatioHeight = new HTuple();
    hv_WindowImageRatioWidth = new HTuple();
    hv_SetPartRow2 = new HTuple();
    hv_SetPartColumn2 = new HTuple();
    hv_PrevWindowCoordinatesOut = new HTuple();
    try
    {
      //
      //This procedure sets and returns meta information to display images correctly.
      //
      //Set part for the image to be displayed later and adapt window size (+ MarginBottom + MapColorBarWidth).
      hv__.Dispose();hv__.Dispose();hv_WindowWidth.Dispose();hv_WindowHeight.Dispose();
      HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv__, out hv__, out hv_WindowWidth, 
          out hv_WindowHeight);
      hv_WindowImageRatioHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WindowImageRatioHeight = hv_WindowHeight/(hv_HeightImage*1.0);
      }
      hv_WindowImageRatioWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WindowImageRatioWidth = hv_WindowWidth/(hv_WidthImage*1.0);
      }
      //
      //Set window part such that image is displayed undistorted.
      hv_WindowRow2.Dispose();
      hv_WindowRow2 = new HTuple(hv_WindowHeight);
      hv_WindowColumn2.Dispose();
      hv_WindowColumn2 = new HTuple(hv_WindowWidth);
      hv_WindowRatio.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WindowRatio = hv_WindowColumn2/(hv_WindowRow2*1.0);
      }
      //
      hv_ImageRow2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ImageRow2 = hv_HeightImage+(hv_MarginBottom/hv_WindowImageRatioHeight);
      }
      hv_ImageColumn2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ImageColumn2 = hv_WidthImage+(hv_MapColorBarWidth/hv_WindowImageRatioWidth);
      }
      hv_ImageRatio.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ImageRatio = hv_ImageColumn2/(hv_ImageRow2*1.0);
      }
      if ((int)(new HTuple(hv_ImageRatio.TupleGreater(hv_WindowRatio))) != 0)
      {
        //
        //Extend image until right window border.
        hv_SetPartColumn2.Dispose();
        hv_SetPartColumn2 = new HTuple(hv_ImageColumn2);
        hv_ImageWindowRatioHeight.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ImageWindowRatioHeight = hv_ImageColumn2/(hv_WindowColumn2*1.0);
        }
        hv_ImageRow2InWindow.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ImageRow2InWindow = hv_ImageRow2/hv_ImageWindowRatioHeight;
        }
        hv_SetPartRow2.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SetPartRow2 = hv_ImageRow2+((hv_WindowRow2-hv_ImageRow2InWindow)/hv_WindowImageRatioWidth);
        }
      }
      else
      {
        //
        //Extend image until bottom of window.
        hv_SetPartRow2.Dispose();
        hv_SetPartRow2 = new HTuple(hv_ImageRow2);
        hv_ImageWindowRatioHeight.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ImageWindowRatioHeight = hv_ImageRow2/(hv_WindowRow2*1.0);
        }
        hv_ImageCol2InWindow.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_ImageCol2InWindow = hv_ImageColumn2/hv_ImageWindowRatioHeight;
        }
        hv_SetPartColumn2.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SetPartColumn2 = hv_ImageColumn2+((hv_WindowColumn2-hv_ImageCol2InWindow)/hv_WindowImageRatioHeight);
        }
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_SetPartRow2, hv_SetPartColumn2);
      }
      //
      //Return the coordinates of the new window.
      hv_PrevWindowCoordinatesOut.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_PrevWindowCoordinatesOut = new HTuple();
      hv_PrevWindowCoordinatesOut = hv_PrevWindowCoordinatesOut.TupleConcat(hv_WindowRow1, hv_WindowColumn1, hv_WindowWidth, hv_WindowHeight);
      }
      //

      hv__.Dispose();
      hv_WindowWidth.Dispose();
      hv_WindowHeight.Dispose();
      hv_WindowRow2.Dispose();
      hv_WindowColumn2.Dispose();
      hv_WindowRatio.Dispose();
      hv_ImageRow2.Dispose();
      hv_ImageColumn2.Dispose();
      hv_ImageRatio.Dispose();
      hv_ImageWindowRatioHeight.Dispose();
      hv_ImageRow2InWindow.Dispose();
      hv_ImageCol2InWindow.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv__.Dispose();
      hv_WindowWidth.Dispose();
      hv_WindowHeight.Dispose();
      hv_WindowRow2.Dispose();
      hv_WindowColumn2.Dispose();
      hv_WindowRatio.Dispose();
      hv_ImageRow2.Dispose();
      hv_ImageColumn2.Dispose();
      hv_ImageRatio.Dispose();
      hv_ImageWindowRatioHeight.Dispose();
      hv_ImageRow2InWindow.Dispose();
      hv_ImageCol2InWindow.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Chapter: Deep Learning / Model
  // Short Description: Write the dictionaries of the samples in DLSampleBatch to hdict files and store the paths in DLDataset. 
  public void write_dl_samples (HTuple hv_DLDataset, HTuple hv_SampleIndices, HTuple hv_DLSampleBatch, 
      HTuple hv_GenParamName, HTuple hv_GenParamValue)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_RaiseErrorWriteDict = new HTuple();
    HTuple hv_IndexGenParam = new HTuple(), hv_DLSampleDirExists = new HTuple();
    HTuple hv_OutDir = new HTuple(), hv_DatasetSamples = new HTuple();
    HTuple hv_I = new HTuple(), hv_DLDatasetIndex = new HTuple();
    HTuple hv_DatasetSample = new HTuple(), hv_DLSample = new HTuple();
    HTuple hv_DatasetImageID = new HTuple(), hv_SampleImageID = new HTuple();
    HTuple hv_FileNameOut = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //
      //This procedure writes all given DLSamples in DLSampleBatch to hdict files
      //and stores the file paths in the respective samples of the DLDataset.
      //The directory needs to be given in dlsample_dir, before calling this procedure.
      //
      //The output filename is created in the following way: image_id + '_dlsample.hdict'
      //
      //Set the default values.
      //Raise error when writing dictionary.
      hv_RaiseErrorWriteDict.Dispose();
      hv_RaiseErrorWriteDict = "true";
      //
      //Transfer generic parameters.
      if ((int)(new HTuple((new HTuple(hv_GenParamName.TupleLength())).TupleNotEqual(
          new HTuple(hv_GenParamValue.TupleLength())))) != 0)
      {
        throw new HalconException("GenParamName and GenParamValue have to be of equal length.");
      }
      //
      if ((int)(new HTuple(hv_GenParamName.TupleNotEqual(new HTuple()))) != 0)
      {
        for (hv_IndexGenParam=0; (int)hv_IndexGenParam<=(int)((new HTuple(hv_GenParamName.TupleLength()
            ))-1); hv_IndexGenParam = (int)hv_IndexGenParam + 1)
        {
          if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_IndexGenParam))).TupleEqual(
              "raise_error_if_content_not_serializable"))) != 0)
          {
            //Set 'raise_error_if_content_not_serializable' for writing write_dict.
            hv_RaiseErrorWriteDict.Dispose();
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            hv_RaiseErrorWriteDict = hv_GenParamValue.TupleSelect(
                hv_IndexGenParam);
            }
          }
          else
          {
            throw new HalconException("Unknown GenParam key : "+(hv_GenParamName.TupleSelect(
                hv_IndexGenParam)));
          }
        }
      }
      //
      //Check the parameters.
      //Check that the base path is available in the DLDataset.
      hv_DLSampleDirExists.Dispose();
      HOperatorSet.GetDictParam(hv_DLDataset, "key_exists", "dlsample_dir", out hv_DLSampleDirExists);
      if ((int)(hv_DLSampleDirExists.TupleNot()) != 0)
      {
        throw new HalconException("The dataset needs to include the key 'dlsample_dir'.");

        hv_RaiseErrorWriteDict.Dispose();
        hv_IndexGenParam.Dispose();
        hv_DLSampleDirExists.Dispose();
        hv_OutDir.Dispose();
        hv_DatasetSamples.Dispose();
        hv_I.Dispose();
        hv_DLDatasetIndex.Dispose();
        hv_DatasetSample.Dispose();
        hv_DLSample.Dispose();
        hv_DatasetImageID.Dispose();
        hv_SampleImageID.Dispose();
        hv_FileNameOut.Dispose();

        return;
      }

      if ((int)(new HTuple((new HTuple(hv_DLSampleBatch.TupleLength())).TupleNotEqual(
          new HTuple(hv_SampleIndices.TupleLength())))) != 0)
      {
        throw new HalconException("The input tuples DLSampleBatch and SampleIndices need to match in length.");

        hv_RaiseErrorWriteDict.Dispose();
        hv_IndexGenParam.Dispose();
        hv_DLSampleDirExists.Dispose();
        hv_OutDir.Dispose();
        hv_DatasetSamples.Dispose();
        hv_I.Dispose();
        hv_DLDatasetIndex.Dispose();
        hv_DatasetSample.Dispose();
        hv_DLSample.Dispose();
        hv_DatasetImageID.Dispose();
        hv_SampleImageID.Dispose();
        hv_FileNameOut.Dispose();

        return;
      }
      //
      //Write preprocessed data.
      //
      //Get the base path for the outputs.
      hv_OutDir.Dispose();
      HOperatorSet.GetDictTuple(hv_DLDataset, "dlsample_dir", out hv_OutDir);
      //
      //Get the samples.
      hv_DatasetSamples.Dispose();
      HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DatasetSamples);
      //
      //Loop over all samples in the batch.
      for (hv_I=0; (int)hv_I<=(int)((new HTuple(hv_DLSampleBatch.TupleLength()))-1); hv_I = (int)hv_I + 1)
      {
        //Get the sample dictionaries.
        hv_DLDatasetIndex.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DLDatasetIndex = hv_SampleIndices.TupleSelect(
            hv_I);
        }
        hv_DatasetSample.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DatasetSample = hv_DatasetSamples.TupleSelect(
            hv_DLDatasetIndex);
        }
        hv_DLSample.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_DLSample = hv_DLSampleBatch.TupleSelect(
            hv_I);
        }
        //
        //Check that image IDs match.
        hv_DatasetImageID.Dispose();
        HOperatorSet.GetDictTuple(hv_DatasetSample, "image_id", out hv_DatasetImageID);
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_SampleImageID.Dispose();
        HOperatorSet.GetDictTuple(hv_DLSampleBatch.TupleSelect(hv_I), "image_id", 
            out hv_SampleImageID);
        }
        if ((int)(new HTuple(hv_DatasetImageID.TupleNotEqual(hv_SampleImageID))) != 0)
        {
          throw new HalconException("Image IDs do not match. Please use correct indexing in input argument SampleIndices.");

          hv_RaiseErrorWriteDict.Dispose();
          hv_IndexGenParam.Dispose();
          hv_DLSampleDirExists.Dispose();
          hv_OutDir.Dispose();
          hv_DatasetSamples.Dispose();
          hv_I.Dispose();
          hv_DLDatasetIndex.Dispose();
          hv_DatasetSample.Dispose();
          hv_DLSample.Dispose();
          hv_DatasetImageID.Dispose();
          hv_SampleImageID.Dispose();
          hv_FileNameOut.Dispose();

          return;
        }
        //
        //Generate the output file name.
        hv_FileNameOut.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_FileNameOut = hv_SampleImageID+"_dlsample.hdict";
        }
        //
        //Write output dictionary.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.WriteDict(hv_DLSample, (hv_OutDir+"/")+hv_FileNameOut, "raise_error_if_content_not_serializable", 
            hv_RaiseErrorWriteDict);
        }
        //Add output path to DLDataset sample dictionary.
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetDictTuple(hv_DatasetSamples.TupleSelect(hv_DLDatasetIndex), 
            "dlsample_file_name", hv_FileNameOut);
        }
        //
      }


      hv_RaiseErrorWriteDict.Dispose();
      hv_IndexGenParam.Dispose();
      hv_DLSampleDirExists.Dispose();
      hv_OutDir.Dispose();
      hv_DatasetSamples.Dispose();
      hv_I.Dispose();
      hv_DLDatasetIndex.Dispose();
      hv_DatasetSample.Dispose();
      hv_DLSample.Dispose();
      hv_DatasetImageID.Dispose();
      hv_SampleImageID.Dispose();
      hv_FileNameOut.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_RaiseErrorWriteDict.Dispose();
      hv_IndexGenParam.Dispose();
      hv_DLSampleDirExists.Dispose();
      hv_OutDir.Dispose();
      hv_DatasetSamples.Dispose();
      hv_I.Dispose();
      hv_DLDatasetIndex.Dispose();
      hv_DatasetSample.Dispose();
      hv_DLSample.Dispose();
      hv_DatasetImageID.Dispose();
      hv_SampleImageID.Dispose();
      hv_FileNameOut.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Local procedures 
  public void create_tiny_example_dataset (out HTuple hv_DLDataset)
  {


    // Local iconic variables 

    // Local control variables 

    HTuple hv_HalconExampleDir = new HTuple();
    HTuple hv_HalconImageDir = new HTuple(), hv_DLSamples = new HTuple();
    HTuple hv_DLSample = new HTuple();
    // Initialize local and output iconic variables 
    hv_DLDataset = new HTuple();
    try
    {
      //This procedure creates a tiny dataset out of the pill bag dataset.
      //
      //Path to the image directory.
      hv_HalconExampleDir.Dispose();
      HOperatorSet.GetSystem("example_dir", out hv_HalconExampleDir);
      hv_HalconImageDir.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_HalconImageDir = hv_HalconExampleDir+"/images/";
      }
      //
      //Create DLDataset
      hv_DLDataset.Dispose();
      HOperatorSet.CreateDict(out hv_DLDataset);
      HOperatorSet.SetDictTuple(hv_DLDataset, "image_dir", hv_HalconImageDir);
      HOperatorSet.SetDictTuple(hv_DLDataset, "class_ids", (((((((((new HTuple(1)).TupleConcat(
          2)).TupleConcat(3)).TupleConcat(4)).TupleConcat(5)).TupleConcat(6)).TupleConcat(
          7)).TupleConcat(8)).TupleConcat(9)).TupleConcat(10));
      HOperatorSet.SetDictTuple(hv_DLDataset, "class_names", (((((((((new HTuple("Omega-3")).TupleConcat(
          "KMW")).TupleConcat("Stomach tablet")).TupleConcat("Ginko")).TupleConcat(
          "Ginseng")).TupleConcat("Glucosamine")).TupleConcat("Cognivia")).TupleConcat(
          "Capsularum I")).TupleConcat("Iron tablet")).TupleConcat("Vitamin-B"));
      //Create Samples
      hv_DLSamples.Dispose();
      hv_DLSamples = new HTuple();
      hv_DLSample.Dispose();
      HOperatorSet.CreateDict(out hv_DLSample);
      HOperatorSet.SetDictTuple(hv_DLSample, "image_id", 220);
      HOperatorSet.SetDictTuple(hv_DLSample, "image_file_name", "pill_bag/pill_bag_220.png");
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row1", ((((((((new HTuple(98)).TupleConcat(
          105)).TupleConcat(220)).TupleConcat(307)).TupleConcat(161)).TupleConcat(
          435)).TupleConcat(460)).TupleConcat(514)).TupleConcat(542));
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col1", ((((((((new HTuple(422)).TupleConcat(
          313)).TupleConcat(338)).TupleConcat(287)).TupleConcat(424)).TupleConcat(
          646)).TupleConcat(965)).TupleConcat(820)).TupleConcat(892));
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row2", ((((((((new HTuple(181)).TupleConcat(
          228)).TupleConcat(337)).TupleConcat(392)).TupleConcat(265)).TupleConcat(
          637)).TupleConcat(542)).TupleConcat(595)).TupleConcat(636));
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col2", ((((((((new HTuple(510)).TupleConcat(
          432)).TupleConcat(459)).TupleConcat(376)).TupleConcat(669)).TupleConcat(
          830)).TupleConcat(1052)).TupleConcat(905)).TupleConcat(1037));
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_label_id", ((((((((new HTuple(5)).TupleConcat(
          7)).TupleConcat(7)).TupleConcat(5)).TupleConcat(6)).TupleConcat(1)).TupleConcat(
          9)).TupleConcat(5)).TupleConcat(2));
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_DLSamples = hv_DLSamples.TupleConcat(
          hv_DLSample);
      hv_DLSamples.Dispose();
      hv_DLSamples = ExpTmpLocalVar_DLSamples;
      }
      }
      //
      hv_DLSample.Dispose();
      HOperatorSet.CreateDict(out hv_DLSample);
      HOperatorSet.SetDictTuple(hv_DLSample, "image_id", 134);
      HOperatorSet.SetDictTuple(hv_DLSample, "image_file_name", "pill_bag/pill_bag_134.png");
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row1", (((((((((((new HTuple(354)).TupleConcat(
          152)).TupleConcat(315)).TupleConcat(142)).TupleConcat(483)).TupleConcat(
          458)).TupleConcat(160)).TupleConcat(294)).TupleConcat(237)).TupleConcat(
          438)).TupleConcat(523)).TupleConcat(527));
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col1", (((((((((((new HTuple(488)).TupleConcat(
          733)).TupleConcat(588)).TupleConcat(557)).TupleConcat(371)).TupleConcat(
          894)).TupleConcat(474)).TupleConcat(361)).TupleConcat(403)).TupleConcat(
          686)).TupleConcat(646)).TupleConcat(855));
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row2", (((((((((((new HTuple(561)).TupleConcat(
          242)).TupleConcat(422)).TupleConcat(275)).TupleConcat(613)).TupleConcat(
          538)).TupleConcat(241)).TupleConcat(489)).TupleConcat(350)).TupleConcat(
          529)).TupleConcat(599)).TupleConcat(610));
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col2", (((((((((((new HTuple(655)).TupleConcat(
          872)).TupleConcat(721)).TupleConcat(690)).TupleConcat(504)).TupleConcat(
          977)).TupleConcat(554)).TupleConcat(506)).TupleConcat(636)).TupleConcat(
          897)).TupleConcat(857)).TupleConcat(937));
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_label_id", (((((((((((new HTuple(1)).TupleConcat(
          2)).TupleConcat(2)).TupleConcat(3)).TupleConcat(3)).TupleConcat(5)).TupleConcat(
          5)).TupleConcat(10)).TupleConcat(6)).TupleConcat(4)).TupleConcat(8)).TupleConcat(
          9));
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_DLSamples = hv_DLSamples.TupleConcat(
          hv_DLSample);
      hv_DLSamples.Dispose();
      hv_DLSamples = ExpTmpLocalVar_DLSamples;
      }
      }
      //
      hv_DLSample.Dispose();
      HOperatorSet.CreateDict(out hv_DLSample);
      HOperatorSet.SetDictTuple(hv_DLSample, "image_id", 287);
      HOperatorSet.SetDictTuple(hv_DLSample, "image_file_name", "pill_bag/pill_bag_287.png");
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row1", (((((((((new HTuple(152)).TupleConcat(
          157)).TupleConcat(218)).TupleConcat(255)).TupleConcat(206)).TupleConcat(
          298)).TupleConcat(417)).TupleConcat(552)).TupleConcat(547)).TupleConcat(
          563));
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col1", (((((((((new HTuple(948)).TupleConcat(
          712)).TupleConcat(745)).TupleConcat(587)).TupleConcat(393)).TupleConcat(
          419)).TupleConcat(378)).TupleConcat(409)).TupleConcat(723)).TupleConcat(
          935));
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row2", (((((((((new HTuple(272)).TupleConcat(
          270)).TupleConcat(355)).TupleConcat(376)).TupleConcat(313)).TupleConcat(
          432)).TupleConcat(599)).TupleConcat(636)).TupleConcat(637)).TupleConcat(
          650));
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col2", (((((((((new HTuple(1072)).TupleConcat(
          918)).TupleConcat(972)).TupleConcat(714)).TupleConcat(606)).TupleConcat(
          554)).TupleConcat(581)).TupleConcat(495)).TupleConcat(939)).TupleConcat(
          1021));
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_label_id", (((((((((new HTuple(7)).TupleConcat(
          8)).TupleConcat(1)).TupleConcat(2)).TupleConcat(4)).TupleConcat(3)).TupleConcat(
          1)).TupleConcat(5)).TupleConcat(4)).TupleConcat(9));
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_DLSamples = hv_DLSamples.TupleConcat(
          hv_DLSample);
      hv_DLSamples.Dispose();
      hv_DLSamples = ExpTmpLocalVar_DLSamples;
      }
      }
      //
      hv_DLSample.Dispose();
      HOperatorSet.CreateDict(out hv_DLSample);
      HOperatorSet.SetDictTuple(hv_DLSample, "image_id", 141);
      HOperatorSet.SetDictTuple(hv_DLSample, "image_file_name", "pill_bag/pill_bag_141.png");
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row1", ((((((((((new HTuple(451)).TupleConcat(
          502)).TupleConcat(364)).TupleConcat(213)).TupleConcat(328)).TupleConcat(
          229)).TupleConcat(435)).TupleConcat(478)).TupleConcat(369)).TupleConcat(
          432)).TupleConcat(144));
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col1", ((((((((((new HTuple(503)).TupleConcat(
          394)).TupleConcat(411)).TupleConcat(723)).TupleConcat(786)).TupleConcat(
          493)).TupleConcat(616)).TupleConcat(684)).TupleConcat(915)).TupleConcat(
          371)).TupleConcat(718));
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row2", ((((((((((new HTuple(570)).TupleConcat(
          619)).TupleConcat(464)).TupleConcat(329)).TupleConcat(404)).TupleConcat(
          361)).TupleConcat(517)).TupleConcat(563)).TupleConcat(554)).TupleConcat(
          514)).TupleConcat(222));
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col2", ((((((((((new HTuple(622)).TupleConcat(
          512)).TupleConcat(545)).TupleConcat(847)).TupleConcat(998)).TupleConcat(
          627)).TupleConcat(698)).TupleConcat(898)).TupleConcat(1108)).TupleConcat(
          452)).TupleConcat(930));
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_label_id", ((((((((((new HTuple(7)).TupleConcat(
          7)).TupleConcat(2)).TupleConcat(2)).TupleConcat(10)).TupleConcat(3)).TupleConcat(
          9)).TupleConcat(4)).TupleConcat(6)).TupleConcat(5)).TupleConcat(8));
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_DLSamples = hv_DLSamples.TupleConcat(
          hv_DLSample);
      hv_DLSamples.Dispose();
      hv_DLSamples = ExpTmpLocalVar_DLSamples;
      }
      }
      //
      hv_DLSample.Dispose();
      HOperatorSet.CreateDict(out hv_DLSample);
      HOperatorSet.SetDictTuple(hv_DLSample, "image_id", 337);
      HOperatorSet.SetDictTuple(hv_DLSample, "image_file_name", "pill_bag/pill_bag_337.png");
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row1", ((((((((new HTuple(176)).TupleConcat(
          131)).TupleConcat(163)).TupleConcat(235)).TupleConcat(270)).TupleConcat(
          367)).TupleConcat(413)).TupleConcat(321)).TupleConcat(426));
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col1", ((((((((new HTuple(959)).TupleConcat(
          669)).TupleConcat(404)).TupleConcat(610)).TupleConcat(396)).TupleConcat(
          894)).TupleConcat(579)).TupleConcat(1037)).TupleConcat(794));
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row2", ((((((((new HTuple(279)).TupleConcat(
          250)).TupleConcat(265)).TupleConcat(319)).TupleConcat(394)).TupleConcat(
          467)).TupleConcat(505)).TupleConcat(535)).TupleConcat(590));
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col2", ((((((((new HTuple(1097)).TupleConcat(
          790)).TupleConcat(642)).TupleConcat(695)).TupleConcat(597)).TupleConcat(
          1039)).TupleConcat(722)).TupleConcat(1132)).TupleConcat(1011));
      HOperatorSet.SetDictTuple(hv_DLSample, "bbox_label_id", ((((((((new HTuple(2)).TupleConcat(
          7)).TupleConcat(1)).TupleConcat(5)).TupleConcat(8)).TupleConcat(2)).TupleConcat(
          2)).TupleConcat(4)).TupleConcat(1));
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_DLSamples = hv_DLSamples.TupleConcat(
          hv_DLSample);
      hv_DLSamples.Dispose();
      hv_DLSamples = ExpTmpLocalVar_DLSamples;
      }
      }
      //
      HOperatorSet.SetDictTuple(hv_DLDataset, "samples", hv_DLSamples);
      //

      hv_HalconExampleDir.Dispose();
      hv_HalconImageDir.Dispose();
      hv_DLSamples.Dispose();
      hv_DLSample.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_HalconExampleDir.Dispose();
      hv_HalconImageDir.Dispose();
      hv_DLSamples.Dispose();
      hv_DLSample.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_close_example_image_window (HTuple hv_ExampleInternals)
  {



    // Local control variables 

    HTuple hv_WindowHandleImages = new HTuple();
    HTuple hv_Exception = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure closes the image window.
      //
      try
      {
        hv_WindowHandleImages.Dispose();
        HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images", out hv_WindowHandleImages);
        HDevWindowStack.SetActive(hv_WindowHandleImages);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.CloseWindow(HDevWindowStack.Pop());
        }
        //Delete key.
        HOperatorSet.RemoveDictKey(hv_ExampleInternals, "window_images");
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
      }
      //

      hv_WindowHandleImages.Dispose();
      hv_Exception.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_WindowHandleImages.Dispose();
      hv_Exception.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_close_example_legend_window (HTuple hv_ExampleInternals)
  {



    // Local control variables 

    HTuple hv_WindowHandleLegend = new HTuple();
    HTuple hv_Exception = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure closes the legend window.
      //
      try
      {
        hv_WindowHandleLegend.Dispose();
        HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_legend", out hv_WindowHandleLegend);
        HDevWindowStack.SetActive(hv_WindowHandleLegend);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.CloseWindow(HDevWindowStack.Pop());
        }
        //Delete key.
        HOperatorSet.RemoveDictKey(hv_ExampleInternals, "window_legend");
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
      }
      //

      hv_WindowHandleLegend.Dispose();
      hv_Exception.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_WindowHandleLegend.Dispose();
      hv_Exception.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_close_example_windows (HTuple hv_ExampleInternals)
  {



    // Local control variables 

    HTuple hv_ShowExampleScreens = new HTuple();
    HTuple hv_Keys = new HTuple(), hv_Index = new HTuple();
    HTuple hv_WindowHandle = new HTuple(), hv_Exception = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure closes all example windows.
      //
      hv_ShowExampleScreens.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
      if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
      {

        hv_ShowExampleScreens.Dispose();
        hv_Keys.Dispose();
        hv_Index.Dispose();
        hv_WindowHandle.Dispose();
        hv_Exception.Dispose();

        return;
      }
      //
      hv_Keys.Dispose();
      HOperatorSet.GetDictParam(hv_ExampleInternals, "keys", new HTuple(), out hv_Keys);
      for (hv_Index=0; (int)hv_Index<=(int)(new HTuple(hv_Keys.TupleLength())); hv_Index = (int)hv_Index + 1)
      {
        try
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_WindowHandle.Dispose();
          HOperatorSet.GetDictTuple(hv_ExampleInternals, hv_Keys.TupleSelect(hv_Index), 
              out hv_WindowHandle);
          }
          HDevWindowStack.SetActive(hv_WindowHandle);
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.CloseWindow(HDevWindowStack.Pop());
          }
        }
        // catch (Exception) 
        catch (HalconException HDevExpDefaultException1)
        {
          HDevExpDefaultException1.ToHTuple(out hv_Exception);
        }
      }
      //

      hv_ShowExampleScreens.Dispose();
      hv_Keys.Dispose();
      hv_Index.Dispose();
      hv_WindowHandle.Dispose();
      hv_Exception.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_ShowExampleScreens.Dispose();
      hv_Keys.Dispose();
      hv_Index.Dispose();
      hv_WindowHandle.Dispose();
      hv_Exception.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_disp_end_of_program (HTuple hv_ExampleInternals)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ShowExampleScreens = new HTuple();
    HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure closes all example windows.
      //
      hv_ShowExampleScreens.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
      if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
      {

        hv_ShowExampleScreens.Dispose();
        hv_WindowHandleText.Dispose();
        hv_Text.Dispose();

        return;
      }
      //
      //Reset the open windows for a clean display.
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
      dev_display_example_reset_windows(hv_ExampleInternals);
      //
      //Display explanatory text.
      hv_WindowHandleText.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
      HDevWindowStack.SetActive(hv_WindowHandleText);
      //
      hv_Text.Dispose();
      hv_Text = "Now the first part 'Creation of the model and dataset preprocessing'";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "of the workflow for DL object detection is finished.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "The model and the dataset are ready for training.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "To get to the example of the DL object detection training";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("process, please run 'detect_pills_deep_learning_2_train.hdev'.");
      //
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
            "left", "black", "box", "true");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Please open the next example.", 
            "window", "bottom", "right", "black", new HTuple(), new HTuple());
      }
      //

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_example_reset_windows (HTuple hv_ExampleInternals)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_WindowHandlesToClose = new HTuple();
    HTuple hv_Exception = new HTuple(), hv_I = new HTuple();
    HTuple hv_WindowHandleKeys = new HTuple(), hv_Index = new HTuple();
    HTuple hv_WindowImagesNeeded = new HTuple(), hv_WindowLegendNeeded = new HTuple();
    HTuple hv_WindowHandleImages = new HTuple(), hv_WindowHandleLegend = new HTuple();
    HTuple hv_WindowHandleText = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure resets the graphics windows.
      //
      //Close any windows that are listed in key 'window_handles_to_close'.
      try
      {
        hv_WindowHandlesToClose.Dispose();
        HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_handles_to_close", 
            out hv_WindowHandlesToClose);
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        hv_WindowHandlesToClose.Dispose();
        hv_WindowHandlesToClose = new HTuple();
      }
      for (hv_I=0; (int)hv_I<=(int)((new HTuple(hv_WindowHandlesToClose.TupleLength()
          ))-1); hv_I = (int)hv_I + 1)
      {
        HDevWindowStack.SetActive(hv_WindowHandlesToClose.TupleSelect(
            hv_I));
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.CloseWindow(HDevWindowStack.Pop());
        }
      }
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_handles_to_close", new HTuple());
      //
      //Open image window if needed.
      hv_WindowHandleKeys.Dispose();
      HOperatorSet.GetDictParam(hv_ExampleInternals, "keys", new HTuple(), out hv_WindowHandleKeys);
      hv_Index.Dispose();
      HOperatorSet.TupleFind(hv_WindowHandleKeys, "window_images", out hv_Index);
      hv_WindowImagesNeeded.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_needed", out hv_WindowImagesNeeded);
      if ((int)(hv_WindowImagesNeeded.TupleAnd(new HTuple(hv_Index.TupleEqual(-1)))) != 0)
      {
        //Open new window for images.
        dev_open_example_image_window(hv_ExampleInternals);
      }
      else if ((int)((new HTuple(hv_WindowImagesNeeded.TupleNot())).TupleAnd(
          new HTuple(hv_Index.TupleNotEqual(-1)))) != 0)
      {
        //Window for images exists but is not needed -> close it.
        dev_close_example_image_window(hv_ExampleInternals);
      }
      //
      //Open legend window if needed.
      hv_WindowHandleKeys.Dispose();
      HOperatorSet.GetDictParam(hv_ExampleInternals, "keys", new HTuple(), out hv_WindowHandleKeys);
      hv_Index.Dispose();
      HOperatorSet.TupleFind(hv_WindowHandleKeys, "window_legend", out hv_Index);
      hv_WindowLegendNeeded.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_legend_needed", out hv_WindowLegendNeeded);
      if ((int)(hv_WindowLegendNeeded.TupleAnd(new HTuple(hv_Index.TupleEqual(-1)))) != 0)
      {
        //Open new window for legend.
        dev_open_example_legend_window(hv_ExampleInternals, 290);
      }
      else if ((int)((new HTuple(hv_WindowLegendNeeded.TupleNot())).TupleAnd(
          new HTuple(hv_Index.TupleNotEqual(-1)))) != 0)
      {
        //Window for legend exists but is not needed -> close it.
        dev_close_example_legend_window(hv_ExampleInternals);
      }
      //
      //Set the correct area (part) of the image window.
      try
      {
        hv_WindowHandleImages.Dispose();
        HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images", out hv_WindowHandleImages);
        HDevWindowStack.SetActive(hv_WindowHandleImages);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
        }
        //Set default window extends
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), 360, 0, 800, 
              500);
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetPart(HDevWindowStack.GetActive(), 1, 1, -1, -1);
        }
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
      }
      //
      //Set the correct area (part) of the legend window.
      try
      {
        hv_WindowHandleLegend.Dispose();
        HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_legend", out hv_WindowHandleLegend);
        HDevWindowStack.SetActive(hv_WindowHandleLegend);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
        }
        //Set default window extends
        if (HDevWindowStack.IsOpen())
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), 360, 800+5, 
              290, 500);
          }
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetPart(HDevWindowStack.GetActive(), 1, 1, -1, -1);
        }
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
      }
      hv_WindowHandleText.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
      HDevWindowStack.SetActive(hv_WindowHandleText);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
      }

      hv_WindowHandlesToClose.Dispose();
      hv_Exception.Dispose();
      hv_I.Dispose();
      hv_WindowHandleKeys.Dispose();
      hv_Index.Dispose();
      hv_WindowImagesNeeded.Dispose();
      hv_WindowLegendNeeded.Dispose();
      hv_WindowHandleImages.Dispose();
      hv_WindowHandleLegend.Dispose();
      hv_WindowHandleText.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_WindowHandlesToClose.Dispose();
      hv_Exception.Dispose();
      hv_I.Dispose();
      hv_WindowHandleKeys.Dispose();
      hv_Index.Dispose();
      hv_WindowImagesNeeded.Dispose();
      hv_WindowLegendNeeded.Dispose();
      hv_WindowHandleImages.Dispose();
      hv_WindowHandleLegend.Dispose();
      hv_WindowHandleText.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_pill_bags_example_dataset_preview (HTuple hv_ExampleInternals)
  {



    // Local iconic variables 

    HObject ho_Image=null, ho_TiledImage=null;

    // Local control variables 

    HTuple hv_PillBagPath1 = new HTuple(), hv_PillBagPath2 = new HTuple();
    HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
    HTuple hv_WindowImages = new HTuple(), hv_Exception = new HTuple();
    HTuple hv_WindowText = new HTuple(), hv_ErrorAndAdviceText = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    HOperatorSet.GenEmptyObj(out ho_TiledImage);
    try
    {
      //This procedure displays a selection of pill bag images.
      //
      try
      {
        //Read some example images.
        hv_PillBagPath1.Dispose();
        hv_PillBagPath1 = "pill_bag/pill_bag_001";
        hv_PillBagPath2.Dispose();
        hv_PillBagPath2 = "pill_bag/pill_bag_002";
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_Image.Dispose();
        HOperatorSet.ReadImage(out ho_Image, hv_PillBagPath1.TupleConcat(hv_PillBagPath2));
        }
        ho_TiledImage.Dispose();
        HOperatorSet.TileImages(ho_Image, out ho_TiledImage, 2, "horizontal");
        //Generate background image.
        hv_Width.Dispose();hv_Height.Dispose();
        HOperatorSet.GetImageSize(ho_TiledImage, out hv_Width, out hv_Height);
        //Get the image window handle.
        dev_open_example_image_window(hv_ExampleInternals);
        hv_WindowImages.Dispose();
        HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images", out hv_WindowImages);
        HDevWindowStack.SetActive(hv_WindowImages);
        if (HDevWindowStack.IsOpen())
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), 360, 0, hv_Width/3.0, 
              hv_Height/3.0);
          }
        }
        //Display the background and the images.
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_Height, hv_Width);
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_TiledImage, HDevWindowStack.GetActive());
        }
      }
      // catch (Exception) 
      catch (HalconException HDevExpDefaultException1)
      {
        HDevExpDefaultException1.ToHTuple(out hv_Exception);
        hv_WindowText.Dispose();
        HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowText);
        HDevWindowStack.SetActive(hv_WindowText);
        //If the example image files are not found, an error message is displayed.
        hv_ErrorAndAdviceText.Dispose();
        hv_ErrorAndAdviceText = "The images required for this example could not be found.";
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ErrorAndAdviceText = hv_ErrorAndAdviceText.TupleConcat(
            "");
        hv_ErrorAndAdviceText.Dispose();
        hv_ErrorAndAdviceText = ExpTmpLocalVar_ErrorAndAdviceText;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ErrorAndAdviceText = hv_ErrorAndAdviceText.TupleConcat(
            "These images are part of a separate installer. Please");
        hv_ErrorAndAdviceText.Dispose();
        hv_ErrorAndAdviceText = ExpTmpLocalVar_ErrorAndAdviceText;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ErrorAndAdviceText = hv_ErrorAndAdviceText.TupleConcat(
            "refer to the Installation Guide for more information on");
        hv_ErrorAndAdviceText.Dispose();
        hv_ErrorAndAdviceText = ExpTmpLocalVar_ErrorAndAdviceText;
        }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_ErrorAndAdviceText = hv_ErrorAndAdviceText.TupleConcat(
            "this topic!");
        hv_ErrorAndAdviceText.Dispose();
        hv_ErrorAndAdviceText = ExpTmpLocalVar_ErrorAndAdviceText;
        }
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
        }
        set_display_font(hv_WindowText, 20, "mono", "true", "false");
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ErrorAndAdviceText, 
              "window", "top", "left", "red", new HTuple(), new HTuple());
        }
        set_display_font(hv_WindowText, 16, "mono", "true", "false");
      }
      ho_Image.Dispose();
      ho_TiledImage.Dispose();

      hv_PillBagPath1.Dispose();
      hv_PillBagPath2.Dispose();
      hv_Width.Dispose();
      hv_Height.Dispose();
      hv_WindowImages.Dispose();
      hv_Exception.Dispose();
      hv_WindowText.Dispose();
      hv_ErrorAndAdviceText.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Image.Dispose();
      ho_TiledImage.Dispose();

      hv_PillBagPath1.Dispose();
      hv_PillBagPath2.Dispose();
      hv_Width.Dispose();
      hv_Height.Dispose();
      hv_WindowImages.Dispose();
      hv_Exception.Dispose();
      hv_WindowText.Dispose();
      hv_ErrorAndAdviceText.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_screen_detection_data_part_1 (HTuple hv_ExampleInternals)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ShowExampleScreens = new HTuple();
    HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure introduces read_dl_dataset_from_coco.
      //
      hv_ShowExampleScreens.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
      if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
      {

        hv_ShowExampleScreens.Dispose();
        hv_WindowHandleText.Dispose();
        hv_Text.Dispose();

        return;
      }
      //
      //Reset the open windows for a clean display.
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
      dev_display_example_reset_windows(hv_ExampleInternals);
      //
      //Display explanatory text.
      hv_WindowHandleText.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
      HDevWindowStack.SetActive(hv_WindowHandleText);
      //
      hv_Text.Dispose();
      hv_Text = "Step 1.1: Read the dataset";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "Data used for DL object detection need to be labeled with";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "bounding boxes. ";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("Here, we use a dataset that has been labeled already.");
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "It is saved in a COCO file and so we read it";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "using the procedure 'read_dl_dataset_from_coco'.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("A DLDataset dictionary created by e.g.,");
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "the MVTec Deep Learning Tool can be read using read_dict().";
      //
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
            "left", "black", "box", "true");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to see a few example images", 
            "window", "bottom", "right", "black", "box", "true");
      }
      //

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_screen_detection_data_part_2 (HTuple hv_ExampleInternals)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ShowExampleScreens = new HTuple();
    HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
    HTuple hv_DLPreprocessParam = new HTuple(), hv_DLDataset = new HTuple();
    HTuple hv_WindowHandleLegend = new HTuple(), hv_WindowHandleDict = new HTuple();
    HTuple hv_GenParamValue = new HTuple(), hv_WindowHandleImages = new HTuple();
    HTuple hv_WindowImageColumn1 = new HTuple(), hv_WindowImageRow1 = new HTuple();
    HTuple hv_WindowImageWidth = new HTuple(), hv_WindowImageHeight = new HTuple();
    HTuple hv_Row = new HTuple(), hv_Column = new HTuple();
    HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
    HTuple hv_DLSamples = new HTuple(), hv_DLSampleIndices = new HTuple();
    HTuple hv_DLSampleIndicesShuffled = new HTuple(), hv_Idx = new HTuple();
    HTuple hv_DLSample = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure displays example images of the dataset.
      //
      hv_ShowExampleScreens.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
      if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
      {

        hv_ShowExampleScreens.Dispose();
        hv_WindowHandleText.Dispose();
        hv_Text.Dispose();
        hv_DLPreprocessParam.Dispose();
        hv_DLDataset.Dispose();
        hv_WindowHandleLegend.Dispose();
        hv_WindowHandleDict.Dispose();
        hv_GenParamValue.Dispose();
        hv_WindowHandleImages.Dispose();
        hv_WindowImageColumn1.Dispose();
        hv_WindowImageRow1.Dispose();
        hv_WindowImageWidth.Dispose();
        hv_WindowImageHeight.Dispose();
        hv_Row.Dispose();
        hv_Column.Dispose();
        hv_Width.Dispose();
        hv_Height.Dispose();
        hv_DLSamples.Dispose();
        hv_DLSampleIndices.Dispose();
        hv_DLSampleIndicesShuffled.Dispose();
        hv_Idx.Dispose();
        hv_DLSample.Dispose();

        return;
      }
      //
      //Reset the open windows for a clean display.
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 1);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 1);
      dev_display_example_reset_windows(hv_ExampleInternals);
      //
      //Display explanatory text.
      hv_WindowHandleText.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
      HDevWindowStack.SetActive(hv_WindowHandleText);
      //
      hv_Text.Dispose();
      hv_Text = "Step 1.1: Read the dataset";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "Data used for DL object detection need to be labeled with";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "bounding boxes. ";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("Here, we use a dataset that has been labeled already.");
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "It is saved in a COCO file and so we read it";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "using the procedure 'read_dl_dataset_from_coco'.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("A DLDataset dictionary created by e.g.,");
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "the MVTec Deep Learning Tool can be read using read_dict().";
      //
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
            "left", "black", "box", "true");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Please wait ...", "window", 
            "bottom", "right", "black", new HTuple(), new HTuple());
      }
      //
      //Display example image.
      hv_DLPreprocessParam.Dispose();
      HOperatorSet.CreateDict(out hv_DLPreprocessParam);
      HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "model_type", "detection");
      HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "image_height", 320);
      HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "image_width", 512);
      HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "image_num_channels", 3);
      HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "image_range_min", -127);
      HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "image_range_max", 128);
      HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "domain_handling", "full_domain");
      HOperatorSet.SetDictTuple(hv_DLPreprocessParam, "normalization_type", "none");
      //
      //Read a tiny dataset that is a subset of the pill bag dataset.
      hv_DLDataset.Dispose();
      create_tiny_example_dataset(out hv_DLDataset);
      //
      //Display a temporary legend.
      hv_WindowHandleLegend.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_legend", out hv_WindowHandleLegend);
      HDevWindowStack.SetActive(hv_WindowHandleLegend);
      //
      hv_WindowHandleDict.Dispose();
      HOperatorSet.CreateDict(out hv_WindowHandleDict);
      hv_GenParamValue.Dispose();
      HOperatorSet.GetDictParam(hv_ExampleInternals, "keys", new HTuple(), out hv_GenParamValue);
      hv_WindowHandleImages.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images", out hv_WindowHandleImages);
      HDevWindowStack.SetActive(hv_WindowHandleImages);
      //To display the Text at the bottom of the image such that the image is undistorted,
      //change size of windows.
      hv_WindowImageColumn1.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_x", out hv_WindowImageColumn1);
      hv_WindowImageRow1.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_y", out hv_WindowImageRow1);
      hv_WindowImageWidth.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_width", out hv_WindowImageWidth);
      hv_WindowImageHeight.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_height", out hv_WindowImageHeight);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_WindowImageHeight = hv_WindowImageHeight+39.88;
      hv_WindowImageHeight.Dispose();
      hv_WindowImageHeight = ExpTmpLocalVar_WindowImageHeight;
      }
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_WindowImageRow1, 
            hv_WindowImageColumn1, hv_WindowImageWidth, hv_WindowImageHeight);
      }
      //Same for legend window
      hv_Row.Dispose();hv_Column.Dispose();hv_Width.Dispose();hv_Height.Dispose();
      HOperatorSet.GetWindowExtents(hv_WindowHandleLegend, out hv_Row, out hv_Column, 
          out hv_Width, out hv_Height);
      HDevWindowStack.SetActive(hv_WindowHandleLegend);
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_WindowImageRow1, 
            (hv_WindowImageColumn1+hv_WindowImageWidth)+5, 290, hv_WindowImageHeight);
        }
      }
      HDevWindowStack.SetActive(hv_WindowHandleImages);
      //
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      HOperatorSet.SetDictTuple(hv_WindowHandleDict, "bbox_ground_truth", hv_WindowHandleImages.TupleConcat(
          hv_WindowHandleLegend));
      }
      hv_DLSamples.Dispose();
      HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLSamples);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_DLSampleIndices.Dispose();
      HOperatorSet.TupleGenSequence(0, (new HTuple(hv_DLSamples.TupleLength()))-1, 
          1, out hv_DLSampleIndices);
      }
      HOperatorSet.SetSystem("seed_rand", 42);
      hv_DLSampleIndicesShuffled.Dispose();
      tuple_shuffle(hv_DLSampleIndices, out hv_DLSampleIndicesShuffled);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_DLSampleIndicesShuffled = hv_DLSampleIndicesShuffled.TupleSelectRange(
          0,4);
      hv_DLSampleIndicesShuffled.Dispose();
      hv_DLSampleIndicesShuffled = ExpTmpLocalVar_DLSampleIndicesShuffled;
      }
      }
      //
      //Display all samples contained in tiny dataset.
      hv_DLSamples.Dispose();
      HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLSamples);
      for (hv_Idx=0; (int)hv_Idx<=(int)((new HTuple(hv_DLSamples.TupleLength()))-1); hv_Idx = (int)hv_Idx + 1)
      {
        hv_DLSample.Dispose();
        gen_dl_samples(hv_DLDataset, hv_Idx, "detection", new HTuple(), out hv_DLSample);
        //Display samples.
        dev_display_dl_data(hv_DLSample, new HTuple(), hv_DLDataset, "bbox_ground_truth", 
            new HTuple(), hv_WindowHandleDict);
        //
        HDevWindowStack.SetActive(hv_WindowHandleLegend);
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispText(HDevWindowStack.GetActive(), "Please wait ...", "window", 
              "bottom", "right", "black", new HTuple(), new HTuple());
        }
        HOperatorSet.WaitSeconds(2);
      }
      //
      HDevWindowStack.SetActive(hv_WindowHandleText);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", 
            "window", "bottom", "right", "black", new HTuple(), new HTuple());
      }
      HDevWindowStack.SetActive(hv_WindowHandleLegend);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", 
            "window", "bottom", "right", "black", new HTuple(), new HTuple());
      }
      //

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();
      hv_DLPreprocessParam.Dispose();
      hv_DLDataset.Dispose();
      hv_WindowHandleLegend.Dispose();
      hv_WindowHandleDict.Dispose();
      hv_GenParamValue.Dispose();
      hv_WindowHandleImages.Dispose();
      hv_WindowImageColumn1.Dispose();
      hv_WindowImageRow1.Dispose();
      hv_WindowImageWidth.Dispose();
      hv_WindowImageHeight.Dispose();
      hv_Row.Dispose();
      hv_Column.Dispose();
      hv_Width.Dispose();
      hv_Height.Dispose();
      hv_DLSamples.Dispose();
      hv_DLSampleIndices.Dispose();
      hv_DLSampleIndicesShuffled.Dispose();
      hv_Idx.Dispose();
      hv_DLSample.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();
      hv_DLPreprocessParam.Dispose();
      hv_DLDataset.Dispose();
      hv_WindowHandleLegend.Dispose();
      hv_WindowHandleDict.Dispose();
      hv_GenParamValue.Dispose();
      hv_WindowHandleImages.Dispose();
      hv_WindowImageColumn1.Dispose();
      hv_WindowImageRow1.Dispose();
      hv_WindowImageWidth.Dispose();
      hv_WindowImageHeight.Dispose();
      hv_Row.Dispose();
      hv_Column.Dispose();
      hv_Width.Dispose();
      hv_Height.Dispose();
      hv_DLSamples.Dispose();
      hv_DLSampleIndices.Dispose();
      hv_DLSampleIndicesShuffled.Dispose();
      hv_Idx.Dispose();
      hv_DLSample.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_screen_generate_model_parameters (HTuple hv_ExampleInternals)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ShowExampleScreens = new HTuple();
    HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure introduces determine_dl_model_detection_param.
      //
      hv_ShowExampleScreens.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
      if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
      {

        hv_ShowExampleScreens.Dispose();
        hv_WindowHandleText.Dispose();
        hv_Text.Dispose();

        return;
      }
      //
      //Reset the open windows for a clean display.
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
      dev_display_example_reset_windows(hv_ExampleInternals);
      //
      //Display explanatory text.
      hv_WindowHandleText.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
      HDevWindowStack.SetActive(hv_WindowHandleText);
      //
      hv_Text.Dispose();
      hv_Text = "Step 2: Generate model parameters from dataset";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("Since the previously mentioned model parameters 'min_level',");
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("'max_level', 'anchor_num_subscales', and");
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("'anchor_aspect_ratios' depend on the reference bounding boxes,");
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "it is possible to optimize these parameters by analyzing the";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "dataset.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("Therefore, the procedure 'determine_dl_model_detection_param'");
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "can be used to generate value suggestions.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      //
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
            "left", "black", "box", "true");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", 
            "window", "bottom", "right", "black", new HTuple(), new HTuple());
      }
      //

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_screen_introduction_model (HTuple hv_ExampleInternals)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ShowExampleScreens = new HTuple();
    HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure explains the obligatory parameters for model creation.
      //
      hv_ShowExampleScreens.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
      if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
      {

        hv_ShowExampleScreens.Dispose();
        hv_WindowHandleText.Dispose();
        hv_Text.Dispose();

        return;
      }
      //
      //Reset the open windows for a clean display.
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
      dev_display_example_reset_windows(hv_ExampleInternals);
      //
      //Display explanatory text.
      hv_WindowHandleText.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
      HDevWindowStack.SetActive(hv_WindowHandleText);
      //
      hv_Text.Dispose();
      hv_Text = "Step 2: Creation of an object detection model";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "Create a DL object detection model using 'create_dl_model_detection'.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "There are two parameters that have to be set at least:";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "- Backbone:   Pretrained network used for extracting feature maps";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "- NumClasses: Number of classes";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "Other model parameters can be customized optionally. The most";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "important ones are explained in the following screens.";
      //
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
            "left", "black", "box", "true");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", 
            "window", "bottom", "right", "black", new HTuple(), new HTuple());
      }
      //

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_screen_introduction_part_1 (HTuple hv_ExampleInternals)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ShowExampleScreens = new HTuple();
    HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure displays an overview on the different example parts.
      //
      hv_ShowExampleScreens.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
      if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
      {

        hv_ShowExampleScreens.Dispose();
        hv_WindowHandleText.Dispose();
        hv_Text.Dispose();

        return;
      }
      //
      //Reset the open windows for a clean display.
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
      dev_display_example_reset_windows(hv_ExampleInternals);
      //
      //Display explanatory text.
      hv_WindowHandleText.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
      HDevWindowStack.SetActive(hv_WindowHandleText);
      //
      hv_Text.Dispose();
      hv_Text = new HTuple("This example is part of a series of examples, which summarize the");
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "workflow for DL object detection. It uses the MVTec pill bag dataset.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "The four parts are: ";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "1. Creation of the model and dataset preprocessing.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "2. Training of the model.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "3. Evaluation of the trained model.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "4. Inference on new images.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "This example covers part 1:";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "'Creation of the model and dataset preprocessing'.";
      //
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
            "left", "black", "box", "true");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", 
            "window", "bottom", "right", "black", new HTuple(), new HTuple());
      }
      //

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_screen_introduction_part_2 (HTuple hv_ExampleInternals)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ShowExampleScreens = new HTuple();
    HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure displays an overview of this example
      //and some example images.
      //
      hv_ShowExampleScreens.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
      if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
      {

        hv_ShowExampleScreens.Dispose();
        hv_WindowHandleText.Dispose();
        hv_Text.Dispose();

        return;
      }
      //
      //Reset the open windows for a clean display.
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
      dev_display_example_reset_windows(hv_ExampleInternals);
      //
      //Display explanatory text.
      hv_WindowHandleText.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
      HDevWindowStack.SetActive(hv_WindowHandleText);
      //
      hv_Text.Dispose();
      hv_Text = "This example covers the following three main steps:";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = " - how labeled data is read and split for training";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = " - how a DL Object Detection model is created and";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = " - how the labeled data is preprocessed to be";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "   suitable for training with the created model.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "The separate steps will be explained in the following screens.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("Below, you see some example images of the MVTec pill bag dataset.");
      //
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
            "left", "black", "box", "true");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", 
            "window", "bottom", "right", "black", new HTuple(), new HTuple());
      }
      //
      //Display example images.
      dev_display_pill_bags_example_dataset_preview(hv_ExampleInternals);
      //

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_screen_model_anchor_aspect_ratios (HTuple hv_ExampleInternals)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_Image, ho_ReferenceBox1, ho_ReferenceBox2;
    HObject ho_ReferenceBox3;

    // Local control variables 

    HTuple hv_ShowExampleScreens = new HTuple();
    HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
    HTuple hv_WindowHandleImages = new HTuple(), hv_ImageWidth = new HTuple();
    HTuple hv_ImageHeight = new HTuple(), hv_ImageZoomWidth = new HTuple();
    HTuple hv_ImageZoomHeight = new HTuple(), hv_ImageToZoomRatio = new HTuple();
    HTuple hv_Colors = new HTuple(), hv_Sequence = new HTuple();
    HTuple hv_WindowHandleLegend = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    HOperatorSet.GenEmptyObj(out ho_ReferenceBox1);
    HOperatorSet.GenEmptyObj(out ho_ReferenceBox2);
    HOperatorSet.GenEmptyObj(out ho_ReferenceBox3);
    try
    {
      //This procedure displays an introduction about the choice of anchor_aspect_ratios.
      //
      hv_ShowExampleScreens.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
      if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
      {
        ho_Image.Dispose();
        ho_ReferenceBox1.Dispose();
        ho_ReferenceBox2.Dispose();
        ho_ReferenceBox3.Dispose();

        hv_ShowExampleScreens.Dispose();
        hv_WindowHandleText.Dispose();
        hv_Text.Dispose();
        hv_WindowHandleImages.Dispose();
        hv_ImageWidth.Dispose();
        hv_ImageHeight.Dispose();
        hv_ImageZoomWidth.Dispose();
        hv_ImageZoomHeight.Dispose();
        hv_ImageToZoomRatio.Dispose();
        hv_Colors.Dispose();
        hv_Sequence.Dispose();
        hv_WindowHandleLegend.Dispose();

        return;
      }
      //
      //Reset the open windows for a clean display.
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 1);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 1);
      dev_display_example_reset_windows(hv_ExampleInternals);
      //
      //Display explanatory text.
      hv_WindowHandleText.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
      HDevWindowStack.SetActive(hv_WindowHandleText);
      //
      hv_Text.Dispose();
      hv_Text = "Step 2: Generic model parameter 'anchor_aspect_ratios'";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("In general, a dataset contains objects with different shapes.");
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("To improve finding non-squared objects, set arbitrary aspect");
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "ratios using 'anchor_aspect_ratios'.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "All user defined generic model parameters are set in a";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("dictionary, which is used by 'create_dl_model_detection'");
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "to create the DL object detection model.";
      //
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
            "left", "black", "box", "true");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", 
            "window", "bottom", "right", "black", new HTuple(), new HTuple());
      }
      //
      //Display example image.
      hv_WindowHandleImages.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images", out hv_WindowHandleImages);
      HDevWindowStack.SetActive(hv_WindowHandleImages);
      HOperatorSet.SetWindowParam(hv_WindowHandleImages, "flush", "false");
      //Display image.
      ho_Image.Dispose();
      HOperatorSet.ReadImage(out ho_Image, "pill_bag/pill_bag_001.png");
      hv_ImageWidth.Dispose();hv_ImageHeight.Dispose();
      HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
      hv_ImageZoomWidth.Dispose();
      hv_ImageZoomWidth = 512;
      hv_ImageZoomHeight.Dispose();
      hv_ImageZoomHeight = 320;
      hv_ImageToZoomRatio.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ImageToZoomRatio = (hv_ImageZoomHeight.TupleReal()
          )/(hv_ImageHeight.TupleReal());
      }
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ZoomImageSize(ho_Image, out ExpTmpOutVar_0, hv_ImageZoomWidth, 
          hv_ImageZoomHeight, "constant");
      ho_Image.Dispose();
      ho_Image = ExpTmpOutVar_0;
      }
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_ImageZoomHeight-1, 
            hv_ImageZoomWidth-1);
        }
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
      }
      //Display anchors.
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
      }
      hv_Colors.Dispose();
      get_distinct_colors(3, 0, 0, 128, out hv_Colors);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Sequence.Dispose();
      HOperatorSet.TupleGenSequence((new HTuple(hv_Colors.TupleLength()))-1, 0, -1, 
          out hv_Sequence);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Colors = hv_Colors.TupleSelect(
          hv_Sequence);
      hv_Colors.Dispose();
      hv_Colors = ExpTmpLocalVar_Colors;
      }
      }
      HOperatorSet.SetWindowParam(hv_WindowHandleImages, "flush", "false");
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 3);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_ReferenceBox1.Dispose();
      HOperatorSet.GenRectangle2(out ho_ReferenceBox1, hv_ImageToZoomRatio*206, hv_ImageToZoomRatio*560, 
          0, 2*((new HTuple(2)).TuplePow(3)), 2*((new HTuple(2)).TuplePow(3)));
      }
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Colors.TupleSelect(
            0));
        }
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_ReferenceBox1, HDevWindowStack.GetActive());
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_ReferenceBox2.Dispose();
      HOperatorSet.GenRectangle2(out ho_ReferenceBox2, hv_ImageToZoomRatio*365, hv_ImageToZoomRatio*920, 
          0, (((new HTuple(3)).TupleSqrt())*2)*((new HTuple(2)).TuplePow(4)), ((1/((new HTuple(3)).TupleSqrt()
          ))*2)*((new HTuple(2)).TuplePow(4)));
      }
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Colors.TupleSelect(
            1));
        }
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_ReferenceBox2, HDevWindowStack.GetActive());
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_ReferenceBox3.Dispose();
      HOperatorSet.GenRectangle2(out ho_ReferenceBox3, hv_ImageToZoomRatio*310, hv_ImageToZoomRatio*390, 
          0, ((1/((new HTuple(2)).TupleSqrt()))*2)*((new HTuple(2)).TuplePow(4)), 
          (((new HTuple(2)).TupleSqrt())*2)*((new HTuple(2)).TuplePow(4)));
      }
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Colors.TupleSelect(
            2));
        }
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_ReferenceBox3, HDevWindowStack.GetActive());
      }
      //Display a legend.
      hv_WindowHandleLegend.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_legend", out hv_WindowHandleLegend);
      HDevWindowStack.SetActive(hv_WindowHandleLegend);
      hv_Text.Dispose();
      hv_Text = "Anchors (reference bounding boxes) with";
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Text = hv_Text.TupleConcat(
          "different aspect ratios:");
      hv_Text.Dispose();
      hv_Text = ExpTmpLocalVar_Text;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Text = hv_Text.TupleConcat(
          ((new HTuple("- Aspect ratio 1.0")).TupleConcat("- Aspect ratio 0.33")).TupleConcat(
          "- Aspect ratio 2.0"));
      hv_Text.Dispose();
      hv_Text = ExpTmpLocalVar_Text;
      }
      }
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
            "left", ((new HTuple("white")).TupleConcat("white")).TupleConcat(hv_Colors), 
            "box", "false");
        }
      }
      HOperatorSet.FlushBuffer(hv_WindowHandleImages);
      HOperatorSet.SetWindowParam(hv_WindowHandleImages, "flush", "true");
      //
      ho_Image.Dispose();
      ho_ReferenceBox1.Dispose();
      ho_ReferenceBox2.Dispose();
      ho_ReferenceBox3.Dispose();

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();
      hv_WindowHandleImages.Dispose();
      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_ImageZoomWidth.Dispose();
      hv_ImageZoomHeight.Dispose();
      hv_ImageToZoomRatio.Dispose();
      hv_Colors.Dispose();
      hv_Sequence.Dispose();
      hv_WindowHandleLegend.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Image.Dispose();
      ho_ReferenceBox1.Dispose();
      ho_ReferenceBox2.Dispose();
      ho_ReferenceBox3.Dispose();

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();
      hv_WindowHandleImages.Dispose();
      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_ImageZoomWidth.Dispose();
      hv_ImageZoomHeight.Dispose();
      hv_ImageToZoomRatio.Dispose();
      hv_Colors.Dispose();
      hv_Sequence.Dispose();
      hv_WindowHandleLegend.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_screen_model_anchor_num_subscales (HTuple hv_ExampleInternals)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_Image, ho_ReferenceBoxLevel=null;

    // Local control variables 

    HTuple hv_ShowExampleScreens = new HTuple();
    HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
    HTuple hv_WindowHandleImages = new HTuple(), hv_ImageWidth = new HTuple();
    HTuple hv_ImageHeight = new HTuple(), hv_ImageZoomWidth = new HTuple();
    HTuple hv_ImageZoomHeight = new HTuple(), hv_ImageToZoomRatio = new HTuple();
    HTuple hv_Colors = new HTuple(), hv_Sequence = new HTuple();
    HTuple hv_LineStyle = new HTuple(), hv_Level = new HTuple();
    HTuple hv_Subscale = new HTuple(), hv_WindowHandleLegend = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    HOperatorSet.GenEmptyObj(out ho_ReferenceBoxLevel);
    try
    {
      //This procedure displays an introduction about the choice of the subscale parameter.
      //
      hv_ShowExampleScreens.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
      if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
      {
        ho_Image.Dispose();
        ho_ReferenceBoxLevel.Dispose();

        hv_ShowExampleScreens.Dispose();
        hv_WindowHandleText.Dispose();
        hv_Text.Dispose();
        hv_WindowHandleImages.Dispose();
        hv_ImageWidth.Dispose();
        hv_ImageHeight.Dispose();
        hv_ImageZoomWidth.Dispose();
        hv_ImageZoomHeight.Dispose();
        hv_ImageToZoomRatio.Dispose();
        hv_Colors.Dispose();
        hv_Sequence.Dispose();
        hv_LineStyle.Dispose();
        hv_Level.Dispose();
        hv_Subscale.Dispose();
        hv_WindowHandleLegend.Dispose();

        return;
      }
      //
      //Reset the open windows for a clean display.
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 1);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 1);
      dev_display_example_reset_windows(hv_ExampleInternals);
      //
      //Display explanatory text.
      hv_WindowHandleText.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
      HDevWindowStack.SetActive(hv_WindowHandleText);
      //
      hv_Text.Dispose();
      hv_Text = "Step 2: Generic model parameter 'anchor_num_subscales'";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("To achieve a finer spread of box sizes to be detected, use");
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "'anchor_num_subscales'.";
      //
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
            "left", "black", "box", "true");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", 
            "window", "bottom", "right", "black", new HTuple(), new HTuple());
      }
      //
      //Display example image.
      hv_WindowHandleImages.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images", out hv_WindowHandleImages);
      HDevWindowStack.SetActive(hv_WindowHandleImages);
      HOperatorSet.SetWindowParam(hv_WindowHandleImages, "flush", "false");
      //Display image.
      ho_Image.Dispose();
      HOperatorSet.ReadImage(out ho_Image, "pill_bag/pill_bag_001.png");
      hv_ImageWidth.Dispose();hv_ImageHeight.Dispose();
      HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
      hv_ImageZoomWidth.Dispose();
      hv_ImageZoomWidth = 512;
      hv_ImageZoomHeight.Dispose();
      hv_ImageZoomHeight = 320;
      hv_ImageToZoomRatio.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ImageToZoomRatio = (hv_ImageZoomHeight.TupleReal()
          )/(hv_ImageHeight.TupleReal());
      }
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ZoomImageSize(ho_Image, out ExpTmpOutVar_0, hv_ImageZoomWidth, 
          hv_ImageZoomHeight, "constant");
      ho_Image.Dispose();
      ho_Image = ExpTmpOutVar_0;
      }
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_ImageZoomHeight-1, 
            hv_ImageZoomWidth-1);
        }
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
      }
      //Display anchors.
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
      }
      hv_Colors.Dispose();
      get_distinct_colors(5, 0, 0, 128, out hv_Colors);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Sequence.Dispose();
      HOperatorSet.TupleGenSequence((new HTuple(hv_Colors.TupleLength()))-1, 0, -1, 
          out hv_Sequence);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Colors = hv_Colors.TupleSelect(
          hv_Sequence);
      hv_Colors.Dispose();
      hv_Colors = ExpTmpLocalVar_Colors;
      }
      }
      hv_LineStyle.Dispose();
      HOperatorSet.GetLineStyle(hv_WindowHandleImages, out hv_LineStyle);
      HOperatorSet.SetWindowParam(hv_WindowHandleImages, "flush", "false");
      for (hv_Level=2; (int)hv_Level<=6; hv_Level = (int)hv_Level + 1)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_ReferenceBoxLevel.Dispose();
        HOperatorSet.GenRectangle2(out ho_ReferenceBoxLevel, hv_ImageToZoomRatio*414, 
            hv_ImageToZoomRatio*520, 0, 2*((new HTuple(2)).TuplePow(hv_Level)), 2*((new HTuple(2)).TuplePow(
            hv_Level)));
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 3);
        }
        HOperatorSet.SetLineStyle(hv_WindowHandleImages, hv_LineStyle);
        if (HDevWindowStack.IsOpen())
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Colors.TupleSelect(
              hv_Level-2));
          }
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_ReferenceBoxLevel, HDevWindowStack.GetActive());
        }
        for (hv_Subscale=0; (int)hv_Subscale<=2; hv_Subscale = (int)hv_Subscale + 1)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          ho_ReferenceBoxLevel.Dispose();
          HOperatorSet.GenRectangle2(out ho_ReferenceBoxLevel, hv_ImageToZoomRatio*414, 
              hv_ImageToZoomRatio*520, 0, 2*((new HTuple(2)).TuplePow(hv_Level+((hv_Subscale.TupleReal()
              )/3.0))), 2*((new HTuple(2)).TuplePow(hv_Level+((hv_Subscale.TupleReal()
              )/3.0))));
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 2);
          }
          HOperatorSet.SetLineStyle(hv_WindowHandleImages, (new HTuple(10)).TupleConcat(
              6));
          if (HDevWindowStack.IsOpen())
          {
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
            HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Colors.TupleSelect(
                hv_Level-2));
            }
          }
          if (HDevWindowStack.IsOpen())
          {
            HOperatorSet.DispObj(ho_ReferenceBoxLevel, HDevWindowStack.GetActive()
                );
          }
        }
      }
      HOperatorSet.SetLineStyle(hv_WindowHandleImages, hv_LineStyle);
      //Display a legend.
      hv_WindowHandleLegend.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_legend", out hv_WindowHandleLegend);
      HDevWindowStack.SetActive(hv_WindowHandleLegend);
      hv_Text.Dispose();
      hv_Text = "Anchors (reference bounding boxes)";
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Text = hv_Text.TupleConcat(
          "with anchor_num_subscales = 3:");
      hv_Text.Dispose();
      hv_Text = ExpTmpLocalVar_Text;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Text = hv_Text.TupleConcat(
          ((((new HTuple("- Level 2: 16 x 16 + subscales")).TupleConcat("- Level 3: 32 x 32 + subscales")).TupleConcat(
          "- Level 4: 64 x 64 + subscales")).TupleConcat("- Level 5: 128 x 128 + subscales")).TupleConcat(
          "- Level 6: 256 x 256 + subscales"));
      hv_Text.Dispose();
      hv_Text = ExpTmpLocalVar_Text;
      }
      }
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
            "left", ((new HTuple("white")).TupleConcat("white")).TupleConcat(hv_Colors), 
            "box", "false");
        }
      }
      HOperatorSet.FlushBuffer(hv_WindowHandleImages);
      HOperatorSet.SetWindowParam(hv_WindowHandleImages, "flush", "true");
      //
      ho_Image.Dispose();
      ho_ReferenceBoxLevel.Dispose();

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();
      hv_WindowHandleImages.Dispose();
      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_ImageZoomWidth.Dispose();
      hv_ImageZoomHeight.Dispose();
      hv_ImageToZoomRatio.Dispose();
      hv_Colors.Dispose();
      hv_Sequence.Dispose();
      hv_LineStyle.Dispose();
      hv_Level.Dispose();
      hv_Subscale.Dispose();
      hv_WindowHandleLegend.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Image.Dispose();
      ho_ReferenceBoxLevel.Dispose();

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();
      hv_WindowHandleImages.Dispose();
      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_ImageZoomWidth.Dispose();
      hv_ImageZoomHeight.Dispose();
      hv_ImageToZoomRatio.Dispose();
      hv_Colors.Dispose();
      hv_Sequence.Dispose();
      hv_LineStyle.Dispose();
      hv_Level.Dispose();
      hv_Subscale.Dispose();
      hv_WindowHandleLegend.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_screen_model_image_size (HTuple hv_ExampleInternals)
  {



    // Local iconic variables 

    HObject ho_Image, ho_ImageZoomed, ho_ImagePart;
    HObject ho_ImageZoomedPart, ho_ObjectsConcat, ho_TiledImage;

    // Local control variables 

    HTuple hv_ShowExampleScreens = new HTuple();
    HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
    HTuple hv_WindowHandleImages = new HTuple(), hv_ImageWidth = new HTuple();
    HTuple hv_ImageHeight = new HTuple(), hv_ImageZoomWidth = new HTuple();
    HTuple hv_ZoomedImageToImage = new HTuple(), hv_ImageZoomHeight = new HTuple();
    HTuple hv_ImageRatio = new HTuple(), hv_Ratio = new HTuple();
    HTuple hv_CropHeight = new HTuple(), hv_CropWidth = new HTuple();
    HTuple hv_Row1 = new HTuple(), hv_Col1 = new HTuple();
    HTuple hv_Row2 = new HTuple(), hv_Col2 = new HTuple();
    HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
    HTuple hv_Row = new HTuple(), hv_Column = new HTuple();
    HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
    HTuple hv__ = new HTuple(), hv_TextWidth = new HTuple();
    HTuple hv_TextHeight = new HTuple(), hv_TextCol = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    HOperatorSet.GenEmptyObj(out ho_ImageZoomed);
    HOperatorSet.GenEmptyObj(out ho_ImagePart);
    HOperatorSet.GenEmptyObj(out ho_ImageZoomedPart);
    HOperatorSet.GenEmptyObj(out ho_ObjectsConcat);
    HOperatorSet.GenEmptyObj(out ho_TiledImage);
    try
    {
      //This procedure displays an introduction about the choice of the image size
      //
      hv_ShowExampleScreens.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
      if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
      {
        ho_Image.Dispose();
        ho_ImageZoomed.Dispose();
        ho_ImagePart.Dispose();
        ho_ImageZoomedPart.Dispose();
        ho_ObjectsConcat.Dispose();
        ho_TiledImage.Dispose();

        hv_ShowExampleScreens.Dispose();
        hv_WindowHandleText.Dispose();
        hv_Text.Dispose();
        hv_WindowHandleImages.Dispose();
        hv_ImageWidth.Dispose();
        hv_ImageHeight.Dispose();
        hv_ImageZoomWidth.Dispose();
        hv_ZoomedImageToImage.Dispose();
        hv_ImageZoomHeight.Dispose();
        hv_ImageRatio.Dispose();
        hv_Ratio.Dispose();
        hv_CropHeight.Dispose();
        hv_CropWidth.Dispose();
        hv_Row1.Dispose();
        hv_Col1.Dispose();
        hv_Row2.Dispose();
        hv_Col2.Dispose();
        hv_Width.Dispose();
        hv_Height.Dispose();
        hv_Row.Dispose();
        hv_Column.Dispose();
        hv_WindowWidth.Dispose();
        hv_WindowHeight.Dispose();
        hv__.Dispose();
        hv_TextWidth.Dispose();
        hv_TextHeight.Dispose();
        hv_TextCol.Dispose();

        return;
      }
      //
      //Reset the open windows for a clean display.
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 1);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
      dev_display_example_reset_windows(hv_ExampleInternals);
      //
      //Display explanatory text.
      hv_WindowHandleText.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
      HDevWindowStack.SetActive(hv_WindowHandleText);
      //
      hv_Text.Dispose();
      hv_Text = "Step 2: Generic model parameters for setting the image size";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("With regard to the training/inference speed and GPU memory requirements,");
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "a small image size is advantageous.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("However, the image size should be chosen such that the contained");
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "objects are still clearly visible.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("The image size can be set with 'image_width', 'image_height',");
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "and 'image_num_channels'.";
      //
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
            "left", "black", "box", "true");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", 
            "window", "bottom", "right", "black", new HTuple(), new HTuple());
      }
      //
      //Display example image.
      hv_WindowHandleImages.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images", out hv_WindowHandleImages);
      HDevWindowStack.SetActive(hv_WindowHandleImages);
      HOperatorSet.SetWindowParam(hv_WindowHandleImages, "flush", "false");
      //
      //Create example image.
      ho_Image.Dispose();
      HOperatorSet.ReadImage(out ho_Image, "pill_bag/pill_bag_001.png");
      hv_ImageWidth.Dispose();hv_ImageHeight.Dispose();
      HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
      hv_ImageZoomWidth.Dispose();
      hv_ImageZoomWidth = 512;
      hv_ZoomedImageToImage.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ZoomedImageToImage = hv_ImageZoomWidth/(1.0*hv_ImageWidth);
      }
      hv_ImageZoomHeight.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ImageZoomHeight = ((hv_ImageHeight*hv_ZoomedImageToImage)).TupleRound()
          ;
      }
      ho_ImageZoomed.Dispose();
      HOperatorSet.ZoomImageSize(ho_Image, out ho_ImageZoomed, hv_ImageZoomWidth, 
          hv_ImageZoomHeight, "constant");
      //
      hv_ImageRatio.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ImageRatio = (hv_ImageWidth.TupleReal()
          )/(hv_ImageHeight.TupleReal());
      }
      hv_Ratio.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Ratio = hv_ImageWidth/(1.0*hv_ImageHeight);
      }
      hv_CropHeight.Dispose();
      hv_CropHeight = 350;
      hv_CropWidth.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_CropWidth = hv_Ratio*hv_CropHeight;
      }
      hv_Row1.Dispose();
      hv_Row1 = 180;
      hv_Col1.Dispose();
      hv_Col1 = 300;
      hv_Row2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Row2 = hv_Row1+hv_CropHeight;
      }
      hv_Col2.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Col2 = hv_Col1+(hv_CropWidth*0.5);
      }
      ho_ImagePart.Dispose();
      HOperatorSet.CropRectangle1(ho_Image, out ho_ImagePart, hv_Row1, hv_Col1, hv_Row2, 
          hv_Col2);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      ho_ImageZoomedPart.Dispose();
      HOperatorSet.CropRectangle1(ho_ImageZoomed, out ho_ImageZoomedPart, hv_Row1*hv_ZoomedImageToImage, 
          hv_Col1*hv_ZoomedImageToImage, hv_Row2*hv_ZoomedImageToImage, hv_Col2*hv_ZoomedImageToImage);
      }
      //
      ho_ObjectsConcat.Dispose();
      HOperatorSet.ConcatObj(ho_ImagePart, ho_ImageZoomedPart, out ho_ObjectsConcat
          );
      ho_TiledImage.Dispose();
      HOperatorSet.TileImages(ho_ObjectsConcat, out ho_TiledImage, 2, "vertical");
      hv_Width.Dispose();hv_Height.Dispose();
      HOperatorSet.GetImageSize(ho_TiledImage, out hv_Width, out hv_Height);
      //
      //Display.
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_Height-1, hv_Width-1);
        }
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_TiledImage, HDevWindowStack.GetActive());
      }
      //
      //Add text for image parts
      hv_Row.Dispose();hv_Column.Dispose();hv_WindowWidth.Dispose();hv_WindowHeight.Dispose();
      HOperatorSet.GetWindowExtents(hv_WindowHandleImages, out hv_Row, out hv_Column, 
          out hv_WindowWidth, out hv_WindowHeight);
      hv_Text.Dispose();
      hv_Text = "Original resolution";
      hv__.Dispose();hv__.Dispose();hv_TextWidth.Dispose();hv_TextHeight.Dispose();
      HOperatorSet.GetStringExtents(hv_WindowHandleImages, hv_Text, out hv__, out hv__, 
          out hv_TextWidth, out hv_TextHeight);
      hv_TextCol.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TextCol = (hv_WindowWidth*0.25)-(hv_TextWidth*0.5);
      }
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", hv_WindowHeight-(2*hv_TextHeight), 
            hv_TextCol, "black", new HTuple(), new HTuple());
        }
      }
      hv_Text.Dispose();
      hv_Text = "Resolution for image size 512 x 320";
      hv__.Dispose();hv__.Dispose();hv_TextWidth.Dispose();hv_TextHeight.Dispose();
      HOperatorSet.GetStringExtents(hv_WindowHandleImages, hv_Text, out hv__, out hv__, 
          out hv_TextWidth, out hv_TextHeight);
      hv_TextCol.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TextCol = (hv_WindowWidth*0.75)-(hv_TextWidth*0.5);
      }
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", hv_WindowHeight-(2*hv_TextHeight), 
            hv_TextCol, "black", new HTuple(), new HTuple());
        }
      }
      //
      //Display.
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_Height, hv_Width);
      }
      HOperatorSet.FlushBuffer(hv_WindowHandleImages);
      HOperatorSet.SetWindowParam(hv_WindowHandleImages, "flush", "true");
      //
      ho_Image.Dispose();
      ho_ImageZoomed.Dispose();
      ho_ImagePart.Dispose();
      ho_ImageZoomedPart.Dispose();
      ho_ObjectsConcat.Dispose();
      ho_TiledImage.Dispose();

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();
      hv_WindowHandleImages.Dispose();
      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_ImageZoomWidth.Dispose();
      hv_ZoomedImageToImage.Dispose();
      hv_ImageZoomHeight.Dispose();
      hv_ImageRatio.Dispose();
      hv_Ratio.Dispose();
      hv_CropHeight.Dispose();
      hv_CropWidth.Dispose();
      hv_Row1.Dispose();
      hv_Col1.Dispose();
      hv_Row2.Dispose();
      hv_Col2.Dispose();
      hv_Width.Dispose();
      hv_Height.Dispose();
      hv_Row.Dispose();
      hv_Column.Dispose();
      hv_WindowWidth.Dispose();
      hv_WindowHeight.Dispose();
      hv__.Dispose();
      hv_TextWidth.Dispose();
      hv_TextHeight.Dispose();
      hv_TextCol.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Image.Dispose();
      ho_ImageZoomed.Dispose();
      ho_ImagePart.Dispose();
      ho_ImageZoomedPart.Dispose();
      ho_ObjectsConcat.Dispose();
      ho_TiledImage.Dispose();

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();
      hv_WindowHandleImages.Dispose();
      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_ImageZoomWidth.Dispose();
      hv_ZoomedImageToImage.Dispose();
      hv_ImageZoomHeight.Dispose();
      hv_ImageRatio.Dispose();
      hv_Ratio.Dispose();
      hv_CropHeight.Dispose();
      hv_CropWidth.Dispose();
      hv_Row1.Dispose();
      hv_Col1.Dispose();
      hv_Row2.Dispose();
      hv_Col2.Dispose();
      hv_Width.Dispose();
      hv_Height.Dispose();
      hv_Row.Dispose();
      hv_Column.Dispose();
      hv_WindowWidth.Dispose();
      hv_WindowHeight.Dispose();
      hv__.Dispose();
      hv_TextWidth.Dispose();
      hv_TextHeight.Dispose();
      hv_TextCol.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_screen_model_levels (HTuple hv_ExampleInternals)
  {



    // Stack for temporary objects 
    HObject[] OTemp = new HObject[20];

    // Local iconic variables 

    HObject ho_Image, ho_ReferenceBoxLevel=null;

    // Local control variables 

    HTuple hv_ShowExampleScreens = new HTuple();
    HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
    HTuple hv_WindowHandleImages = new HTuple(), hv_ImageWidth = new HTuple();
    HTuple hv_ImageHeight = new HTuple(), hv_ImageZoomWidth = new HTuple();
    HTuple hv_ImageZoomHeight = new HTuple(), hv_ImageToZoomRatio = new HTuple();
    HTuple hv_Colors = new HTuple(), hv_Sequence = new HTuple();
    HTuple hv_Level = new HTuple(), hv_WindowHandleLegend = new HTuple();
    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image);
    HOperatorSet.GenEmptyObj(out ho_ReferenceBoxLevel);
    try
    {
      //This procedure displays an introduction about the choice of min_level and max_level
      //
      hv_ShowExampleScreens.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
      if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
      {
        ho_Image.Dispose();
        ho_ReferenceBoxLevel.Dispose();

        hv_ShowExampleScreens.Dispose();
        hv_WindowHandleText.Dispose();
        hv_Text.Dispose();
        hv_WindowHandleImages.Dispose();
        hv_ImageWidth.Dispose();
        hv_ImageHeight.Dispose();
        hv_ImageZoomWidth.Dispose();
        hv_ImageZoomHeight.Dispose();
        hv_ImageToZoomRatio.Dispose();
        hv_Colors.Dispose();
        hv_Sequence.Dispose();
        hv_Level.Dispose();
        hv_WindowHandleLegend.Dispose();

        return;
      }
      //
      //Reset the open windows for a clean display.
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 1);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 1);
      dev_display_example_reset_windows(hv_ExampleInternals);
      //
      //Display explanatory text.
      hv_WindowHandleText.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
      HDevWindowStack.SetActive(hv_WindowHandleText);
      //
      hv_Text.Dispose();
      hv_Text = new HTuple("Step 2: Generic model parameters 'min_level', 'max_level'");
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "A good choice of the levels is essential for finding objects";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "of different size.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "Objects of different size are found on different levels.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("This means, the higher the level gets, the bigger are the");
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "objects found on this level.";
      //
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
            "left", "black", "box", "true");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", 
            "window", "bottom", "right", "black", new HTuple(), new HTuple());
      }
      //
      //Display example image.
      hv_WindowHandleImages.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images", out hv_WindowHandleImages);
      HDevWindowStack.SetActive(hv_WindowHandleImages);
      HOperatorSet.SetWindowParam(hv_WindowHandleImages, "flush", "false");
      //Display image.
      ho_Image.Dispose();
      HOperatorSet.ReadImage(out ho_Image, "pill_bag/pill_bag_001.png");
      hv_ImageWidth.Dispose();hv_ImageHeight.Dispose();
      HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
      hv_ImageZoomWidth.Dispose();
      hv_ImageZoomWidth = 512;
      hv_ImageZoomHeight.Dispose();
      hv_ImageZoomHeight = 320;
      hv_ImageToZoomRatio.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_ImageToZoomRatio = (hv_ImageZoomHeight.TupleReal()
          )/(hv_ImageHeight.TupleReal());
      }
      {
      HObject ExpTmpOutVar_0;
      HOperatorSet.ZoomImageSize(ho_Image, out ExpTmpOutVar_0, hv_ImageZoomWidth, 
          hv_ImageZoomHeight, "constant");
      ho_Image.Dispose();
      ho_Image = ExpTmpOutVar_0;
      }
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_ImageZoomHeight-1, 
            hv_ImageZoomWidth-1);
        }
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
      }
      //Display anchors.
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 3);
      }
      hv_Colors.Dispose();
      get_distinct_colors(5, 0, 0, 128, out hv_Colors);
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Sequence.Dispose();
      HOperatorSet.TupleGenSequence((new HTuple(hv_Colors.TupleLength()))-1, 0, -1, 
          out hv_Sequence);
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Colors = hv_Colors.TupleSelect(
          hv_Sequence);
      hv_Colors.Dispose();
      hv_Colors = ExpTmpLocalVar_Colors;
      }
      }
      HOperatorSet.SetWindowParam(hv_WindowHandleImages, "flush", "false");
      for (hv_Level=2; (int)hv_Level<=6; hv_Level = (int)hv_Level + 1)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        ho_ReferenceBoxLevel.Dispose();
        HOperatorSet.GenRectangle2(out ho_ReferenceBoxLevel, hv_ImageToZoomRatio*414, 
            hv_ImageToZoomRatio*520, 0, 2*((new HTuple(2)).TuplePow(hv_Level)), 2*((new HTuple(2)).TuplePow(
            hv_Level)));
        }
        if (HDevWindowStack.IsOpen())
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Colors.TupleSelect(
              hv_Level-2));
          }
        }
        if (HDevWindowStack.IsOpen())
        {
          HOperatorSet.DispObj(ho_ReferenceBoxLevel, HDevWindowStack.GetActive());
        }
      }
      //Display a legend.
      hv_WindowHandleLegend.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_legend", out hv_WindowHandleLegend);
      HDevWindowStack.SetActive(hv_WindowHandleLegend);
      hv_Text.Dispose();
      hv_Text = "Anchors (reference bounding boxes) for";
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Text = hv_Text.TupleConcat(
          "an image of size 512 x 320:");
      hv_Text.Dispose();
      hv_Text = ExpTmpLocalVar_Text;
      }
      }
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      {
      HTuple 
        ExpTmpLocalVar_Text = hv_Text.TupleConcat(
          ((((new HTuple("- Level 2: 16 x 16")).TupleConcat("- Level 3: 32 x 32")).TupleConcat(
          "- Level 4: 64 x 64")).TupleConcat("- Level 5: 128 x 128")).TupleConcat(
          "- Level 6: 256 x 256"));
      hv_Text.Dispose();
      hv_Text = ExpTmpLocalVar_Text;
      }
      }
      if (HDevWindowStack.IsOpen())
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
            "left", ((new HTuple("white")).TupleConcat("white")).TupleConcat(hv_Colors), 
            "box", "false");
        }
      }
      HOperatorSet.FlushBuffer(hv_WindowHandleImages);
      HOperatorSet.SetWindowParam(hv_WindowHandleImages, "flush", "true");
      //
      ho_Image.Dispose();
      ho_ReferenceBoxLevel.Dispose();

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();
      hv_WindowHandleImages.Dispose();
      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_ImageZoomWidth.Dispose();
      hv_ImageZoomHeight.Dispose();
      hv_ImageToZoomRatio.Dispose();
      hv_Colors.Dispose();
      hv_Sequence.Dispose();
      hv_Level.Dispose();
      hv_WindowHandleLegend.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_Image.Dispose();
      ho_ReferenceBoxLevel.Dispose();

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();
      hv_WindowHandleImages.Dispose();
      hv_ImageWidth.Dispose();
      hv_ImageHeight.Dispose();
      hv_ImageZoomWidth.Dispose();
      hv_ImageZoomHeight.Dispose();
      hv_ImageToZoomRatio.Dispose();
      hv_Colors.Dispose();
      hv_Sequence.Dispose();
      hv_Level.Dispose();
      hv_WindowHandleLegend.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_screen_preprocessing_data (HTuple hv_ExampleInternals)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ShowExampleScreens = new HTuple();
    HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure explains how to preprocess the data
      //
      hv_ShowExampleScreens.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
      if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
      {

        hv_ShowExampleScreens.Dispose();
        hv_WindowHandleText.Dispose();
        hv_Text.Dispose();

        return;
      }
      //
      //Reset the open windows for a clean display.
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
      dev_display_example_reset_windows(hv_ExampleInternals);
      //
      //Display explanatory text.
      hv_WindowHandleText.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
      HDevWindowStack.SetActive(hv_WindowHandleText);
      //
      hv_Text.Dispose();
      hv_Text = "Step 3: Preprocess the dataset";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "This can be done using 'preprocess_dl_dataset'.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "To get the necessary preprocessing parameters from the";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("model, use 'create_dl_preprocess_param_from_model'.");
      //
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
            "left", "black", "box", "true");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", 
            "window", "bottom", "right", "black", new HTuple(), new HTuple());
      }
      //

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_screen_preprocessing_introduction (HTuple hv_ExampleInternals)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ShowExampleScreens = new HTuple();
    HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure introduces the reason for preprocessing.
      //
      hv_ShowExampleScreens.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
      if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
      {

        hv_ShowExampleScreens.Dispose();
        hv_WindowHandleText.Dispose();
        hv_Text.Dispose();

        return;
      }
      //
      //Reset the open windows for a clean display.
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
      dev_display_example_reset_windows(hv_ExampleInternals);
      //
      //Display explanatory text.
      hv_WindowHandleText.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
      HDevWindowStack.SetActive(hv_WindowHandleText);
      //
      hv_Text.Dispose();
      hv_Text = "Step 3: Preprocess the dataset";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("After creation of the DL object detection model, its underlying");
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "network architecture is fixed to the specified input values.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("Therefore, data subjected to the model during training or");
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "inference needs to be preprocessed according to the model";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "parameters.";
      //
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
            "left", "black", "box", "true");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", 
            "window", "bottom", "right", "black", new HTuple(), new HTuple());
      }
      //

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_screen_run_program (HTuple hv_ExampleInternals)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ShowExampleScreens = new HTuple();
    HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure shows a final text before starting with preprocessing.
      //
      hv_ShowExampleScreens.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
      if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
      {

        hv_ShowExampleScreens.Dispose();
        hv_WindowHandleText.Dispose();
        hv_Text.Dispose();

        return;
      }
      //
      //Reset the open windows for a clean display.
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
      dev_display_example_reset_windows(hv_ExampleInternals);
      //
      //Display explanatory text.
      hv_WindowHandleText.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
      HDevWindowStack.SetActive(hv_WindowHandleText);
      //
      hv_Text.Dispose();
      hv_Text = "The program will now start to create the model and to preprocess";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "the data.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "Reading and splitting the dataset can take a few seconds.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "A variable inspect window will show the progress of the preprocessing.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("After preprocessing, it is recommended to check the");
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("preprocessed dataset. Therefore, some samples will be");
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "displayed at the end of the program.";
      //
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
            "left", "black", "box", "true");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", 
            "window", "bottom", "right", "black", "box", "true");
      }
      //

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_ShowExampleScreens.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_display_screen_split_dataset (HTuple hv_ExampleInternals)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_ShowExampleScreens = new HTuple();
    HTuple hv_TrainRatio = new HTuple(), hv_ValRatio = new HTuple();
    HTuple hv_TestRatio = new HTuple(), hv_WindowHandleText = new HTuple();
    HTuple hv_Text = new HTuple(), hv_WindowHandleImages = new HTuple();
    HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
    HTuple hv_PieChartCenterRow = new HTuple(), hv_PieChartCenterCol = new HTuple();
    HTuple hv_PieChartRadius = new HTuple(), hv_Colors = new HTuple();
    HTuple hv_pi = new HTuple(), hv_Ratios = new HTuple();
    HTuple hv_alpha = new HTuple(), hv_K = new HTuple(), hv_Ascent = new HTuple();
    HTuple hv_Descent = new HTuple(), hv_TextWidth = new HTuple();
    HTuple hv_TextHeight = new HTuple(), hv_Row = new HTuple();
    HTuple hv_Col = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure explains the splitting of the dataset.
      //
      hv_ShowExampleScreens.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
      if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
      {

        hv_ShowExampleScreens.Dispose();
        hv_TrainRatio.Dispose();
        hv_ValRatio.Dispose();
        hv_TestRatio.Dispose();
        hv_WindowHandleText.Dispose();
        hv_Text.Dispose();
        hv_WindowHandleImages.Dispose();
        hv_Width.Dispose();
        hv_Height.Dispose();
        hv_PieChartCenterRow.Dispose();
        hv_PieChartCenterCol.Dispose();
        hv_PieChartRadius.Dispose();
        hv_Colors.Dispose();
        hv_pi.Dispose();
        hv_Ratios.Dispose();
        hv_alpha.Dispose();
        hv_K.Dispose();
        hv_Ascent.Dispose();
        hv_Descent.Dispose();
        hv_TextWidth.Dispose();
        hv_TextHeight.Dispose();
        hv_Row.Dispose();
        hv_Col.Dispose();

        return;
      }
      //
      //Set the parameters used for the split in the example.
      hv_TrainRatio.Dispose();
      hv_TrainRatio = 0.7;
      hv_ValRatio.Dispose();
      hv_ValRatio = 0.15;
      hv_TestRatio.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_TestRatio = (1.0-hv_TrainRatio)-hv_ValRatio;
      }
      //
      //Display explanatory text.
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 1);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
      dev_display_example_reset_windows(hv_ExampleInternals);
      //
      //Display the explanatory text.
      hv_WindowHandleText.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
      HDevWindowStack.SetActive(hv_WindowHandleText);
      //
      hv_Text.Dispose();
      hv_Text = "Step 1.2: Split the dataset";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "The procedure 'split_dl_dataset' splits the dataset randomly into";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("three subsets, such that samples of the same class are evenly");
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("distributed over the subsets, respecting the specified ratio.");
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "Splitting is important in order to evaluate the generalization";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "capabilities of the learned model more realistically.";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = "";
      if (hv_Text == null)
        hv_Text = new HTuple();
      hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("In this example, we use the ratios for splitting as displayed below. ");
      //
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top", 
            "left", "black", "box", "true");
      }
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", 
            "window", "bottom", "right", "black", new HTuple(), new HTuple());
      }
      //
      //Visualize the split used for the example settings.
      hv_WindowHandleImages.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images", out hv_WindowHandleImages);
      HDevWindowStack.SetActive(hv_WindowHandleImages);
      hv_Width.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_width", out hv_Width);
      hv_Height.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_height", out hv_Height);
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_Height, hv_Width);
      }
      //
      //Create a pie chart for visualization.
      hv_PieChartCenterRow.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_PieChartCenterRow = hv_Height/2.0;
      }
      hv_PieChartCenterCol.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_PieChartCenterCol = hv_Width/2.0;
      }
      hv_PieChartRadius.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_PieChartRadius = (((hv_Width.TupleConcat(
          hv_Height))).TupleMin())*0.425;
      }
      //
      hv_Colors.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Colors = (
          (new HTuple("#000088")).TupleConcat("#0000aa")).TupleConcat("#0000cc")+"ff";
      }
      //
      hv_pi.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_pi = 4.0*((new HTuple(1.0)).TupleAtan()
          );
      }
      hv_Ratios.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Ratios = new HTuple();
      hv_Ratios = hv_Ratios.TupleConcat(hv_TrainRatio, hv_ValRatio, hv_TestRatio);
      }
      hv_Text.Dispose();
      hv_Text = new HTuple();
      hv_Text[0] = "Train";
      hv_Text[1] = "Validation";
      hv_Text[2] = "Test";
      hv_alpha.Dispose();
      hv_alpha = 0;
      dev_display_pie_chart(hv_WindowHandleImages, hv_Ratios, hv_PieChartCenterRow, 
          hv_PieChartCenterCol, hv_PieChartRadius, hv_Colors, new HTuple());
      for (hv_K=0; (int)hv_K<=(int)((new HTuple(hv_Ratios.TupleLength()))-1); hv_K = (int)hv_K + 1)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_alpha = hv_alpha+((hv_Ratios.TupleSelect(
            hv_K))*hv_pi);
        hv_alpha.Dispose();
        hv_alpha = ExpTmpLocalVar_alpha;
        }
        }
        if (hv_Text == null)
          hv_Text = new HTuple();
        hv_Text[hv_K] = (((hv_Text.TupleSelect(hv_K))+" ")+((((hv_Ratios.TupleSelect(
            hv_K))*100)).TupleInt()))+"%";
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Ascent.Dispose();hv_Descent.Dispose();hv_TextWidth.Dispose();hv_TextHeight.Dispose();
        HOperatorSet.GetStringExtents(hv_WindowHandleImages, hv_Text.TupleSelect(
            hv_K), out hv_Ascent, out hv_Descent, out hv_TextWidth, out hv_TextHeight);
        }
        if ((int)((new HTuple(hv_alpha.TupleGreaterEqual(hv_pi/4.0))).TupleAnd(new HTuple(hv_pi.TupleLessEqual(
            (3*hv_pi)/4.0)))) != 0)
        {
          hv_Row.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Row = (hv_PieChartCenterRow-((hv_alpha.TupleCos()
              )*hv_PieChartRadius))-(hv_TextWidth/2.0);
          }
        }
        else
        {
          hv_Row.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Row = hv_PieChartCenterRow-((hv_alpha.TupleCos()
              )*hv_PieChartRadius);
          }
        }
        hv_Col.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Col = hv_PieChartCenterCol-((hv_alpha.TupleSin()
            )*hv_PieChartRadius);
        }
        if ((int)(new HTuple(hv_alpha.TupleLessEqual(hv_pi/2.0))) != 0)
        {
        }
        else
        {
          hv_Col.Dispose();
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          hv_Col = (hv_PieChartCenterCol-((hv_alpha.TupleSin()
              )*hv_PieChartRadius))-(hv_TextWidth/2.0);
          }
        }
        if (HDevWindowStack.IsOpen())
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text.TupleSelect(
              hv_K), "image", hv_Row, hv_Col, "black", new HTuple(), new HTuple());
          }
        }
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_alpha = hv_alpha+((hv_Ratios.TupleSelect(
            hv_K))*hv_pi);
        hv_alpha.Dispose();
        hv_alpha = ExpTmpLocalVar_alpha;
        }
        }
      }
      //
      HOperatorSet.FlushBuffer(hv_WindowHandleText);
      HOperatorSet.SetWindowParam(hv_WindowHandleText, "flush", "true");
      //
      //

      hv_ShowExampleScreens.Dispose();
      hv_TrainRatio.Dispose();
      hv_ValRatio.Dispose();
      hv_TestRatio.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();
      hv_WindowHandleImages.Dispose();
      hv_Width.Dispose();
      hv_Height.Dispose();
      hv_PieChartCenterRow.Dispose();
      hv_PieChartCenterCol.Dispose();
      hv_PieChartRadius.Dispose();
      hv_Colors.Dispose();
      hv_pi.Dispose();
      hv_Ratios.Dispose();
      hv_alpha.Dispose();
      hv_K.Dispose();
      hv_Ascent.Dispose();
      hv_Descent.Dispose();
      hv_TextWidth.Dispose();
      hv_TextHeight.Dispose();
      hv_Row.Dispose();
      hv_Col.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_ShowExampleScreens.Dispose();
      hv_TrainRatio.Dispose();
      hv_ValRatio.Dispose();
      hv_TestRatio.Dispose();
      hv_WindowHandleText.Dispose();
      hv_Text.Dispose();
      hv_WindowHandleImages.Dispose();
      hv_Width.Dispose();
      hv_Height.Dispose();
      hv_PieChartCenterRow.Dispose();
      hv_PieChartCenterCol.Dispose();
      hv_PieChartRadius.Dispose();
      hv_Colors.Dispose();
      hv_pi.Dispose();
      hv_Ratios.Dispose();
      hv_alpha.Dispose();
      hv_K.Dispose();
      hv_Ascent.Dispose();
      hv_Descent.Dispose();
      hv_TextWidth.Dispose();
      hv_TextHeight.Dispose();
      hv_Row.Dispose();
      hv_Col.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_example_init (HTuple hv_ShowExampleScreens, out HTuple hv_ExampleInternals)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_WindowWidthText = new HTuple(), hv_WindowHeightText = new HTuple();
    HTuple hv_WindowBGColor = new HTuple(), hv_WindowHandleText = new HTuple();
    // Initialize local and output iconic variables 
    hv_ExampleInternals = new HTuple();
    try
    {
      //This procedure initializes the graphic windows that are used for explanations during the example.
      //
      //A dict that will be used/adapted by other example procedures.
      hv_ExampleInternals.Dispose();
      HOperatorSet.CreateDict(out hv_ExampleInternals);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "show_example_screens", hv_ShowExampleScreens);
      if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
      {

        hv_WindowWidthText.Dispose();
        hv_WindowHeightText.Dispose();
        hv_WindowBGColor.Dispose();
        hv_WindowHandleText.Dispose();

        return;
      }
      //
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.CloseWindow(HDevWindowStack.Pop());
      }
      hv_WindowWidthText.Dispose();
      hv_WindowWidthText = 800;
      hv_WindowHeightText.Dispose();
      hv_WindowHeightText = 300;
      hv_WindowBGColor.Dispose();
      hv_WindowBGColor = "gray";
      HOperatorSet.SetWindowAttr("background_color",hv_WindowBGColor);
      HOperatorSet.OpenWindow(0,0,hv_WindowWidthText,hv_WindowHeightText,0,"visible","",out hv_WindowHandleText);
      HDevWindowStack.Push(hv_WindowHandleText);
      set_display_font(hv_WindowHandleText, 16, "mono", "true", "false");
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_text", hv_WindowHandleText);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_text_width", hv_WindowWidthText);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_text_height", hv_WindowHeightText);
      //
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
      //

      hv_WindowWidthText.Dispose();
      hv_WindowHeightText.Dispose();
      hv_WindowBGColor.Dispose();
      hv_WindowHandleText.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_WindowWidthText.Dispose();
      hv_WindowHeightText.Dispose();
      hv_WindowBGColor.Dispose();
      hv_WindowHandleText.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_open_example_image_window (HTuple hv_ExampleInternals)
  {



    // Local iconic variables 

    // Local control variables 

    HTuple hv_WindowHeightText = new HTuple();
    HTuple hv_WindowWidthImage = new HTuple(), hv_WindowHeightImages = new HTuple();
    HTuple hv_WindowBGColor = new HTuple(), hv_WindowYImages = new HTuple();
    HTuple hv_WindowXImages = new HTuple(), hv_WindowHandleImages = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure initializes the graphic windows that are used to display example images.
      //
      hv_WindowHeightText.Dispose();
      hv_WindowHeightText = 300;
      hv_WindowWidthImage.Dispose();
      hv_WindowWidthImage = 800;
      hv_WindowHeightImages.Dispose();
      hv_WindowHeightImages = 500;
      hv_WindowBGColor.Dispose();
      hv_WindowBGColor = "gray";
      //
      hv_WindowYImages.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_WindowYImages = hv_WindowHeightText+60;
      }
      hv_WindowXImages.Dispose();
      hv_WindowXImages = 0;
      HOperatorSet.SetWindowAttr("background_color",hv_WindowBGColor);
      HOperatorSet.OpenWindow(hv_WindowYImages,hv_WindowXImages,hv_WindowWidthImage,hv_WindowHeightImages,0,"visible","",out hv_WindowHandleImages);
      HDevWindowStack.Push(hv_WindowHandleImages);
      set_display_font(hv_WindowHandleImages, 16, "mono", "true", "false");
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images", hv_WindowHandleImages);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_width", hv_WindowWidthImage);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_height", hv_WindowHeightImages);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_x", hv_WindowXImages);
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_y", hv_WindowYImages);

      hv_WindowHeightText.Dispose();
      hv_WindowWidthImage.Dispose();
      hv_WindowHeightImages.Dispose();
      hv_WindowBGColor.Dispose();
      hv_WindowYImages.Dispose();
      hv_WindowXImages.Dispose();
      hv_WindowHandleImages.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_WindowHeightText.Dispose();
      hv_WindowWidthImage.Dispose();
      hv_WindowHeightImages.Dispose();
      hv_WindowBGColor.Dispose();
      hv_WindowYImages.Dispose();
      hv_WindowXImages.Dispose();
      hv_WindowHandleImages.Dispose();

      throw HDevExpDefaultException;
    }
  }

  public void dev_open_example_legend_window (HTuple hv_ExampleInternals, HTuple hv_WindowWidth)
  {



    // Local control variables 

    HTuple hv_WindowImagesHeight = new HTuple();
    HTuple hv_WindowImagesWidth = new HTuple(), hv_WindowImagesX = new HTuple();
    HTuple hv_WindowImagesY = new HTuple(), hv_WindowHandleLegend = new HTuple();
    // Initialize local and output iconic variables 
    try
    {
      //This procedure initializes the graphic windows that are used to display a legend.
      //
      hv_WindowImagesHeight.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_height", out hv_WindowImagesHeight);
      hv_WindowImagesWidth.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_width", out hv_WindowImagesWidth);
      hv_WindowImagesX.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_x", out hv_WindowImagesX);
      hv_WindowImagesY.Dispose();
      HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_y", out hv_WindowImagesY);
      HOperatorSet.SetWindowAttr("background_color","black");
      HOperatorSet.OpenWindow(hv_WindowImagesY,(hv_WindowImagesX+hv_WindowImagesWidth)+5,hv_WindowWidth,hv_WindowImagesHeight,0,"visible","",out hv_WindowHandleLegend);
      HDevWindowStack.Push(hv_WindowHandleLegend);
      set_display_font(hv_WindowHandleLegend, 14, "mono", "true", "false");
      HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend", hv_WindowHandleLegend);

      hv_WindowImagesHeight.Dispose();
      hv_WindowImagesWidth.Dispose();
      hv_WindowImagesX.Dispose();
      hv_WindowImagesY.Dispose();
      hv_WindowHandleLegend.Dispose();

      return;
    }
    catch (HalconException HDevExpDefaultException)
    {

      hv_WindowImagesHeight.Dispose();
      hv_WindowImagesWidth.Dispose();
      hv_WindowImagesX.Dispose();
      hv_WindowImagesY.Dispose();
      hv_WindowHandleLegend.Dispose();

      throw HDevExpDefaultException;
    }
  }

  // Short Description: Generates NumColors distinct colors 
  public void get_distinct_colors (HTuple hv_NumColors, HTuple hv_Random, HTuple hv_StartColor, 
      HTuple hv_EndColor, out HTuple hv_Colors)
  {



      // Local iconic variables 

      HObject ho_HLSImageH, ho_HLSImageL, ho_HLSImageS;
      HObject ho_ImageR, ho_ImageG, ho_ImageB;

      // Local control variables 

      HTuple hv_IsString = new HTuple(), hv_Hue = new HTuple();
      HTuple hv_Lightness = new HTuple(), hv_Saturation = new HTuple();
      HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
      HTuple hv_Red = new HTuple(), hv_Green = new HTuple();
      HTuple hv_Blue = new HTuple();
      HTuple   hv_EndColor_COPY_INP_TMP = new HTuple(hv_EndColor);
      HTuple   hv_Random_COPY_INP_TMP = new HTuple(hv_Random);

      // Initialize local and output iconic variables 
      HOperatorSet.GenEmptyObj(out ho_HLSImageH);
      HOperatorSet.GenEmptyObj(out ho_HLSImageL);
      HOperatorSet.GenEmptyObj(out ho_HLSImageS);
      HOperatorSet.GenEmptyObj(out ho_ImageR);
      HOperatorSet.GenEmptyObj(out ho_ImageG);
      HOperatorSet.GenEmptyObj(out ho_ImageB);
      hv_Colors = new HTuple();
      try
      {
      //
      //We get distinct color-values first in HLS color-space.
      //Assumes hue [0, EndColor), lightness [0, 1), saturation [0, 1).
      //
      //Parameter checks.
      //NumColors.
      if ((int)(new HTuple(hv_NumColors.TupleLess(1))) != 0)
      {
        throw new HalconException("NumColors should be at least 1");
      }
      if ((int)(((hv_NumColors.TupleIsInt())).TupleNot()) != 0)
      {
        throw new HalconException("NumColors should be of type int");
      }
      if ((int)(new HTuple((new HTuple(hv_NumColors.TupleLength())).TupleNotEqual(
          1))) != 0)
      {
        throw new HalconException("NumColors should have length 1");
      }
      //Random.
      if ((int)((new HTuple(hv_Random_COPY_INP_TMP.TupleNotEqual(0))).TupleAnd(new HTuple(hv_Random_COPY_INP_TMP.TupleNotEqual(
          1)))) != 0)
      {
        hv_IsString.Dispose();
        HOperatorSet.TupleIsString(hv_Random_COPY_INP_TMP, out hv_IsString);
        if ((int)(hv_IsString) != 0)
        {
          using (HDevDisposeHelper dh = new HDevDisposeHelper())
          {
          {
          HTuple 
            ExpTmpLocalVar_Random = (new HTuple(hv_Random_COPY_INP_TMP.TupleEqual(
              "true"))).TupleOr("false");
          hv_Random_COPY_INP_TMP.Dispose();
          hv_Random_COPY_INP_TMP = ExpTmpLocalVar_Random;
          }
          }
        }
        else
        {
          throw new HalconException("Random should be either true or false");
        }
      }
      //StartColor.
      if ((int)(new HTuple((new HTuple(hv_StartColor.TupleLength())).TupleNotEqual(
          1))) != 0)
      {
        throw new HalconException("StartColor should have length 1");
      }
      if ((int)((new HTuple(hv_StartColor.TupleLess(0))).TupleOr(new HTuple(hv_StartColor.TupleGreater(
          255)))) != 0)
      {
        throw new HalconException(new HTuple("StartColor should be in the range [0, 255]"));
      }
      if ((int)(((hv_StartColor.TupleIsInt())).TupleNot()) != 0)
      {
        throw new HalconException("StartColor should be of type int");
      }
      //EndColor.
      if ((int)(new HTuple((new HTuple(hv_EndColor_COPY_INP_TMP.TupleLength())).TupleNotEqual(
          1))) != 0)
      {
        throw new HalconException("EndColor should have length 1");
      }
      if ((int)((new HTuple(hv_EndColor_COPY_INP_TMP.TupleLess(0))).TupleOr(new HTuple(hv_EndColor_COPY_INP_TMP.TupleGreater(
          255)))) != 0)
      {
        throw new HalconException(new HTuple("EndColor should be in the range [0, 255]"));
      }
      if ((int)(((hv_EndColor_COPY_INP_TMP.TupleIsInt())).TupleNot()) != 0)
      {
        throw new HalconException("EndColor should be of type int");
      }
      //
      //Color generation.
      if ((int)(new HTuple(hv_StartColor.TupleGreater(hv_EndColor_COPY_INP_TMP))) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_EndColor = hv_EndColor_COPY_INP_TMP+255;
        hv_EndColor_COPY_INP_TMP.Dispose();
        hv_EndColor_COPY_INP_TMP = ExpTmpLocalVar_EndColor;
        }
        }
      }
      if ((int)(new HTuple(hv_NumColors.TupleNotEqual(1))) != 0)
      {
        hv_Hue.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Hue = (hv_StartColor+(((((hv_EndColor_COPY_INP_TMP-hv_StartColor)*((HTuple.TupleGenSequence(
            0,hv_NumColors-1,1)).TupleReal()))/(((hv_NumColors-1)).TupleReal()))).TupleInt()
            ))%255;
        }
      }
      else
      {
        hv_Hue.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Hue = ((hv_StartColor.TupleConcat(
            hv_EndColor_COPY_INP_TMP))).TupleMean();
        }
      }
      if ((int)(hv_Random_COPY_INP_TMP) != 0)
      {
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        {
        HTuple 
          ExpTmpLocalVar_Hue = hv_Hue.TupleSelect(
            (HTuple.TupleRand(hv_NumColors)).TupleSortIndex());
        hv_Hue.Dispose();
        hv_Hue = ExpTmpLocalVar_Hue;
        }
        }
        hv_Lightness.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Lightness = ((((5.0+HTuple.TupleRand(
            hv_NumColors))*255.0)/10.0)).TupleInt();
        }
        hv_Saturation.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Saturation = ((((9.0+HTuple.TupleRand(
            hv_NumColors))*255.0)/10.0)).TupleInt();
        }
      }
      else
      {
        hv_Lightness.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Lightness = ((HTuple.TupleGenConst(
            hv_NumColors,0.55)*255.0)).TupleInt();
        }
        hv_Saturation.Dispose();
        using (HDevDisposeHelper dh = new HDevDisposeHelper())
        {
        hv_Saturation = ((HTuple.TupleGenConst(
            hv_NumColors,0.95)*255.0)).TupleInt();
        }
      }
      //
      //Write colors to a 3-channel image in order to transform easier.
      ho_HLSImageH.Dispose();
      HOperatorSet.GenImageConst(out ho_HLSImageH, "byte", 1, hv_NumColors);
      ho_HLSImageL.Dispose();
      HOperatorSet.GenImageConst(out ho_HLSImageL, "byte", 1, hv_NumColors);
      ho_HLSImageS.Dispose();
      HOperatorSet.GenImageConst(out ho_HLSImageS, "byte", 1, hv_NumColors);
      hv_Rows.Dispose();hv_Columns.Dispose();
      HOperatorSet.GetRegionPoints(ho_HLSImageH, out hv_Rows, out hv_Columns);
      HOperatorSet.SetGrayval(ho_HLSImageH, hv_Rows, hv_Columns, hv_Hue);
      HOperatorSet.SetGrayval(ho_HLSImageL, hv_Rows, hv_Columns, hv_Lightness);
      HOperatorSet.SetGrayval(ho_HLSImageS, hv_Rows, hv_Columns, hv_Saturation);
      //
      //Convert from HLS to RGB.
      ho_ImageR.Dispose();ho_ImageG.Dispose();ho_ImageB.Dispose();
      HOperatorSet.TransToRgb(ho_HLSImageH, ho_HLSImageL, ho_HLSImageS, out ho_ImageR, 
          out ho_ImageG, out ho_ImageB, "hls");
      //
      //Get RGB-values and transform to Hex.
      hv_Red.Dispose();
      HOperatorSet.GetGrayval(ho_ImageR, hv_Rows, hv_Columns, out hv_Red);
      hv_Green.Dispose();
      HOperatorSet.GetGrayval(ho_ImageG, hv_Rows, hv_Columns, out hv_Green);
      hv_Blue.Dispose();
      HOperatorSet.GetGrayval(ho_ImageB, hv_Rows, hv_Columns, out hv_Blue);
      hv_Colors.Dispose();
      using (HDevDisposeHelper dh = new HDevDisposeHelper())
      {
      hv_Colors = (("#"+(hv_Red.TupleString(
          "02x")))+(hv_Green.TupleString("02x")))+(hv_Blue.TupleString("02x"));
      }
      ho_HLSImageH.Dispose();
      ho_HLSImageL.Dispose();
      ho_HLSImageS.Dispose();
      ho_ImageR.Dispose();
      ho_ImageG.Dispose();
      ho_ImageB.Dispose();

      hv_EndColor_COPY_INP_TMP.Dispose();
      hv_Random_COPY_INP_TMP.Dispose();
      hv_IsString.Dispose();
      hv_Hue.Dispose();
      hv_Lightness.Dispose();
      hv_Saturation.Dispose();
      hv_Rows.Dispose();
      hv_Columns.Dispose();
      hv_Red.Dispose();
      hv_Green.Dispose();
      hv_Blue.Dispose();

      return;

    }
    catch (HalconException HDevExpDefaultException)
    {
      ho_HLSImageH.Dispose();
      ho_HLSImageL.Dispose();
      ho_HLSImageS.Dispose();
      ho_ImageR.Dispose();
      ho_ImageG.Dispose();
      ho_ImageB.Dispose();

      hv_EndColor_COPY_INP_TMP.Dispose();
      hv_Random_COPY_INP_TMP.Dispose();
      hv_IsString.Dispose();
      hv_Hue.Dispose();
      hv_Lightness.Dispose();
      hv_Saturation.Dispose();
      hv_Rows.Dispose();
      hv_Columns.Dispose();
      hv_Red.Dispose();
      hv_Green.Dispose();
      hv_Blue.Dispose();

      throw HDevExpDefaultException;
    }
  }

  #region DispImageAdaptively(自适应显示图像,不会改变图像长宽比)
  /// <summary>
  /// 自适应显示图像,不会改变图像长宽比
  /// </summary>
  public void DispImageAdaptively(ref HWindowControl hWindowControl, HObject ho_Image)
  {

      HOperatorSet.ClearWindow(hWindowControl.HalconWindow);

      int mW = hWindowControl.Width;

      int mH = hWindowControl.Height;

      HTuple hv_width = new HTuple(); HTuple hv_height = new HTuple();

      HOperatorSet.GetImageSize(ho_Image, out hv_width, out hv_height);

      int imageW = Convert.ToInt32(hv_width.ToString());

      int imageH = Convert.ToInt32(hv_height.ToString());

      if (mW > 0 && mH > 0)
      {

          double mScale_Window = Convert.ToDouble(mW) / Convert.ToDouble(mH);

          double mScale_Image = Convert.ToDouble(imageW) / Convert.ToDouble(imageH);

          double row1, column1, row2, column2;

          int mH_1 = Convert.ToInt32(mW / mScale_Image);

          System.Drawing.Rectangle rect = hWindowControl.ImagePart;



          if (mH_1 > mH)
          {

              row1 = 0;

              row2 = imageH;

              double mImage_w = imageH * mScale_Window - imageW;

              double mD_Image_W = Math.Abs(mImage_w / 2.0);

              column1 = mD_Image_W;

              column2 = imageW + mD_Image_W;



              rect.X = -(int)Math.Round(mD_Image_W);

              rect.Y = 0;

              rect.Height = imageH;

              rect.Width = (int)Math.Round(imageH * mScale_Window);

          }

          else
          {

              column1 = 0;

              column2 = imageW;

              double mImage_h = Convert.ToDouble(imageW) / mScale_Window - imageH;

              double mD_Image_H = Math.Abs(mImage_h / 2.0);

              row1 = mD_Image_H;

              row2 = imageH + mD_Image_H;



              rect.X = 0;

              rect.Y = -(int)Math.Round(mD_Image_H);

              rect.Height = (int)Math.Round(Convert.ToDouble(imageW) / mScale_Window);

              rect.Width = imageW;

          }

          hWindowControl.ImagePart = rect;

      }

      HOperatorSet.DispObj(ho_Image, hWindowControl.HalconWindow);

  }
  #endregion
    }
}
