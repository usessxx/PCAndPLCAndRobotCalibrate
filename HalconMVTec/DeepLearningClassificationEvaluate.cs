using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using HalconDotNet;
using System.Windows.Forms;
using System.Threading;

namespace HalconMVTec
{
    public class DeepLearningClassificationEvaluate
    {
        // Local control variables 
        HTuple hv_PreprocessResultDirectoryPath = new HTuple();//存储预处理结果-sample文件夹 及 hdict文件的上一级文件夹路径(包含文件夹名)
        HTuple hv_PreprocessResultFileName = new HTuple();//预处理结果文件名(以".hdict"为后缀,例如:dl_preprocess_dataset.hdict)
        //HTuple hv_PreprocessResultParameterFileName = new HTuple();//预处理结果-参数的文件名(以".hdict"为后缀,例如:dl_preprocess_param.hdict)
        HTuple hv_BestModelBaseName = new HTuple();//已训练好的Best模型文件的存放路径(包含文件名,不需要后缀)(例如:best_dl_model_classification.hdl;best_dl_model_classification_info.hdict)

        HTuple hv_ClassificationMeasures = new HTuple();
        HTuple hv_BatchSize = new HTuple();
        HTuple hv_UseGPU = new HTuple();
        HTuple hv_CudaLoaded = new HTuple();
        HTuple hv_CuDNNLoaded = new HTuple();
        HTuple hv_CuBlasLoaded = new HTuple();
        HTuple hv_DLModelHandle = new HTuple();
        HTuple hv_DLDataset = new HTuple();
        HTuple hv_GenParamEval = new HTuple();
        HTuple hv_EvaluationResult = new HTuple();
        HTuple hv_EvalParams = new HTuple();
        HTuple hv_WindowHandleDict = new HTuple();
        HTuple hv_GenParamEvalDisplay = new HTuple();
        HTuple hv_SelectedHeatmapGTClassName = new HTuple();
        HTuple hv_SelectedHeatmapInfClassName = new HTuple();
        HTuple hv_EvaluatedSamples = new HTuple();
        HTuple hv_ImageIDs = new HTuple();
        HTuple hv_ImageLabelIDs = new HTuple();
        HTuple hv_Predictions = new HTuple();
        HTuple hv_ClassNames = new HTuple();
        HTuple hv_ClassIDs = new HTuple();
        HTuple hv_PredictedClassID = new HTuple();
        HTuple hv_GroundTruthClassID = new HTuple();
        HTuple hv_GTIndices = new HTuple();
        HTuple hv_PredictionIndices = new HTuple();
        HTuple hv_ImageIDsSelected = new HTuple();
        HTuple hv_HeatmapMethod = new HTuple();
        HTuple hv_TargetClassID = new HTuple();
        HTuple hv_HeatmapParam = new HTuple();
        HTuple hv_FeatureSize = new HTuple();
        HTuple hv_SamplingSize = new HTuple();
        HTuple hv_DLSamples = new HTuple();
        HTuple hv_Index = new HTuple();
        HTuple hv_DLSampleIndex = new HTuple();
        HTuple hv_DLSample = new HTuple();
        HTuple hv_DLResult = new HTuple();


        public bool displayNextFlag = false;

        #region DeepLearningClassificationEvaluate(构造函数里对评估参数初始化)
        //构造函数里对评估参数初始化
        public DeepLearningClassificationEvaluate()
        {
            //MODIFY
            //ADD FOR DISPLAY
            //非常重要!如果没有以下4行代码,则开启的两个窗口不显示内容,且这两个窗口是死机的状态!!!
            HOperatorSet.SetSystem("width", 512);
            HOperatorSet.SetSystem("height", 512);
            if (HalconAPI.isWindows)
                HOperatorSet.SetSystem("use_window_thread", "true");
        }
        #endregion

        #region EvaluateAction(评估开始)
        public void EvaluateAction(string preprocessResultDirectoryPath, string preprocessResultFileName,string bestModelBaseName)
        {
            // Initialize local and output iconic variables 
            try
            {
                dev_update_off();


                hv_PreprocessResultDirectoryPath = preprocessResultDirectoryPath;
                hv_PreprocessResultFileName=preprocessResultFileName;
                hv_BestModelBaseName = bestModelBaseName;
                //Evaluation parameters.
                //
                //Evaluation measures.
                //因为加了 top3_error 会报错(为什么?),所以取消
                //ClassificationMeasures := ['top1_error','top3_error','precision','recall','f_score','absolute_confusion_matrix','relative_confusion_matrix']
                hv_ClassificationMeasures.Dispose();
                hv_ClassificationMeasures = new HTuple();
                hv_ClassificationMeasures[0] = "top1_error";
                hv_ClassificationMeasures[1] = "precision";
                hv_ClassificationMeasures[2] = "recall";
                hv_ClassificationMeasures[3] = "f_score";
                hv_ClassificationMeasures[4] = "absolute_confusion_matrix";
                hv_ClassificationMeasures[5] = "relative_confusion_matrix";
                //Batch size used during evaluation.
                hv_BatchSize.Dispose();
                hv_BatchSize = 4;
                //The evaluation can be performed on GPU or CPU.
                //See the respective system requirements in the Installation Guide.
                hv_UseGPU.Dispose();
                hv_UseGPU = 1;
                //*
                //
                //**********************************
                //**   Evaluation of the model   ***
                //**********************************
                //
                //Check availability of GPU mode.
                if ((int)(hv_UseGPU) != 0)
                {
                    hv_CudaLoaded.Dispose();
                    HOperatorSet.GetSystem("cuda_loaded", out hv_CudaLoaded);
                    hv_CuDNNLoaded.Dispose();
                    HOperatorSet.GetSystem("cudnn_loaded", out hv_CuDNNLoaded);
                    hv_CuBlasLoaded.Dispose();
                    HOperatorSet.GetSystem("cublas_loaded", out hv_CuBlasLoaded);
                    if ((int)((new HTuple((new HTuple((new HTuple(hv_CudaLoaded.TupleEqual("true"))).TupleAnd(
                        new HTuple(hv_CuDNNLoaded.TupleEqual("true"))))).TupleAnd(new HTuple(hv_CuBlasLoaded.TupleEqual(
                        "true"))))).TupleNot()) != 0)
                    {
                        hv_UseGPU.Dispose();
                        hv_UseGPU = 0;
                    }
                }

                try
                {
                    check_data_availability_COPY_1(hv_PreprocessResultDirectoryPath, hv_PreprocessResultDirectoryPath + "\\" + hv_PreprocessResultFileName, hv_BestModelBaseName + ".hdl", 1);
                }
                catch (Exception ex)
                {
                    MessageBox.Show("数据文件检查错误!" + "\r" + ex.ToString());
                    return;
                }
                //
                //Read the retrained model.
                hv_DLModelHandle.Dispose();
                HOperatorSet.ReadDlModel(hv_BestModelBaseName, out hv_DLModelHandle);
                //
                //Initialize the model.
                if ((int)(hv_UseGPU.TupleNot()) != 0)
                {
                    HOperatorSet.SetDlModelParam(hv_DLModelHandle, "runtime", "cpu");
                }
                HOperatorSet.SetDlModelParam(hv_DLModelHandle, "batch_size", hv_BatchSize);
                HOperatorSet.SetDlModelParam(hv_DLModelHandle, "runtime_init", "immediately");
                //
                //Read the preprocessed DLDataset file.
                hv_DLDataset.Dispose();
                HOperatorSet.ReadDict(hv_PreprocessResultDirectoryPath + "\\" + hv_PreprocessResultFileName, new HTuple(), new HTuple(), out hv_DLDataset);
                //
                //Set parameters for evaluation.
                hv_GenParamEval.Dispose();
                HOperatorSet.CreateDict(out hv_GenParamEval);
                HOperatorSet.SetDictTuple(hv_GenParamEval, "measures", hv_ClassificationMeasures);
                HOperatorSet.SetDictTuple(hv_GenParamEval, "show_progress", "true");
                //
                //Evaluate the retrained model.
                hv_EvaluationResult.Dispose(); hv_EvalParams.Dispose();
                evaluate_dl_model(hv_DLDataset, hv_DLModelHandle, "split", "test", hv_GenParamEval,
                    out hv_EvaluationResult, out hv_EvalParams);
                //
                //
                //******************************
                //**   Display the results   ***
                //******************************
                //
                //Display measures.
                hv_WindowHandleDict.Dispose();
                HOperatorSet.CreateDict(out hv_WindowHandleDict);
                hv_GenParamEvalDisplay.Dispose();
                HOperatorSet.CreateDict(out hv_GenParamEvalDisplay);
                HOperatorSet.SetDictTuple(hv_GenParamEvalDisplay, "display_mode", (((new HTuple("measures")).TupleConcat(
                    "pie_charts_precision")).TupleConcat("pie_charts_recall")).TupleConcat(
                    "absolute_confusion_matrix"));
                dev_display_classification_evaluation(hv_EvaluationResult, hv_EvalParams, hv_GenParamEvalDisplay,
                    hv_WindowHandleDict);
                if (HDevWindowStack.IsOpen())
                {
                    //MODIFY
                    displayNextFlag = false;
                    while (!displayNextFlag)
                    {
                        Thread.Sleep(100);
                    }
                    displayNextFlag = false;
                    //HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press F5 to continue",
                    //    "window", "bottom", "right", "black", new HTuple(), new HTuple());
                }
                //
                // stop(...); only in hdevelop
                dev_close_window_dict(hv_WindowHandleDict);
                //
                //Call interactive confusion matrix.
                dev_display_dl_interactive_confusion_matrix(hv_DLDataset, hv_EvaluationResult,
                    new HTuple());
                //
                //Close window handles.
                dev_close_window_dict(hv_WindowHandleDict);
                //
                //
                //**************************************
                //**   Visual inspection of images   ***
                //**************************************
                //
                //To inspect some examples more precisely,
                //calculate and display a heatmap.
                //Here, we choose the samples
                //labeled and classified as 'contamination'.
                //
                hv_SelectedHeatmapGTClassName.Dispose();
                hv_SelectedHeatmapGTClassName = "contamination";
                hv_SelectedHeatmapInfClassName.Dispose();
                hv_SelectedHeatmapInfClassName = "contamination";
                //
                //Get information from DLDataset and EvaluationResult.
                hv_EvaluatedSamples.Dispose();
                HOperatorSet.GetDictTuple(hv_EvaluationResult, "evaluated_samples", out hv_EvaluatedSamples);
                hv_ImageIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvaluatedSamples, "image_ids", out hv_ImageIDs);
                hv_ImageLabelIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvaluatedSamples, "image_label_ids", out hv_ImageLabelIDs);
                hv_Predictions.Dispose();
                HOperatorSet.GetDictTuple(hv_EvaluatedSamples, "top1_predictions", out hv_Predictions);
                hv_ClassNames.Dispose();
                HOperatorSet.GetDictTuple(hv_DLDataset, "class_names", out hv_ClassNames);
                hv_ClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_DLDataset, "class_ids", out hv_ClassIDs);
                //Get class IDs for selected classes.
                //此处报错.不知道什么原因.改为置零
                //PredictedClassID := ClassIDs[find(ClassNames,SelectedHeatmapInfClassName)]
                //GroundTruthClassID := ClassIDs[find(ClassNames,SelectedHeatmapGTClassName)]
                hv_PredictedClassID.Dispose();
                hv_PredictedClassID = 0;
                hv_GroundTruthClassID.Dispose();
                hv_GroundTruthClassID = 0;
                //Get tuple position of selected classes.
                hv_GTIndices.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_GTIndices = ((hv_ImageLabelIDs.TupleEqualElem(
                        hv_GroundTruthClassID))).TupleFind(1);
                }
                hv_PredictionIndices.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PredictionIndices = ((hv_Predictions.TupleEqualElem(
                        hv_PredictedClassID))).TupleFind(1);
                }
                //Get image IDs for selected combination.
                hv_ImageIDsSelected.Dispose();
                hv_ImageIDsSelected = new HTuple();
                if ((int)((new HTuple(hv_PredictionIndices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_PredictionIndices.TupleNotEqual(
                    new HTuple())))) != 0)
                {
                    hv_ImageIDsSelected.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageIDsSelected = hv_ImageIDs.TupleSelect(
                            hv_GTIndices.TupleIntersection(hv_PredictionIndices));
                    }
                }
                //
                //We offer two heatmap options, a fast heatmap operator
                //supporting the method 'grad_cam' and a confidence-based
                //approach implemented as procedure.
                //In this example, set HeatmapMethod to 'heatmap_grad_cam'
                //or 'heatmap_confidence_based' to switch between the heatmap options.
                hv_HeatmapMethod.Dispose();
                hv_HeatmapMethod = "heatmap_grad_cam";
                //
                if ((int)((new HTuple(hv_HeatmapMethod.TupleNotEqual("heatmap_grad_cam"))).TupleAnd(
                    new HTuple(hv_HeatmapMethod.TupleNotEqual("heatmap_confidence_based")))) != 0)
                {
                    throw new HalconException("Unsupported heatmap option.");
                }
                else if ((int)((new HTuple(hv_HeatmapMethod.TupleEqual("heatmap_grad_cam"))).TupleAnd(
                    hv_UseGPU.TupleNot())) != 0)
                {
                    throw new HalconException("The heatmap option \"heatmap_grad_cam\" is only supported for GPU runtime");
                }
                //
                //Set the target class ID or [] to show the heatmap
                //for the classified class.
                hv_TargetClassID.Dispose();
                hv_TargetClassID = new HTuple();
                hv_HeatmapParam.Dispose();
                HOperatorSet.CreateDict(out hv_HeatmapParam);
                if ((int)(new HTuple(hv_HeatmapMethod.TupleEqual("heatmap_grad_cam"))) != 0)
                {
                    //Set generic parameters for operator heatmap.
                    HOperatorSet.SetDictTuple(hv_HeatmapParam, "use_conv_only", "false");
                    HOperatorSet.SetDictTuple(hv_HeatmapParam, "scaling", "scale_after_relu");
                }
                else
                {
                    //Set target class ID.
                    HOperatorSet.SetDictTuple(hv_HeatmapParam, "target_class_id", hv_TargetClassID);
                    //Set the feature size and the sampling size for the
                    //confidence based approach.
                    hv_FeatureSize.Dispose();
                    hv_FeatureSize = 30;
                    hv_SamplingSize.Dispose();
                    hv_SamplingSize = 10;
                    HOperatorSet.SetDictTuple(hv_HeatmapParam, "feature_size", hv_FeatureSize);
                    HOperatorSet.SetDictTuple(hv_HeatmapParam, "sampling_size", hv_SamplingSize);
                }
                //
                //Heatmaps are displayed in sequence, hence set batch size to 1.
                HOperatorSet.SetDlModelParam(hv_DLModelHandle, "batch_size", 1);
                //
                //Visualize heatmaps for selected samples.
                hv_WindowHandleDict.Dispose();
                HOperatorSet.CreateDict(out hv_WindowHandleDict);
                hv_DLSamples.Dispose();
                HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLSamples);
                HTuple end_val168 = (((new HTuple((new HTuple(hv_ImageIDsSelected.TupleLength()
                    )) - 1)).TupleConcat(10))).TupleMin();
                HTuple step_val168 = 1;
                for (hv_Index = 0; hv_Index.Continue(end_val168, step_val168); hv_Index = hv_Index.TupleAdd(step_val168))
                {
                    //Select the corresponding DLSample.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DLSampleIndex.Dispose();
                        find_dl_samples(hv_DLSamples, "image_id", hv_ImageIDsSelected.TupleSelect(
                            hv_Index), "match", out hv_DLSampleIndex);
                    }
                    hv_DLSample.Dispose();
                    read_dl_samples(hv_DLDataset, hv_DLSampleIndex, out hv_DLSample);
                    //
                    if ((int)(new HTuple(hv_HeatmapMethod.TupleEqual("heatmap_grad_cam"))) != 0)
                    {
                        hv_DLResult.Dispose();
                        HOperatorSet.GenDlModelHeatmap(hv_DLModelHandle, hv_DLSample, "grad_cam",
                            hv_TargetClassID, hv_HeatmapParam, out hv_DLResult);
                    }
                    else
                    {
                        //Create temporary DLResult for display.
                        hv_DLResult.Dispose();
                        HOperatorSet.CreateDict(out hv_DLResult);
                        gen_dl_model_classification_heatmap(hv_DLModelHandle, hv_DLSample, hv_DLResult,
                            hv_HeatmapParam);
                    }
                    dev_display_dl_data(hv_DLSample, hv_DLResult, hv_DLDataset, hv_HeatmapMethod,
                        new HTuple(), hv_WindowHandleDict);
                    if (HDevWindowStack.IsOpen())
                    {
                        //MODIFY
                        displayNextFlag = false;
                        while (!displayNextFlag)
                        {
                            Thread.Sleep(100);
                        }
                        displayNextFlag = false;
                        //HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press F5 to continue.",
                        //    "window", "bottom", "right", "black", new HTuple(), new HTuple());
                    }
                    // stop(...); only in hdevelop
                }
                //
                //Close the windows.
                dev_close_window_dict(hv_WindowHandleDict);
                //
            }
            catch (HalconException HDevExpDefaultException)
            {
                hv_ClassificationMeasures.Dispose();
                hv_BatchSize.Dispose();
                hv_UseGPU.Dispose();
                hv_CudaLoaded.Dispose();
                hv_CuDNNLoaded.Dispose();
                hv_CuBlasLoaded.Dispose();
                hv_DLModelHandle.Dispose();
                hv_DLDataset.Dispose();
                hv_GenParamEval.Dispose();
                hv_EvaluationResult.Dispose();
                hv_EvalParams.Dispose();
                hv_WindowHandleDict.Dispose();
                hv_GenParamEvalDisplay.Dispose();
                hv_SelectedHeatmapGTClassName.Dispose();
                hv_SelectedHeatmapInfClassName.Dispose();
                hv_EvaluatedSamples.Dispose();
                hv_ImageIDs.Dispose();
                hv_ImageLabelIDs.Dispose();
                hv_Predictions.Dispose();
                hv_ClassNames.Dispose();
                hv_ClassIDs.Dispose();
                hv_PredictedClassID.Dispose();
                hv_GroundTruthClassID.Dispose();
                hv_GTIndices.Dispose();
                hv_PredictionIndices.Dispose();
                hv_ImageIDsSelected.Dispose();
                hv_HeatmapMethod.Dispose();
                hv_TargetClassID.Dispose();
                hv_HeatmapParam.Dispose();
                hv_FeatureSize.Dispose();
                hv_SamplingSize.Dispose();
                hv_DLSamples.Dispose();
                hv_Index.Dispose();
                hv_DLSampleIndex.Dispose();
                hv_DLSample.Dispose();
                hv_DLResult.Dispose();

                throw HDevExpDefaultException;
            }

            hv_ClassificationMeasures.Dispose();
            hv_BatchSize.Dispose();
            hv_UseGPU.Dispose();
            hv_CudaLoaded.Dispose();
            hv_CuDNNLoaded.Dispose();
            hv_CuBlasLoaded.Dispose();
            hv_DLModelHandle.Dispose();
            hv_DLDataset.Dispose();
            hv_GenParamEval.Dispose();
            hv_EvaluationResult.Dispose();
            hv_EvalParams.Dispose();
            hv_WindowHandleDict.Dispose();
            hv_GenParamEvalDisplay.Dispose();
            hv_SelectedHeatmapGTClassName.Dispose();
            hv_SelectedHeatmapInfClassName.Dispose();
            hv_EvaluatedSamples.Dispose();
            hv_ImageIDs.Dispose();
            hv_ImageLabelIDs.Dispose();
            hv_Predictions.Dispose();
            hv_ClassNames.Dispose();
            hv_ClassIDs.Dispose();
            hv_PredictedClassID.Dispose();
            hv_GroundTruthClassID.Dispose();
            hv_GTIndices.Dispose();
            hv_PredictionIndices.Dispose();
            hv_ImageIDsSelected.Dispose();
            hv_HeatmapMethod.Dispose();
            hv_TargetClassID.Dispose();
            hv_HeatmapParam.Dispose();
            hv_FeatureSize.Dispose();
            hv_SamplingSize.Dispose();
            hv_DLSamples.Dispose();
            hv_Index.Dispose();
            hv_DLSampleIndex.Dispose();
            hv_DLSample.Dispose();
            hv_DLResult.Dispose();

        }
        #endregion





        // Procedures 
        // External procedures 
        public void add_colormap_to_image(HObject ho_GrayValueImage, HObject ho_Image,
            out HObject ho_ColoredImage, HTuple hv_HeatmapColorScheme)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_RGBValueImage, ho_Channels, ho_ChannelsScaled;
            HObject ho_Channel = null, ho_ChannelScaled = null, ho_ChannelScaledByte = null;
            HObject ho_ImageByte, ho_ImageByteR = null, ho_ImageByteG = null;
            HObject ho_ImageByteB = null;

            // Local copy input parameter variables 
            HObject ho_GrayValueImage_COPY_INP_TMP;
            ho_GrayValueImage_COPY_INP_TMP = new HObject(ho_GrayValueImage);



            // Local control variables 

            HTuple hv_Type = new HTuple(), hv_NumChannels = new HTuple();
            HTuple hv_ChannelIndex = new HTuple(), hv_ChannelMin = new HTuple();
            HTuple hv_ChannelMax = new HTuple(), hv__ = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ColoredImage);
            HOperatorSet.GenEmptyObj(out ho_RGBValueImage);
            HOperatorSet.GenEmptyObj(out ho_Channels);
            HOperatorSet.GenEmptyObj(out ho_ChannelsScaled);
            HOperatorSet.GenEmptyObj(out ho_Channel);
            HOperatorSet.GenEmptyObj(out ho_ChannelScaled);
            HOperatorSet.GenEmptyObj(out ho_ChannelScaledByte);
            HOperatorSet.GenEmptyObj(out ho_ImageByte);
            HOperatorSet.GenEmptyObj(out ho_ImageByteR);
            HOperatorSet.GenEmptyObj(out ho_ImageByteG);
            HOperatorSet.GenEmptyObj(out ho_ImageByteB);
            try
            {
                //
                //This procedure adds a gray-value image to a RGB image with a chosen colormap.
                //
                hv_Type.Dispose();
                HOperatorSet.GetImageType(ho_GrayValueImage_COPY_INP_TMP, out hv_Type);
                //The image LUT needs a byte image. Rescale real images.
                if ((int)(new HTuple(hv_Type.TupleEqual("real"))) != 0)
                {
                    {
                        HObject ExpTmpOutVar_0;
                        scale_image_range(ho_GrayValueImage_COPY_INP_TMP, out ExpTmpOutVar_0, 0,
                            1);
                        ho_GrayValueImage_COPY_INP_TMP.Dispose();
                        ho_GrayValueImage_COPY_INP_TMP = ExpTmpOutVar_0;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConvertImageType(ho_GrayValueImage_COPY_INP_TMP, out ExpTmpOutVar_0,
                            "byte");
                        ho_GrayValueImage_COPY_INP_TMP.Dispose();
                        ho_GrayValueImage_COPY_INP_TMP = ExpTmpOutVar_0;
                    }
                }
                else if ((int)(new HTuple(hv_Type.TupleNotEqual("byte"))) != 0)
                {
                    throw new HalconException(new HTuple("For this transformation, a byte or real image is needed!"));
                }
                //
                //Apply the chosen color scheme on the gray value.
                ho_RGBValueImage.Dispose();
                apply_colorscheme_on_gray_value_image(ho_GrayValueImage_COPY_INP_TMP, out ho_RGBValueImage,
                    hv_HeatmapColorScheme);
                //
                //Convert input image to byte image for visualization.
                ho_Channels.Dispose();
                HOperatorSet.ImageToChannels(ho_Image, out ho_Channels);
                hv_NumChannels.Dispose();
                HOperatorSet.CountChannels(ho_Image, out hv_NumChannels);
                ho_ChannelsScaled.Dispose();
                HOperatorSet.GenEmptyObj(out ho_ChannelsScaled);
                HTuple end_val19 = hv_NumChannels;
                HTuple step_val19 = 1;
                for (hv_ChannelIndex = 1; hv_ChannelIndex.Continue(end_val19, step_val19); hv_ChannelIndex = hv_ChannelIndex.TupleAdd(step_val19))
                {
                    ho_Channel.Dispose();
                    HOperatorSet.SelectObj(ho_Channels, out ho_Channel, hv_ChannelIndex);
                    hv_ChannelMin.Dispose(); hv_ChannelMax.Dispose(); hv__.Dispose();
                    HOperatorSet.MinMaxGray(ho_Channel, ho_Channel, 0, out hv_ChannelMin, out hv_ChannelMax,
                        out hv__);
                    ho_ChannelScaled.Dispose();
                    scale_image_range(ho_Channel, out ho_ChannelScaled, hv_ChannelMin, hv_ChannelMax);
                    ho_ChannelScaledByte.Dispose();
                    HOperatorSet.ConvertImageType(ho_ChannelScaled, out ho_ChannelScaledByte,
                        "byte");
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_ChannelsScaled, ho_ChannelScaledByte, out ExpTmpOutVar_0
                            );
                        ho_ChannelsScaled.Dispose();
                        ho_ChannelsScaled = ExpTmpOutVar_0;
                    }
                }
                ho_ImageByte.Dispose();
                HOperatorSet.ChannelsToImage(ho_ChannelsScaled, out ho_ImageByte);
                //
                //Note that ImageByte needs to have the same number of channels as
                //RGBValueImage to display colormap image correctly.
                hv_NumChannels.Dispose();
                HOperatorSet.CountChannels(ho_ImageByte, out hv_NumChannels);
                if ((int)(new HTuple(hv_NumChannels.TupleNotEqual(3))) != 0)
                {
                    //Just take the first channel and use this to generate
                    //an image with 3 channels for visualization.
                    ho_ImageByteR.Dispose();
                    HOperatorSet.AccessChannel(ho_ImageByte, out ho_ImageByteR, 1);
                    ho_ImageByteG.Dispose();
                    HOperatorSet.CopyImage(ho_ImageByteR, out ho_ImageByteG);
                    ho_ImageByteB.Dispose();
                    HOperatorSet.CopyImage(ho_ImageByteR, out ho_ImageByteB);
                    ho_ImageByte.Dispose();
                    HOperatorSet.Compose3(ho_ImageByteR, ho_ImageByteG, ho_ImageByteB, out ho_ImageByte
                        );
                }
                //
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.AddImage(ho_ImageByte, ho_RGBValueImage, out ExpTmpOutVar_0, 0.5,
                        0);
                    ho_RGBValueImage.Dispose();
                    ho_RGBValueImage = ExpTmpOutVar_0;
                }
                ho_ColoredImage.Dispose();
                ho_ColoredImage = new HObject(ho_RGBValueImage);
                //
                ho_GrayValueImage_COPY_INP_TMP.Dispose();
                ho_RGBValueImage.Dispose();
                ho_Channels.Dispose();
                ho_ChannelsScaled.Dispose();
                ho_Channel.Dispose();
                ho_ChannelScaled.Dispose();
                ho_ChannelScaledByte.Dispose();
                ho_ImageByte.Dispose();
                ho_ImageByteR.Dispose();
                ho_ImageByteG.Dispose();
                ho_ImageByteB.Dispose();

                hv_Type.Dispose();
                hv_NumChannels.Dispose();
                hv_ChannelIndex.Dispose();
                hv_ChannelMin.Dispose();
                hv_ChannelMax.Dispose();
                hv__.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_GrayValueImage_COPY_INP_TMP.Dispose();
                ho_RGBValueImage.Dispose();
                ho_Channels.Dispose();
                ho_ChannelsScaled.Dispose();
                ho_Channel.Dispose();
                ho_ChannelScaled.Dispose();
                ho_ChannelScaledByte.Dispose();
                ho_ImageByte.Dispose();
                ho_ImageByteR.Dispose();
                ho_ImageByteG.Dispose();
                ho_ImageByteB.Dispose();

                hv_Type.Dispose();
                hv_NumChannels.Dispose();
                hv_ChannelIndex.Dispose();
                hv_ChannelMin.Dispose();
                hv_ChannelMax.Dispose();
                hv__.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Short Description: Create a lookup table and convert a grey scale image. 
        public void apply_colorscheme_on_gray_value_image(HObject ho_InputImage, out HObject ho_ResultImage,
            HTuple hv_Schema)
        {




            // Local iconic variables 

            HObject ho_ImageR, ho_ImageG, ho_ImageB;

            // Local control variables 

            HTuple hv_X = new HTuple(), hv_Low = new HTuple();
            HTuple hv_High = new HTuple(), hv_OffR = new HTuple();
            HTuple hv_OffG = new HTuple(), hv_OffB = new HTuple();
            HTuple hv_A1 = new HTuple(), hv_A0 = new HTuple(), hv_R = new HTuple();
            HTuple hv_G = new HTuple(), hv_B = new HTuple(), hv_A0R = new HTuple();
            HTuple hv_A0G = new HTuple(), hv_A0B = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ResultImage);
            HOperatorSet.GenEmptyObj(out ho_ImageR);
            HOperatorSet.GenEmptyObj(out ho_ImageG);
            HOperatorSet.GenEmptyObj(out ho_ImageB);
            try
            {
                //
                //This procedure generates an RGB ResultImage for a grey-value InputImage.
                //In order to do so, create a color distribution as look up table
                //according to the Schema.
                //
                hv_X.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_X = HTuple.TupleGenSequence(
                        0, 255, 1);
                }
                hv_Low.Dispose();
                HOperatorSet.TupleGenConst(256, 0, out hv_Low);
                hv_High.Dispose();
                HOperatorSet.TupleGenConst(256, 255, out hv_High);
                //
                if ((int)(new HTuple(hv_Schema.TupleEqual("jet"))) != 0)
                {
                    //Scheme Jet: from blue to red
                    hv_OffR.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_OffR = 3.0 * 64.0;
                    }
                    hv_OffG.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_OffG = 2.0 * 64.0;
                    }
                    hv_OffB.Dispose();
                    hv_OffB = 64.0;
                    hv_A1.Dispose();
                    hv_A1 = -4.0;
                    hv_A0.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_A0 = 255.0 + 128.0;
                    }
                    hv_R.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_R = ((((((((hv_X - hv_OffR)).TupleAbs()
                            ) * hv_A1) + hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
                    }
                    hv_G.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_G = ((((((((hv_X - hv_OffG)).TupleAbs()
                            ) * hv_A1) + hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
                    }
                    hv_B.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_B = ((((((((hv_X - hv_OffB)).TupleAbs()
                            ) * hv_A1) + hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
                    }
                    //
                }
                else if ((int)(new HTuple(hv_Schema.TupleEqual("inverse_jet"))) != 0)
                {
                    //Scheme InvJet: from red to blue.
                    hv_OffR.Dispose();
                    hv_OffR = 64;
                    hv_OffG.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_OffG = 2 * 64;
                    }
                    hv_OffB.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_OffB = 3 * 64;
                    }
                    hv_A1.Dispose();
                    hv_A1 = -4.0;
                    hv_A0.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_A0 = 255.0 + 128.0;
                    }
                    hv_R.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_R = ((((((((hv_X - hv_OffR)).TupleAbs()
                            ) * hv_A1) + hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
                    }
                    hv_G.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_G = ((((((((hv_X - hv_OffG)).TupleAbs()
                            ) * hv_A1) + hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
                    }
                    hv_B.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_B = ((((((((hv_X - hv_OffB)).TupleAbs()
                            ) * hv_A1) + hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
                    }
                    //
                }
                else if ((int)(new HTuple(hv_Schema.TupleEqual("hot"))) != 0)
                {
                    //Scheme Hot.
                    hv_A1.Dispose();
                    hv_A1 = 3.0;
                    hv_A0R.Dispose();
                    hv_A0R = 0.0;
                    hv_A0G.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_A0G = ((1.0 / 3.0) * hv_A1) * 255.0;
                    }
                    hv_A0B.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_A0B = ((2.0 / 3.0) * hv_A1) * 255.0;
                    }
                    hv_R.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_R = (((((hv_X * hv_A1) - hv_A0R)).TupleMax2(
                            hv_Low))).TupleMin2(hv_High);
                    }
                    hv_G.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_G = (((((hv_X * hv_A1) - hv_A0G)).TupleMax2(
                            hv_Low))).TupleMin2(hv_High);
                    }
                    hv_B.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_B = (((((hv_X * hv_A1) - hv_A0B)).TupleMax2(
                            hv_Low))).TupleMin2(hv_High);
                    }
                    //
                }
                else if ((int)(new HTuple(hv_Schema.TupleEqual("inverse_hot"))) != 0)
                {
                    //Scheme Inverse Hot.
                    hv_A1.Dispose();
                    hv_A1 = -3.0;
                    hv_A0R.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_A0R = hv_A1 * 255.0;
                    }
                    hv_A0G.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_A0G = ((2.0 / 3.0) * hv_A1) * 255.0;
                    }
                    hv_A0B.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_A0B = ((1.0 / 3.0) * hv_A1) * 255.0;
                    }
                    hv_R.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_R = (((((hv_X * hv_A1) - hv_A0R)).TupleMax2(
                            hv_Low))).TupleMin2(hv_High);
                    }
                    hv_G.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_G = (((((hv_X * hv_A1) - hv_A0G)).TupleMax2(
                            hv_Low))).TupleMin2(hv_High);
                    }
                    hv_B.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_B = (((((hv_X * hv_A1) - hv_A0B)).TupleMax2(
                            hv_Low))).TupleMin2(hv_High);
                    }
                    //
                }
                else
                {
                    //
                    throw new HalconException(("Unknown color schema: " + hv_Schema) + ".");
                    //
                }
                //
                ho_ImageR.Dispose();
                HOperatorSet.LutTrans(ho_InputImage, out ho_ImageR, hv_R);
                ho_ImageG.Dispose();
                HOperatorSet.LutTrans(ho_InputImage, out ho_ImageG, hv_G);
                ho_ImageB.Dispose();
                HOperatorSet.LutTrans(ho_InputImage, out ho_ImageB, hv_B);
                ho_ResultImage.Dispose();
                HOperatorSet.Compose3(ho_ImageR, ho_ImageG, ho_ImageB, out ho_ResultImage);
                //
                ho_ImageR.Dispose();
                ho_ImageG.Dispose();
                ho_ImageB.Dispose();

                hv_X.Dispose();
                hv_Low.Dispose();
                hv_High.Dispose();
                hv_OffR.Dispose();
                hv_OffG.Dispose();
                hv_OffB.Dispose();
                hv_A1.Dispose();
                hv_A0.Dispose();
                hv_R.Dispose();
                hv_G.Dispose();
                hv_B.Dispose();
                hv_A0R.Dispose();
                hv_A0G.Dispose();
                hv_A0B.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_ImageR.Dispose();
                ho_ImageG.Dispose();
                ho_ImageB.Dispose();

                hv_X.Dispose();
                hv_Low.Dispose();
                hv_High.Dispose();
                hv_OffR.Dispose();
                hv_OffG.Dispose();
                hv_OffB.Dispose();
                hv_A1.Dispose();
                hv_A0.Dispose();
                hv_R.Dispose();
                hv_G.Dispose();
                hv_B.Dispose();
                hv_A0R.Dispose();
                hv_A0G.Dispose();
                hv_A0B.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        public void area_iou(HTuple hv_Sample, HTuple hv_Result, HTuple hv_InstanceType,
            HTuple hv_ResultSortIndices, out HTuple hv_SampleArea, out HTuple hv_ResultArea,
            out HTuple hv_IoU)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_GtRow1 = new HTuple(), hv_GtCol1 = new HTuple();
            HTuple hv_GtRow2 = new HTuple(), hv_GtCol2 = new HTuple();
            HTuple hv_ResRow1 = new HTuple(), hv_ResCol1 = new HTuple();
            HTuple hv_ResRow2 = new HTuple(), hv_ResCol2 = new HTuple();
            HTuple hv_GtIdx = new HTuple(), hv_Height = new HTuple();
            HTuple hv_Width = new HTuple(), hv_ValidIdxs = new HTuple();
            HTuple hv_Intersection = new HTuple(), hv_Union = new HTuple();
            HTuple hv_GtRow = new HTuple(), hv_GtCol = new HTuple();
            HTuple hv_GtLength1 = new HTuple(), hv_GtLength2 = new HTuple();
            HTuple hv_GtPhi = new HTuple(), hv_ResRow = new HTuple();
            HTuple hv_ResCol = new HTuple(), hv_ResLength1 = new HTuple();
            HTuple hv_ResLength2 = new HTuple(), hv_ResPhi = new HTuple();
            // Initialize local and output iconic variables 
            hv_SampleArea = new HTuple();
            hv_ResultArea = new HTuple();
            hv_IoU = new HTuple();
            try
            {
                //
                //Compute the intersection over union (IoU) between
                //the ground truth and the inferred bounding box of the object instances.
                //The bounding box type is determined over the InstanceType.
                //
                if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
                {
                    //Get bounding box coordinates.
                    hv_GtRow1.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_row1", out hv_GtRow1);
                    hv_GtCol1.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_col1", out hv_GtCol1);
                    hv_GtRow2.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_row2", out hv_GtRow2);
                    hv_GtCol2.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_col2", out hv_GtCol2);
                    hv_ResRow1.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_row1", out hv_ResRow1);
                    hv_ResCol1.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_col1", out hv_ResCol1);
                    hv_ResRow2.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_row2", out hv_ResRow2);
                    hv_ResCol2.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_col2", out hv_ResCol2);
                    //
                    //Sort the results.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResRow1 = hv_ResRow1.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResRow1.Dispose();
                            hv_ResRow1 = ExpTmpLocalVar_ResRow1;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResCol1 = hv_ResCol1.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResCol1.Dispose();
                            hv_ResCol1 = ExpTmpLocalVar_ResCol1;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResRow2 = hv_ResRow2.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResRow2.Dispose();
                            hv_ResRow2 = ExpTmpLocalVar_ResRow2;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResCol2 = hv_ResCol2.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResCol2.Dispose();
                            hv_ResCol2 = ExpTmpLocalVar_ResCol2;
                        }
                    }
                    //
                    //Compute areas.
                    hv_SampleArea.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SampleArea = (hv_GtRow2 - hv_GtRow1) * (hv_GtCol2 - hv_GtCol1);
                    }
                    hv_ResultArea.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ResultArea = (hv_ResRow2 - hv_ResRow1) * (hv_ResCol2 - hv_ResCol1);
                    }
                    //
                    //Compute IoUs.
                    hv_IoU.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_IoU = HTuple.TupleGenConst(
                            (new HTuple(hv_GtRow1.TupleLength())) * (new HTuple(hv_ResRow1.TupleLength()
                            )), 0);
                    }
                    if ((int)(new HTuple((new HTuple(hv_IoU.TupleLength())).TupleGreater(0))) != 0)
                    {
                        for (hv_GtIdx = 0; (int)hv_GtIdx <= (int)((new HTuple(hv_GtRow1.TupleLength()
                            )) - 1); hv_GtIdx = (int)hv_GtIdx + 1)
                        {
                            hv_Height.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Height = (((hv_GtRow2.TupleSelect(
                                    hv_GtIdx))).TupleMin2(hv_ResRow2)) - (((hv_GtRow1.TupleSelect(hv_GtIdx))).TupleMax2(
                                    hv_ResRow1));
                            }
                            hv_Width.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Width = (((hv_GtCol2.TupleSelect(
                                    hv_GtIdx))).TupleMin2(hv_ResCol2)) - (((hv_GtCol1.TupleSelect(hv_GtIdx))).TupleMax2(
                                    hv_ResCol1));
                            }
                            hv_ValidIdxs.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ValidIdxs = (new HTuple(((hv_Height.TupleGreaterElem(
                                    0))).TupleAnd(hv_Width.TupleGreaterElem(0)))).TupleFind(1);
                            }
                            if ((int)(new HTuple(hv_ValidIdxs.TupleGreater(-1))) != 0)
                            {
                                hv_Intersection.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Intersection = (hv_Height.TupleSelect(
                                        hv_ValidIdxs)) * (hv_Width.TupleSelect(hv_ValidIdxs));
                                }
                                hv_Union.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Union = ((hv_SampleArea.TupleSelect(
                                        hv_GtIdx)) + (hv_ResultArea.TupleSelect(hv_ValidIdxs))) - hv_Intersection;
                                }
                                if (hv_IoU == null)
                                    hv_IoU = new HTuple();
                                hv_IoU[(hv_GtIdx * (new HTuple(hv_ResRow1.TupleLength()))) + hv_ValidIdxs] = (hv_Intersection.TupleReal()
                                    ) / hv_Union;
                            }
                        }
                    }
                }
                else if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
                {
                    //Get bounding box coordinates.
                    hv_GtRow.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_row", out hv_GtRow);
                    hv_GtCol.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_col", out hv_GtCol);
                    hv_GtLength1.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_length1", out hv_GtLength1);
                    hv_GtLength2.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_length2", out hv_GtLength2);
                    hv_GtPhi.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_phi", out hv_GtPhi);
                    hv_ResRow.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_row", out hv_ResRow);
                    hv_ResCol.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_col", out hv_ResCol);
                    hv_ResLength1.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_length1", out hv_ResLength1);
                    hv_ResLength2.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_length2", out hv_ResLength2);
                    hv_ResPhi.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_phi", out hv_ResPhi);
                    //
                    //Sort results.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResRow = hv_ResRow.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResRow.Dispose();
                            hv_ResRow = ExpTmpLocalVar_ResRow;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResCol = hv_ResCol.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResCol.Dispose();
                            hv_ResCol = ExpTmpLocalVar_ResCol;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResLength1 = hv_ResLength1.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResLength1.Dispose();
                            hv_ResLength1 = ExpTmpLocalVar_ResLength1;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResLength2 = hv_ResLength2.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResLength2.Dispose();
                            hv_ResLength2 = ExpTmpLocalVar_ResLength2;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResPhi = hv_ResPhi.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResPhi.Dispose();
                            hv_ResPhi = ExpTmpLocalVar_ResPhi;
                        }
                    }
                    //
                    //Compute Areas.
                    hv_SampleArea.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SampleArea = (4.0 * hv_GtLength1) * hv_GtLength2;
                    }
                    hv_ResultArea.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ResultArea = (4.0 * hv_ResLength1) * hv_ResLength2;
                    }
                    //
                    //Compute IoUs.
                    hv_IoU.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_IoU = HTuple.TupleGenConst(
                            (new HTuple(hv_GtRow.TupleLength())) * (new HTuple(hv_ResRow.TupleLength()
                            )), 0);
                    }
                    if ((int)(new HTuple((new HTuple(hv_IoU.TupleLength())).TupleGreater(0))) != 0)
                    {
                        for (hv_GtIdx = 0; (int)hv_GtIdx <= (int)((new HTuple(hv_GtRow.TupleLength()
                            )) - 1); hv_GtIdx = (int)hv_GtIdx + 1)
                        {
                            hv_ValidIdxs.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ValidIdxs = (new HTuple(((((hv_SampleArea.TupleSelect(
                                    hv_GtIdx))).TupleGreaterElem(0))).TupleAnd(hv_ResultArea.TupleGreaterElem(
                                    0)))).TupleFind(1);
                            }
                            if ((int)(new HTuple(hv_ValidIdxs.TupleGreater(-1))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Intersection.Dispose();
                                    HOperatorSet.AreaIntersectionRectangle2(hv_GtRow.TupleSelect(hv_GtIdx),
                                        hv_GtCol.TupleSelect(hv_GtIdx), hv_GtPhi.TupleSelect(hv_GtIdx),
                                        hv_GtLength1.TupleSelect(hv_GtIdx), hv_GtLength2.TupleSelect(hv_GtIdx),
                                        hv_ResRow.TupleSelect(hv_ValidIdxs), hv_ResCol.TupleSelect(hv_ValidIdxs),
                                        hv_ResPhi.TupleSelect(hv_ValidIdxs), hv_ResLength1.TupleSelect(
                                        hv_ValidIdxs), hv_ResLength2.TupleSelect(hv_ValidIdxs), out hv_Intersection);
                                }
                                hv_Union.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Union = ((hv_SampleArea.TupleSelect(
                                        hv_GtIdx)) + (hv_ResultArea.TupleSelect(hv_ValidIdxs))) - hv_Intersection;
                                }
                                if (hv_IoU == null)
                                    hv_IoU = new HTuple();
                                hv_IoU[(hv_GtIdx * (new HTuple(hv_ResRow.TupleLength()))) + hv_ValidIdxs] = (hv_Intersection.TupleReal()
                                    ) / hv_Union;
                            }
                        }
                    }
                }
                else
                {
                    throw new HalconException(("Instance type '" + hv_InstanceType) + "' is not supported");
                }

                hv_GtRow1.Dispose();
                hv_GtCol1.Dispose();
                hv_GtRow2.Dispose();
                hv_GtCol2.Dispose();
                hv_ResRow1.Dispose();
                hv_ResCol1.Dispose();
                hv_ResRow2.Dispose();
                hv_ResCol2.Dispose();
                hv_GtIdx.Dispose();
                hv_Height.Dispose();
                hv_Width.Dispose();
                hv_ValidIdxs.Dispose();
                hv_Intersection.Dispose();
                hv_Union.Dispose();
                hv_GtRow.Dispose();
                hv_GtCol.Dispose();
                hv_GtLength1.Dispose();
                hv_GtLength2.Dispose();
                hv_GtPhi.Dispose();
                hv_ResRow.Dispose();
                hv_ResCol.Dispose();
                hv_ResLength1.Dispose();
                hv_ResLength2.Dispose();
                hv_ResPhi.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_GtRow1.Dispose();
                hv_GtCol1.Dispose();
                hv_GtRow2.Dispose();
                hv_GtCol2.Dispose();
                hv_ResRow1.Dispose();
                hv_ResCol1.Dispose();
                hv_ResRow2.Dispose();
                hv_ResCol2.Dispose();
                hv_GtIdx.Dispose();
                hv_Height.Dispose();
                hv_Width.Dispose();
                hv_ValidIdxs.Dispose();
                hv_Intersection.Dispose();
                hv_Union.Dispose();
                hv_GtRow.Dispose();
                hv_GtCol.Dispose();
                hv_GtLength1.Dispose();
                hv_GtLength2.Dispose();
                hv_GtPhi.Dispose();
                hv_ResRow.Dispose();
                hv_ResCol.Dispose();
                hv_ResLength1.Dispose();
                hv_ResLength2.Dispose();
                hv_ResPhi.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Calculate evaluation measures based on the values of RunningMeasures and the settings in EvalParams. 
        public void calculate_evaluation_measures(HTuple hv_RunningMeasures, HTuple hv_EvalParams,
            out HTuple hv_EvaluationResult)
        {



            // Local control variables 

            HTuple hv_EvaluationType = new HTuple();
            // Initialize local and output iconic variables 
            hv_EvaluationResult = new HTuple();
            try
            {
                //
                //This procedure calculates the final measures depending on the evaluation type.
                //
                hv_EvaluationType.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "evaluation_type", out hv_EvaluationType);
                if ((int)(new HTuple(hv_EvaluationType.TupleEqual("anomaly_detection"))) != 0)
                {
                    hv_EvaluationResult.Dispose();
                    calculate_image_anomaly_measures(hv_RunningMeasures, hv_EvalParams, out hv_EvaluationResult);
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("classification"))) != 0)
                {
                    hv_EvaluationResult.Dispose();
                    calculate_image_classification_measures(hv_RunningMeasures, hv_EvalParams,
                        out hv_EvaluationResult);
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("detection"))) != 0)
                {
                    hv_EvaluationResult.Dispose();
                    calculate_instance_measures(hv_RunningMeasures, hv_EvalParams, out hv_EvaluationResult);
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("segmentation"))) != 0)
                {
                    hv_EvaluationResult.Dispose();
                    calculate_pixel_measures(hv_RunningMeasures, hv_EvalParams, out hv_EvaluationResult);
                }
                //

                hv_EvaluationType.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_EvaluationType.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection
        // Short Description: Calculate anomaly detection measures based on RunningMeasures. 
        public void calculate_image_anomaly_measures(HTuple hv_RunningMeasures, HTuple hv_EvalParams,
            out HTuple hv_EvaluationResult)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_MinScaling = new HTuple(), hv_MaxScaling = new HTuple();
            HTuple hv_ImageIDs = new HTuple(), hv_AnomalyLabelIDs = new HTuple();
            HTuple hv_AnomalyScores = new HTuple(), hv_AnomalyScoreHistogram = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_MinScorePlot = new HTuple();
            HTuple hv_MaxScorePlot = new HTuple(), hv_NumBins = new HTuple();
            HTuple hv_OKIndices = new HTuple(), hv_ImageLevelScoresOK = new HTuple();
            HTuple hv_HistoOK = new HTuple(), hv_BinSize = new HTuple();
            HTuple hv_HistoCumulOK = new HTuple(), hv_NOKIndices = new HTuple();
            HTuple hv_ImageLevelScoresNOK = new HTuple(), hv_HistoNOK = new HTuple();
            HTuple hv_HistoCumulNOK = new HTuple(), hv_AnomalyScoreBins = new HTuple();
            HTuple hv_ScoreHistogram = new HTuple();
            // Initialize local and output iconic variables 
            hv_EvaluationResult = new HTuple();
            try
            {
                //
                //This procedure calculates the final summarizing image anomaly detection measures based on the running measures.
                //
                //Set some parameters.
                hv_MinScaling.Dispose();
                hv_MinScaling = 0.7;
                hv_MaxScaling.Dispose();
                hv_MaxScaling = 1.3;
                //Get and check values in RunningMeasures.
                //
                //Get image ids.
                hv_ImageIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "image_ids", out hv_ImageIDs);
                //Get anomaly ids.
                hv_AnomalyLabelIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "anomaly_label_ids", out hv_AnomalyLabelIDs);
                //Get image scores.
                hv_AnomalyScores.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "anomaly_scores", out hv_AnomalyScores);
                //Get anomaly score thresholds from EvalParams.
                try
                {
                    hv_AnomalyScoreHistogram.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "anomaly_score_histogram", out hv_AnomalyScoreHistogram);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    hv_MinScorePlot.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MinScorePlot = hv_MinScaling * (hv_AnomalyScores.TupleMin()
                            );
                    }
                    hv_MaxScorePlot.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxScorePlot = hv_MaxScaling * (hv_AnomalyScores.TupleMax()
                            );
                    }
                    hv_NumBins.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumBins = new HTuple(hv_AnomalyScores.TupleLength()
                            );
                    }
                }
                //
                //No minimum value given.
                try
                {
                    hv_MinScorePlot.Dispose();
                    HOperatorSet.GetDictTuple(hv_AnomalyScoreHistogram, "min", out hv_MinScorePlot);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    hv_MinScorePlot.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MinScorePlot = ((hv_MinScaling * (hv_AnomalyScores.TupleMin()
                            ))).TupleReal();
                    }
                }
                //
                //No maximum value given.
                try
                {
                    hv_MaxScorePlot.Dispose();
                    HOperatorSet.GetDictTuple(hv_AnomalyScoreHistogram, "max", out hv_MaxScorePlot);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    hv_MaxScorePlot.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxScorePlot = ((hv_MaxScaling * (hv_AnomalyScores.TupleMax()
                            ))).TupleReal();
                    }
                }
                //
                //No number of bins given.
                try
                {
                    hv_NumBins.Dispose();
                    HOperatorSet.GetDictTuple(hv_AnomalyScoreHistogram, "num_bins", out hv_NumBins);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    hv_NumBins.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumBins = new HTuple(hv_AnomalyScores.TupleLength()
                            );
                    }
                }
                //
                //Estimate thresholds for histogram calculation by using min/max of the anomaly scores.
                if ((int)((new HTuple(hv_MinScorePlot.TupleEqual(-1))).TupleOr(new HTuple((new HTuple(hv_MinScorePlot.TupleLength()
                    )).TupleEqual(0)))) != 0)
                {
                    hv_MinScorePlot.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MinScorePlot = hv_MinScaling * (hv_AnomalyScores.TupleMin()
                            );
                    }
                }
                else if ((int)(new HTuple(hv_MinScorePlot.TupleLess(0))) != 0)
                {
                    throw new HalconException("Invalid value for minimum histogram value. Must be >= 0.");
                }
                //
                if ((int)((new HTuple(hv_MaxScorePlot.TupleEqual(-1))).TupleOr(new HTuple((new HTuple(hv_MaxScorePlot.TupleLength()
                    )).TupleEqual(0)))) != 0)
                {
                    hv_MaxScorePlot.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxScorePlot = (new HTuple(1.0)).TupleMin2(
                            hv_MaxScaling * (hv_AnomalyScores.TupleMax()));
                    }
                }
                else if ((int)(new HTuple(hv_MaxScorePlot.TupleLessEqual(0))) != 0)
                {
                    throw new HalconException("Invalid value for maximum histogram value. Must be > 0.");
                }
                //
                if ((int)((new HTuple(hv_NumBins.TupleEqual(-1))).TupleOr(new HTuple((new HTuple(hv_NumBins.TupleLength()
                    )).TupleEqual(0)))) != 0)
                {
                    hv_NumBins.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumBins = new HTuple(hv_AnomalyScores.TupleLength()
                            );
                    }
                }
                else if ((int)(new HTuple(hv_NumBins.TupleEqual(0))) != 0)
                {
                    throw new HalconException("Invalid number of bins. Must at least be 1.");
                }
                //
                //Assign scores with the right labels.
                hv_OKIndices.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_OKIndices = hv_AnomalyLabelIDs.TupleFind(
                        0);
                }
                hv_ImageLevelScoresOK.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ImageLevelScoresOK = hv_AnomalyScores.TupleSelect(
                        hv_OKIndices);
                }
                //
                //Calculate histograms.
                hv_HistoOK.Dispose(); hv_BinSize.Dispose();
                HOperatorSet.TupleHistoRange(hv_ImageLevelScoresOK, hv_MinScorePlot, hv_MaxScorePlot,
                    hv_NumBins, out hv_HistoOK, out hv_BinSize);
                //
                //Calculate cumulative histogram
                hv_HistoCumulOK.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HistoCumulOK = 1.0 - (((hv_HistoOK / ((((new HTuple(1.0)).TupleMax2(
                        hv_HistoOK.TupleSum()))).TupleReal()))).TupleCumul());
                }
                //
                hv_NOKIndices.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NOKIndices = hv_AnomalyLabelIDs.TupleFind(
                        1);
                }
                if ((int)(new HTuple(hv_NOKIndices.TupleNotEqual(-1))) != 0)
                {
                    hv_ImageLevelScoresNOK.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageLevelScoresNOK = hv_AnomalyScores.TupleSelect(
                            hv_NOKIndices);
                    }
                    hv_HistoNOK.Dispose(); hv_BinSize.Dispose();
                    HOperatorSet.TupleHistoRange(hv_ImageLevelScoresNOK, hv_MinScorePlot, hv_MaxScorePlot,
                        hv_NumBins, out hv_HistoNOK, out hv_BinSize);
                    hv_HistoCumulNOK.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_HistoCumulNOK = ((hv_HistoNOK / ((((new HTuple(1.0)).TupleMax2(
                            hv_HistoNOK.TupleSum()))).TupleReal()))).TupleCumul();
                    }
                }
                else
                {
                    hv_HistoCumulNOK.Dispose();
                    hv_HistoCumulNOK = new HTuple();
                }
                //
                //Calculate left sided bins.
                hv_AnomalyScoreBins.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_AnomalyScoreBins = HTuple.TupleGenSequence(
                        hv_MinScorePlot, hv_MinScorePlot + (((hv_NumBins - 1) + 1e-4) * hv_BinSize), hv_BinSize);
                }
                //
                //Create dictionary for the score histogram.
                hv_ScoreHistogram.Dispose();
                HOperatorSet.CreateDict(out hv_ScoreHistogram);
                HOperatorSet.SetDictTuple(hv_ScoreHistogram, "ok", hv_HistoCumulOK);
                HOperatorSet.SetDictTuple(hv_ScoreHistogram, "nok", hv_HistoCumulNOK);
                //
                //Set the score histogram in the results dictionary.
                hv_EvaluationResult.Dispose();
                HOperatorSet.CreateDict(out hv_EvaluationResult);
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "anomaly_score_histogram", hv_ScoreHistogram);
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "anomaly_score_bins", hv_AnomalyScoreBins);
                //

                hv_MinScaling.Dispose();
                hv_MaxScaling.Dispose();
                hv_ImageIDs.Dispose();
                hv_AnomalyLabelIDs.Dispose();
                hv_AnomalyScores.Dispose();
                hv_AnomalyScoreHistogram.Dispose();
                hv_Exception.Dispose();
                hv_MinScorePlot.Dispose();
                hv_MaxScorePlot.Dispose();
                hv_NumBins.Dispose();
                hv_OKIndices.Dispose();
                hv_ImageLevelScoresOK.Dispose();
                hv_HistoOK.Dispose();
                hv_BinSize.Dispose();
                hv_HistoCumulOK.Dispose();
                hv_NOKIndices.Dispose();
                hv_ImageLevelScoresNOK.Dispose();
                hv_HistoNOK.Dispose();
                hv_HistoCumulNOK.Dispose();
                hv_AnomalyScoreBins.Dispose();
                hv_ScoreHistogram.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_MinScaling.Dispose();
                hv_MaxScaling.Dispose();
                hv_ImageIDs.Dispose();
                hv_AnomalyLabelIDs.Dispose();
                hv_AnomalyScores.Dispose();
                hv_AnomalyScoreHistogram.Dispose();
                hv_Exception.Dispose();
                hv_MinScorePlot.Dispose();
                hv_MaxScorePlot.Dispose();
                hv_NumBins.Dispose();
                hv_OKIndices.Dispose();
                hv_ImageLevelScoresOK.Dispose();
                hv_HistoOK.Dispose();
                hv_BinSize.Dispose();
                hv_HistoCumulOK.Dispose();
                hv_NOKIndices.Dispose();
                hv_ImageLevelScoresNOK.Dispose();
                hv_HistoNOK.Dispose();
                hv_HistoCumulNOK.Dispose();
                hv_AnomalyScoreBins.Dispose();
                hv_ScoreHistogram.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Calculate image classification measures based on RunningMeasures. 
        public void calculate_image_classification_measures(HTuple hv_RunningMeasures,
            HTuple hv_EvalParams, out HTuple hv_EvaluationResult)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_TopKErrorKs = new HTuple(), hv_CalcPrecision = new HTuple();
            HTuple hv_CalcRecall = new HTuple(), hv_CalcFScore = new HTuple();
            HTuple hv_CalcAbsoluteConfusionMatrix = new HTuple(), hv_CalcRelativeConfusionMatrix = new HTuple();
            HTuple hv_Measures = new HTuple(), hv_RegExpTopKError = new HTuple();
            HTuple hv_M = new HTuple(), hv_ComputeTopKError = new HTuple();
            HTuple hv_K = new HTuple(), hv_ClassIDs = new HTuple();
            HTuple hv_KeyExists = new HTuple(), hv_ClassesToEvaluate = new HTuple();
            HTuple hv_ClassIDsToEvaluate = new HTuple(), hv_ClassNames = new HTuple();
            HTuple hv_Index = new HTuple(), hv_Position = new HTuple();
            HTuple hv_ImageIDs = new HTuple(), hv_ImageLabelIDs = new HTuple();
            HTuple hv_Predictions = new HTuple(), hv_TopKPredictions = new HTuple();
            HTuple hv_EvalIndex = new HTuple(), hv_CurrentEvalClass = new HTuple();
            HTuple hv_IndexClass = new HTuple(), hv_EvaluatedSamples = new HTuple();
            HTuple hv_ConfusionMatrix = new HTuple(), hv_RelativeConfusionMatrix = new HTuple();
            HTuple hv_EvalClassID = new HTuple(), hv_KIndex = new HTuple();
            HTuple hv_Indices = new HTuple(), hv_TopKError = new HTuple();
            HTuple hv_NumClasses = new HTuple(), hv_ClassPrecisions = new HTuple();
            HTuple hv_MatrixRowSumID = new HTuple(), hv_TruePositive = new HTuple();
            HTuple hv_SumPredictedClass = new HTuple(), hv_ClassPrecision = new HTuple();
            HTuple hv_Precision = new HTuple(), hv_ClassRecalls = new HTuple();
            HTuple hv_MatrixColumnSumID = new HTuple(), hv_SumLabel = new HTuple();
            HTuple hv_ClassRecall = new HTuple(), hv_Recall = new HTuple();
            HTuple hv_ClassFScores = new HTuple(), hv_SumPrecisionRecall = new HTuple();
            HTuple hv_PositiveIndices = new HTuple(), hv_FScore = new HTuple();
            HTuple hv_KeyName = new HTuple();
            // Initialize local and output iconic variables 
            hv_EvaluationResult = new HTuple();
            try
            {
                //
                //This procedure calculates the final summarizing image classification measures based on the running measures.
                //
                //Set default values.
                hv_TopKErrorKs.Dispose();
                hv_TopKErrorKs = new HTuple();
                hv_CalcPrecision.Dispose();
                hv_CalcPrecision = 0;
                hv_CalcRecall.Dispose();
                hv_CalcRecall = 0;
                hv_CalcFScore.Dispose();
                hv_CalcFScore = 0;
                hv_CalcAbsoluteConfusionMatrix.Dispose();
                hv_CalcAbsoluteConfusionMatrix = 0;
                hv_CalcRelativeConfusionMatrix.Dispose();
                hv_CalcRelativeConfusionMatrix = 0;
                //
                //Check which measures are to be calculated.
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                hv_RegExpTopKError.Dispose();
                hv_RegExpTopKError = "top([0-9]+)_error";
                for (hv_M = 0; (int)hv_M <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_M = (int)hv_M + 1)
                {
                    hv_ComputeTopKError.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ComputeTopKError = ((hv_Measures.TupleSelect(
                            hv_M))).TupleRegexpTest("top([0-9]+)_error");
                    }
                    if ((int)(hv_ComputeTopKError) != 0)
                    {
                        hv_K.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_K = ((((hv_Measures.TupleSelect(
                                hv_M))).TupleRegexpMatch(hv_RegExpTopKError))).TupleNumber();
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_TopKErrorKs = ((hv_TopKErrorKs.TupleConcat(
                                    hv_K))).TupleSort();
                                hv_TopKErrorKs.Dispose();
                                hv_TopKErrorKs = ExpTmpLocalVar_TopKErrorKs;
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "precision"))) != 0)
                    {
                        hv_CalcPrecision.Dispose();
                        hv_CalcPrecision = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "recall"))) != 0)
                    {
                        hv_CalcRecall.Dispose();
                        hv_CalcRecall = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "f_score"))) != 0)
                    {
                        hv_CalcFScore.Dispose();
                        hv_CalcFScore = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "absolute_confusion_matrix"))) != 0)
                    {
                        hv_CalcAbsoluteConfusionMatrix.Dispose();
                        hv_CalcAbsoluteConfusionMatrix = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "relative_confusion_matrix"))) != 0)
                    {
                        hv_CalcRelativeConfusionMatrix.Dispose();
                        hv_CalcRelativeConfusionMatrix = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "all"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_TopKErrorKs = ((hv_TopKErrorKs.TupleConcat(
                                    1))).TupleSort();
                                hv_TopKErrorKs.Dispose();
                                hv_TopKErrorKs = ExpTmpLocalVar_TopKErrorKs;
                            }
                        }
                        hv_CalcPrecision.Dispose();
                        hv_CalcPrecision = 1;
                        hv_CalcRecall.Dispose();
                        hv_CalcRecall = 1;
                        hv_CalcFScore.Dispose();
                        hv_CalcFScore = 1;
                        hv_CalcAbsoluteConfusionMatrix.Dispose();
                        hv_CalcAbsoluteConfusionMatrix = 1;
                        hv_CalcRelativeConfusionMatrix.Dispose();
                        hv_CalcRelativeConfusionMatrix = 1;
                    }
                    else
                    {
                        throw new HalconException("Unknown image classification measure: " + (hv_Measures.TupleSelect(
                            hv_M)));
                    }
                }
                //
                //Initialize output dictionary and get necessary evaluation parameters.
                hv_EvaluationResult.Dispose();
                HOperatorSet.CreateDict(out hv_EvaluationResult);
                hv_ClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                hv_KeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "class_names_to_evaluate",
                    out hv_KeyExists);
                if ((int)(hv_KeyExists) != 0)
                {
                    hv_ClassesToEvaluate.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "class_names_to_evaluate", out hv_ClassesToEvaluate);
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate = new HTuple();
                    hv_ClassNames.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "class_names", out hv_ClassNames);
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_ClassesToEvaluate.TupleLength()
                        )) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        hv_Position.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Position = (((((new HTuple("global")).TupleConcat(
                                hv_ClassNames))).TupleEqualElem(hv_ClassesToEvaluate.TupleSelect(hv_Index)))).TupleFind(
                                1);
                        }
                        if ((int)((new HTuple(hv_Position.TupleEqual(-1))).TupleOr(new HTuple(hv_Position.TupleEqual(
                            new HTuple())))) != 0)
                        {
                            throw new HalconException("Invalid entry in  'class_names_to_evaluate': " + ((((new HTuple("global")).TupleConcat(
                                hv_ClassesToEvaluate))).TupleSelect(hv_Index)));
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_ClassIDsToEvaluate = hv_ClassIDsToEvaluate.TupleConcat(
                                    (((new HTuple("global")).TupleConcat(hv_ClassIDs))).TupleSelect(hv_Position));
                                hv_ClassIDsToEvaluate.Dispose();
                                hv_ClassIDsToEvaluate = ExpTmpLocalVar_ClassIDsToEvaluate;
                            }
                        }
                    }
                    HOperatorSet.SetDictTuple(hv_EvalParams, "class_ids_to_evaluate", hv_ClassIDsToEvaluate);
                }
                hv_ClassIDsToEvaluate.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids_to_evaluate", out hv_ClassIDsToEvaluate);
                //
                //Get and check values in RunningMeasures.
                hv_ImageIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "image_ids", out hv_ImageIDs);
                hv_ImageLabelIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "image_label_ids", out hv_ImageLabelIDs);
                hv_Predictions.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "top1_predictions", out hv_Predictions);
                hv_TopKPredictions.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "topk_predictions", out hv_TopKPredictions);
                //
                //Check if needed classes appear in image label IDs.
                //For the confusion matrices, all classes need to be represented.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_CalcAbsoluteConfusionMatrix = (new HTuple((new HTuple(hv_CalcPrecision.TupleOr(
                            hv_CalcRecall))).TupleOr(hv_CalcFScore))).TupleOr(hv_CalcAbsoluteConfusionMatrix);
                        hv_CalcAbsoluteConfusionMatrix.Dispose();
                        hv_CalcAbsoluteConfusionMatrix = ExpTmpLocalVar_CalcAbsoluteConfusionMatrix;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_CalcRelativeConfusionMatrix = (new HTuple((new HTuple(hv_CalcPrecision.TupleOr(
                            hv_CalcRecall))).TupleOr(hv_CalcFScore))).TupleOr(hv_CalcRelativeConfusionMatrix);
                        hv_CalcRelativeConfusionMatrix.Dispose();
                        hv_CalcRelativeConfusionMatrix = ExpTmpLocalVar_CalcRelativeConfusionMatrix;
                    }
                }
                if ((int)(hv_CalcAbsoluteConfusionMatrix.TupleOr(hv_CalcRelativeConfusionMatrix)) != 0)
                {
                    if ((int)(new HTuple(((((hv_ImageLabelIDs.TupleSort())).TupleUniq())).TupleNotEqual(
                        hv_ClassIDs.TupleSort()))) != 0)
                    {
                        throw new HalconException("Not all classes are represented in the ground truth labels. \nPlease check your data split.");
                    }
                }
                //For top-K errors, the evaluated classes need to be represented.
                if ((int)(new HTuple(hv_TopKErrorKs.TupleNotEqual(new HTuple()))) != 0)
                {
                    for (hv_EvalIndex = 0; (int)hv_EvalIndex <= (int)((new HTuple(hv_ClassIDsToEvaluate.TupleLength()
                        )) - 1); hv_EvalIndex = (int)hv_EvalIndex + 1)
                    {
                        hv_CurrentEvalClass.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentEvalClass = hv_ClassIDsToEvaluate.TupleSelect(
                                hv_EvalIndex);
                        }
                        if ((int)(new HTuple(hv_CurrentEvalClass.TupleNotEqual("global"))) != 0)
                        {
                            hv_IndexClass.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_IndexClass = hv_ImageLabelIDs.TupleFind(
                                    hv_CurrentEvalClass);
                            }
                            if ((int)((new HTuple(hv_IndexClass.TupleEqual(-1))).TupleOr(new HTuple(hv_IndexClass.TupleEqual(
                                new HTuple())))) != 0)
                            {
                                throw new HalconException(("The evaluated class ID " + hv_CurrentEvalClass) + " is not represented in the ground truth labels.");
                            }
                        }
                    }
                }
                //
                //Set image IDs, image label IDs, and top1-predictions to of evaluated samples EvaluationResult.
                hv_EvaluatedSamples.Dispose();
                HOperatorSet.CreateDict(out hv_EvaluatedSamples);
                HOperatorSet.SetDictTuple(hv_EvaluatedSamples, "image_ids", hv_ImageIDs);
                HOperatorSet.SetDictTuple(hv_EvaluatedSamples, "image_label_ids", hv_ImageLabelIDs);
                HOperatorSet.SetDictTuple(hv_EvaluatedSamples, "top1_predictions", hv_Predictions);
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "evaluated_samples", hv_EvaluatedSamples);
                //
                //Calculate absolute confusion matrix if needed and set it to EvaluationResult.
                if ((int)(hv_CalcAbsoluteConfusionMatrix) != 0)
                {
                    hv_ConfusionMatrix.Dispose();
                    gen_confusion_matrix(hv_ImageLabelIDs, hv_Predictions, "display_matrix",
                        "none", new HTuple(), out hv_ConfusionMatrix);
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "absolute_confusion_matrix",
                        hv_ConfusionMatrix);
                }
                //
                //Calculate relative confusion matrix.
                if ((int)(hv_CalcRelativeConfusionMatrix) != 0)
                {
                    hv_RelativeConfusionMatrix.Dispose();
                    gen_confusion_matrix(hv_ImageLabelIDs, hv_Predictions, (new HTuple("display_matrix")).TupleConcat(
                        "return_matrix"), (new HTuple("none")).TupleConcat("relative"), new HTuple(),
                        out hv_RelativeConfusionMatrix);
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "relative_confusion_matrix",
                        hv_RelativeConfusionMatrix);
                }
                //
                // Calcuate measures for every class to be evaluated.
                for (hv_EvalIndex = 0; (int)hv_EvalIndex <= (int)((new HTuple(hv_ClassIDsToEvaluate.TupleLength()
                    )) - 1); hv_EvalIndex = (int)hv_EvalIndex + 1)
                {
                    hv_CurrentEvalClass.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentEvalClass = hv_ClassIDsToEvaluate.TupleSelect(
                            hv_EvalIndex);
                    }
                    hv_EvalClassID.Dispose();
                    HOperatorSet.CreateDict(out hv_EvalClassID);
                    //
                    //Calculate top-K errors.
                    for (hv_KIndex = 0; (int)hv_KIndex <= (int)((new HTuple(hv_TopKErrorKs.TupleLength()
                        )) - 1); hv_KIndex = (int)hv_KIndex + 1)
                    {
                        hv_K.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_K = hv_TopKErrorKs.TupleSelect(
                                hv_KIndex);
                        }
                        if ((int)(new HTuple(hv_CurrentEvalClass.TupleEqual("global"))) != 0)
                        {
                            hv_Indices.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Indices = HTuple.TupleGenSequence(
                                    0, (new HTuple(hv_ImageLabelIDs.TupleLength())) - 1, 1);
                            }
                        }
                        else
                        {
                            hv_Indices.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Indices = hv_ImageLabelIDs.TupleFind(
                                    hv_CurrentEvalClass);
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TopKError.Dispose();
                            compute_top_k_error(hv_ImageLabelIDs.TupleSelect(hv_Indices), hv_TopKPredictions.TupleSelect(
                                hv_Indices), hv_K, out hv_TopKError);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_EvalClassID, ("top" + hv_K) + "_error", hv_TopKError);
                        }
                    }
                    //
                    if ((int)(new HTuple(hv_CurrentEvalClass.TupleEqual("global"))) != 0)
                    {
                        //Compute the mean of the measures for all classes.
                        hv_NumClasses.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_NumClasses = new HTuple(hv_ClassIDs.TupleLength()
                                );
                        }
                        hv_IndexClass.Dispose();
                        hv_IndexClass = new HTuple(hv_ClassIDs);
                    }
                    else
                    {
                        //Compute the measures for a certain class.
                        hv_NumClasses.Dispose();
                        hv_NumClasses = 1;
                        hv_IndexClass.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_IndexClass = hv_ClassIDs.TupleFind(
                                hv_CurrentEvalClass);
                        }
                    }
                    //
                    //Calculate prediction.
                    if ((int)(hv_CalcPrecision.TupleOr(hv_CalcFScore)) != 0)
                    {
                        hv_ClassPrecisions.Dispose();
                        hv_ClassPrecisions = new HTuple();
                        hv_MatrixRowSumID.Dispose();
                        HOperatorSet.SumMatrix(hv_ConfusionMatrix, "rows", out hv_MatrixRowSumID);
                        HTuple end_val138 = hv_NumClasses - 1;
                        HTuple step_val138 = 1;
                        for (hv_Index = 0; hv_Index.Continue(end_val138, step_val138); hv_Index = hv_Index.TupleAdd(step_val138))
                        {
                            //Compute the precision for every selected class.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TruePositive.Dispose();
                                HOperatorSet.GetValueMatrix(hv_ConfusionMatrix, hv_IndexClass.TupleSelect(
                                    hv_Index), hv_IndexClass.TupleSelect(hv_Index), out hv_TruePositive);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_SumPredictedClass.Dispose();
                                HOperatorSet.GetValueMatrix(hv_MatrixRowSumID, hv_IndexClass.TupleSelect(
                                    hv_Index), 0, out hv_SumPredictedClass);
                            }
                            if ((int)(new HTuple(hv_SumPredictedClass.TupleEqual(0))) != 0)
                            {
                                hv_ClassPrecision.Dispose();
                                hv_ClassPrecision = 0;
                            }
                            else
                            {
                                hv_ClassPrecision.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ClassPrecision = hv_TruePositive / hv_SumPredictedClass;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ClassPrecisions = hv_ClassPrecisions.TupleConcat(
                                        hv_ClassPrecision);
                                    hv_ClassPrecisions.Dispose();
                                    hv_ClassPrecisions = ExpTmpLocalVar_ClassPrecisions;
                                }
                            }
                        }
                        hv_Precision.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Precision = hv_ClassPrecisions.TupleMean()
                                ;
                        }
                        HOperatorSet.ClearMatrix(hv_MatrixRowSumID);
                        if ((int)(new HTuple(hv_NumClasses.TupleEqual(1))) != 0)
                        {
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "precision", hv_Precision);
                        }
                        else
                        {
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "mean_precision", hv_Precision);
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "precision_per_class", hv_ClassPrecisions);
                        }
                    }
                    //
                    //Calculate recall.
                    if ((int)(hv_CalcRecall.TupleOr(hv_CalcFScore)) != 0)
                    {
                        hv_ClassRecalls.Dispose();
                        hv_ClassRecalls = new HTuple();
                        hv_MatrixColumnSumID.Dispose();
                        HOperatorSet.SumMatrix(hv_ConfusionMatrix, "columns", out hv_MatrixColumnSumID);
                        HTuple end_val163 = hv_NumClasses - 1;
                        HTuple step_val163 = 1;
                        for (hv_Index = 0; hv_Index.Continue(end_val163, step_val163); hv_Index = hv_Index.TupleAdd(step_val163))
                        {
                            //Compute the recall for every class.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TruePositive.Dispose();
                                HOperatorSet.GetValueMatrix(hv_ConfusionMatrix, hv_IndexClass.TupleSelect(
                                    hv_Index), hv_IndexClass.TupleSelect(hv_Index), out hv_TruePositive);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_SumLabel.Dispose();
                                HOperatorSet.GetValueMatrix(hv_MatrixColumnSumID, 0, hv_IndexClass.TupleSelect(
                                    hv_Index), out hv_SumLabel);
                            }
                            hv_ClassRecall.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClassRecall = hv_TruePositive / hv_SumLabel;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ClassRecalls = hv_ClassRecalls.TupleConcat(
                                        hv_ClassRecall);
                                    hv_ClassRecalls.Dispose();
                                    hv_ClassRecalls = ExpTmpLocalVar_ClassRecalls;
                                }
                            }
                        }
                        hv_Recall.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Recall = hv_ClassRecalls.TupleMean()
                                ;
                        }
                        HOperatorSet.ClearMatrix(hv_MatrixColumnSumID);
                        if ((int)(new HTuple(hv_NumClasses.TupleEqual(1))) != 0)
                        {
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "recall", hv_Recall);
                        }
                        else
                        {
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "mean_recall", hv_Recall);
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "recall_per_class", hv_ClassRecalls);
                        }
                    }
                    //
                    //Calculate F-score.
                    if ((int)(hv_CalcFScore) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClassFScores.Dispose();
                            HOperatorSet.TupleGenConst(new HTuple(hv_ClassPrecisions.TupleLength()),
                                0.0, out hv_ClassFScores);
                        }
                        hv_SumPrecisionRecall.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_SumPrecisionRecall = hv_ClassPrecisions + hv_ClassRecalls;
                        }
                        hv_PositiveIndices.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_PositiveIndices = ((hv_SumPrecisionRecall.TupleNotEqualElem(
                                0.0))).TupleFind(1);
                        }
                        if ((int)((new HTuple(hv_PositiveIndices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_PositiveIndices.TupleNotEqual(
                            new HTuple())))) != 0)
                        {
                            if (hv_ClassFScores == null)
                                hv_ClassFScores = new HTuple();
                            hv_ClassFScores[hv_PositiveIndices] = ((2 * (hv_ClassPrecisions.TupleSelect(
                                hv_PositiveIndices))) * (hv_ClassRecalls.TupleSelect(hv_PositiveIndices))) / (hv_SumPrecisionRecall.TupleSelect(
                                hv_PositiveIndices));
                        }
                        hv_FScore.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FScore = hv_ClassFScores.TupleMean()
                                ;
                        }
                        if ((int)(new HTuple(hv_NumClasses.TupleEqual(1))) != 0)
                        {
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "f_score", hv_FScore);
                        }
                        else
                        {
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "mean_f_score", hv_FScore);
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "f_score_per_class", hv_ClassFScores);
                        }
                    }
                    //
                    //Set evaluation results for current class ID.
                    hv_KeyName.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_KeyName = hv_ClassIDsToEvaluate.TupleSelect(
                            hv_EvalIndex);
                    }
                    if ((int)(new HTuple(((hv_ClassIDsToEvaluate.TupleSelect(hv_EvalIndex))).TupleNotEqual(
                        "global"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_KeyName = "class_id_" + hv_KeyName;
                                hv_KeyName.Dispose();
                                hv_KeyName = ExpTmpLocalVar_KeyName;
                            }
                        }
                    }
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, hv_KeyName, hv_EvalClassID);
                }
                //

                hv_TopKErrorKs.Dispose();
                hv_CalcPrecision.Dispose();
                hv_CalcRecall.Dispose();
                hv_CalcFScore.Dispose();
                hv_CalcAbsoluteConfusionMatrix.Dispose();
                hv_CalcRelativeConfusionMatrix.Dispose();
                hv_Measures.Dispose();
                hv_RegExpTopKError.Dispose();
                hv_M.Dispose();
                hv_ComputeTopKError.Dispose();
                hv_K.Dispose();
                hv_ClassIDs.Dispose();
                hv_KeyExists.Dispose();
                hv_ClassesToEvaluate.Dispose();
                hv_ClassIDsToEvaluate.Dispose();
                hv_ClassNames.Dispose();
                hv_Index.Dispose();
                hv_Position.Dispose();
                hv_ImageIDs.Dispose();
                hv_ImageLabelIDs.Dispose();
                hv_Predictions.Dispose();
                hv_TopKPredictions.Dispose();
                hv_EvalIndex.Dispose();
                hv_CurrentEvalClass.Dispose();
                hv_IndexClass.Dispose();
                hv_EvaluatedSamples.Dispose();
                hv_ConfusionMatrix.Dispose();
                hv_RelativeConfusionMatrix.Dispose();
                hv_EvalClassID.Dispose();
                hv_KIndex.Dispose();
                hv_Indices.Dispose();
                hv_TopKError.Dispose();
                hv_NumClasses.Dispose();
                hv_ClassPrecisions.Dispose();
                hv_MatrixRowSumID.Dispose();
                hv_TruePositive.Dispose();
                hv_SumPredictedClass.Dispose();
                hv_ClassPrecision.Dispose();
                hv_Precision.Dispose();
                hv_ClassRecalls.Dispose();
                hv_MatrixColumnSumID.Dispose();
                hv_SumLabel.Dispose();
                hv_ClassRecall.Dispose();
                hv_Recall.Dispose();
                hv_ClassFScores.Dispose();
                hv_SumPrecisionRecall.Dispose();
                hv_PositiveIndices.Dispose();
                hv_FScore.Dispose();
                hv_KeyName.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_TopKErrorKs.Dispose();
                hv_CalcPrecision.Dispose();
                hv_CalcRecall.Dispose();
                hv_CalcFScore.Dispose();
                hv_CalcAbsoluteConfusionMatrix.Dispose();
                hv_CalcRelativeConfusionMatrix.Dispose();
                hv_Measures.Dispose();
                hv_RegExpTopKError.Dispose();
                hv_M.Dispose();
                hv_ComputeTopKError.Dispose();
                hv_K.Dispose();
                hv_ClassIDs.Dispose();
                hv_KeyExists.Dispose();
                hv_ClassesToEvaluate.Dispose();
                hv_ClassIDsToEvaluate.Dispose();
                hv_ClassNames.Dispose();
                hv_Index.Dispose();
                hv_Position.Dispose();
                hv_ImageIDs.Dispose();
                hv_ImageLabelIDs.Dispose();
                hv_Predictions.Dispose();
                hv_TopKPredictions.Dispose();
                hv_EvalIndex.Dispose();
                hv_CurrentEvalClass.Dispose();
                hv_IndexClass.Dispose();
                hv_EvaluatedSamples.Dispose();
                hv_ConfusionMatrix.Dispose();
                hv_RelativeConfusionMatrix.Dispose();
                hv_EvalClassID.Dispose();
                hv_KIndex.Dispose();
                hv_Indices.Dispose();
                hv_TopKError.Dispose();
                hv_NumClasses.Dispose();
                hv_ClassPrecisions.Dispose();
                hv_MatrixRowSumID.Dispose();
                hv_TruePositive.Dispose();
                hv_SumPredictedClass.Dispose();
                hv_ClassPrecision.Dispose();
                hv_Precision.Dispose();
                hv_ClassRecalls.Dispose();
                hv_MatrixColumnSumID.Dispose();
                hv_SumLabel.Dispose();
                hv_ClassRecall.Dispose();
                hv_Recall.Dispose();
                hv_ClassFScores.Dispose();
                hv_SumPrecisionRecall.Dispose();
                hv_PositiveIndices.Dispose();
                hv_FScore.Dispose();
                hv_KeyName.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Calculate instance measures based on RunningMeasures. 
        public void calculate_instance_measures(HTuple hv_RunningMeasures, HTuple hv_EvalParams,
            out HTuple hv_EvaluationResult)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_CalcClassAP = new HTuple(), hv_CalcMeanAP = new HTuple();
            HTuple hv_CalcSoAP = new HTuple(), hv_InstanceType = new HTuple();
            HTuple hv_Measures = new HTuple(), hv_M = new HTuple();
            HTuple hv_ClassIDs = new HTuple(), hv_NumClasses = new HTuple();
            HTuple hv_MaxNumDetections = new HTuple(), hv_AreaRanges = new HTuple();
            HTuple hv_IoUThresholds = new HTuple(), hv_DetailedEvaluation = new HTuple();
            HTuple hv_KeyExists = new HTuple(), hv_AreaNames = new HTuple();
            HTuple hv_MinAreas = new HTuple(), hv_MaxAreas = new HTuple();
            HTuple hv_RecThreshs = new HTuple(), hv_MDIdx = new HTuple();
            HTuple hv_MaxNum = new HTuple(), hv_MaxNumStr = new HTuple();
            HTuple hv_CurrentRunningMeasures = new HTuple(), hv_PerMaxNumEvaluationResult = new HTuple();
            HTuple hv_AreaIdx = new HTuple(), hv_MinArea = new HTuple();
            HTuple hv_MaxArea = new HTuple(), hv_AreaName = new HTuple();
            HTuple hv_AreaRunningMeasures = new HTuple(), hv_PerClassNumGt = new HTuple();
            HTuple hv_PerClassNumPred = new HTuple(), hv_PerClassConfidence = new HTuple();
            HTuple hv_PerClassNumGtIgnore = new HTuple(), hv_CurrentEvaluationResult = new HTuple();
            HTuple hv_ITIdx = new HTuple(), hv_PerIoUAP = new HTuple();
            HTuple hv_PerIoUSoAP = new HTuple(), hv_PerIoUDetailedEvaluation = new HTuple();
            HTuple hv_ClsIdx = new HTuple(), hv_PerClassDetailedEvaluation = new HTuple();
            HTuple hv_DetectionConfusionMatrix = new HTuple(), hv_PerIoUMeasure = new HTuple();
            HTuple hv_NumImgIDsWithFN = new HTuple(), hv_NumImgIDsWithFP = new HTuple();
            HTuple hv_ImgIDsWithFN = new HTuple(), hv_ImgIDsWithFP = new HTuple();
            HTuple hv_ClassMAPDict = new HTuple(), hv_ClassMSoAPDict = new HTuple();
            HTuple hv_ClassesWithGt = new HTuple(), hv_PerClassMAP = new HTuple();
            HTuple hv_PerIoUMAP = new HTuple(), hv_PerClassMSoAP = new HTuple();
            HTuple hv_PerIoUMSoAP = new HTuple(), hv_PerIoUNumClassesWithTP = new HTuple();
            HTuple hv_PerIoUTP = new HTuple(), hv_PerIoUFN = new HTuple();
            HTuple hv_PerIoUFP = new HTuple(), hv_PerIoUFPClass = new HTuple();
            HTuple hv_PerIoUFPBackground = new HTuple(), hv_PerIoUFPLocalization = new HTuple();
            HTuple hv_PerIoUFPDuplicate = new HTuple(), hv_PerIoUFPMultiple = new HTuple();
            HTuple hv_PerIoUSoAPClass = new HTuple(), hv_PerIoUSoAPLocalization = new HTuple();
            HTuple hv_PerIoUSoAPDuplicate = new HTuple(), hv_PerIoUSoAPMultiple = new HTuple();
            HTuple hv_PerIoUNumClassesWithFPClass = new HTuple(), hv_PerIoUNumClassesWithFPLocalization = new HTuple();
            HTuple hv_PerIoUNumClassesWithFPDuplicate = new HTuple();
            HTuple hv_PerIoUNumClassesWithFPMultiple = new HTuple();
            HTuple hv_ClassAPPerIoU = new HTuple(), hv_ClassSoAPPerIoU = new HTuple();
            HTuple hv_NumGt = new HTuple(), hv_NumGtIgnore = new HTuple();
            HTuple hv_NumPred = new HTuple(), hv_Confidences = new HTuple();
            HTuple hv_SortIdxs = new HTuple(), hv_CurrentClassMeasures = new HTuple();
            HTuple hv_IsTP = new HTuple(), hv_Ignore = new HTuple();
            HTuple hv_NoIgnoreIdxs = new HTuple(), hv_IsFP = new HTuple();
            HTuple hv_AccumulatedIsTP = new HTuple(), hv_AccumulatedIsFP = new HTuple();
            HTuple hv_Recall = new HTuple(), hv_Precision = new HTuple();
            HTuple hv_InterpolatedPrecision = new HTuple(), hv_PIdx = new HTuple();
            HTuple hv_PrecisionAtRecThreshs = new HTuple(), hv_RTIdx = new HTuple();
            HTuple hv_RecQuantile = new HTuple(), hv_AOD = new HTuple();
            HTuple hv_IdxsTP = new HTuple(), hv_IsFPClass = new HTuple();
            HTuple hv_IsFPBackground = new HTuple(), hv_IsFPLocalization = new HTuple();
            HTuple hv_IsFPDuplicate = new HTuple(), hv_IsFPMultiple = new HTuple();
            HTuple hv_NumTP = new HTuple(), hv_NumFP = new HTuple();
            HTuple hv_NumFN = new HTuple(), hv_NumFPClass = new HTuple();
            HTuple hv_NumFPBackground = new HTuple(), hv_NumFPLocalization = new HTuple();
            HTuple hv_NumFPDuplicate = new HTuple(), hv_NumFPMultiple = new HTuple();
            HTuple hv_IndicesWithClassConfusion = new HTuple(), hv_IsFPClassIdxs = new HTuple();
            HTuple hv_ClassIdxsConfused = new HTuple(), hv_Idx = new HTuple();
            HTuple hv_NumConfusedThisIdx = new HTuple(), hv_AODClass = new HTuple();
            HTuple hv_IdxsClass = new HTuple(), hv_ResSoAPClass = new HTuple();
            HTuple hv_AODLocalization = new HTuple(), hv_IdxsLocalization = new HTuple();
            HTuple hv_ResSoAPLocalization = new HTuple(), hv_AODDuplicate = new HTuple();
            HTuple hv_IdxsDuplicate = new HTuple(), hv_ResSoAPDuplicate = new HTuple();
            HTuple hv_AODMultiple = new HTuple(), hv_IdxsMultiple = new HTuple();
            HTuple hv_ResSoAPMultiple = new HTuple(), hv_MeanClassAP = new HTuple();
            HTuple hv_MeanClassSoAP = new HTuple(), hv_MAP = new HTuple();
            HTuple hv_MSoAP = new HTuple(), hv_IoUsWithTP = new HTuple();
            HTuple hv_MSoAPAll = new HTuple(), hv_NumSoAPAll = new HTuple();
            HTuple hv_IoUsWithFPClass = new HTuple(), hv_IoUsWithFPLocalization = new HTuple();
            HTuple hv_IoUsWithFPDuplicate = new HTuple(), hv_IoUsWithFPMultiple = new HTuple();
            // Initialize local and output iconic variables 
            hv_EvaluationResult = new HTuple();
            try
            {
                //
                //This procedure calculates the final summarizing instance measures based on the running measures.
                //
                //Set default values.
                hv_CalcClassAP.Dispose();
                hv_CalcClassAP = 0;
                hv_CalcMeanAP.Dispose();
                hv_CalcMeanAP = 0;
                hv_CalcSoAP.Dispose();
                hv_CalcSoAP = 0;
                //Check which measures are to be calculated.
                hv_InstanceType.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "instance_type", out hv_InstanceType);
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                for (hv_M = 0; (int)hv_M <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_M = (int)hv_M + 1)
                {
                    if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual("mean_ap"))) != 0)
                    {
                        hv_CalcMeanAP.Dispose();
                        hv_CalcMeanAP = 1;
                        //As we need to calculate the class APs anyway, we also write them out.
                        hv_CalcClassAP.Dispose();
                        hv_CalcClassAP = 1;
                    }
                    else if ((int)((new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "soap"))).TupleAnd(new HTuple(hv_InstanceType.TupleEqual("rectangle2")))) != 0)
                    {
                        hv_CalcSoAP.Dispose();
                        hv_CalcSoAP = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "all"))) != 0)
                    {
                        hv_CalcClassAP.Dispose();
                        hv_CalcClassAP = 1;
                        hv_CalcMeanAP.Dispose();
                        hv_CalcMeanAP = 1;
                        if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
                        {
                            hv_CalcSoAP.Dispose();
                            hv_CalcSoAP = 1;
                        }
                    }
                    else
                    {
                        throw new HalconException("Unknown Instance Measure: " + (hv_Measures.TupleSelect(
                            hv_M)));
                    }
                }
                //*
                //Dependencies of measures:
                //
                //Recall (per-class)       *                   --> AP per class --> mAP
                //Precision (per-class)  /
                //
                //*
                //Initialize output dictionary and get necessary evaluation parameters.
                hv_EvaluationResult.Dispose();
                HOperatorSet.CreateDict(out hv_EvaluationResult);
                hv_ClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                hv_NumClasses.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
                hv_MaxNumDetections.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "max_num_detections", out hv_MaxNumDetections);
                hv_AreaRanges.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "area_ranges", out hv_AreaRanges);
                hv_IoUThresholds.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "iou_threshold", out hv_IoUThresholds);
                //Check if a detailed evaluation should be done.
                hv_DetailedEvaluation.Dispose();
                hv_DetailedEvaluation = 0;
                hv_KeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "detailed_evaluation",
                    out hv_KeyExists);
                if ((int)(hv_KeyExists.TupleSelect(0)) != 0)
                {
                    hv_DetailedEvaluation.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "detailed_evaluation", out hv_DetailedEvaluation);
                }
                //
                //Get information about area ranges.
                hv_AreaNames.Dispose();
                HOperatorSet.GetDictTuple(hv_AreaRanges, "name", out hv_AreaNames);
                hv_MinAreas.Dispose();
                HOperatorSet.GetDictTuple(hv_AreaRanges, "min", out hv_MinAreas);
                hv_MaxAreas.Dispose();
                HOperatorSet.GetDictTuple(hv_AreaRanges, "max", out hv_MaxAreas);
                //
                //Equidistant thresholds used to approximate the area under the Precision-Recall curve.
                hv_RecThreshs.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RecThreshs = HTuple.TupleGenSequence(
                        0.0, 1.0, 0.01);
                }
                //Start with calculation.
                if ((int)(hv_CalcClassAP.TupleOr(hv_CalcMeanAP)) != 0)
                {
                    //Loop over maximal number of detections.
                    for (hv_MDIdx = 0; (int)hv_MDIdx <= (int)((new HTuple(hv_MaxNumDetections.TupleLength()
                        )) - 1); hv_MDIdx = (int)hv_MDIdx + 1)
                    {
                        //
                        //Get corresponding running measures.
                        hv_MaxNum.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MaxNum = hv_MaxNumDetections.TupleSelect(
                                hv_MDIdx);
                        }
                        hv_MaxNumStr.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MaxNumStr = "" + hv_MaxNum;
                        }
                        if ((int)(new HTuple(hv_MaxNum.TupleEqual(-1))) != 0)
                        {
                            hv_MaxNumStr.Dispose();
                            hv_MaxNumStr = "all";
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentRunningMeasures.Dispose();
                            HOperatorSet.GetDictTuple(hv_RunningMeasures, "max_num_detections_" + hv_MaxNumStr,
                                out hv_CurrentRunningMeasures);
                        }
                        //
                        //Initialize output dictionary.
                        hv_PerMaxNumEvaluationResult.Dispose();
                        HOperatorSet.CreateDict(out hv_PerMaxNumEvaluationResult);
                        //
                        //Loop over area ranges.
                        for (hv_AreaIdx = 0; (int)hv_AreaIdx <= (int)((new HTuple(hv_AreaNames.TupleLength()
                            )) - 1); hv_AreaIdx = (int)hv_AreaIdx + 1)
                        {
                            //Get area thresholds.
                            hv_MinArea.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_MinArea = hv_MinAreas.TupleSelect(
                                    hv_AreaIdx);
                            }
                            hv_MaxArea.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_MaxArea = hv_MaxAreas.TupleSelect(
                                    hv_AreaIdx);
                            }
                            hv_AreaName.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_AreaName = hv_AreaNames.TupleSelect(
                                    hv_AreaIdx);
                            }
                            //
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_AreaRunningMeasures.Dispose();
                                HOperatorSet.GetDictTuple(hv_CurrentRunningMeasures, "area_" + hv_AreaName,
                                    out hv_AreaRunningMeasures);
                            }
                            //
                            hv_PerClassNumGt.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_gt", out hv_PerClassNumGt);
                            hv_PerClassNumPred.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_pred", out hv_PerClassNumPred);
                            hv_PerClassConfidence.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "confidence", out hv_PerClassConfidence);
                            hv_PerClassNumGtIgnore.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_gt_ignore", out hv_PerClassNumGtIgnore);
                            //
                            //Initialize output dictionary.
                            hv_CurrentEvaluationResult.Dispose();
                            HOperatorSet.CreateDict(out hv_CurrentEvaluationResult);
                            for (hv_ITIdx = 0; (int)hv_ITIdx <= (int)((new HTuple(hv_IoUThresholds.TupleLength()
                                )) - 1); hv_ITIdx = (int)hv_ITIdx + 1)
                            {
                                hv_PerIoUAP.Dispose();
                                HOperatorSet.CreateDict(out hv_PerIoUAP);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "ap_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                        hv_ITIdx)))).TupleRegexpReplace("\\.", "")), hv_PerIoUAP);
                                }
                                if ((int)(hv_CalcSoAP) != 0)
                                {
                                    hv_PerIoUSoAP.Dispose();
                                    HOperatorSet.CreateDict(out hv_PerIoUSoAP);
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "soap_tp_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                            hv_ITIdx)))).TupleRegexpReplace("\\.", "")), hv_PerIoUSoAP);
                                    }
                                }
                                if ((int)(hv_DetailedEvaluation) != 0)
                                {
                                    //Initialize detailed measures.
                                    hv_PerIoUDetailedEvaluation.Dispose();
                                    HOperatorSet.CreateDict(out hv_PerIoUDetailedEvaluation);
                                    HTuple end_val97 = hv_NumClasses - 1;
                                    HTuple step_val97 = 1;
                                    for (hv_ClsIdx = 0; hv_ClsIdx.Continue(end_val97, step_val97); hv_ClsIdx = hv_ClsIdx.TupleAdd(step_val97))
                                    {
                                        hv_PerClassDetailedEvaluation.Dispose();
                                        HOperatorSet.CreateDict(out hv_PerClassDetailedEvaluation);
                                        //Initialize with zeros in case there is no ground truth for this class.
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_tp",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fn",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_class",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_background",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_duplicate",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_localization",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_multiple",
                                            0);
                                        if ((int)(hv_CalcSoAP) != 0)
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "soap_fp_class",
                                                -1);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "soap_fp_duplicate",
                                                -1);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "soap_fp_localization",
                                                -1);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "soap_fp_multiple",
                                                -1);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "class_" + (hv_ClassIDs.TupleSelect(
                                                hv_ClsIdx)), hv_PerClassDetailedEvaluation);
                                        }
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_DetectionConfusionMatrix.Dispose();
                                        HOperatorSet.CreateMatrix(hv_NumClasses + 1, hv_NumClasses + 4, 0, out hv_DetectionConfusionMatrix);
                                    }
                                    HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "detection_confusion_matrix",
                                        hv_DetectionConfusionMatrix);
                                    //
                                    //Get and set image IDs with false negatives and false positives.
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUMeasure.Dispose();
                                        HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                            hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUMeasure);
                                    }
                                    //Get image IDs with false negatives and false positives, respectively.
                                    hv_NumImgIDsWithFN.Dispose();
                                    HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_negatives",
                                        out hv_NumImgIDsWithFN);
                                    hv_NumImgIDsWithFP.Dispose();
                                    HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_positives",
                                        out hv_NumImgIDsWithFP);
                                    hv_ImgIDsWithFN.Dispose();
                                    HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_negatives",
                                        out hv_ImgIDsWithFN);
                                    hv_ImgIDsWithFP.Dispose();
                                    HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_positives",
                                        out hv_ImgIDsWithFP);
                                    //Set in current output.
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "image_ids_with_false_negatives",
                                            hv_ImgIDsWithFN.TupleSelectRange(0, hv_NumImgIDsWithFN - 1));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "image_ids_with_false_positives",
                                            hv_ImgIDsWithFP.TupleSelectRange(0, hv_NumImgIDsWithFP - 1));
                                    }
                                    //
                                    //Set output for this IoU.
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "detailed_evaluation_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                            hv_ITIdx)))).TupleRegexpReplace("\\.", "")), hv_PerIoUDetailedEvaluation);
                                    }
                                }
                            }
                            hv_ClassMAPDict.Dispose();
                            HOperatorSet.CreateDict(out hv_ClassMAPDict);
                            HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_iou_ap",
                                hv_ClassMAPDict);
                            if ((int)(hv_CalcSoAP) != 0)
                            {
                                hv_ClassMSoAPDict.Dispose();
                                HOperatorSet.CreateDict(out hv_ClassMSoAPDict);
                                HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_iou_soap_tp",
                                    hv_ClassMSoAPDict);
                            }
                            //
                            //Check which classes have ground truth annotations.
                            hv_ClassesWithGt.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClassesWithGt = ((((hv_PerClassNumGt - hv_PerClassNumGtIgnore)).TupleGreaterElem(
                                    0))).TupleFind(1);
                            }
                            if ((int)(new HTuple(hv_ClassesWithGt.TupleEqual(-1))) != 0)
                            {
                                hv_ClassesWithGt.Dispose();
                                hv_ClassesWithGt = new HTuple();
                            }
                            //
                            //Initialize PerClassMAP, i.e. mean average precision over IoU-thresholds per class.
                            hv_PerClassMAP.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_PerClassMAP = HTuple.TupleGenConst(
                                    hv_NumClasses, -1.0);
                            }
                            //
                            //Initialize PerIoUMAP, i.e. mean average precision over classes per IoU-threshold.
                            hv_PerIoUMAP.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_PerIoUMAP = HTuple.TupleGenConst(
                                    new HTuple(hv_IoUThresholds.TupleLength()), 0.0);
                            }
                            //
                            if ((int)(hv_CalcSoAP) != 0)
                            {
                                //Initialize PerClassMSoAP, i.e. mean SoAP over IoU-thresholds per class.
                                hv_PerClassMSoAP.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerClassMSoAP = HTuple.TupleGenConst(
                                        hv_NumClasses, -1.0);
                                }
                                //Initialize PerIoUMSoAP, i.e. mean SoAP over classes per IoU-threshold.
                                hv_PerIoUMSoAP.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUMSoAP = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0.0);
                                }
                                //Initialize PerIoUNumClassesWithTP to store the class-indices where true positives occured.
                                hv_PerIoUNumClassesWithTP.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUNumClassesWithTP = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                            }
                            //
                            if ((int)(hv_DetailedEvaluation) != 0)
                            {
                                //Initialize overall num_fn, num_tp, ...
                                hv_PerIoUTP.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUTP = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_PerIoUFN.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUFN = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_PerIoUFP.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUFP = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_PerIoUFPClass.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUFPClass = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_PerIoUFPBackground.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUFPBackground = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_PerIoUFPLocalization.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUFPLocalization = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_PerIoUFPDuplicate.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUFPDuplicate = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_PerIoUFPMultiple.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUFPMultiple = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                if ((int)(hv_CalcSoAP) != 0)
                                {
                                    hv_PerIoUSoAPClass.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUSoAPClass = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), -1);
                                    }
                                    hv_PerIoUSoAPLocalization.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUSoAPLocalization = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), -1);
                                    }
                                    hv_PerIoUSoAPDuplicate.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUSoAPDuplicate = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), -1);
                                    }
                                    hv_PerIoUSoAPMultiple.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUSoAPMultiple = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), -1);
                                    }
                                    hv_PerIoUNumClassesWithFPClass.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUNumClassesWithFPClass = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                    }
                                    hv_PerIoUNumClassesWithFPLocalization.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUNumClassesWithFPLocalization = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                    }
                                    hv_PerIoUNumClassesWithFPDuplicate.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUNumClassesWithFPDuplicate = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                    }
                                    hv_PerIoUNumClassesWithFPMultiple.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUNumClassesWithFPMultiple = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                    }
                                }
                            }
                            //Loop over all classes.
                            HTuple end_val184 = hv_NumClasses - 1;
                            HTuple step_val184 = 1;
                            for (hv_ClsIdx = 0; hv_ClsIdx.Continue(end_val184, step_val184); hv_ClsIdx = hv_ClsIdx.TupleAdd(step_val184))
                            {
                                //
                                //Initialize per-class AP per IoU-threshold (only for one class).
                                hv_ClassAPPerIoU.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ClassAPPerIoU = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), -1.0);
                                }
                                //
                                if ((int)(hv_CalcSoAP) != 0)
                                {
                                    hv_ClassSoAPPerIoU.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_ClassSoAPPerIoU = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), -1.0);
                                    }
                                }
                                //Get results for this class.
                                hv_NumGt.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_NumGt = hv_PerClassNumGt.TupleSelect(
                                        hv_ClsIdx);
                                }
                                hv_NumGtIgnore.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_NumGtIgnore = hv_PerClassNumGtIgnore.TupleSelect(
                                        hv_ClsIdx);
                                }
                                if ((int)(new HTuple(((hv_NumGt - hv_NumGtIgnore)).TupleGreater(0))) != 0)
                                {
                                    hv_NumPred.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_NumPred = hv_PerClassNumPred.TupleSelect(
                                            hv_ClsIdx);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Confidences.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerClassConfidence, "class_" + (hv_ClassIDs.TupleSelect(
                                            hv_ClsIdx)), out hv_Confidences);
                                    }
                                    //
                                    //Sort the confidences in descending order and
                                    //only take the first NumPred ones due to block allocation.
                                    hv_SortIdxs.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_SortIdxs = ((-(hv_Confidences.TupleSelectRange(
                                            0, hv_NumPred - 1)))).TupleSortIndex();
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_Confidences = hv_Confidences.TupleSelect(
                                                hv_SortIdxs);
                                            hv_Confidences.Dispose();
                                            hv_Confidences = ExpTmpLocalVar_Confidences;
                                        }
                                    }
                                }
                                //
                                //Loop over IoU thresholds.
                                for (hv_ITIdx = 0; (int)hv_ITIdx <= (int)((new HTuple(hv_IoUThresholds.TupleLength()
                                    )) - 1); hv_ITIdx = (int)hv_ITIdx + 1)
                                {
                                    //
                                    //Check if there are ground truth labels for this class.
                                    if ((int)(new HTuple(((hv_NumGt - hv_NumGtIgnore)).TupleGreater(0))) != 0)
                                    {
                                        //
                                        //Get results for this class and IoU-threshold.
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_PerIoUMeasure.Dispose();
                                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                                hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUMeasure);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_CurrentClassMeasures.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "class_" + (hv_ClassIDs.TupleSelect(
                                                hv_ClsIdx)), out hv_CurrentClassMeasures);
                                        }
                                        hv_IsTP.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_tp", out hv_IsTP);
                                        hv_Ignore.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "ignore", out hv_Ignore);
                                        //
                                        //Sort the arrays IsTP and Ignore according to the confidence values.
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_IsTP = hv_IsTP.TupleSelect(
                                                    hv_SortIdxs);
                                                hv_IsTP.Dispose();
                                                hv_IsTP = ExpTmpLocalVar_IsTP;
                                            }
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_Ignore = hv_Ignore.TupleSelect(
                                                    hv_SortIdxs);
                                                hv_Ignore.Dispose();
                                                hv_Ignore = ExpTmpLocalVar_Ignore;
                                            }
                                        }
                                        //
                                        //Sort out the ignored results.
                                        if ((int)(new HTuple((new HTuple(hv_IsTP.TupleLength())).TupleGreater(
                                            0))) != 0)
                                        {
                                            hv_NoIgnoreIdxs.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_NoIgnoreIdxs = hv_Ignore.TupleFind(
                                                    0);
                                            }
                                            if ((int)(new HTuple(hv_NoIgnoreIdxs.TupleNotEqual(-1))) != 0)
                                            {
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_IsTP = hv_IsTP.TupleSelect(
                                                            hv_NoIgnoreIdxs);
                                                        hv_IsTP.Dispose();
                                                        hv_IsTP = ExpTmpLocalVar_IsTP;
                                                    }
                                                }
                                                hv_IsFP.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_IsFP = hv_IsTP.TupleNot()
                                                        ;
                                                }
                                            }
                                            else
                                            {
                                                hv_IsTP.Dispose();
                                                hv_IsTP = new HTuple();
                                                hv_IsFP.Dispose();
                                                hv_IsFP = new HTuple();
                                            }
                                        }
                                        else
                                        {
                                            hv_IsFP.Dispose();
                                            hv_IsFP = new HTuple();
                                        }
                                        //
                                        //Accumulate IsTP and IsFP.
                                        hv_AccumulatedIsTP.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_AccumulatedIsTP = hv_IsTP.TupleCumul()
                                                ;
                                        }
                                        hv_AccumulatedIsFP.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_AccumulatedIsFP = hv_IsFP.TupleCumul()
                                                ;
                                        }
                                        //
                                        //Compute recall.
                                        //The recall is computed with respect to all ground truth instances,
                                        //independent of MaxNum.
                                        hv_Recall.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_Recall = (hv_AccumulatedIsTP.TupleReal()
                                                ) / (hv_NumGt - hv_NumGtIgnore);
                                        }
                                        //
                                        //Compute precision.
                                        hv_Precision.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_Precision = (hv_AccumulatedIsTP.TupleReal()
                                                ) / (hv_AccumulatedIsTP + hv_AccumulatedIsFP);
                                        }
                                        //
                                        //Smooth precision-curve.
                                        hv_InterpolatedPrecision.Dispose();
                                        hv_InterpolatedPrecision = new HTuple(hv_Precision);
                                        for (hv_PIdx = (new HTuple(hv_NumPred.TupleLength())) - 2; (int)hv_PIdx >= 0; hv_PIdx = (int)hv_PIdx + -1)
                                        {
                                            if (hv_InterpolatedPrecision == null)
                                                hv_InterpolatedPrecision = new HTuple();
                                            hv_InterpolatedPrecision[hv_PIdx] = ((hv_Precision.TupleSelect(
                                                hv_PIdx))).TupleMax2(hv_Precision.TupleSelect(hv_PIdx + 1));
                                        }
                                        //Compute approximated area under the Precision-Recall curve using Recall-Thresholds.
                                        hv_PrecisionAtRecThreshs.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_PrecisionAtRecThreshs = HTuple.TupleGenConst(
                                                new HTuple(hv_RecThreshs.TupleLength()), 0.0);
                                        }
                                        for (hv_RTIdx = 0; (int)hv_RTIdx <= (int)((new HTuple(hv_RecThreshs.TupleLength()
                                            )) - 1); hv_RTIdx = (int)hv_RTIdx + 1)
                                        {
                                            hv_RecQuantile.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_RecQuantile = ((hv_Recall.TupleGreaterEqualElem(
                                                    hv_RecThreshs.TupleSelect(hv_RTIdx)))).TupleFindFirst(1);
                                            }
                                            if ((int)(new HTuple(hv_RecQuantile.TupleGreater(-1))) != 0)
                                            {
                                                if (hv_PrecisionAtRecThreshs == null)
                                                    hv_PrecisionAtRecThreshs = new HTuple();
                                                hv_PrecisionAtRecThreshs[hv_RTIdx] = hv_InterpolatedPrecision.TupleSelect(
                                                    hv_RecQuantile);
                                            }
                                        }
                                        //
                                        //Calculate AP as mean of precision at equidistant recall values.
                                        if (hv_ClassAPPerIoU == null)
                                            hv_ClassAPPerIoU = new HTuple();
                                        hv_ClassAPPerIoU[hv_ITIdx] = hv_PrecisionAtRecThreshs.TupleMean()
                                            ;
                                        //
                                        //Accumulate AP over classes.
                                        if (hv_PerIoUMAP == null)
                                            hv_PerIoUMAP = new HTuple();
                                        hv_PerIoUMAP[hv_ITIdx] = (hv_PerIoUMAP.TupleSelect(hv_ITIdx)) + (hv_ClassAPPerIoU.TupleSelect(
                                            hv_ITIdx));
                                        //
                                        if ((int)(hv_CalcSoAP) != 0)
                                        {
                                            //Calculate SoAP out of the mean over absolute orientation differences.
                                            hv_AOD.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "abs_orientation_diff",
                                                out hv_AOD);
                                            hv_IdxsTP.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_IdxsTP = hv_IsTP.TupleFind(
                                                    1);
                                            }
                                            if ((int)((new HTuple((new HTuple(hv_IdxsTP.TupleLength())).TupleGreater(
                                                0))).TupleAnd(new HTuple(hv_IdxsTP.TupleNotEqual(-1)))) != 0)
                                            {
                                                if (hv_ClassSoAPPerIoU == null)
                                                    hv_ClassSoAPPerIoU = new HTuple();
                                                hv_ClassSoAPPerIoU[hv_ITIdx] = 1.0 - ((((hv_AOD.TupleSelect(hv_SortIdxs.TupleSelect(
                                                    hv_NoIgnoreIdxs.TupleSelect(hv_IdxsTP))))).TupleMean()) / ((new HTuple(180)).TupleRad()
                                                    ));
                                                //Accumulate SoAP over classes.
                                                if (hv_PerIoUMSoAP == null)
                                                    hv_PerIoUMSoAP = new HTuple();
                                                hv_PerIoUMSoAP[hv_ITIdx] = (hv_PerIoUMSoAP.TupleSelect(hv_ITIdx)) + (hv_ClassSoAPPerIoU.TupleSelect(
                                                    hv_ITIdx));
                                            }
                                            //Update PerIoUNumClassesWithTP.
                                            if ((int)(new HTuple((new HTuple(hv_AccumulatedIsTP.TupleLength()
                                                )).TupleGreater(0))) != 0)
                                            {
                                                if (hv_PerIoUNumClassesWithTP == null)
                                                    hv_PerIoUNumClassesWithTP = new HTuple();
                                                hv_PerIoUNumClassesWithTP[hv_ITIdx] = (hv_PerIoUNumClassesWithTP.TupleSelect(
                                                    hv_ITIdx)) + (((hv_AccumulatedIsTP.TupleSelect((new HTuple(hv_AccumulatedIsTP.TupleLength()
                                                    )) - 1))).TupleGreaterElem(0));
                                            }
                                        }
                                        //
                                        if ((int)(hv_DetailedEvaluation) != 0)
                                        {
                                            //Summarize detailed evaluation running measures, set matrix-values and update overall detailed measures.
                                            //
                                            //Get the necessary running measures.
                                            hv_IsFPClass.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_fp_class",
                                                out hv_IsFPClass);
                                            hv_IsFPBackground.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_fp_background",
                                                out hv_IsFPBackground);
                                            hv_IsFPLocalization.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_fp_localization",
                                                out hv_IsFPLocalization);
                                            hv_IsFPDuplicate.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_fp_duplicate",
                                                out hv_IsFPDuplicate);
                                            hv_IsFPMultiple.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_fp_multiple",
                                                out hv_IsFPMultiple);
                                            //
                                            //We use the values with maximal recall,
                                            //in case a higher precision is desired, increase 'min_confidence'.
                                            if ((int)(new HTuple((new HTuple(hv_AccumulatedIsTP.TupleLength()
                                                )).TupleGreater(0))) != 0)
                                            {
                                                hv_NumTP.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_NumTP = hv_AccumulatedIsTP.TupleSelect(
                                                        (new HTuple(hv_AccumulatedIsTP.TupleLength())) - 1);
                                                }
                                            }
                                            else
                                            {
                                                hv_NumTP.Dispose();
                                                hv_NumTP = 0;
                                            }
                                            if ((int)(new HTuple((new HTuple(hv_AccumulatedIsFP.TupleLength()
                                                )).TupleGreater(0))) != 0)
                                            {
                                                hv_NumFP.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_NumFP = hv_AccumulatedIsFP.TupleSelect(
                                                        (new HTuple(hv_AccumulatedIsFP.TupleLength())) - 1);
                                                }
                                            }
                                            else
                                            {
                                                hv_NumFP.Dispose();
                                                hv_NumFP = 0;
                                            }
                                            hv_NumFN.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_NumFN = (hv_NumGt - hv_NumGtIgnore) - hv_NumTP;
                                            }
                                            hv_NumFPClass.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_NumFPClass = ((((hv_IsFPClass.TupleSelect(
                                                    hv_SortIdxs))).TupleGreaterElem(-1))).TupleSum();
                                            }
                                            hv_NumFPBackground.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_NumFPBackground = ((((hv_IsFPBackground.TupleSelect(
                                                    hv_SortIdxs))).TupleGreaterElem(0))).TupleSum();
                                            }
                                            hv_NumFPLocalization.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_NumFPLocalization = ((((hv_IsFPLocalization.TupleSelect(
                                                    hv_SortIdxs))).TupleGreaterElem(0))).TupleSum();
                                            }
                                            hv_NumFPDuplicate.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_NumFPDuplicate = ((((hv_IsFPDuplicate.TupleSelect(
                                                    hv_SortIdxs))).TupleGreaterElem(0))).TupleSum();
                                            }
                                            hv_NumFPMultiple.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_NumFPMultiple = ((((hv_IsFPMultiple.TupleSelect(
                                                    hv_SortIdxs))).TupleGreaterElem(0))).TupleSum();
                                            }
                                            if ((int)(new HTuple((new HTuple(hv_SortIdxs.TupleLength())).TupleEqual(
                                                0))) != 0)
                                            {
                                                hv_NumFPClass.Dispose();
                                                hv_NumFPClass = 0;
                                                hv_NumFPBackground.Dispose();
                                                hv_NumFPBackground = 0;
                                                hv_NumFPLocalization.Dispose();
                                                hv_NumFPLocalization = 0;
                                                hv_NumFPDuplicate.Dispose();
                                                hv_NumFPDuplicate = 0;
                                                hv_NumFPMultiple.Dispose();
                                                hv_NumFPMultiple = 0;
                                            }
                                            //Consistency checks.
                                            if ((int)(new HTuple(((((((((((((((((hv_NumTP.TupleConcat(hv_NumFN))).TupleConcat(
                                                hv_NumFP))).TupleConcat(hv_NumFPClass))).TupleConcat(hv_NumFPBackground))).TupleConcat(
                                                hv_NumFPLocalization))).TupleConcat(hv_NumFPDuplicate))).TupleConcat(
                                                hv_NumFPMultiple))).TupleMin())).TupleLess(0))) != 0)
                                            {
                                                throw new HalconException("Fatal error while calculating instance measures.");
                                            }
                                            if ((int)(new HTuple(hv_NumFP.TupleNotEqual((((hv_NumFPClass + hv_NumFPBackground) + hv_NumFPLocalization) + hv_NumFPDuplicate) + hv_NumFPMultiple))) != 0)
                                            {
                                                throw new HalconException("Fatal error while calculating instance measures.");
                                            }
                                            //
                                            //Set per-class measures.
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_PerIoUDetailedEvaluation.Dispose();
                                                HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "detailed_evaluation_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                                    hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUDetailedEvaluation);
                                            }
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_PerClassDetailedEvaluation.Dispose();
                                                HOperatorSet.GetDictTuple(hv_PerIoUDetailedEvaluation, "class_" + (hv_ClassIDs.TupleSelect(
                                                    hv_ClsIdx)), out hv_PerClassDetailedEvaluation);
                                            }
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_tp",
                                                hv_NumTP);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fn",
                                                hv_NumFN);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp",
                                                hv_NumFP);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_class",
                                                hv_NumFPClass);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_background",
                                                hv_NumFPBackground);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_duplicate",
                                                hv_NumFPDuplicate);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_localization",
                                                hv_NumFPLocalization);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_multiple",
                                                hv_NumFPMultiple);
                                            //
                                            //Set detection confusion matrix values.
                                            hv_DetectionConfusionMatrix.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerIoUDetailedEvaluation, "detection_confusion_matrix",
                                                out hv_DetectionConfusionMatrix);
                                            HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx,
                                                hv_ClsIdx, hv_NumTP);
                                            HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_NumClasses,
                                                hv_ClsIdx, hv_NumFN);
                                            HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx,
                                                hv_NumClasses, hv_NumFPBackground);
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx,
                                                    hv_NumClasses + 1, hv_NumFPLocalization);
                                            }
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx,
                                                    hv_NumClasses + 2, hv_NumFPDuplicate);
                                            }
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx,
                                                    hv_NumClasses + 3, hv_NumFPMultiple);
                                            }
                                            //
                                            //Go over IsFPClass and set confusions in matrix.
                                            hv_IndicesWithClassConfusion.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_IndicesWithClassConfusion = ((((hv_IsFPClass.TupleSelect(
                                                    hv_SortIdxs))).TupleGreaterElem(-1))).TupleFind(1);
                                            }
                                            hv_IsFPClassIdxs.Dispose();
                                            hv_IsFPClassIdxs = new HTuple();
                                            if ((int)(new HTuple(hv_IndicesWithClassConfusion.TupleGreater(
                                                -1))) != 0)
                                            {
                                                hv_IsFPClassIdxs.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_IsFPClassIdxs = hv_IsFPClass.TupleSelect(
                                                        hv_SortIdxs.TupleSelect(hv_IndicesWithClassConfusion));
                                                }
                                            }
                                            hv_ClassIdxsConfused.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ClassIdxsConfused = ((hv_IsFPClassIdxs.TupleSort()
                                                    )).TupleUniq();
                                            }
                                            for (hv_Idx = 0; (int)hv_Idx <= (int)((new HTuple(hv_ClassIdxsConfused.TupleLength()
                                                )) - 1); hv_Idx = (int)hv_Idx + 1)
                                            {
                                                hv_NumConfusedThisIdx.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_NumConfusedThisIdx = ((((hv_IsFPClassIdxs.TupleFind(
                                                        hv_ClassIdxsConfused.TupleSelect(hv_Idx)))).TupleGreaterElem(
                                                        -1))).TupleSum();
                                                }
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx,
                                                        hv_ClassIdxsConfused.TupleSelect(hv_Idx), hv_NumConfusedThisIdx);
                                                }
                                            }
                                            //
                                            //Update overall measures.
                                            if (hv_PerIoUFN == null)
                                                hv_PerIoUFN = new HTuple();
                                            hv_PerIoUFN[hv_ITIdx] = (hv_PerIoUFN.TupleSelect(hv_ITIdx)) + hv_NumFN;
                                            if (hv_PerIoUTP == null)
                                                hv_PerIoUTP = new HTuple();
                                            hv_PerIoUTP[hv_ITIdx] = (hv_PerIoUTP.TupleSelect(hv_ITIdx)) + hv_NumTP;
                                            if (hv_PerIoUFP == null)
                                                hv_PerIoUFP = new HTuple();
                                            hv_PerIoUFP[hv_ITIdx] = (hv_PerIoUFP.TupleSelect(hv_ITIdx)) + hv_NumFP;
                                            if (hv_PerIoUFPClass == null)
                                                hv_PerIoUFPClass = new HTuple();
                                            hv_PerIoUFPClass[hv_ITIdx] = (hv_PerIoUFPClass.TupleSelect(hv_ITIdx)) + hv_NumFPClass;
                                            if (hv_PerIoUFPBackground == null)
                                                hv_PerIoUFPBackground = new HTuple();
                                            hv_PerIoUFPBackground[hv_ITIdx] = (hv_PerIoUFPBackground.TupleSelect(
                                                hv_ITIdx)) + hv_NumFPBackground;
                                            if (hv_PerIoUFPLocalization == null)
                                                hv_PerIoUFPLocalization = new HTuple();
                                            hv_PerIoUFPLocalization[hv_ITIdx] = (hv_PerIoUFPLocalization.TupleSelect(
                                                hv_ITIdx)) + hv_NumFPLocalization;
                                            if (hv_PerIoUFPDuplicate == null)
                                                hv_PerIoUFPDuplicate = new HTuple();
                                            hv_PerIoUFPDuplicate[hv_ITIdx] = (hv_PerIoUFPDuplicate.TupleSelect(
                                                hv_ITIdx)) + hv_NumFPDuplicate;
                                            if (hv_PerIoUFPMultiple == null)
                                                hv_PerIoUFPMultiple = new HTuple();
                                            hv_PerIoUFPMultiple[hv_ITIdx] = (hv_PerIoUFPMultiple.TupleSelect(
                                                hv_ITIdx)) + hv_NumFPMultiple;
                                            if ((int)(hv_CalcSoAP) != 0)
                                            {
                                                //Calculate and update absolute difference of orientation for class false positives.
                                                hv_AODClass.Dispose();
                                                HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "abs_orientation_diff_class",
                                                    out hv_AODClass);
                                                hv_IdxsClass.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_IdxsClass = ((hv_AODClass.TupleGreaterElem(
                                                        -1))).TupleFind(1);
                                                }
                                                if ((int)(new HTuple(hv_IdxsClass.TupleNotEqual(-1))) != 0)
                                                {
                                                    hv_ResSoAPClass.Dispose();
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        hv_ResSoAPClass = 1.0 - ((((hv_AODClass.TupleSelect(
                                                            hv_IdxsClass))).TupleMean()) / ((new HTuple(180)).TupleRad()
                                                            ));
                                                    }
                                                    HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation,
                                                        "soap_fp_class", hv_ResSoAPClass);
                                                    //Update mean over classes.
                                                    if (hv_PerIoUNumClassesWithFPClass == null)
                                                        hv_PerIoUNumClassesWithFPClass = new HTuple();
                                                    hv_PerIoUNumClassesWithFPClass[hv_ITIdx] = (hv_PerIoUNumClassesWithFPClass.TupleSelect(
                                                        hv_ITIdx)) + 1;
                                                    if ((int)(new HTuple(((hv_PerIoUSoAPClass.TupleSelect(hv_ITIdx))).TupleEqual(
                                                        -1))) != 0)
                                                    {
                                                        if (hv_PerIoUSoAPClass == null)
                                                            hv_PerIoUSoAPClass = new HTuple();
                                                        hv_PerIoUSoAPClass[hv_ITIdx] = hv_ResSoAPClass;
                                                    }
                                                    else
                                                    {
                                                        if (hv_PerIoUSoAPClass == null)
                                                            hv_PerIoUSoAPClass = new HTuple();
                                                        hv_PerIoUSoAPClass[hv_ITIdx] = (hv_PerIoUSoAPClass.TupleSelect(
                                                            hv_ITIdx)) + hv_ResSoAPClass;
                                                    }
                                                }
                                                //Calculate and update absolute difference of orientation for localization false positives.
                                                hv_AODLocalization.Dispose();
                                                HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "abs_orientation_diff_localization",
                                                    out hv_AODLocalization);
                                                hv_IdxsLocalization.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_IdxsLocalization = ((hv_AODLocalization.TupleGreaterElem(
                                                        -1))).TupleFind(1);
                                                }
                                                if ((int)(new HTuple(hv_IdxsLocalization.TupleNotEqual(-1))) != 0)
                                                {
                                                    hv_ResSoAPLocalization.Dispose();
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        hv_ResSoAPLocalization = 1.0 - ((((hv_AODLocalization.TupleSelect(
                                                            hv_IdxsLocalization))).TupleMean()) / ((new HTuple(180)).TupleRad()
                                                            ));
                                                    }
                                                    HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation,
                                                        "soap_fp_localization", hv_ResSoAPLocalization);
                                                    //Update mean over classes.
                                                    if (hv_PerIoUNumClassesWithFPLocalization == null)
                                                        hv_PerIoUNumClassesWithFPLocalization = new HTuple();
                                                    hv_PerIoUNumClassesWithFPLocalization[hv_ITIdx] = (hv_PerIoUNumClassesWithFPLocalization.TupleSelect(
                                                        hv_ITIdx)) + 1;
                                                    if ((int)(new HTuple(((hv_PerIoUSoAPLocalization.TupleSelect(
                                                        hv_ITIdx))).TupleEqual(-1))) != 0)
                                                    {
                                                        if (hv_PerIoUSoAPLocalization == null)
                                                            hv_PerIoUSoAPLocalization = new HTuple();
                                                        hv_PerIoUSoAPLocalization[hv_ITIdx] = hv_ResSoAPLocalization;
                                                    }
                                                    else
                                                    {
                                                        if (hv_PerIoUSoAPLocalization == null)
                                                            hv_PerIoUSoAPLocalization = new HTuple();
                                                        hv_PerIoUSoAPLocalization[hv_ITIdx] = (hv_PerIoUSoAPLocalization.TupleSelect(
                                                            hv_ITIdx)) + hv_ResSoAPLocalization;
                                                    }
                                                }
                                                //Calculate and update absolute difference of orientation for class false positives.
                                                hv_AODDuplicate.Dispose();
                                                HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "abs_orientation_diff_duplicate",
                                                    out hv_AODDuplicate);
                                                hv_IdxsDuplicate.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_IdxsDuplicate = ((hv_AODDuplicate.TupleGreaterElem(
                                                        -1))).TupleFind(1);
                                                }
                                                if ((int)(new HTuple(hv_IdxsDuplicate.TupleNotEqual(-1))) != 0)
                                                {
                                                    hv_ResSoAPDuplicate.Dispose();
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        hv_ResSoAPDuplicate = 1.0 - ((((hv_AODDuplicate.TupleSelect(
                                                            hv_IdxsDuplicate))).TupleMean()) / ((new HTuple(180)).TupleRad()
                                                            ));
                                                    }
                                                    HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation,
                                                        "soap_fp_duplicate", hv_ResSoAPDuplicate);
                                                    //Update mean over classes.
                                                    if (hv_PerIoUNumClassesWithFPDuplicate == null)
                                                        hv_PerIoUNumClassesWithFPDuplicate = new HTuple();
                                                    hv_PerIoUNumClassesWithFPDuplicate[hv_ITIdx] = (hv_PerIoUNumClassesWithFPDuplicate.TupleSelect(
                                                        hv_ITIdx)) + 1;
                                                    if ((int)(new HTuple(((hv_PerIoUSoAPDuplicate.TupleSelect(
                                                        hv_ITIdx))).TupleEqual(-1))) != 0)
                                                    {
                                                        if (hv_PerIoUSoAPDuplicate == null)
                                                            hv_PerIoUSoAPDuplicate = new HTuple();
                                                        hv_PerIoUSoAPDuplicate[hv_ITIdx] = hv_ResSoAPDuplicate;
                                                    }
                                                    else
                                                    {
                                                        if (hv_PerIoUSoAPDuplicate == null)
                                                            hv_PerIoUSoAPDuplicate = new HTuple();
                                                        hv_PerIoUSoAPDuplicate[hv_ITIdx] = (hv_PerIoUSoAPDuplicate.TupleSelect(
                                                            hv_ITIdx)) + hv_ResSoAPDuplicate;
                                                    }
                                                }
                                                //Calculate and update absolute difference of orientation for multiple false positives.
                                                hv_AODMultiple.Dispose();
                                                HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "abs_orientation_diff_multiple",
                                                    out hv_AODMultiple);
                                                hv_IdxsMultiple.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_IdxsMultiple = ((hv_AODMultiple.TupleGreaterElem(
                                                        -1))).TupleFind(1);
                                                }
                                                if ((int)(new HTuple(hv_IdxsMultiple.TupleNotEqual(-1))) != 0)
                                                {
                                                    hv_ResSoAPMultiple.Dispose();
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        hv_ResSoAPMultiple = 1.0 - ((((hv_AODMultiple.TupleSelect(
                                                            hv_IdxsMultiple))).TupleMean()) / ((new HTuple(180)).TupleRad()
                                                            ));
                                                    }
                                                    HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation,
                                                        "soap_fp_multiple", hv_ResSoAPMultiple);
                                                    //Update mean over classes.
                                                    if (hv_PerIoUNumClassesWithFPMultiple == null)
                                                        hv_PerIoUNumClassesWithFPMultiple = new HTuple();
                                                    hv_PerIoUNumClassesWithFPMultiple[hv_ITIdx] = (hv_PerIoUNumClassesWithFPMultiple.TupleSelect(
                                                        hv_ITIdx)) + 1;
                                                    if ((int)(new HTuple(((hv_PerIoUSoAPMultiple.TupleSelect(
                                                        hv_ITIdx))).TupleEqual(-1))) != 0)
                                                    {
                                                        if (hv_PerIoUSoAPMultiple == null)
                                                            hv_PerIoUSoAPMultiple = new HTuple();
                                                        hv_PerIoUSoAPMultiple[hv_ITIdx] = hv_ResSoAPMultiple;
                                                    }
                                                    else
                                                    {
                                                        if (hv_PerIoUSoAPMultiple == null)
                                                            hv_PerIoUSoAPMultiple = new HTuple();
                                                        hv_PerIoUSoAPMultiple[hv_ITIdx] = (hv_PerIoUSoAPMultiple.TupleSelect(
                                                            hv_ITIdx)) + hv_ResSoAPMultiple;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    //
                                    //Write to output.
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUAP.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "ap_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                            hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUAP);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUAP, "class_" + (hv_ClassIDs.TupleSelect(
                                            hv_ClsIdx)), hv_ClassAPPerIoU.TupleSelect(hv_ITIdx));
                                    }
                                    if ((int)(hv_CalcSoAP) != 0)
                                    {
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_PerIoUSoAP.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "soap_tp_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                                hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUSoAP);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUSoAP, "class_" + (hv_ClassIDs.TupleSelect(
                                                hv_ClsIdx)), hv_ClassSoAPPerIoU.TupleSelect(hv_ITIdx));
                                        }
                                    }
                                }
                                //
                                //Class mAP is the mean over IoU-thresholds.
                                if (hv_PerClassMAP == null)
                                    hv_PerClassMAP = new HTuple();
                                hv_PerClassMAP[hv_ClsIdx] = hv_ClassAPPerIoU.TupleMean();
                                hv_ClassMAPDict.Dispose();
                                HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "mean_iou_ap",
                                    out hv_ClassMAPDict);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_ClassMAPDict, "class_" + (hv_ClassIDs.TupleSelect(
                                        hv_ClsIdx)), hv_PerClassMAP.TupleSelect(hv_ClsIdx));
                                }
                                if ((int)(hv_CalcSoAP) != 0)
                                {
                                    //ClassMSoAP is the mean over IoU-thresholds.
                                    if (hv_PerClassMSoAP == null)
                                        hv_PerClassMSoAP = new HTuple();
                                    hv_PerClassMSoAP[hv_ClsIdx] = hv_ClassSoAPPerIoU.TupleMean();
                                    hv_ClassMSoAPDict.Dispose();
                                    HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "mean_iou_soap_tp",
                                        out hv_ClassMSoAPDict);
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_ClassMSoAPDict, "class_" + (hv_ClassIDs.TupleSelect(
                                            hv_ClsIdx)), hv_PerClassMSoAP.TupleSelect(hv_ClsIdx));
                                    }
                                }
                            }
                            //
                            //Calculate the mean AP and optionally mean SoAP (over classes) per IoU-threshold.
                            for (hv_ITIdx = 0; (int)hv_ITIdx <= (int)((new HTuple(hv_IoUThresholds.TupleLength()
                                )) - 1); hv_ITIdx = (int)hv_ITIdx + 1)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUAP.Dispose();
                                    HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "ap_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                        hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUAP);
                                }
                                //
                                //Consider only present classes.
                                hv_MeanClassAP.Dispose();
                                hv_MeanClassAP = -1.0;
                                if ((int)(new HTuple((new HTuple(hv_ClassesWithGt.TupleLength())).TupleGreater(
                                    0))) != 0)
                                {
                                    hv_MeanClassAP.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_MeanClassAP = (hv_PerIoUMAP.TupleSelect(
                                            hv_ITIdx)) / (new HTuple(hv_ClassesWithGt.TupleLength()));
                                    }
                                }
                                HOperatorSet.SetDictTuple(hv_PerIoUAP, "mean_class_ap", hv_MeanClassAP);
                                if ((int)(hv_CalcSoAP) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUSoAP.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "soap_tp_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                            hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUSoAP);
                                    }
                                    //
                                    //Consider only present classes.
                                    hv_MeanClassSoAP.Dispose();
                                    hv_MeanClassSoAP = -1.0;
                                    if ((int)(new HTuple(((hv_PerIoUNumClassesWithTP.TupleSelect(hv_ITIdx))).TupleGreater(
                                        0))) != 0)
                                    {
                                        hv_MeanClassSoAP.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_MeanClassSoAP = (hv_PerIoUMSoAP.TupleSelect(
                                                hv_ITIdx)) / (hv_PerIoUNumClassesWithTP.TupleSelect(hv_ITIdx));
                                        }
                                    }
                                    HOperatorSet.SetDictTuple(hv_PerIoUSoAP, "mean_class_soap_tp", hv_MeanClassSoAP);
                                }
                                //
                                if ((int)(hv_DetailedEvaluation) != 0)
                                {
                                    //Add overall measures for TP, FN, FP, ...
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUDetailedEvaluation.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "detailed_evaluation_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                            hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUDetailedEvaluation);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_tp",
                                            hv_PerIoUTP.TupleSelect(hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fn",
                                            hv_PerIoUFN.TupleSelect(hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp",
                                            hv_PerIoUFP.TupleSelect(hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_class",
                                            hv_PerIoUFPClass.TupleSelect(hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_background",
                                            hv_PerIoUFPBackground.TupleSelect(hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_duplicate",
                                            hv_PerIoUFPDuplicate.TupleSelect(hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_localization",
                                            hv_PerIoUFPLocalization.TupleSelect(hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_multiple",
                                            hv_PerIoUFPMultiple.TupleSelect(hv_ITIdx));
                                    }
                                    if ((int)(hv_CalcSoAP) != 0)
                                    {
                                        if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPClass.TupleSelect(
                                            hv_ITIdx))).TupleGreater(0))) != 0)
                                        {
                                            if (hv_PerIoUSoAPClass == null)
                                                hv_PerIoUSoAPClass = new HTuple();
                                            hv_PerIoUSoAPClass[hv_ITIdx] = (hv_PerIoUSoAPClass.TupleSelect(
                                                hv_ITIdx)) / (hv_PerIoUNumClassesWithFPClass.TupleSelect(hv_ITIdx));
                                        }
                                        if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPLocalization.TupleSelect(
                                            hv_ITIdx))).TupleGreater(0))) != 0)
                                        {
                                            if (hv_PerIoUSoAPLocalization == null)
                                                hv_PerIoUSoAPLocalization = new HTuple();
                                            hv_PerIoUSoAPLocalization[hv_ITIdx] = (hv_PerIoUSoAPLocalization.TupleSelect(
                                                hv_ITIdx)) / (hv_PerIoUNumClassesWithFPLocalization.TupleSelect(
                                                hv_ITIdx));
                                        }
                                        if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPDuplicate.TupleSelect(
                                            hv_ITIdx))).TupleGreater(0))) != 0)
                                        {
                                            if (hv_PerIoUSoAPDuplicate == null)
                                                hv_PerIoUSoAPDuplicate = new HTuple();
                                            hv_PerIoUSoAPDuplicate[hv_ITIdx] = (hv_PerIoUSoAPDuplicate.TupleSelect(
                                                hv_ITIdx)) / (hv_PerIoUNumClassesWithFPDuplicate.TupleSelect(
                                                hv_ITIdx));
                                        }
                                        if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPMultiple.TupleSelect(
                                            hv_ITIdx))).TupleGreater(0))) != 0)
                                        {
                                            if (hv_PerIoUSoAPMultiple == null)
                                                hv_PerIoUSoAPMultiple = new HTuple();
                                            hv_PerIoUSoAPMultiple[hv_ITIdx] = (hv_PerIoUSoAPMultiple.TupleSelect(
                                                hv_ITIdx)) / (hv_PerIoUNumClassesWithFPMultiple.TupleSelect(
                                                hv_ITIdx));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "soap_fp_class",
                                                hv_PerIoUSoAPClass.TupleSelect(hv_ITIdx));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "soap_fp_localization",
                                                hv_PerIoUSoAPLocalization.TupleSelect(hv_ITIdx));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "soap_fp_duplicate",
                                                hv_PerIoUSoAPDuplicate.TupleSelect(hv_ITIdx));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "soap_fp_multiple",
                                                hv_PerIoUSoAPMultiple.TupleSelect(hv_ITIdx));
                                        }
                                    }
                                }
                            }
                            //
                            //Calculate overall mean AP (over classes and IoU-thresholds).
                            //Also here only classes with ground truth annotations are taken into account.
                            hv_MAP.Dispose();
                            hv_MAP = -1.0;
                            if ((int)(new HTuple((new HTuple(hv_ClassesWithGt.TupleLength())).TupleGreater(
                                0))) != 0)
                            {
                                hv_MAP.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_MAP = (((hv_PerClassMAP.TupleSelect(
                                        hv_ClassesWithGt))).TupleSum()) / (new HTuple(hv_ClassesWithGt.TupleLength()
                                        ));
                                }
                            }
                            HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_ap", hv_MAP);
                            if ((int)(hv_CalcSoAP) != 0)
                            {
                                hv_MSoAP.Dispose();
                                hv_MSoAP = -1.0;
                                if ((int)(new HTuple(((hv_PerIoUNumClassesWithTP.TupleSum())).TupleGreater(
                                    0))) != 0)
                                {
                                    hv_IoUsWithTP.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_IoUsWithTP = ((hv_PerIoUNumClassesWithTP.TupleGreaterElem(
                                            0))).TupleFind(1);
                                    }
                                    hv_MSoAP.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_MSoAP = ((((hv_PerIoUMSoAP.TupleSelect(
                                            hv_IoUsWithTP)) / (hv_PerIoUNumClassesWithTP.TupleSelect(hv_IoUsWithTP)))).TupleSum()
                                            ) / (new HTuple(hv_IoUsWithTP.TupleLength()));
                                    }
                                }
                                HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_soap_tp",
                                    hv_MSoAP);
                                if ((int)(hv_DetailedEvaluation) != 0)
                                {
                                    hv_MSoAPAll.Dispose();
                                    hv_MSoAPAll = 0.0;
                                    hv_NumSoAPAll.Dispose();
                                    hv_NumSoAPAll = 0;
                                    if ((int)(new HTuple(((hv_PerIoUNumClassesWithTP.TupleSum())).TupleGreater(
                                        0))) != 0)
                                    {
                                        hv_IoUsWithTP.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_IoUsWithTP = ((hv_PerIoUNumClassesWithTP.TupleGreaterElem(
                                                0))).TupleFind(1);
                                        }
                                        hv_MSoAPAll.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_MSoAPAll = hv_MSoAP * (((hv_PerIoUNumClassesWithTP.TupleSelect(
                                                hv_IoUsWithTP))).TupleSum());
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_NumSoAPAll = hv_NumSoAPAll + (((hv_PerIoUNumClassesWithTP.TupleSelect(
                                                    hv_IoUsWithTP))).TupleSum());
                                                hv_NumSoAPAll.Dispose();
                                                hv_NumSoAPAll = ExpTmpLocalVar_NumSoAPAll;
                                            }
                                        }
                                    }
                                    if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPClass.TupleSum())).TupleGreater(
                                        0))) != 0)
                                    {
                                        hv_IoUsWithFPClass.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_IoUsWithFPClass = ((hv_PerIoUNumClassesWithFPClass.TupleGreaterElem(
                                                0))).TupleFind(1);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_MSoAPAll = hv_MSoAPAll + (((((hv_PerIoUSoAPClass.TupleSelect(
                                                    hv_IoUsWithFPClass))).TupleSum()) / (new HTuple(hv_IoUsWithFPClass.TupleLength()
                                                    ))) * (((hv_PerIoUNumClassesWithFPClass.TupleSelect(hv_IoUsWithFPClass))).TupleSum()
                                                    ));
                                                hv_MSoAPAll.Dispose();
                                                hv_MSoAPAll = ExpTmpLocalVar_MSoAPAll;
                                            }
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_NumSoAPAll = hv_NumSoAPAll + (((hv_PerIoUNumClassesWithFPClass.TupleSelect(
                                                    hv_IoUsWithFPClass))).TupleSum());
                                                hv_NumSoAPAll.Dispose();
                                                hv_NumSoAPAll = ExpTmpLocalVar_NumSoAPAll;
                                            }
                                        }
                                    }
                                    if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPLocalization.TupleSum()
                                        )).TupleGreater(0))) != 0)
                                    {
                                        hv_IoUsWithFPLocalization.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_IoUsWithFPLocalization = ((hv_PerIoUNumClassesWithFPLocalization.TupleGreaterElem(
                                                0))).TupleFind(1);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_MSoAPAll = hv_MSoAPAll + (((((hv_PerIoUSoAPLocalization.TupleSelect(
                                                    hv_IoUsWithFPLocalization))).TupleSum()) / (new HTuple(hv_IoUsWithFPLocalization.TupleLength()
                                                    ))) * (((hv_PerIoUNumClassesWithFPLocalization.TupleSelect(hv_IoUsWithFPLocalization))).TupleSum()
                                                    ));
                                                hv_MSoAPAll.Dispose();
                                                hv_MSoAPAll = ExpTmpLocalVar_MSoAPAll;
                                            }
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_NumSoAPAll = hv_NumSoAPAll + (((hv_PerIoUNumClassesWithFPLocalization.TupleSelect(
                                                    hv_IoUsWithFPLocalization))).TupleSum());
                                                hv_NumSoAPAll.Dispose();
                                                hv_NumSoAPAll = ExpTmpLocalVar_NumSoAPAll;
                                            }
                                        }
                                    }
                                    if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPDuplicate.TupleSum()
                                        )).TupleGreater(0))) != 0)
                                    {
                                        hv_IoUsWithFPDuplicate.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_IoUsWithFPDuplicate = ((hv_PerIoUNumClassesWithFPDuplicate.TupleGreaterElem(
                                                0))).TupleFind(1);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_MSoAPAll = hv_MSoAPAll + (((((hv_PerIoUSoAPDuplicate.TupleSelect(
                                                    hv_IoUsWithFPDuplicate))).TupleSum()) / (new HTuple(hv_IoUsWithFPDuplicate.TupleLength()
                                                    ))) * (((hv_PerIoUNumClassesWithFPDuplicate.TupleSelect(hv_IoUsWithFPDuplicate))).TupleSum()
                                                    ));
                                                hv_MSoAPAll.Dispose();
                                                hv_MSoAPAll = ExpTmpLocalVar_MSoAPAll;
                                            }
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_NumSoAPAll = hv_NumSoAPAll + (((hv_PerIoUNumClassesWithFPDuplicate.TupleSelect(
                                                    hv_IoUsWithFPDuplicate))).TupleSum());
                                                hv_NumSoAPAll.Dispose();
                                                hv_NumSoAPAll = ExpTmpLocalVar_NumSoAPAll;
                                            }
                                        }
                                    }
                                    if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPMultiple.TupleSum()
                                        )).TupleGreater(0))) != 0)
                                    {
                                        hv_IoUsWithFPMultiple.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_IoUsWithFPMultiple = ((hv_PerIoUNumClassesWithFPMultiple.TupleGreaterElem(
                                                0))).TupleFind(1);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_MSoAPAll = hv_MSoAPAll + (((((hv_PerIoUSoAPMultiple.TupleSelect(
                                                    hv_IoUsWithFPMultiple))).TupleSum()) / (new HTuple(hv_IoUsWithFPMultiple.TupleLength()
                                                    ))) * (((hv_PerIoUNumClassesWithFPMultiple.TupleSelect(hv_IoUsWithFPMultiple))).TupleSum()
                                                    ));
                                                hv_MSoAPAll.Dispose();
                                                hv_MSoAPAll = ExpTmpLocalVar_MSoAPAll;
                                            }
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_NumSoAPAll = hv_NumSoAPAll + (((hv_PerIoUNumClassesWithFPMultiple.TupleSelect(
                                                    hv_IoUsWithFPMultiple))).TupleSum());
                                                hv_NumSoAPAll.Dispose();
                                                hv_NumSoAPAll = ExpTmpLocalVar_NumSoAPAll;
                                            }
                                        }
                                    }
                                    if ((int)(new HTuple(hv_NumSoAPAll.TupleGreater(0))) != 0)
                                    {
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_soap_all",
                                                (hv_MSoAPAll.TupleReal()) / hv_NumSoAPAll);
                                        }
                                    }
                                    else
                                    {
                                        HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_soap_all",
                                            -1);
                                    }

                                }
                            }
                            //
                            //Add CurrentEvaluationResult to output.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_PerMaxNumEvaluationResult, "area_" + hv_AreaName,
                                    hv_CurrentEvaluationResult);
                            }
                        }
                        //Add PerMaxNumEvaluationResult to output.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_EvaluationResult, "max_num_detections_" + hv_MaxNumStr,
                                hv_PerMaxNumEvaluationResult);
                        }
                    }
                }
                //

                hv_CalcClassAP.Dispose();
                hv_CalcMeanAP.Dispose();
                hv_CalcSoAP.Dispose();
                hv_InstanceType.Dispose();
                hv_Measures.Dispose();
                hv_M.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClasses.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_IoUThresholds.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_KeyExists.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_RecThreshs.Dispose();
                hv_MDIdx.Dispose();
                hv_MaxNum.Dispose();
                hv_MaxNumStr.Dispose();
                hv_CurrentRunningMeasures.Dispose();
                hv_PerMaxNumEvaluationResult.Dispose();
                hv_AreaIdx.Dispose();
                hv_MinArea.Dispose();
                hv_MaxArea.Dispose();
                hv_AreaName.Dispose();
                hv_AreaRunningMeasures.Dispose();
                hv_PerClassNumGt.Dispose();
                hv_PerClassNumPred.Dispose();
                hv_PerClassConfidence.Dispose();
                hv_PerClassNumGtIgnore.Dispose();
                hv_CurrentEvaluationResult.Dispose();
                hv_ITIdx.Dispose();
                hv_PerIoUAP.Dispose();
                hv_PerIoUSoAP.Dispose();
                hv_PerIoUDetailedEvaluation.Dispose();
                hv_ClsIdx.Dispose();
                hv_PerClassDetailedEvaluation.Dispose();
                hv_DetectionConfusionMatrix.Dispose();
                hv_PerIoUMeasure.Dispose();
                hv_NumImgIDsWithFN.Dispose();
                hv_NumImgIDsWithFP.Dispose();
                hv_ImgIDsWithFN.Dispose();
                hv_ImgIDsWithFP.Dispose();
                hv_ClassMAPDict.Dispose();
                hv_ClassMSoAPDict.Dispose();
                hv_ClassesWithGt.Dispose();
                hv_PerClassMAP.Dispose();
                hv_PerIoUMAP.Dispose();
                hv_PerClassMSoAP.Dispose();
                hv_PerIoUMSoAP.Dispose();
                hv_PerIoUNumClassesWithTP.Dispose();
                hv_PerIoUTP.Dispose();
                hv_PerIoUFN.Dispose();
                hv_PerIoUFP.Dispose();
                hv_PerIoUFPClass.Dispose();
                hv_PerIoUFPBackground.Dispose();
                hv_PerIoUFPLocalization.Dispose();
                hv_PerIoUFPDuplicate.Dispose();
                hv_PerIoUFPMultiple.Dispose();
                hv_PerIoUSoAPClass.Dispose();
                hv_PerIoUSoAPLocalization.Dispose();
                hv_PerIoUSoAPDuplicate.Dispose();
                hv_PerIoUSoAPMultiple.Dispose();
                hv_PerIoUNumClassesWithFPClass.Dispose();
                hv_PerIoUNumClassesWithFPLocalization.Dispose();
                hv_PerIoUNumClassesWithFPDuplicate.Dispose();
                hv_PerIoUNumClassesWithFPMultiple.Dispose();
                hv_ClassAPPerIoU.Dispose();
                hv_ClassSoAPPerIoU.Dispose();
                hv_NumGt.Dispose();
                hv_NumGtIgnore.Dispose();
                hv_NumPred.Dispose();
                hv_Confidences.Dispose();
                hv_SortIdxs.Dispose();
                hv_CurrentClassMeasures.Dispose();
                hv_IsTP.Dispose();
                hv_Ignore.Dispose();
                hv_NoIgnoreIdxs.Dispose();
                hv_IsFP.Dispose();
                hv_AccumulatedIsTP.Dispose();
                hv_AccumulatedIsFP.Dispose();
                hv_Recall.Dispose();
                hv_Precision.Dispose();
                hv_InterpolatedPrecision.Dispose();
                hv_PIdx.Dispose();
                hv_PrecisionAtRecThreshs.Dispose();
                hv_RTIdx.Dispose();
                hv_RecQuantile.Dispose();
                hv_AOD.Dispose();
                hv_IdxsTP.Dispose();
                hv_IsFPClass.Dispose();
                hv_IsFPBackground.Dispose();
                hv_IsFPLocalization.Dispose();
                hv_IsFPDuplicate.Dispose();
                hv_IsFPMultiple.Dispose();
                hv_NumTP.Dispose();
                hv_NumFP.Dispose();
                hv_NumFN.Dispose();
                hv_NumFPClass.Dispose();
                hv_NumFPBackground.Dispose();
                hv_NumFPLocalization.Dispose();
                hv_NumFPDuplicate.Dispose();
                hv_NumFPMultiple.Dispose();
                hv_IndicesWithClassConfusion.Dispose();
                hv_IsFPClassIdxs.Dispose();
                hv_ClassIdxsConfused.Dispose();
                hv_Idx.Dispose();
                hv_NumConfusedThisIdx.Dispose();
                hv_AODClass.Dispose();
                hv_IdxsClass.Dispose();
                hv_ResSoAPClass.Dispose();
                hv_AODLocalization.Dispose();
                hv_IdxsLocalization.Dispose();
                hv_ResSoAPLocalization.Dispose();
                hv_AODDuplicate.Dispose();
                hv_IdxsDuplicate.Dispose();
                hv_ResSoAPDuplicate.Dispose();
                hv_AODMultiple.Dispose();
                hv_IdxsMultiple.Dispose();
                hv_ResSoAPMultiple.Dispose();
                hv_MeanClassAP.Dispose();
                hv_MeanClassSoAP.Dispose();
                hv_MAP.Dispose();
                hv_MSoAP.Dispose();
                hv_IoUsWithTP.Dispose();
                hv_MSoAPAll.Dispose();
                hv_NumSoAPAll.Dispose();
                hv_IoUsWithFPClass.Dispose();
                hv_IoUsWithFPLocalization.Dispose();
                hv_IoUsWithFPDuplicate.Dispose();
                hv_IoUsWithFPMultiple.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_CalcClassAP.Dispose();
                hv_CalcMeanAP.Dispose();
                hv_CalcSoAP.Dispose();
                hv_InstanceType.Dispose();
                hv_Measures.Dispose();
                hv_M.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClasses.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_IoUThresholds.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_KeyExists.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_RecThreshs.Dispose();
                hv_MDIdx.Dispose();
                hv_MaxNum.Dispose();
                hv_MaxNumStr.Dispose();
                hv_CurrentRunningMeasures.Dispose();
                hv_PerMaxNumEvaluationResult.Dispose();
                hv_AreaIdx.Dispose();
                hv_MinArea.Dispose();
                hv_MaxArea.Dispose();
                hv_AreaName.Dispose();
                hv_AreaRunningMeasures.Dispose();
                hv_PerClassNumGt.Dispose();
                hv_PerClassNumPred.Dispose();
                hv_PerClassConfidence.Dispose();
                hv_PerClassNumGtIgnore.Dispose();
                hv_CurrentEvaluationResult.Dispose();
                hv_ITIdx.Dispose();
                hv_PerIoUAP.Dispose();
                hv_PerIoUSoAP.Dispose();
                hv_PerIoUDetailedEvaluation.Dispose();
                hv_ClsIdx.Dispose();
                hv_PerClassDetailedEvaluation.Dispose();
                hv_DetectionConfusionMatrix.Dispose();
                hv_PerIoUMeasure.Dispose();
                hv_NumImgIDsWithFN.Dispose();
                hv_NumImgIDsWithFP.Dispose();
                hv_ImgIDsWithFN.Dispose();
                hv_ImgIDsWithFP.Dispose();
                hv_ClassMAPDict.Dispose();
                hv_ClassMSoAPDict.Dispose();
                hv_ClassesWithGt.Dispose();
                hv_PerClassMAP.Dispose();
                hv_PerIoUMAP.Dispose();
                hv_PerClassMSoAP.Dispose();
                hv_PerIoUMSoAP.Dispose();
                hv_PerIoUNumClassesWithTP.Dispose();
                hv_PerIoUTP.Dispose();
                hv_PerIoUFN.Dispose();
                hv_PerIoUFP.Dispose();
                hv_PerIoUFPClass.Dispose();
                hv_PerIoUFPBackground.Dispose();
                hv_PerIoUFPLocalization.Dispose();
                hv_PerIoUFPDuplicate.Dispose();
                hv_PerIoUFPMultiple.Dispose();
                hv_PerIoUSoAPClass.Dispose();
                hv_PerIoUSoAPLocalization.Dispose();
                hv_PerIoUSoAPDuplicate.Dispose();
                hv_PerIoUSoAPMultiple.Dispose();
                hv_PerIoUNumClassesWithFPClass.Dispose();
                hv_PerIoUNumClassesWithFPLocalization.Dispose();
                hv_PerIoUNumClassesWithFPDuplicate.Dispose();
                hv_PerIoUNumClassesWithFPMultiple.Dispose();
                hv_ClassAPPerIoU.Dispose();
                hv_ClassSoAPPerIoU.Dispose();
                hv_NumGt.Dispose();
                hv_NumGtIgnore.Dispose();
                hv_NumPred.Dispose();
                hv_Confidences.Dispose();
                hv_SortIdxs.Dispose();
                hv_CurrentClassMeasures.Dispose();
                hv_IsTP.Dispose();
                hv_Ignore.Dispose();
                hv_NoIgnoreIdxs.Dispose();
                hv_IsFP.Dispose();
                hv_AccumulatedIsTP.Dispose();
                hv_AccumulatedIsFP.Dispose();
                hv_Recall.Dispose();
                hv_Precision.Dispose();
                hv_InterpolatedPrecision.Dispose();
                hv_PIdx.Dispose();
                hv_PrecisionAtRecThreshs.Dispose();
                hv_RTIdx.Dispose();
                hv_RecQuantile.Dispose();
                hv_AOD.Dispose();
                hv_IdxsTP.Dispose();
                hv_IsFPClass.Dispose();
                hv_IsFPBackground.Dispose();
                hv_IsFPLocalization.Dispose();
                hv_IsFPDuplicate.Dispose();
                hv_IsFPMultiple.Dispose();
                hv_NumTP.Dispose();
                hv_NumFP.Dispose();
                hv_NumFN.Dispose();
                hv_NumFPClass.Dispose();
                hv_NumFPBackground.Dispose();
                hv_NumFPLocalization.Dispose();
                hv_NumFPDuplicate.Dispose();
                hv_NumFPMultiple.Dispose();
                hv_IndicesWithClassConfusion.Dispose();
                hv_IsFPClassIdxs.Dispose();
                hv_ClassIdxsConfused.Dispose();
                hv_Idx.Dispose();
                hv_NumConfusedThisIdx.Dispose();
                hv_AODClass.Dispose();
                hv_IdxsClass.Dispose();
                hv_ResSoAPClass.Dispose();
                hv_AODLocalization.Dispose();
                hv_IdxsLocalization.Dispose();
                hv_ResSoAPLocalization.Dispose();
                hv_AODDuplicate.Dispose();
                hv_IdxsDuplicate.Dispose();
                hv_ResSoAPDuplicate.Dispose();
                hv_AODMultiple.Dispose();
                hv_IdxsMultiple.Dispose();
                hv_ResSoAPMultiple.Dispose();
                hv_MeanClassAP.Dispose();
                hv_MeanClassSoAP.Dispose();
                hv_MAP.Dispose();
                hv_MSoAP.Dispose();
                hv_IoUsWithTP.Dispose();
                hv_MSoAPAll.Dispose();
                hv_NumSoAPAll.Dispose();
                hv_IoUsWithFPClass.Dispose();
                hv_IoUsWithFPLocalization.Dispose();
                hv_IoUsWithFPDuplicate.Dispose();
                hv_IoUsWithFPMultiple.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Calculate pixel measures based on RunningMeasures. 
        public void calculate_pixel_measures(HTuple hv_RunningMeasures, HTuple hv_EvalParams,
            out HTuple hv_EvaluationResult)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_CalcClassPixelAccuracy = new HTuple();
            HTuple hv_CalcPixelAccuracy = new HTuple(), hv_CalcPixelConfusionMatrix = new HTuple();
            HTuple hv_CalcMeanAccuracy = new HTuple(), hv_CalcMeanIou = new HTuple();
            HTuple hv_CalcClassIou = new HTuple(), hv_CalcFWIou = new HTuple();
            HTuple hv_Measures = new HTuple(), hv_M = new HTuple();
            HTuple hv_ConfMatrix = new HTuple(), hv_TPMat = new HTuple();
            HTuple hv_TP = new HTuple(), hv_SumRowMat = new HTuple();
            HTuple hv_RowSum = new HTuple(), hv_FP = new HTuple();
            HTuple hv_SumColMat = new HTuple(), hv_ColSum = new HTuple();
            HTuple hv_FN = new HTuple(), hv_IgnoreClassIDs = new HTuple();
            HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
            HTuple hv_FPIgnore = new HTuple(), hv_GT = new HTuple();
            HTuple hv_ClsIdxValid = new HTuple(), hv_ClassPixelAccuracy = new HTuple();
            HTuple hv_MeanAccuracy = new HTuple(), hv_PixelAccuracy = new HTuple();
            HTuple hv_ClassIoU = new HTuple(), hv_MeanIoU = new HTuple();
            HTuple hv_FWIoU = new HTuple(), hv_FwWeights = new HTuple();
            // Initialize local and output iconic variables 
            hv_EvaluationResult = new HTuple();
            try
            {
                //
                //This procedure calculates the pixel-wise measures based on the values in running measures.
                //
                //Set default values.
                hv_CalcClassPixelAccuracy.Dispose();
                hv_CalcClassPixelAccuracy = 0;
                hv_CalcPixelAccuracy.Dispose();
                hv_CalcPixelAccuracy = 0;
                hv_CalcPixelConfusionMatrix.Dispose();
                hv_CalcPixelConfusionMatrix = 0;
                hv_CalcMeanAccuracy.Dispose();
                hv_CalcMeanAccuracy = 0;
                hv_CalcMeanIou.Dispose();
                hv_CalcMeanIou = 0;
                hv_CalcClassIou.Dispose();
                hv_CalcClassIou = 0;
                hv_CalcFWIou.Dispose();
                hv_CalcFWIou = 0;
                //Check which measures are to be calculated.
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                hv_EvaluationResult.Dispose();
                HOperatorSet.CreateDict(out hv_EvaluationResult);
                for (hv_M = 0; (int)hv_M <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_M = (int)hv_M + 1)
                {
                    if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual("pixel_accuracy"))) != 0)
                    {
                        hv_CalcPixelAccuracy.Dispose();
                        hv_CalcPixelAccuracy = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "class_pixel_accuracy"))) != 0)
                    {
                        hv_CalcClassPixelAccuracy.Dispose();
                        hv_CalcClassPixelAccuracy = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "pixel_confusion_matrix"))) != 0)
                    {
                        hv_CalcPixelConfusionMatrix.Dispose();
                        hv_CalcPixelConfusionMatrix = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "mean_accuracy"))) != 0)
                    {
                        hv_CalcMeanAccuracy.Dispose();
                        hv_CalcMeanAccuracy = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "mean_iou"))) != 0)
                    {
                        hv_CalcMeanIou.Dispose();
                        hv_CalcMeanIou = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "class_iou"))) != 0)
                    {
                        hv_CalcClassIou.Dispose();
                        hv_CalcClassIou = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "frequency_weighted_iou"))) != 0)
                    {
                        hv_CalcFWIou.Dispose();
                        hv_CalcFWIou = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "all"))) != 0)
                    {
                        hv_CalcPixelAccuracy.Dispose();
                        hv_CalcPixelAccuracy = 1;
                        hv_CalcClassPixelAccuracy.Dispose();
                        hv_CalcClassPixelAccuracy = 1;
                        hv_CalcPixelConfusionMatrix.Dispose();
                        hv_CalcPixelConfusionMatrix = 1;
                        hv_CalcMeanAccuracy.Dispose();
                        hv_CalcMeanAccuracy = 1;
                        hv_CalcMeanIou.Dispose();
                        hv_CalcMeanIou = 1;
                        hv_CalcClassIou.Dispose();
                        hv_CalcClassIou = 1;
                        hv_CalcFWIou.Dispose();
                        hv_CalcFWIou = 1;
                    }
                    else
                    {
                        throw new HalconException("Unknown Segmentation Measure: " + (hv_Measures.TupleSelect(
                            hv_M)));
                    }
                }
                //
                //Depending on the running measure values (ConfusionMatrix or TP/FP/FN),
                //we first calculate TP/FP/FN from the ConfusionMatrix.
                if ((int)(hv_CalcPixelConfusionMatrix) != 0)
                {
                    //Get the running measures.
                    hv_ConfMatrix.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "pixel_confusion_matrix", out hv_ConfMatrix);
                    //Get the per-class true positives as the diagonal of the matrix.
                    hv_TPMat.Dispose();
                    HOperatorSet.GetDiagonalMatrix(hv_ConfMatrix, 0, out hv_TPMat);
                    hv_TP.Dispose();
                    HOperatorSet.GetFullMatrix(hv_TPMat, out hv_TP);
                    //For the confusion matrix, the row determines the predicted class-IDs,
                    //the column determines the ground truth class-IDs.
                    //Get the per-class false positives (FP) as the sum over the rows minus the diagonal (TP).
                    hv_SumRowMat.Dispose();
                    HOperatorSet.SumMatrix(hv_ConfMatrix, "rows", out hv_SumRowMat);
                    hv_RowSum.Dispose();
                    HOperatorSet.GetFullMatrix(hv_SumRowMat, out hv_RowSum);
                    hv_FP.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_FP = hv_RowSum - hv_TP;
                    }
                    //Get the per-class false negatives (FN) as the sum over the columns minus the diagonal (TP).
                    hv_SumColMat.Dispose();
                    HOperatorSet.SumMatrix(hv_ConfMatrix, "columns", out hv_SumColMat);
                    hv_ColSum.Dispose();
                    HOperatorSet.GetFullMatrix(hv_SumColMat, out hv_ColSum);
                    hv_FN.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_FN = hv_ColSum - hv_TP;
                    }
                    //We do not want to count the false positives (FP) in the ignore region.
                    //The false negatives (FN) are not affected, since the model does not predict the ignore class.
                    hv_IgnoreClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "ignore_class_ids", out hv_IgnoreClassIDs);
                    if ((int)(new HTuple((new HTuple(hv_IgnoreClassIDs.TupleLength())).TupleGreater(
                        0))) != 0)
                    {
                        //The ignore class corresponds to the last row/column in the confusion matrix.
                        hv_Rows.Dispose(); hv_Columns.Dispose();
                        HOperatorSet.GetSizeMatrix(hv_ConfMatrix, out hv_Rows, out hv_Columns);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FPIgnore.Dispose();
                            HOperatorSet.GetValueMatrix(hv_ConfMatrix, HTuple.TupleGenSequence(0, hv_Rows - 1, 1),
                                HTuple.TupleGenConst(hv_Rows, hv_Columns - 1), out hv_FPIgnore);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_FP = hv_FP - hv_FPIgnore;
                                hv_FP.Dispose();
                                hv_FP = ExpTmpLocalVar_FP;
                            }
                        }
                        //Remove last entries of TP, FP, FN (those related to the ignore class).
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_TP = hv_TP.TupleSelectRange(
                                    0, (new HTuple(hv_TP.TupleLength())) - 2);
                                hv_TP.Dispose();
                                hv_TP = ExpTmpLocalVar_TP;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_FP = hv_FP.TupleSelectRange(
                                    0, (new HTuple(hv_FP.TupleLength())) - 2);
                                hv_FP.Dispose();
                                hv_FP = ExpTmpLocalVar_FP;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_FN = hv_FN.TupleSelectRange(
                                    0, (new HTuple(hv_FN.TupleLength())) - 2);
                                hv_FN.Dispose();
                                hv_FN = ExpTmpLocalVar_FN;
                            }
                        }
                        //Remove last row/column from confusion matrix.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HTuple ExpTmpOutVar_0;
                            HOperatorSet.GetSubMatrix(hv_ConfMatrix, 0, 0, hv_Rows - 1, hv_Columns - 1,
                                out ExpTmpOutVar_0);
                            hv_ConfMatrix.Dispose();
                            hv_ConfMatrix = ExpTmpOutVar_0;
                        }
                    }
                    //Paste the confusion matrix to the output.
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "pixel_confusion_matrix",
                        hv_ConfMatrix);
                }
                else
                {
                    //Get the running measure values.
                    hv_TP.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "tp", out hv_TP);
                    hv_FP.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "fp", out hv_FP);
                    hv_FN.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "fn", out hv_FN);
                }
                //
                //It might be the case, that some of the classes are not present in the set of validation images.
                //--> Exclude these classes (they are indirectly present as they reduce the number of TP for other classes).
                hv_GT.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_GT = hv_TP + hv_FN;
                }
                hv_ClsIdxValid.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ClsIdxValid = ((hv_GT.TupleGreaterElem(
                        0))).TupleFind(1);
                }
                //
                //Mean Accuracy, Class Pixel Accuracy.
                //-> If one of 'mean_accuracy', 'class_pixel_accuracy' is specified, we give back both of them
                //   as they have to be calculated anyway (to the most part).
                if ((int)(hv_CalcClassPixelAccuracy.TupleOr(hv_CalcMeanAccuracy)) != 0)
                {
                    //Compute pixel accuracy per class (although we might only use it for the overall pixel accuracy).
                    hv_ClassPixelAccuracy.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassPixelAccuracy = HTuple.TupleGenConst(
                            new HTuple(hv_GT.TupleLength()), -1);
                    }
                    hv_MeanAccuracy.Dispose();
                    hv_MeanAccuracy = -1;
                    if ((int)(new HTuple(((hv_ClsIdxValid.TupleSelect(0))).TupleGreater(-1))) != 0)
                    {
                        if (hv_ClassPixelAccuracy == null)
                            hv_ClassPixelAccuracy = new HTuple();
                        hv_ClassPixelAccuracy[hv_ClsIdxValid] = (((hv_TP.TupleSelect(hv_ClsIdxValid))).TupleReal()
                            ) / (hv_GT.TupleSelect(hv_ClsIdxValid));
                        hv_MeanAccuracy.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MeanAccuracy = ((hv_ClassPixelAccuracy.TupleSelect(
                                hv_ClsIdxValid))).TupleMean();
                        }
                    }
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "class_pixel_accuracy", hv_ClassPixelAccuracy);
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "mean_accuracy", hv_MeanAccuracy);
                }
                //Pixel Accuracy
                if ((int)(hv_CalcPixelAccuracy) != 0)
                {
                    //Compute pixel accuracy as the total ratio of pixels that have been correctly predicted.
                    hv_PixelAccuracy.Dispose();
                    hv_PixelAccuracy = -1;
                    if ((int)(new HTuple(((hv_ClsIdxValid.TupleSelect(0))).TupleGreater(-1))) != 0)
                    {
                        hv_PixelAccuracy.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_PixelAccuracy = (((((hv_TP.TupleSelect(
                                hv_ClsIdxValid))).TupleSum())).TupleReal()) / (((hv_GT.TupleSelect(hv_ClsIdxValid))).TupleSum()
                                );
                        }
                    }
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "pixel_accuracy", hv_PixelAccuracy);
                }
                //Mean IoU, class IoU, frequency weighted IoU:
                //-> If the measures 'class_iou', 'mean_iou' or 'frequency_weighted_iou' is specified,
                //   we return all three of them as they have to be calculated anyway (to the most part).
                if ((int)((new HTuple(hv_CalcMeanIou.TupleOr(hv_CalcClassIou))).TupleOr(hv_CalcFWIou)) != 0)
                {
                    hv_ClassIoU.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassIoU = HTuple.TupleGenConst(
                            new HTuple(hv_GT.TupleLength()), -1);
                    }
                    hv_MeanIoU.Dispose();
                    hv_MeanIoU = -1;
                    hv_FWIoU.Dispose();
                    hv_FWIoU = -1;
                    if ((int)(new HTuple(((hv_ClsIdxValid.TupleSelect(0))).TupleGreater(-1))) != 0)
                    {
                        if (hv_ClassIoU == null)
                            hv_ClassIoU = new HTuple();
                        hv_ClassIoU[hv_ClsIdxValid] = (((hv_TP.TupleSelect(hv_ClsIdxValid))).TupleReal()
                            ) / ((hv_GT.TupleSelect(hv_ClsIdxValid)) + (hv_FP.TupleSelect(hv_ClsIdxValid)));
                        hv_MeanIoU.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MeanIoU = ((hv_ClassIoU.TupleSelect(
                                hv_ClsIdxValid))).TupleMean();
                        }
                        hv_FwWeights.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FwWeights = (hv_GT.TupleReal()
                                ) / (hv_GT.TupleSum());
                        }
                        hv_FWIoU.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FWIoU = (((hv_FwWeights.TupleSelect(
                                hv_ClsIdxValid)) * (hv_ClassIoU.TupleSelect(hv_ClsIdxValid)))).TupleSum()
                                ;
                        }
                    }
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "class_iou", hv_ClassIoU);
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "mean_iou", hv_MeanIoU);
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "frequency_weighted_iou",
                        hv_FWIoU);
                }
                //

                hv_CalcClassPixelAccuracy.Dispose();
                hv_CalcPixelAccuracy.Dispose();
                hv_CalcPixelConfusionMatrix.Dispose();
                hv_CalcMeanAccuracy.Dispose();
                hv_CalcMeanIou.Dispose();
                hv_CalcClassIou.Dispose();
                hv_CalcFWIou.Dispose();
                hv_Measures.Dispose();
                hv_M.Dispose();
                hv_ConfMatrix.Dispose();
                hv_TPMat.Dispose();
                hv_TP.Dispose();
                hv_SumRowMat.Dispose();
                hv_RowSum.Dispose();
                hv_FP.Dispose();
                hv_SumColMat.Dispose();
                hv_ColSum.Dispose();
                hv_FN.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_FPIgnore.Dispose();
                hv_GT.Dispose();
                hv_ClsIdxValid.Dispose();
                hv_ClassPixelAccuracy.Dispose();
                hv_MeanAccuracy.Dispose();
                hv_PixelAccuracy.Dispose();
                hv_ClassIoU.Dispose();
                hv_MeanIoU.Dispose();
                hv_FWIoU.Dispose();
                hv_FwWeights.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_CalcClassPixelAccuracy.Dispose();
                hv_CalcPixelAccuracy.Dispose();
                hv_CalcPixelConfusionMatrix.Dispose();
                hv_CalcMeanAccuracy.Dispose();
                hv_CalcMeanIou.Dispose();
                hv_CalcClassIou.Dispose();
                hv_CalcFWIou.Dispose();
                hv_Measures.Dispose();
                hv_M.Dispose();
                hv_ConfMatrix.Dispose();
                hv_TPMat.Dispose();
                hv_TP.Dispose();
                hv_SumRowMat.Dispose();
                hv_RowSum.Dispose();
                hv_FP.Dispose();
                hv_SumColMat.Dispose();
                hv_ColSum.Dispose();
                hv_FN.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_FPIgnore.Dispose();
                hv_GT.Dispose();
                hv_ClsIdxValid.Dispose();
                hv_ClassPixelAccuracy.Dispose();
                hv_MeanAccuracy.Dispose();
                hv_PixelAccuracy.Dispose();
                hv_ClassIoU.Dispose();
                hv_MeanIoU.Dispose();
                hv_FWIoU.Dispose();
                hv_FwWeights.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Parameters
        public void color_string_to_rgb(HTuple hv_Color, out HTuple hv_RGB)
        {



            // Local iconic variables 

            HObject ho_Rectangle, ho_Image;

            // Local control variables 

            HTuple hv_WindowHandleBuffer = new HTuple();
            HTuple hv_Exception = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Rectangle);
            HOperatorSet.GenEmptyObj(out ho_Image);
            hv_RGB = new HTuple();
            try
            {
                hv_WindowHandleBuffer.Dispose();
                HOperatorSet.OpenWindow(0, 0, 1, 1, 0, "buffer", "", out hv_WindowHandleBuffer);
                HOperatorSet.SetPart(hv_WindowHandleBuffer, 0, 0, -1, -1);
                ho_Rectangle.Dispose();
                HOperatorSet.GenRectangle1(out ho_Rectangle, 0, 0, 0, 0);
                try
                {
                    HOperatorSet.SetColor(hv_WindowHandleBuffer, hv_Color);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    hv_Exception.Dispose();
                    hv_Exception = "Wrong value of control parameter Color (must be a valid color string)";
                    throw new HalconException(hv_Exception);
                }
                HOperatorSet.DispObj(ho_Rectangle, hv_WindowHandleBuffer);
                ho_Image.Dispose();
                HOperatorSet.DumpWindowImage(out ho_Image, hv_WindowHandleBuffer);
                HOperatorSet.CloseWindow(hv_WindowHandleBuffer);
                hv_RGB.Dispose();
                HOperatorSet.GetGrayval(ho_Image, 0, 0, out hv_RGB);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_RGB = hv_RGB + (
                            (new HTuple(0)).TupleConcat(0)).TupleConcat(0);
                        hv_RGB.Dispose();
                        hv_RGB = ExpTmpLocalVar_RGB;
                    }
                }
                ho_Rectangle.Dispose();
                ho_Image.Dispose();

                hv_WindowHandleBuffer.Dispose();
                hv_Exception.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Rectangle.Dispose();
                ho_Image.Dispose();

                hv_WindowHandleBuffer.Dispose();
                hv_Exception.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Classification
        // Short Description: Calculate top-K error. 
        public void compute_top_k_error(HTuple hv_ImageLabelIDs, HTuple hv_TopKPredictions,
            HTuple hv_K, out HTuple hv_TopKError)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_NumMatches = new HTuple(), hv_Index = new HTuple();
            HTuple hv_Predictions = new HTuple(), hv_PredictedClasses = new HTuple();
            // Initialize local and output iconic variables 
            hv_TopKError = new HTuple();
            try
            {
                //
                //This procedure calculates the top-K error out of the given predictions and labels.
                //
                hv_NumMatches.Dispose();
                hv_NumMatches = 0;
                //
                //Loop through all selected ground truth labels.
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_ImageLabelIDs.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    //Get the K best results.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Predictions.Dispose();
                        HOperatorSet.GetDictTuple(hv_TopKPredictions.TupleSelect(hv_Index), "predictions",
                            out hv_Predictions);
                    }
                    hv_PredictedClasses.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_PredictedClasses = hv_Predictions.TupleSelectRange(
                            0, hv_K - 1);
                    }
                    //Count how often the ground truth label
                    //and K predicted classes match.
                    if ((int)(new HTuple(((hv_PredictedClasses.TupleFind(hv_ImageLabelIDs.TupleSelect(
                        hv_Index)))).TupleNotEqual(-1))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_NumMatches = hv_NumMatches + 1;
                                hv_NumMatches.Dispose();
                                hv_NumMatches = ExpTmpLocalVar_NumMatches;
                            }
                        }
                    }
                }
                hv_TopKError.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TopKError = 1.0 - ((hv_NumMatches.TupleReal()
                        ) / (new HTuple(hv_ImageLabelIDs.TupleLength())));
                }
                //

                hv_NumMatches.Dispose();
                hv_Index.Dispose();
                hv_Predictions.Dispose();
                hv_PredictedClasses.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_NumMatches.Dispose();
                hv_Index.Dispose();
                hv_Predictions.Dispose();
                hv_PredictedClasses.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Generate a dictionary EvalParams, which contains default values for evaluation parameters. 
        public void create_evaluation_default_param(HTuple hv_EvaluationType, HTuple hv_ClassIDsModel,
            out HTuple hv_EvalParams)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_AvailableEvaluationTypes = new HTuple();
            HTuple hv_EvaluationTypesStr = new HTuple(), hv_Indices = new HTuple();
            HTuple hv_EvaluateInstances = new HTuple(), hv_Measures = new HTuple();
            HTuple hv_AnomalyScoreHistogram = new HTuple(), hv_AreaRanges = new HTuple();
            HTuple hv_AllocationBlockLength = new HTuple();
            // Initialize local and output iconic variables 
            hv_EvalParams = new HTuple();
            try
            {
                //
                //This procedure generates a dictionary EvalParams,
                //which contains default values for evaluation parameters.
                //Depending on the evaluation type, the corresponding default parameters and values are set.
                //The class IDs that the model can predict must be given via ClassIDsModel.
                //
                //Check inputs.
                hv_AvailableEvaluationTypes.Dispose();
                hv_AvailableEvaluationTypes = new HTuple();
                hv_AvailableEvaluationTypes[0] = "anomaly_detection";
                hv_AvailableEvaluationTypes[1] = "classification";
                hv_AvailableEvaluationTypes[2] = "detection";
                hv_AvailableEvaluationTypes[3] = "segmentation";
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_EvaluationTypesStr.Dispose();
                    HOperatorSet.TupleGenConst((2 * (new HTuple(hv_AvailableEvaluationTypes.TupleLength()
                        ))) - 1, new HTuple("','"), out hv_EvaluationTypesStr);
                }
                if (hv_EvaluationTypesStr == null)
                    hv_EvaluationTypesStr = new HTuple();
                hv_EvaluationTypesStr[HTuple.TupleGenSequence(0, new HTuple(hv_EvaluationTypesStr.TupleLength()
                    ), 2)] = hv_AvailableEvaluationTypes;
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_EvaluationTypesStr = hv_EvaluationTypesStr.TupleSum()
                            ;
                        hv_EvaluationTypesStr.Dispose();
                        hv_EvaluationTypesStr = ExpTmpLocalVar_EvaluationTypesStr;
                    }
                }
                hv_Indices.Dispose();
                HOperatorSet.TupleFind(hv_AvailableEvaluationTypes, hv_EvaluationType, out hv_Indices);
                if ((int)((new HTuple(hv_Indices.TupleEqual(-1))).TupleOr(new HTuple(hv_Indices.TupleEqual(
                    new HTuple())))) != 0)
                {
                    throw new HalconException(((("Unknown evaluation_type: " + hv_EvaluationType) + ". Choose one of ['") + hv_EvaluationTypesStr) + "']");
                }
                if ((int)(new HTuple((new HTuple(hv_ClassIDsModel.TupleLength())).TupleLess(
                    1))) != 0)
                {
                    throw new HalconException("ClassIDsModel should have at least one entry");
                }
                //
                //Initialize EvalParams.
                hv_EvalParams.Dispose();
                HOperatorSet.CreateDict(out hv_EvalParams);
                HOperatorSet.SetDictTuple(hv_EvalParams, "evaluation_type", hv_EvaluationType);
                //
                //Set the class IDs.
                HOperatorSet.SetDictTuple(hv_EvalParams, "class_ids", hv_ClassIDsModel);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_EvalParams, "num_classes", new HTuple(hv_ClassIDsModel.TupleLength()
                        ));
                }
                //
                //Set specific parameters depending on the evaluation type.
                hv_EvaluateInstances.Dispose();
                hv_EvaluateInstances = 0;
                if ((int)(new HTuple(hv_EvaluationType.TupleEqual("anomaly_detection"))) != 0)
                {
                    //
                    //Set default image level measures.
                    hv_Measures.Dispose();
                    hv_Measures = "anomaly_score_histogram";
                    //
                    //Create dictionary for anomaly score histogram and set default
                    //values. -1 means that the parameter is estimated during evaluation.
                    hv_AnomalyScoreHistogram.Dispose();
                    HOperatorSet.CreateDict(out hv_AnomalyScoreHistogram);
                    HOperatorSet.SetDictTuple(hv_AnomalyScoreHistogram, "min", 0.0);
                    HOperatorSet.SetDictTuple(hv_AnomalyScoreHistogram, "max", 1.0);
                    HOperatorSet.SetDictTuple(hv_AnomalyScoreHistogram, "num_bins", -1);
                    //
                    HOperatorSet.SetDictTuple(hv_EvalParams, "anomaly_score_histogram", hv_AnomalyScoreHistogram);
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("classification"))) != 0)
                {
                    //
                    //Set default classification measures.
                    hv_Measures.Dispose();
                    hv_Measures = "top1_error";
                    //
                    //Per default all classes are used for evaluation.
                    HOperatorSet.SetDictTuple(hv_EvalParams, "class_ids_to_evaluate", "global");
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("detection"))) != 0)
                {
                    //
                    //Set default detection measures.
                    hv_Measures.Dispose();
                    hv_Measures = "mean_ap";
                    //
                    //Set detection-specific default values.
                    hv_EvaluateInstances.Dispose();
                    hv_EvaluateInstances = 1;
                    HOperatorSet.SetDictTuple(hv_EvalParams, "instance_type", "rectangle1");
                    //Generate ten IoU-thresholds from 0.5 to 0.95 in steps of 0.05.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_EvalParams, "iou_threshold", HTuple.TupleGenSequence(
                            0.5, 0.96, 0.05));
                    }
                    //Set maximal number of detections to -1, i.e. all results per image will be evaluated.
                    HOperatorSet.SetDictTuple(hv_EvalParams, "max_num_detections", -1);
                    //Set default area range named 'all', thus areas from 0 to a value larger than all likely occurring values.
                    hv_AreaRanges.Dispose();
                    HOperatorSet.CreateDict(out hv_AreaRanges);
                    HOperatorSet.SetDictTuple(hv_AreaRanges, "name", "all");
                    HOperatorSet.SetDictTuple(hv_AreaRanges, "min", 0);
                    HOperatorSet.SetDictTuple(hv_AreaRanges, "max", 2e8);
                    HOperatorSet.SetDictTuple(hv_EvalParams, "area_ranges", hv_AreaRanges);
                    //Some tuples are changing their length during the evaluation. As this slows down the
                    //evaluation process they are allocated in blocks of AllocationBlockLength.
                    hv_AllocationBlockLength.Dispose();
                    hv_AllocationBlockLength = 200;
                    HOperatorSet.SetDictTuple(hv_EvalParams, "allocation_block_length", hv_AllocationBlockLength);
                    //Detailed evaluation is not switched on per default, as it slows down the evaluation-process.
                    HOperatorSet.SetDictTuple(hv_EvalParams, "detailed_evaluation", 0);
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("segmentation"))) != 0)
                {
                    //
                    //Set default pixel measures.
                    hv_Measures.Dispose();
                    hv_Measures = new HTuple();
                    hv_Measures[0] = "pixel_accuracy";
                    hv_Measures[1] = "mean_accuracy";
                    hv_Measures[2] = "mean_iou";
                    //
                    //Per default there are no ignored classes.
                    HOperatorSet.SetDictTuple(hv_EvalParams, "ignore_class_ids", new HTuple());
                }
                //
                HOperatorSet.SetDictTuple(hv_EvalParams, "evaluate_instances", hv_EvaluateInstances);
                HOperatorSet.SetDictTuple(hv_EvalParams, "measures", hv_Measures);
                //

                hv_AvailableEvaluationTypes.Dispose();
                hv_EvaluationTypesStr.Dispose();
                hv_Indices.Dispose();
                hv_EvaluateInstances.Dispose();
                hv_Measures.Dispose();
                hv_AnomalyScoreHistogram.Dispose();
                hv_AreaRanges.Dispose();
                hv_AllocationBlockLength.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_AvailableEvaluationTypes.Dispose();
                hv_EvaluationTypesStr.Dispose();
                hv_Indices.Dispose();
                hv_EvaluateInstances.Dispose();
                hv_Measures.Dispose();
                hv_AnomalyScoreHistogram.Dispose();
                hv_AreaRanges.Dispose();
                hv_AllocationBlockLength.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Window
        // Short Description: Close all window handles contained in a dictionary. 
        public void dev_close_window_dict(HTuple hv_WindowHandleDict)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_WindowHandleKeys = new HTuple();
            HTuple hv_Index = new HTuple(), hv_WindowHandles = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_RemovedWindowIndices = new HTuple();
            HTuple hv_WindowHandleIndex = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure closes all window handles
                //that are contained in the dictionary WindowHandleDict.
                //
                hv_WindowHandleKeys.Dispose();
                HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_WindowHandleKeys);
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_WindowHandleKeys.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    try
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_WindowHandles.Dispose();
                            HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKeys.TupleSelect(
                                hv_Index), out hv_WindowHandles);
                        }
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException1)
                    {
                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        continue;
                    }
                    hv_RemovedWindowIndices.Dispose();
                    hv_RemovedWindowIndices = new HTuple();
                    for (hv_WindowHandleIndex = 0; (int)hv_WindowHandleIndex <= (int)((new HTuple(hv_WindowHandles.TupleLength()
                        )) - 1); hv_WindowHandleIndex = (int)hv_WindowHandleIndex + 1)
                    {
                        //Not every entry has to be a window handle, therefore use try-catch.
                        try
                        {
                            //Call set_window_param to check if the handle is a window handle.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowHandleIndex),
                                    "flush", "false");
                            }
                            HDevWindowStack.SetActive(hv_WindowHandles.TupleSelect(
                                hv_WindowHandleIndex));
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_RemovedWindowIndices = hv_RemovedWindowIndices.TupleConcat(
                                        hv_WindowHandleIndex);
                                    hv_RemovedWindowIndices.Dispose();
                                    hv_RemovedWindowIndices = ExpTmpLocalVar_RemovedWindowIndices;
                                }
                            }
                        }
                        // catch (Exception) 
                        catch (HalconException HDevExpDefaultException1)
                        {
                            HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        }
                    }
                    {
                        HTuple ExpTmpOutVar_0;
                        HOperatorSet.TupleRemove(hv_WindowHandles, hv_RemovedWindowIndices, out ExpTmpOutVar_0);
                        hv_WindowHandles.Dispose();
                        hv_WindowHandles = ExpTmpOutVar_0;
                    }
                    //If some entries remained, set reduced tuple. Otherwise, remove whole key entry.
                    if ((int)(new HTuple((new HTuple(hv_WindowHandles.TupleLength())).TupleGreater(
                        0))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_WindowHandleDict, hv_WindowHandleKeys.TupleSelect(
                                hv_Index), hv_WindowHandles);
                        }
                    }
                    else
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.RemoveDictKey(hv_WindowHandleDict, hv_WindowHandleKeys.TupleSelect(
                                hv_Index));
                        }
                    }
                }
                //

                hv_WindowHandleKeys.Dispose();
                hv_Index.Dispose();
                hv_WindowHandles.Dispose();
                hv_Exception.Dispose();
                hv_RemovedWindowIndices.Dispose();
                hv_WindowHandleIndex.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_WindowHandleKeys.Dispose();
                hv_Index.Dispose();
                hv_WindowHandles.Dispose();
                hv_Exception.Dispose();
                hv_RemovedWindowIndices.Dispose();
                hv_WindowHandleIndex.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: Display an interactive button. 
        public void dev_disp_button(HTuple hv_String, HTuple hv_Row, HTuple hv_Column,
            HTuple hv_Width, HTuple hv_Height, HTuple hv_ColorString, HTuple hv_ColorBackground,
            HTuple hv_ColorBackgroundActive, HTuple hv_WindowHandle, out HTuple hv_SelectedButton)
        {



            // Local iconic variables 

            HObject ho_ButtonRect, ho_ObjectSelected = null;

            // Local control variables 

            HTuple hv_ClipRegion = new HTuple(), hv_Flush = new HTuple();
            HTuple hv__ = new HTuple(), hv_WindowWidth = new HTuple();
            HTuple hv_WindowHeight = new HTuple(), hv_PartHeight = new HTuple();
            HTuple hv_PartWidth = new HTuple(), hv_WindowImageWidthRatio = new HTuple();
            HTuple hv_WindowImageHeightRatio = new HTuple(), hv_ButtonRowScaled = new HTuple();
            HTuple hv_ButtonColumnScaled = new HTuple(), hv_ButtonHeightScaled = new HTuple();
            HTuple hv_ButtonWidthScaled = new HTuple(), hv_HighlightColors = new HTuple();
            HTuple hv_Ascents = new HTuple(), hv_Descents = new HTuple();
            HTuple hv_TextWidths = new HTuple(), hv_Index = new HTuple();
            HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
            HTuple hv_TextWidth = new HTuple(), hv_TextHeight = new HTuple();
            HTuple hv_TextRow = new HTuple(), hv_TextColumn = new HTuple();
            HTuple hv_Button = new HTuple(), hv_ButtonIndex = new HTuple();
            HTuple hv_IsInside = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_ColorBackground_COPY_INP_TMP = new HTuple(hv_ColorBackground);
            HTuple hv_Column_COPY_INP_TMP = new HTuple(hv_Column);
            HTuple hv_Row_COPY_INP_TMP = new HTuple(hv_Row);

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ButtonRect);
            HOperatorSet.GenEmptyObj(out ho_ObjectSelected);
            hv_SelectedButton = new HTuple();
            try
            {
                //
                //This procedure displays one or more interactive buttons.
                //It is possible to customize the size, position, and color of the buttons.
                //The index of the clicked button is returned.
                //
                hv_ClipRegion.Dispose();
                HOperatorSet.GetSystem("clip_region", out hv_ClipRegion);
                HOperatorSet.SetSystem("clip_region", "false");
                // dev_get_preferences(...); only in hdevelop
                // dev_set_preferences(...); only in hdevelop
                hv_Flush.Dispose();
                HOperatorSet.GetWindowParam(hv_WindowHandle, "flush", out hv_Flush);
                HOperatorSet.SetWindowParam(hv_WindowHandle, "flush", "false");
                //
                //Get the scaling factor for window/image coordinate conversion.
                hv__.Dispose(); hv__.Dispose(); hv_WindowWidth.Dispose(); hv_WindowHeight.Dispose();
                HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv__, out hv__, out hv_WindowWidth,
                    out hv_WindowHeight);
                hv__.Dispose(); hv__.Dispose(); hv_PartHeight.Dispose(); hv_PartWidth.Dispose();
                HOperatorSet.GetPart(hv_WindowHandle, out hv__, out hv__, out hv_PartHeight,
                    out hv_PartWidth);
                hv_WindowImageWidthRatio.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowImageWidthRatio = hv_WindowWidth / (1.0 * hv_PartWidth);
                }
                hv_WindowImageHeightRatio.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowImageHeightRatio = hv_WindowHeight / (1.0 * hv_PartHeight);
                }
                //
                //Scale the button coordinates.
                hv_ButtonRowScaled.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ButtonRowScaled = hv_Row_COPY_INP_TMP / hv_WindowImageHeightRatio;
                }
                hv_ButtonColumnScaled.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ButtonColumnScaled = hv_Column_COPY_INP_TMP / hv_WindowImageWidthRatio;
                }
                hv_ButtonHeightScaled.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ButtonHeightScaled = hv_Height / hv_WindowImageHeightRatio;
                }
                hv_ButtonWidthScaled.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ButtonWidthScaled = hv_Width / hv_WindowImageWidthRatio;
                }
                //
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_ButtonRect.Dispose();
                    HOperatorSet.GenRectangle1(out ho_ButtonRect, hv_ButtonRowScaled, hv_ButtonColumnScaled,
                        hv_ButtonRowScaled + hv_ButtonHeightScaled, hv_ButtonColumnScaled + hv_ButtonWidthScaled);
                }
                if ((int)(new HTuple((new HTuple(hv_ColorBackground_COPY_INP_TMP.TupleLength()
                    )).TupleEqual(1))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ColorBackground = HTuple.TupleGenConst(
                                new HTuple(hv_String.TupleLength()), hv_ColorBackground_COPY_INP_TMP);
                            hv_ColorBackground_COPY_INP_TMP.Dispose();
                            hv_ColorBackground_COPY_INP_TMP = ExpTmpLocalVar_ColorBackground;
                        }
                    }
                }
                hv_HighlightColors.Dispose();
                hv_HighlightColors = new HTuple(hv_ColorBackground_COPY_INP_TMP);
                //
                //We want to place the text centered in the button.
                hv_Ascents.Dispose();
                hv_Ascents = new HTuple();
                hv_Descents.Dispose();
                hv_Descents = new HTuple();
                hv_TextWidths.Dispose();
                hv_TextWidths = new HTuple();
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_String.TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Ascent.Dispose(); hv_Descent.Dispose(); hv_TextWidth.Dispose(); hv_TextHeight.Dispose();
                        HOperatorSet.GetStringExtents(hv_WindowHandle, hv_String.TupleSelect(hv_Index),
                            out hv_Ascent, out hv_Descent, out hv_TextWidth, out hv_TextHeight);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Ascents = hv_Ascents.TupleConcat(
                                hv_Ascent);
                            hv_Ascents.Dispose();
                            hv_Ascents = ExpTmpLocalVar_Ascents;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Descents = hv_Descents.TupleConcat(
                                hv_Descent);
                            hv_Descents.Dispose();
                            hv_Descents = ExpTmpLocalVar_Descents;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_TextWidths = hv_TextWidths.TupleConcat(
                                hv_TextWidth);
                            hv_TextWidths.Dispose();
                            hv_TextWidths = ExpTmpLocalVar_TextWidths;
                        }
                    }
                }
                //
                hv_TextRow.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TextRow = (hv_Row_COPY_INP_TMP + ((hv_Height - hv_TextHeight) / 2)) - hv_Descent;
                }
                hv_TextColumn.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TextColumn = hv_Column_COPY_INP_TMP + ((hv_Width - hv_TextWidths) / 2);
                }
                hv_SelectedButton.Dispose();
                hv_SelectedButton = 0;
                hv_Button.Dispose();
                hv_Button = 0;
                //
                while ((int)((new HTuple(hv_SelectedButton.TupleEqual(0))).TupleOr(new HTuple(hv_Button.TupleNotEqual(
                    1)))) != 0)
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_HighlightColors);
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_ButtonRect, HDevWindowStack.GetActive());
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_String, "window",
                            hv_TextRow, hv_TextColumn, hv_ColorString, "box", "false");
                    }
                    //Actual display.
                    HOperatorSet.FlushBuffer(hv_WindowHandle);
                    try
                    {
                        hv_Row_COPY_INP_TMP.Dispose(); hv_Column_COPY_INP_TMP.Dispose(); hv_Button.Dispose();
                        HOperatorSet.GetMposition(hv_WindowHandle, out hv_Row_COPY_INP_TMP, out hv_Column_COPY_INP_TMP,
                            out hv_Button);
                        hv_SelectedButton.Dispose();
                        hv_SelectedButton = 0;
                        for (hv_ButtonIndex = 1; (int)hv_ButtonIndex <= (int)(new HTuple(hv_ButtonRowScaled.TupleLength()
                            )); hv_ButtonIndex = (int)hv_ButtonIndex + 1)
                        {
                            ho_ObjectSelected.Dispose();
                            HOperatorSet.SelectObj(ho_ButtonRect, out ho_ObjectSelected, hv_ButtonIndex);
                            hv_IsInside.Dispose();
                            HOperatorSet.TestRegionPoint(ho_ObjectSelected, hv_Row_COPY_INP_TMP,
                                hv_Column_COPY_INP_TMP, out hv_IsInside);
                            if ((int)(hv_IsInside) != 0)
                            {
                                hv_SelectedButton.Dispose();
                                hv_SelectedButton = new HTuple(hv_ButtonIndex);
                                break;
                            }
                        }
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException1)
                    {
                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    }
                    if ((int)(new HTuple(hv_SelectedButton.TupleGreater(0))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_HighlightColors.Dispose();
                            HOperatorSet.TupleReplace(hv_ColorBackground_COPY_INP_TMP, hv_SelectedButton - 1,
                                hv_ColorBackgroundActive, out hv_HighlightColors);
                        }
                    }
                    else
                    {
                        hv_HighlightColors.Dispose();
                        hv_HighlightColors = new HTuple(hv_ColorBackground_COPY_INP_TMP);
                    }
                }
                //Return index.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_SelectedButton = hv_SelectedButton - 1;
                        hv_SelectedButton.Dispose();
                        hv_SelectedButton = ExpTmpLocalVar_SelectedButton;
                    }
                }
                //
                HOperatorSet.SetSystem("clip_region", hv_ClipRegion);
                // dev_set_preferences(...); only in hdevelop
                HOperatorSet.SetWindowParam(hv_WindowHandle, "flush", hv_Flush);
                //
                ho_ButtonRect.Dispose();
                ho_ObjectSelected.Dispose();

                hv_ColorBackground_COPY_INP_TMP.Dispose();
                hv_Column_COPY_INP_TMP.Dispose();
                hv_Row_COPY_INP_TMP.Dispose();
                hv_ClipRegion.Dispose();
                hv_Flush.Dispose();
                hv__.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_PartHeight.Dispose();
                hv_PartWidth.Dispose();
                hv_WindowImageWidthRatio.Dispose();
                hv_WindowImageHeightRatio.Dispose();
                hv_ButtonRowScaled.Dispose();
                hv_ButtonColumnScaled.Dispose();
                hv_ButtonHeightScaled.Dispose();
                hv_ButtonWidthScaled.Dispose();
                hv_HighlightColors.Dispose();
                hv_Ascents.Dispose();
                hv_Descents.Dispose();
                hv_TextWidths.Dispose();
                hv_Index.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_TextWidth.Dispose();
                hv_TextHeight.Dispose();
                hv_TextRow.Dispose();
                hv_TextColumn.Dispose();
                hv_Button.Dispose();
                hv_ButtonIndex.Dispose();
                hv_IsInside.Dispose();
                hv_Exception.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_ButtonRect.Dispose();
                ho_ObjectSelected.Dispose();

                hv_ColorBackground_COPY_INP_TMP.Dispose();
                hv_Column_COPY_INP_TMP.Dispose();
                hv_Row_COPY_INP_TMP.Dispose();
                hv_ClipRegion.Dispose();
                hv_Flush.Dispose();
                hv__.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_PartHeight.Dispose();
                hv_PartWidth.Dispose();
                hv_WindowImageWidthRatio.Dispose();
                hv_WindowImageHeightRatio.Dispose();
                hv_ButtonRowScaled.Dispose();
                hv_ButtonColumnScaled.Dispose();
                hv_ButtonHeightScaled.Dispose();
                hv_ButtonWidthScaled.Dispose();
                hv_HighlightColors.Dispose();
                hv_Ascents.Dispose();
                hv_Descents.Dispose();
                hv_TextWidths.Dispose();
                hv_Index.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_TextWidth.Dispose();
                hv_TextHeight.Dispose();
                hv_TextRow.Dispose();
                hv_TextColumn.Dispose();
                hv_Button.Dispose();
                hv_ButtonIndex.Dispose();
                hv_IsInside.Dispose();
                hv_Exception.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Classification
        // Short Description: Display evaluation results of an evaluated DL model of type 'classification'. 
        public void dev_display_classification_evaluation(HTuple hv_EvaluationResult,
            HTuple hv_EvalParam, HTuple hv_GenParam, HTuple hv_WindowHandleDict)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_DisplayMeasures = new HTuple(), hv_DisplayConfusionAbsolute = new HTuple();
            HTuple hv_DisplayConfusionRelative = new HTuple(), hv_DisplayPieChartPrecision = new HTuple();
            HTuple hv_DisplayPieChartRecall = new HTuple(), hv_MeasureColor = new HTuple();
            HTuple hv_RowColNameColor = new HTuple(), hv_DisplayColumnWidth = new HTuple();
            HTuple hv_DisplayColor = new HTuple(), hv_Font = new HTuple();
            HTuple hv_FontSize = new HTuple(), hv_GenParamKeys = new HTuple();
            HTuple hv_Keys = new HTuple(), hv_KeyIndex = new HTuple();
            HTuple hv_KeyExists = new HTuple(), hv_Value = new HTuple();
            HTuple hv_RGB = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_DisplayColumnWidthTmp = new HTuple(), hv_KeysExist = new HTuple();
            HTuple hv_ClassIDs = new HTuple(), hv_ClassNames = new HTuple();
            HTuple hv_MaxChars = new HTuple(), hv_Index = new HTuple();
            HTuple hv_Str = new HTuple(), hv_IsString = new HTuple();
            HTuple hv_Length = new HTuple(), hv_SubStr = new HTuple();
            HTuple hv_ClassIDsToNamesMapping = new HTuple(), hv_AllowedKeyEntries = new HTuple();
            HTuple hv_KeyClasses = new HTuple(), hv_RowNames = new HTuple();
            HTuple hv_Indices = new HTuple(), hv_Matches = new HTuple();
            HTuple hv_EvaluatedClass = new HTuple(), hv_KeyEvaluations = new HTuple();
            HTuple hv_TopKErrors = new HTuple(), hv_MatchesLength = new HTuple();
            HTuple hv_OffSet = new HTuple(), hv_FScoreIndex = new HTuple();
            HTuple hv_ColumnNames = new HTuple(), hv_MatrixID = new HTuple();
            HTuple hv_RowIndex = new HTuple(), hv_Dict = new HTuple();
            HTuple hv_ColumnIndex = new HTuple(), hv_WindowExists = new HTuple();
            HTuple hv_WindowHandleMeasures = new HTuple(), hv_ValueColors = new HTuple();
            HTuple hv_DiagonalColor = new HTuple(), hv_Seq = new HTuple();
            HTuple hv_DiagonalIndices = new HTuple(), hv_RowColumnNames = new HTuple();
            HTuple hv_Booleans = new HTuple(), hv_Strings = new HTuple();
            HTuple hv_KapitalStrings = new HTuple(), hv_ConfusionMatrix = new HTuple();
            HTuple hv_ValuesRelative = new HTuple(), hv_MatrixMaxID = new HTuple();
            HTuple hv_MaxValue = new HTuple(), hv_NumberFormat = new HTuple();
            HTuple hv_WindowHandleConfusion = new HTuple(), hv_WindowHandlePrecision = new HTuple();
            HTuple hv_WindowKeys = new HTuple(), hv_DisplayBooleans = new HTuple();
            HTuple hv_WindowHandleKeyNames = new HTuple(), hv_Row = new HTuple();
            HTuple hv_Column = new HTuple(), hv_MaxColumn = new HTuple();
            HTuple hv_WindowHandle = new HTuple(), hv__ = new HTuple();
            HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
            HTuple hv_GenParam_COPY_INP_TMP = new HTuple(hv_GenParam);

            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure visualizes the evaluation results for a model of type classification.
                //
                //Set the default values.
                hv_DisplayMeasures.Dispose();
                hv_DisplayMeasures = 1;
                hv_DisplayConfusionAbsolute.Dispose();
                hv_DisplayConfusionAbsolute = 0;
                hv_DisplayConfusionRelative.Dispose();
                hv_DisplayConfusionRelative = 0;
                hv_DisplayPieChartPrecision.Dispose();
                hv_DisplayPieChartPrecision = 0;
                hv_DisplayPieChartRecall.Dispose();
                hv_DisplayPieChartRecall = 0;
                hv_MeasureColor.Dispose();
                hv_MeasureColor = "white";
                hv_RowColNameColor.Dispose();
                hv_RowColNameColor = "light gray";
                hv_DisplayColumnWidth.Dispose();
                hv_DisplayColumnWidth = "equal";
                hv_DisplayColor.Dispose();
                hv_DisplayColor = 1;
                hv_Font.Dispose();
                hv_Font = "mono";
                hv_FontSize.Dispose();
                hv_FontSize = 14;
                //
                //Handle the generic parameters.
                if ((int)(new HTuple((new HTuple(hv_GenParam_COPY_INP_TMP.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    hv_GenParamKeys.Dispose();
                    hv_GenParamKeys = new HTuple();
                    hv_GenParamKeys[0] = "display_mode";
                    hv_GenParamKeys[1] = "measure_color";
                    hv_GenParamKeys[2] = "row_col_names_color";
                    hv_GenParamKeys[3] = "display_column_width";
                    hv_GenParamKeys[4] = "display_color";
                    hv_GenParamKeys[5] = "font";
                    hv_GenParamKeys[6] = "font_size";
                    hv_Keys.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam_COPY_INP_TMP, "keys", new HTuple(),
                        out hv_Keys);
                    for (hv_KeyIndex = 0; (int)hv_KeyIndex <= (int)((new HTuple(hv_Keys.TupleLength()
                        )) - 1); hv_KeyIndex = (int)hv_KeyIndex + 1)
                    {
                        if ((int)(new HTuple(((hv_GenParamKeys.TupleFind(hv_Keys.TupleSelect(hv_KeyIndex)))).TupleEqual(
                            -1))) != 0)
                        {
                            throw new HalconException(("Invalid GenParam key '" + (hv_Keys.TupleSelect(
                                hv_KeyIndex))) + "'");
                        }
                    }
                    hv_KeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam_COPY_INP_TMP, "key_exists", hv_GenParamKeys,
                        out hv_KeyExists);
                    //Set display mode.
                    if ((int)(hv_KeyExists.TupleSelect(0)) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Value.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, hv_GenParamKeys.TupleSelect(
                                0), out hv_Value);
                        }
                        if ((int)(new HTuple((new HTuple(hv_Value.TupleLength())).TupleEqual(0))) != 0)
                        {
                            throw new HalconException("GenParam key 'display_mode' cannot be an empty tuple");
                        }
                        else
                        {
                            //Display measures.
                            hv_DisplayMeasures.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_DisplayMeasures = hv_Value.TupleFind(
                                    "measures");
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_DisplayMeasures = (new HTuple((new HTuple(hv_DisplayMeasures.TupleLength()
                                        )).TupleGreater(0))).TupleAnd(new HTuple(hv_DisplayMeasures.TupleNotEqual(
                                        -1)));
                                    hv_DisplayMeasures.Dispose();
                                    hv_DisplayMeasures = ExpTmpLocalVar_DisplayMeasures;
                                }
                            }
                            //Display absolute confusion matrix.
                            hv_DisplayConfusionAbsolute.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_DisplayConfusionAbsolute = hv_Value.TupleFind(
                                    "absolute_confusion_matrix");
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_DisplayConfusionAbsolute = (new HTuple((new HTuple(hv_DisplayConfusionAbsolute.TupleLength()
                                        )).TupleGreater(0))).TupleAnd(new HTuple(hv_DisplayConfusionAbsolute.TupleNotEqual(
                                        -1)));
                                    hv_DisplayConfusionAbsolute.Dispose();
                                    hv_DisplayConfusionAbsolute = ExpTmpLocalVar_DisplayConfusionAbsolute;
                                }
                            }
                            //Display relative confusion matrix.
                            hv_DisplayConfusionRelative.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_DisplayConfusionRelative = hv_Value.TupleFind(
                                    "relative_confusion_matrix");
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_DisplayConfusionRelative = (new HTuple((new HTuple(hv_DisplayConfusionRelative.TupleLength()
                                        )).TupleGreater(0))).TupleAnd(new HTuple(hv_DisplayConfusionRelative.TupleNotEqual(
                                        -1)));
                                    hv_DisplayConfusionRelative.Dispose();
                                    hv_DisplayConfusionRelative = ExpTmpLocalVar_DisplayConfusionRelative;
                                }
                            }
                            //Display pie charts precision.
                            hv_DisplayPieChartPrecision.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_DisplayPieChartPrecision = hv_Value.TupleFind(
                                    "pie_charts_precision");
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_DisplayPieChartPrecision = (new HTuple((new HTuple(hv_DisplayPieChartPrecision.TupleLength()
                                        )).TupleGreater(0))).TupleAnd(new HTuple(hv_DisplayPieChartPrecision.TupleNotEqual(
                                        -1)));
                                    hv_DisplayPieChartPrecision.Dispose();
                                    hv_DisplayPieChartPrecision = ExpTmpLocalVar_DisplayPieChartPrecision;
                                }
                            }
                            //Display pie charts recall.
                            hv_DisplayPieChartRecall.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_DisplayPieChartRecall = hv_Value.TupleFind(
                                    "pie_charts_recall");
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_DisplayPieChartRecall = (new HTuple((new HTuple(hv_DisplayPieChartRecall.TupleLength()
                                        )).TupleGreater(0))).TupleAnd(new HTuple(hv_DisplayPieChartRecall.TupleNotEqual(
                                        -1)));
                                    hv_DisplayPieChartRecall.Dispose();
                                    hv_DisplayPieChartRecall = ExpTmpLocalVar_DisplayPieChartRecall;
                                }
                            }
                            //
                            if ((int)(new HTuple(((((((((((hv_DisplayMeasures.TupleConcat(hv_DisplayConfusionAbsolute))).TupleConcat(
                                hv_DisplayConfusionRelative))).TupleConcat(hv_DisplayPieChartPrecision))).TupleConcat(
                                hv_DisplayPieChartRecall))).TupleSum())).TupleNotEqual(new HTuple(hv_Value.TupleLength()
                                )))) != 0)
                            {
                                throw new HalconException("'display_mode' not supported.");
                            }
                        }
                    }
                    //Set MeasureColor (only for display_mode 'measures').
                    if ((int)(hv_KeyExists.TupleSelect(1)) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Value.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, hv_GenParamKeys.TupleSelect(
                                1), out hv_Value);
                        }
                        if ((int)(new HTuple((new HTuple(hv_Value.TupleLength())).TupleNotEqual(
                            1))) != 0)
                        {
                            throw new HalconException("GenParam 'measure_color' must be a single value");
                        }
                        try
                        {
                            hv_RGB.Dispose();
                            color_string_to_rgb(hv_Value, out hv_RGB);
                        }
                        // catch (Exception) 
                        catch (HalconException HDevExpDefaultException1)
                        {
                            HDevExpDefaultException1.ToHTuple(out hv_Exception);
                            throw new HalconException("GenParam 'measure_color' must be a valid color string");
                        }
                        hv_MeasureColor.Dispose();
                        hv_MeasureColor = new HTuple(hv_Value);
                    }
                    //Set color for row and column names.
                    if ((int)(hv_KeyExists.TupleSelect(2)) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Value.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, hv_GenParamKeys.TupleSelect(
                                2), out hv_Value);
                        }
                        if ((int)(new HTuple((new HTuple(hv_Value.TupleLength())).TupleNotEqual(
                            1))) != 0)
                        {
                            throw new HalconException("GenParam 'row_col_names_color' must be a single value");
                        }
                        try
                        {
                            hv_RGB.Dispose();
                            color_string_to_rgb(hv_Value, out hv_RGB);
                        }
                        // catch (Exception) 
                        catch (HalconException HDevExpDefaultException1)
                        {
                            HDevExpDefaultException1.ToHTuple(out hv_Exception);
                            throw new HalconException("GenParam 'row_col_names_color' must be a valid color string");
                        }
                        hv_RowColNameColor.Dispose();
                        hv_RowColNameColor = new HTuple(hv_Value);
                    }
                    //Set value for displaying column width.
                    if ((int)(hv_KeyExists.TupleSelect(3)) != 0)
                    {
                        hv_DisplayColumnWidthTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, "display_column_width",
                            out hv_DisplayColumnWidthTmp);
                        if ((int)((new HTuple((new HTuple(hv_DisplayColumnWidthTmp.TupleLength()
                            )).TupleNotEqual(1))).TupleOr(new HTuple((new HTuple(((new HTuple("equal")).TupleConcat(
                            "minimal")).TupleFind(hv_DisplayColumnWidthTmp))).TupleEqual(-1)))) != 0)
                        {
                            throw new HalconException("Invalid value for 'display_column_width'");
                        }
                        else
                        {
                            hv_DisplayColumnWidth.Dispose();
                            hv_DisplayColumnWidth = new HTuple(hv_DisplayColumnWidthTmp);
                        }
                    }
                    //Set display_color (only for confusion matrix).
                    if ((int)(hv_KeyExists.TupleSelect(4)) != 0)
                    {
                        hv_DisplayColor.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, "display_color", out hv_DisplayColor);
                        if ((int)((new HTuple((new HTuple(hv_DisplayColor.TupleLength())).TupleNotEqual(
                            1))).TupleOr(new HTuple((new HTuple(((new HTuple("true")).TupleConcat(
                            "false")).TupleFind(hv_DisplayColor))).TupleEqual(-1)))) != 0)
                        {
                            throw new HalconException("Invalid value for 'display_color'");
                        }
                        else
                        {
                            if ((int)(new HTuple(hv_DisplayColor.TupleEqual("true"))) != 0)
                            {
                                hv_DisplayColor.Dispose();
                                hv_DisplayColor = 1;
                            }
                            else
                            {
                                hv_DisplayColor.Dispose();
                                hv_DisplayColor = 0;
                            }
                        }
                    }
                    //Set font (only available for 'measures' and confusion matrices).
                    if ((int)(hv_KeyExists.TupleSelect(5)) != 0)
                    {
                        hv_Font.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, "font", out hv_Font);
                    }
                    //Set font size (only available for 'measures' and confusion matrices).
                    if ((int)(hv_KeyExists.TupleSelect(6)) != 0)
                    {
                        hv_FontSize.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, "font_size", out hv_FontSize);
                        if ((int)((new HTuple(hv_FontSize.TupleLess(8))).TupleOr(new HTuple(hv_FontSize.TupleGreater(
                            64)))) != 0)
                        {
                            throw new HalconException(new HTuple("Font size has to be in range of [8,64]"));
                        }
                    }
                }
                //
                //Check EvalParam and get the class names.
                try
                {
                    hv_KeysExist.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParam, "key_exists", (new HTuple("class_names")).TupleConcat(
                        "class_ids"), out hv_KeysExist);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    throw new HalconException("EvalParam has to be a dictionary");
                }
                if ((int)(((hv_KeysExist.TupleSum())).TupleNot()) != 0)
                {
                    throw new HalconException("EvalParam must contain at least one of the keys 'class_names' or 'class_ids'");
                }
                else if ((int)(((hv_KeysExist.TupleSelect(0))).TupleNot()) != 0)
                {
                    //If class names are not given, use class IDs instead.
                    hv_ClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParam, "class_ids", out hv_ClassIDs);
                    hv_ClassNames.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassNames = "class_id_" + hv_ClassIDs;
                    }
                }
                else
                {
                    //Get the class names from the EvalParam dict.
                    hv_ClassNames.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParam, "class_names", out hv_ClassNames);
                }
                //
                //Cut class names for better visualization and get mapping between class IDs and class names.
                if ((int)(new HTuple(hv_ClassNames.TupleNotEqual(new HTuple()))) != 0)
                {
                    //Cut class names.
                    hv_MaxChars.Dispose();
                    hv_MaxChars = 14;
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_ClassNames.TupleLength()
                        )) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        hv_Str.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Str = hv_ClassNames.TupleSelect(
                                hv_Index);
                        }
                        hv_IsString.Dispose();
                        HOperatorSet.TupleIsString(hv_Str, out hv_IsString);
                        if ((int)(hv_IsString) != 0)
                        {
                            hv_Length.Dispose();
                            HOperatorSet.TupleStrlen(hv_Str, out hv_Length);
                            if ((int)(new HTuple(hv_Length.TupleGreater(hv_MaxChars))) != 0)
                            {
                                hv_SubStr.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_SubStr = (hv_Str.TupleSubstr(
                                        0, hv_MaxChars - 3)) + "...";
                                }
                                if (hv_ClassNames == null)
                                    hv_ClassNames = new HTuple();
                                hv_ClassNames[hv_Index] = hv_SubStr;
                            }
                        }
                    }
                    //Generate mapping.
                    hv_ClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParam, "class_ids", out hv_ClassIDs);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassIDsToNamesMapping.Dispose();
                        HOperatorSet.TupleGenConst(hv_ClassIDs.TupleMax(), -1, out hv_ClassIDsToNamesMapping);
                    }
                    if (hv_ClassIDsToNamesMapping == null)
                        hv_ClassIDsToNamesMapping = new HTuple();
                    hv_ClassIDsToNamesMapping[hv_ClassIDs] = HTuple.TupleGenSequence(0, (new HTuple(hv_ClassIDs.TupleLength()
                        )) - 1, 1);
                }
                //
                //Sanity check for EvaluationResult.
                try
                {
                    hv_Keys.Dispose();
                    HOperatorSet.GetDictParam(hv_EvaluationResult, "keys", new HTuple(), out hv_Keys);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    throw new HalconException("EvaluationResult has to be a dictionary");
                }
                hv_AllowedKeyEntries.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_AllowedKeyEntries = "class_id_" + hv_ClassIDs;
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_AllowedKeyEntries = hv_AllowedKeyEntries.TupleConcat(
                            (((new HTuple("absolute_confusion_matrix")).TupleConcat("relative_confusion_matrix")).TupleConcat(
                            "global")).TupleConcat("evaluated_samples"));
                        hv_AllowedKeyEntries.Dispose();
                        hv_AllowedKeyEntries = ExpTmpLocalVar_AllowedKeyEntries;
                    }
                }
                if ((int)(new HTuple(((hv_Keys.TupleDifference(hv_AllowedKeyEntries))).TupleNotEqual(
                    new HTuple()))) != 0)
                {
                    throw new HalconException("EvaluationResult only supports the following key entries: " + hv_AllowedKeyEntries);
                }
                //
                //Check if requested display modes are available.
                hv_KeysExist.Dispose();
                HOperatorSet.GetDictParam(hv_EvaluationResult, "key_exists", (new HTuple("absolute_confusion_matrix")).TupleConcat(
                    "relative_confusion_matrix"), out hv_KeysExist);
                if ((int)(hv_DisplayConfusionAbsolute.TupleAnd(((hv_KeysExist.TupleSelect(0))).TupleNot()
                    )) != 0)
                {
                    throw new HalconException("Key 'absolute_confusion_matrix' in EvaluationResult is needed to display absolute confusion matrix.\n Please run evaluate_dl_model with this key.");
                }
                if ((int)(hv_DisplayConfusionRelative.TupleAnd(((hv_KeysExist.TupleSelect(1))).TupleNot()
                    )) != 0)
                {
                    throw new HalconException("Key 'relative_confusion_matrix' in EvaluationResult is needed to display relative confusion matrix.\n Please run evaluate_dl_model with this key.");
                }
                //
                //Display measures.
                if ((int)(hv_DisplayMeasures) != 0)
                {
                    //
                    //For each entry in EvaluationResult except *_confusion_matrix, a row containing the measures is displayed.
                    hv_KeyClasses.Dispose();
                    HOperatorSet.GetDictParam(hv_EvaluationResult, "keys", new HTuple(), out hv_KeyClasses);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_KeyClasses = hv_KeyClasses.TupleDifference(
                                ((new HTuple("absolute_confusion_matrix")).TupleConcat("relative_confusion_matrix")).TupleConcat(
                                "evaluated_samples"));
                            hv_KeyClasses.Dispose();
                            hv_KeyClasses = ExpTmpLocalVar_KeyClasses;
                        }
                    }
                    if ((int)(new HTuple((new HTuple(hv_KeyClasses.TupleLength())).TupleEqual(
                        0))) != 0)
                    {
                        throw new HalconException("To display 'measures' an evaluation for at least one class is needed");
                    }
                    if ((int)(new HTuple(hv_ClassNames.TupleNotEqual(new HTuple()))) != 0)
                    {
                        //Match class names for better readability.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_RowNames.Dispose();
                            HOperatorSet.TupleGenConst(new HTuple(hv_KeyClasses.TupleLength()), "global",
                                out hv_RowNames);
                        }
                        hv_Indices.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Indices = ((hv_KeyClasses.TupleNotEqualElem(
                                "global"))).TupleFind(1);
                        }
                        if ((int)(new HTuple(hv_Indices.TupleNotEqual(-1))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Matches.Dispose();
                                HOperatorSet.TupleRegexpMatch(hv_KeyClasses.TupleSelect(hv_Indices),
                                    "class_id_(.*)", out hv_Matches);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_Matches = hv_Matches.TupleNumber()
                                        ;
                                    hv_Matches.Dispose();
                                    hv_Matches = ExpTmpLocalVar_Matches;
                                }
                            }
                            if (hv_RowNames == null)
                                hv_RowNames = new HTuple();
                            hv_RowNames[hv_Indices] = hv_ClassNames.TupleSelect(hv_ClassIDsToNamesMapping.TupleSelect(
                                hv_Matches.TupleInt()));
                        }
                    }
                    else
                    {
                        hv_RowNames.Dispose();
                        HOperatorSet.TupleRegexpReplace(hv_KeyClasses, (new HTuple("_")).TupleConcat(
                            "replace_all"), " ", out hv_RowNames);
                    }
                    //
                    //Get all measures that can be displayed.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_EvaluatedClass.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvaluationResult, hv_KeyClasses.TupleSelect(
                            0), out hv_EvaluatedClass);
                    }
                    hv_KeyEvaluations.Dispose();
                    HOperatorSet.GetDictParam(hv_EvaluatedClass, "keys", new HTuple(), out hv_KeyEvaluations);
                    {
                        HTuple ExpTmpOutVar_0;
                        HOperatorSet.TupleRegexpReplace(hv_KeyEvaluations, (new HTuple("mean_")).TupleConcat(
                            "replace_all"), "", out ExpTmpOutVar_0);
                        hv_KeyEvaluations.Dispose();
                        hv_KeyEvaluations = ExpTmpOutVar_0;
                    }
                    //Throw away unneeded keys.
                    hv_TopKErrors.Dispose();
                    HOperatorSet.TupleRegexpSelect(hv_KeyEvaluations, new HTuple("top([0-9]{1,2})_error"),
                        out hv_TopKErrors);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_KeyEvaluations = hv_KeyEvaluations.TupleIntersection(
                                hv_TopKErrors.TupleConcat(((new HTuple("precision")).TupleConcat("recall")).TupleConcat(
                                "f_score")));
                            hv_KeyEvaluations.Dispose();
                            hv_KeyEvaluations = ExpTmpLocalVar_KeyEvaluations;
                        }
                    }
                    //Sort the entries as follows: ['topK_error', 'precision', 'recall', 'f_score']
                    hv_Matches.Dispose();
                    HOperatorSet.TupleRegexpMatch(hv_KeyEvaluations, "top.*", out hv_Matches);
                    hv_MatchesLength.Dispose();
                    HOperatorSet.TupleStrlen(hv_Matches, out hv_MatchesLength);
                    hv_Indices.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Indices = ((hv_MatchesLength.TupleGreaterElem(
                            0))).TupleFind(1);
                    }
                    if ((int)(new HTuple(hv_Indices.TupleNotEqual(-1))) != 0)
                    {
                        hv_OffSet.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_OffSet = (HTuple.TupleGenSequence(
                                0, (new HTuple(hv_KeyEvaluations.TupleLength())) - 1, 1)).TupleDifference(
                                hv_Indices);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_KeyEvaluations = ((hv_KeyEvaluations.TupleSelect(
                                    hv_Indices))).TupleConcat(hv_KeyEvaluations.TupleSelect(hv_OffSet));
                                hv_KeyEvaluations.Dispose();
                                hv_KeyEvaluations = ExpTmpLocalVar_KeyEvaluations;
                            }
                        }
                    }
                    hv_FScoreIndex.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_FScoreIndex = ((hv_KeyEvaluations.TupleEqualElem(
                            "f_score"))).TupleFind(1);
                    }
                    if ((int)(new HTuple(hv_FScoreIndex.TupleNotEqual(-1))) != 0)
                    {
                        {
                            HTuple ExpTmpOutVar_0;
                            HOperatorSet.TupleRemove(hv_KeyEvaluations, hv_FScoreIndex, out ExpTmpOutVar_0);
                            hv_KeyEvaluations.Dispose();
                            hv_KeyEvaluations = ExpTmpOutVar_0;
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_KeyEvaluations = hv_KeyEvaluations.TupleConcat(
                                    "f_score");
                                hv_KeyEvaluations.Dispose();
                                hv_KeyEvaluations = ExpTmpLocalVar_KeyEvaluations;
                            }
                        }
                    }
                    //Check if any valid keys are still available.
                    if ((int)(new HTuple((new HTuple(hv_KeyEvaluations.TupleLength())).TupleEqual(
                        0))) != 0)
                    {
                        throw new HalconException("To display 'measures' at least one evaluation measure is needed");
                    }
                    hv_ColumnNames.Dispose();
                    hv_ColumnNames = new HTuple(hv_KeyEvaluations);
                    //
                    //Fill matrix
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MatrixID.Dispose();
                        HOperatorSet.CreateMatrix(new HTuple(hv_KeyClasses.TupleLength()), new HTuple(hv_KeyEvaluations.TupleLength()
                            ), 0, out hv_MatrixID);
                    }
                    for (hv_RowIndex = 0; (int)hv_RowIndex <= (int)((new HTuple(hv_KeyClasses.TupleLength()
                        )) - 1); hv_RowIndex = (int)hv_RowIndex + 1)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Dict.Dispose();
                            HOperatorSet.GetDictTuple(hv_EvaluationResult, hv_KeyClasses.TupleSelect(
                                hv_RowIndex), out hv_Dict);
                        }
                        for (hv_ColumnIndex = 0; (int)hv_ColumnIndex <= (int)((new HTuple(hv_KeyEvaluations.TupleLength()
                            )) - 1); hv_ColumnIndex = (int)hv_ColumnIndex + 1)
                        {
                            try
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Value.Dispose();
                                    HOperatorSet.GetDictTuple(hv_Dict, hv_KeyEvaluations.TupleSelect(hv_ColumnIndex),
                                        out hv_Value);
                                }
                            }
                            // catch (Exception) 
                            catch (HalconException HDevExpDefaultException1)
                            {
                                HDevExpDefaultException1.ToHTuple(out hv_Exception);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Value.Dispose();
                                    HOperatorSet.GetDictTuple(hv_Dict, "mean_" + (hv_KeyEvaluations.TupleSelect(
                                        hv_ColumnIndex)), out hv_Value);
                                }
                            }
                            HOperatorSet.SetValueMatrix(hv_MatrixID, hv_RowIndex, hv_ColumnIndex,
                                hv_Value);
                        }
                    }
                    //
                    //Set generic parameters for dev_display_matrix.
                    hv_GenParam_COPY_INP_TMP.Dispose();
                    HOperatorSet.CreateDict(out hv_GenParam_COPY_INP_TMP);
                    HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "title", "Measures");
                    HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "number_format", "0.3f");
                    HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "display_column_width",
                        hv_DisplayColumnWidth);
                    HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "value_colors", hv_MeasureColor);
                    HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "display_color", 1);
                    HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "row_col_names_color",
                        hv_RowColNameColor);
                    //
                    //Check if there is already a window handle.
                    hv_WindowExists.Dispose();
                    HOperatorSet.GetDictParam(hv_WindowHandleDict, "key_exists", "window_measures",
                        out hv_WindowExists);
                    if ((int)(hv_WindowExists) != 0)
                    {
                        hv_WindowHandleMeasures.Dispose();
                        HOperatorSet.GetDictTuple(hv_WindowHandleDict, "window_measures", out hv_WindowHandleMeasures);
                        HDevWindowStack.SetActive(hv_WindowHandleMeasures);
                    }
                    else
                    {
                        HOperatorSet.SetWindowAttr("background_color", "black");
                        HOperatorSet.OpenWindow(0, 0, 512, 512, 0, "visible", "", out hv_WindowHandleMeasures);
                        HDevWindowStack.Push(hv_WindowHandleMeasures);
                        HOperatorSet.SetDictTuple(hv_WindowHandleDict, "window_measures", hv_WindowHandleMeasures);
                    }
                    //
                    //Display.
                    set_display_font(hv_WindowHandleMeasures, hv_FontSize, hv_Font, "false",
                        "false");
                    dev_display_matrix(hv_MatrixID, hv_ColumnNames, hv_RowNames, hv_WindowHandleMeasures,
                        hv_GenParam_COPY_INP_TMP);
                }
                //
                //Visualize confusion matrix.
                if ((int)(hv_DisplayConfusionAbsolute.TupleOr(hv_DisplayConfusionRelative)) != 0)
                {
                    //
                    //Set general generic parameters for dev_display_matrix.
                    hv_GenParam_COPY_INP_TMP.Dispose();
                    HOperatorSet.CreateDict(out hv_GenParam_COPY_INP_TMP);
                    HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "display_column_with",
                        hv_DisplayColumnWidth);
                    HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "display_color", hv_DisplayColor);
                    HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "row_col_names_color",
                        hv_RowColNameColor);
                    HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "axis_titles", (new HTuple("Ground truth")).TupleConcat(
                        "Predicted"));
                    if ((int)(hv_DisplayColor) != 0)
                    {
                        //Display off-diagonal values in red.
                        hv_ValueColors.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ValueColors = HTuple.TupleGenConst(
                                (new HTuple(hv_ClassIDs.TupleLength())) * (new HTuple(hv_ClassIDs.TupleLength()
                                )), "#ff4500");
                        }
                        //Display diagonal values in green.
                        hv_DiagonalColor.Dispose();
                        hv_DiagonalColor = "#00ff00";
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Seq.Dispose();
                            HOperatorSet.TupleGenSequence(0, (new HTuple(hv_ClassIDs.TupleLength())) - 1,
                                1, out hv_Seq);
                        }
                        hv_DiagonalIndices.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_DiagonalIndices = ((new HTuple(hv_ClassIDs.TupleLength()
                                )) * hv_Seq) + hv_Seq;
                        }
                        if (hv_ValueColors == null)
                            hv_ValueColors = new HTuple();
                        hv_ValueColors[hv_DiagonalIndices] = hv_DiagonalColor;
                        HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "value_colors", hv_ValueColors);
                    }
                    //
                    //Set row and column names.
                    if ((int)(new HTuple(hv_ClassNames.TupleNotEqual(new HTuple()))) != 0)
                    {
                        hv_RowColumnNames.Dispose();
                        hv_RowColumnNames = new HTuple(hv_ClassNames);
                    }
                    else
                    {
                        hv_RowColumnNames.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_RowColumnNames = "class_id_" + hv_ClassIDs;
                        }
                    }
                    //
                    //Display confusion matrix.
                    hv_Booleans.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Booleans = new HTuple();
                        hv_Booleans = hv_Booleans.TupleConcat(hv_DisplayConfusionAbsolute, hv_DisplayConfusionRelative);
                    }
                    hv_Strings.Dispose();
                    hv_Strings = new HTuple();
                    hv_Strings[0] = "absolute";
                    hv_Strings[1] = "relative";
                    hv_KapitalStrings.Dispose();
                    hv_KapitalStrings = new HTuple();
                    hv_KapitalStrings[0] = "Absolute";
                    hv_KapitalStrings[1] = "Relative";
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Booleans.TupleLength()
                        )) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        if ((int)(((hv_Booleans.TupleSelect(hv_Index))).TupleNot()) != 0)
                        {
                            continue;
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ConfusionMatrix.Dispose();
                            HOperatorSet.GetDictTuple(hv_EvaluationResult, (hv_Strings.TupleSelect(
                                hv_Index)) + "_confusion_matrix", out hv_ConfusionMatrix);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "title", (hv_KapitalStrings.TupleSelect(
                                hv_Index)) + " confusion matrix");
                        }
                        //Convert relative matrix values to percent.
                        if ((int)(new HTuple(((hv_Strings.TupleSelect(hv_Index))).TupleEqual("relative"))) != 0)
                        {
                            {
                                HTuple ExpTmpOutVar_0;
                                HOperatorSet.CopyMatrix(hv_ConfusionMatrix, out ExpTmpOutVar_0);
                                hv_ConfusionMatrix.Dispose();
                                hv_ConfusionMatrix = ExpTmpOutVar_0;
                            }
                            hv_ValuesRelative.Dispose();
                            HOperatorSet.GetFullMatrix(hv_ConfusionMatrix, out hv_ValuesRelative);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetFullMatrix(hv_ConfusionMatrix, 100 * hv_ValuesRelative);
                            }
                        }
                        //Calculate proper number format.
                        hv_MatrixMaxID.Dispose();
                        HOperatorSet.MaxMatrix(hv_ConfusionMatrix, "full", out hv_MatrixMaxID);
                        hv_MaxValue.Dispose();
                        HOperatorSet.GetFullMatrix(hv_MatrixMaxID, out hv_MaxValue);
                        if ((int)(new HTuple(hv_MaxValue.TupleGreater(0))) != 0)
                        {
                            hv_NumberFormat.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_NumberFormat = (((((hv_MaxValue.TupleLog10()
                                    )).TupleCeil())).TupleInt()) + ".0f";
                            }
                        }
                        else
                        {
                            hv_NumberFormat.Dispose();
                            hv_NumberFormat = "1.0f";
                        }
                        HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "number_format", hv_NumberFormat);
                        //
                        //Check if there is already a window handle.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_WindowExists.Dispose();
                            HOperatorSet.GetDictParam(hv_WindowHandleDict, "key_exists", ("window_" + (hv_Strings.TupleSelect(
                                hv_Index))) + "_confusion_matrix", out hv_WindowExists);
                        }
                        if ((int)(hv_WindowExists.TupleNot()) != 0)
                        {
                            HOperatorSet.SetWindowAttr("background_color", "black");
                            HOperatorSet.OpenWindow(0, 0, 512, 512, 0, "visible", "", out hv_WindowHandleConfusion);
                            HDevWindowStack.Push(hv_WindowHandleConfusion);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_WindowHandleDict, ("window_" + (hv_Strings.TupleSelect(
                                    hv_Index))) + "_confusion_matrix", hv_WindowHandleConfusion);
                            }
                        }
                        else
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowHandleConfusion.Dispose();
                                HOperatorSet.GetDictTuple(hv_WindowHandleDict, ("window_" + (hv_Strings.TupleSelect(
                                    hv_Index))) + "_confusion_matrix", out hv_WindowHandleConfusion);
                            }
                        }
                        //
                        //Display.
                        set_display_font(hv_WindowHandleConfusion, hv_FontSize, hv_Font, "false",
                            "false");
                        dev_display_matrix(hv_ConfusionMatrix, hv_RowColumnNames, hv_RowColumnNames,
                            hv_WindowHandleConfusion, hv_GenParam_COPY_INP_TMP);
                    }
                }
                //
                // Visualization of precision pie charts.
                if ((int)(hv_DisplayPieChartPrecision) != 0)
                {
                    //
                    //Check if there is already a window handle.
                    hv_WindowExists.Dispose();
                    HOperatorSet.GetDictParam(hv_WindowHandleDict, "key_exists", "window_pie_charts_precision",
                        out hv_WindowExists);
                    if ((int)(hv_WindowExists.TupleNot()) != 0)
                    {
                        HOperatorSet.SetWindowAttr("background_color", "black");
                        HOperatorSet.OpenWindow(0, 0, 512, 512, 0, "visible", "", out hv_WindowHandlePrecision);
                        HDevWindowStack.Push(hv_WindowHandlePrecision);
                        HOperatorSet.SetDictTuple(hv_WindowHandleDict, "window_pie_charts_precision",
                            hv_WindowHandlePrecision);
                    }
                    else
                    {
                        hv_WindowHandlePrecision.Dispose();
                        HOperatorSet.GetDictTuple(hv_WindowHandleDict, "window_pie_charts_precision",
                            out hv_WindowHandlePrecision);
                    }
                    //Display.
                    dev_display_classification_evaluation_class_pie_chart(hv_WindowHandlePrecision,
                        hv_EvaluationResult, hv_ClassIDs, "precision");
                }
                //
                // Visualization of recall pie charts.
                if ((int)(hv_DisplayPieChartRecall) != 0)
                {
                    //
                    //Check if there is already a window handle.
                    hv_WindowExists.Dispose();
                    HOperatorSet.GetDictParam(hv_WindowHandleDict, "key_exists", "window_pie_charts_recall",
                        out hv_WindowExists);
                    if ((int)(hv_WindowExists.TupleNot()) != 0)
                    {
                        HOperatorSet.SetWindowAttr("background_color", "black");
                        HOperatorSet.OpenWindow(0, 0, 512, 512, 0, "visible", "", out hv_WindowHandlePrecision);
                        HDevWindowStack.Push(hv_WindowHandlePrecision);
                        HOperatorSet.SetDictTuple(hv_WindowHandleDict, "window_pie_charts_recall",
                            hv_WindowHandlePrecision);
                    }
                    else
                    {
                        hv_WindowHandlePrecision.Dispose();
                        HOperatorSet.GetDictTuple(hv_WindowHandleDict, "window_pie_charts_recall",
                            out hv_WindowHandlePrecision);
                    }
                    //Display.
                    dev_display_classification_evaluation_class_pie_chart(hv_WindowHandlePrecision,
                        hv_EvaluationResult, hv_ClassIDs, "recall");
                }
                //
                //Rearrange windows.
                //Pie charts (if present) are plotted at the left, the rest at the right side.
                hv_WindowKeys.Dispose();
                HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_WindowKeys);
                hv_DisplayBooleans.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_DisplayBooleans = new HTuple();
                    hv_DisplayBooleans = hv_DisplayBooleans.TupleConcat(hv_DisplayPieChartPrecision, hv_DisplayPieChartRecall, hv_DisplayMeasures, hv_DisplayConfusionAbsolute, hv_DisplayConfusionRelative);
                }
                hv_WindowHandleKeyNames.Dispose();
                hv_WindowHandleKeyNames = new HTuple();
                hv_WindowHandleKeyNames[0] = "window_pie_charts_precision";
                hv_WindowHandleKeyNames[1] = "window_pie_charts_recall";
                hv_WindowHandleKeyNames[2] = "window_measures";
                hv_WindowHandleKeyNames[3] = "window_absolute_confusion_matrix";
                hv_WindowHandleKeyNames[4] = "window_relative_confusion_matrix";
                hv_Row.Dispose();
                hv_Row = 0;
                hv_Column.Dispose();
                hv_Column = 0;
                hv_MaxColumn.Dispose();
                hv_MaxColumn = 0;
                if ((int)(new HTuple((new HTuple(hv_WindowKeys.TupleLength())).TupleGreaterEqual(
                    1))) != 0)
                {
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_DisplayBooleans.TupleLength()
                        )) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        if ((int)(new HTuple(hv_Index.TupleEqual(2))) != 0)
                        {
                            hv_Row.Dispose();
                            hv_Row = 0;
                            hv_Column.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Column = hv_MaxColumn + 8;
                            }
                        }
                        if ((int)(hv_DisplayBooleans.TupleSelect(hv_Index)) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowHandle.Dispose();
                                HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKeyNames.TupleSelect(
                                    hv_Index), out hv_WindowHandle);
                            }
                            hv__.Dispose(); hv__.Dispose(); hv_Width.Dispose(); hv_Height.Dispose();
                            HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv__, out hv__, out hv_Width,
                                out hv_Height);
                            HDevWindowStack.SetActive(hv_WindowHandle);
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_Row,
                                    hv_Column, hv_Width, hv_Height);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_Row = (hv_Row + hv_Height) + 55;
                                    hv_Row.Dispose();
                                    hv_Row = ExpTmpLocalVar_Row;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_MaxColumn = hv_MaxColumn.TupleMax2(
                                        hv_Width);
                                    hv_MaxColumn.Dispose();
                                    hv_MaxColumn = ExpTmpLocalVar_MaxColumn;
                                }
                            }
                        }
                    }
                }
                //

                hv_GenParam_COPY_INP_TMP.Dispose();
                hv_DisplayMeasures.Dispose();
                hv_DisplayConfusionAbsolute.Dispose();
                hv_DisplayConfusionRelative.Dispose();
                hv_DisplayPieChartPrecision.Dispose();
                hv_DisplayPieChartRecall.Dispose();
                hv_MeasureColor.Dispose();
                hv_RowColNameColor.Dispose();
                hv_DisplayColumnWidth.Dispose();
                hv_DisplayColor.Dispose();
                hv_Font.Dispose();
                hv_FontSize.Dispose();
                hv_GenParamKeys.Dispose();
                hv_Keys.Dispose();
                hv_KeyIndex.Dispose();
                hv_KeyExists.Dispose();
                hv_Value.Dispose();
                hv_RGB.Dispose();
                hv_Exception.Dispose();
                hv_DisplayColumnWidthTmp.Dispose();
                hv_KeysExist.Dispose();
                hv_ClassIDs.Dispose();
                hv_ClassNames.Dispose();
                hv_MaxChars.Dispose();
                hv_Index.Dispose();
                hv_Str.Dispose();
                hv_IsString.Dispose();
                hv_Length.Dispose();
                hv_SubStr.Dispose();
                hv_ClassIDsToNamesMapping.Dispose();
                hv_AllowedKeyEntries.Dispose();
                hv_KeyClasses.Dispose();
                hv_RowNames.Dispose();
                hv_Indices.Dispose();
                hv_Matches.Dispose();
                hv_EvaluatedClass.Dispose();
                hv_KeyEvaluations.Dispose();
                hv_TopKErrors.Dispose();
                hv_MatchesLength.Dispose();
                hv_OffSet.Dispose();
                hv_FScoreIndex.Dispose();
                hv_ColumnNames.Dispose();
                hv_MatrixID.Dispose();
                hv_RowIndex.Dispose();
                hv_Dict.Dispose();
                hv_ColumnIndex.Dispose();
                hv_WindowExists.Dispose();
                hv_WindowHandleMeasures.Dispose();
                hv_ValueColors.Dispose();
                hv_DiagonalColor.Dispose();
                hv_Seq.Dispose();
                hv_DiagonalIndices.Dispose();
                hv_RowColumnNames.Dispose();
                hv_Booleans.Dispose();
                hv_Strings.Dispose();
                hv_KapitalStrings.Dispose();
                hv_ConfusionMatrix.Dispose();
                hv_ValuesRelative.Dispose();
                hv_MatrixMaxID.Dispose();
                hv_MaxValue.Dispose();
                hv_NumberFormat.Dispose();
                hv_WindowHandleConfusion.Dispose();
                hv_WindowHandlePrecision.Dispose();
                hv_WindowKeys.Dispose();
                hv_DisplayBooleans.Dispose();
                hv_WindowHandleKeyNames.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();
                hv_MaxColumn.Dispose();
                hv_WindowHandle.Dispose();
                hv__.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_GenParam_COPY_INP_TMP.Dispose();
                hv_DisplayMeasures.Dispose();
                hv_DisplayConfusionAbsolute.Dispose();
                hv_DisplayConfusionRelative.Dispose();
                hv_DisplayPieChartPrecision.Dispose();
                hv_DisplayPieChartRecall.Dispose();
                hv_MeasureColor.Dispose();
                hv_RowColNameColor.Dispose();
                hv_DisplayColumnWidth.Dispose();
                hv_DisplayColor.Dispose();
                hv_Font.Dispose();
                hv_FontSize.Dispose();
                hv_GenParamKeys.Dispose();
                hv_Keys.Dispose();
                hv_KeyIndex.Dispose();
                hv_KeyExists.Dispose();
                hv_Value.Dispose();
                hv_RGB.Dispose();
                hv_Exception.Dispose();
                hv_DisplayColumnWidthTmp.Dispose();
                hv_KeysExist.Dispose();
                hv_ClassIDs.Dispose();
                hv_ClassNames.Dispose();
                hv_MaxChars.Dispose();
                hv_Index.Dispose();
                hv_Str.Dispose();
                hv_IsString.Dispose();
                hv_Length.Dispose();
                hv_SubStr.Dispose();
                hv_ClassIDsToNamesMapping.Dispose();
                hv_AllowedKeyEntries.Dispose();
                hv_KeyClasses.Dispose();
                hv_RowNames.Dispose();
                hv_Indices.Dispose();
                hv_Matches.Dispose();
                hv_EvaluatedClass.Dispose();
                hv_KeyEvaluations.Dispose();
                hv_TopKErrors.Dispose();
                hv_MatchesLength.Dispose();
                hv_OffSet.Dispose();
                hv_FScoreIndex.Dispose();
                hv_ColumnNames.Dispose();
                hv_MatrixID.Dispose();
                hv_RowIndex.Dispose();
                hv_Dict.Dispose();
                hv_ColumnIndex.Dispose();
                hv_WindowExists.Dispose();
                hv_WindowHandleMeasures.Dispose();
                hv_ValueColors.Dispose();
                hv_DiagonalColor.Dispose();
                hv_Seq.Dispose();
                hv_DiagonalIndices.Dispose();
                hv_RowColumnNames.Dispose();
                hv_Booleans.Dispose();
                hv_Strings.Dispose();
                hv_KapitalStrings.Dispose();
                hv_ConfusionMatrix.Dispose();
                hv_ValuesRelative.Dispose();
                hv_MatrixMaxID.Dispose();
                hv_MaxValue.Dispose();
                hv_NumberFormat.Dispose();
                hv_WindowHandleConfusion.Dispose();
                hv_WindowHandlePrecision.Dispose();
                hv_WindowKeys.Dispose();
                hv_DisplayBooleans.Dispose();
                hv_WindowHandleKeyNames.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();
                hv_MaxColumn.Dispose();
                hv_WindowHandle.Dispose();
                hv__.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Classification
        // Short Description: Display pie charts for prediction or recall of an classification evaluation. 
        public void dev_display_classification_evaluation_class_pie_chart(HTuple hv_WindowHandle,
            HTuple hv_EvaluationResult, HTuple hv_ClassIDs, HTuple hv_Mode)
        {



            // Local iconic variables 

            HObject ho_Image;

            // Local control variables 

            HTuple hv_FlushValue = new HTuple(), hv_CenterRowOverall = new HTuple();
            HTuple hv_CenterColOverall = new HTuple(), hv_RadiusOverall = new HTuple();
            HTuple hv_MaxClassChartsPerRow = new HTuple(), hv_RadiusClass = new HTuple();
            HTuple hv_ChartRowDistance = new HTuple(), hv_ChartColDistance = new HTuple();
            HTuple hv_StartRow = new HTuple(), hv_StartCol = new HTuple();
            HTuple hv_KeysToPlot = new HTuple(), hv_KeyExists = new HTuple();
            HTuple hv_NumClassCharts = new HTuple(), hv_Measures = new HTuple();
            HTuple hv_MeanValue = new HTuple(), hv_ValuesPerClass = new HTuple();
            HTuple hv_MainTitle = new HTuple(), hv_ClassTitles = new HTuple();
            HTuple hv_Keys = new HTuple(), hv_ClassIDsStr = new HTuple();
            HTuple hv_Index = new HTuple(), hv_Value = new HTuple();
            HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
            HTuple hv_Font = new HTuple(), hv_Colors = new HTuple();
            HTuple hv_GenParamPieChart = new HTuple(), hv_Description = new HTuple();
            HTuple hv_PercentStr = new HTuple(), hv_CenterRow = new HTuple();
            HTuple hv_CenterCol = new HTuple();
            HTuple hv_ClassIDs_COPY_INP_TMP = new HTuple(hv_ClassIDs);

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Image);
            try
            {
                //
                //This procedure plots pie charts for precision and recall.
                //More detailed, the mean over all classes that have been used for
                //evaluation and the values for each class are plotted.
                //
                //Switch off automatic flushing to make visualization smooth.
                hv_FlushValue.Dispose();
                HOperatorSet.GetWindowParam(hv_WindowHandle, "flush", out hv_FlushValue);
                HOperatorSet.SetWindowParam(hv_WindowHandle, "flush", "false");
                //Drawing parameters.
                //Overall pie-chart.
                hv_CenterRowOverall.Dispose();
                hv_CenterRowOverall = 150;
                hv_CenterColOverall.Dispose();
                hv_CenterColOverall = 150;
                hv_RadiusOverall.Dispose();
                hv_RadiusOverall = 100;
                //Per-class pie-chart.
                hv_MaxClassChartsPerRow.Dispose();
                hv_MaxClassChartsPerRow = 10;
                hv_RadiusClass.Dispose();
                hv_RadiusClass = 40;
                hv_ChartRowDistance.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ChartRowDistance = 3 * hv_RadiusClass;
                }
                hv_ChartColDistance.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ChartColDistance = 2.5 * hv_RadiusClass;
                }
                hv_StartRow.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_StartRow = (hv_CenterRowOverall + (1.5 * hv_RadiusOverall)) + (1.5 * hv_RadiusClass);
                }
                hv_StartCol.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_StartCol = 1.5 * hv_RadiusClass;
                }
                //
                //Get values.
                hv_KeysToPlot.Dispose();
                hv_KeysToPlot = "global";
                hv_KeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvaluationResult, "key_exists", "global", out hv_KeyExists);
                if ((int)(hv_KeyExists) != 0)
                {
                    hv_KeysToPlot.Dispose();
                    hv_KeysToPlot = "global";
                    hv_NumClassCharts.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumClassCharts = new HTuple(hv_ClassIDs_COPY_INP_TMP.TupleLength()
                            );
                    }
                    hv_Measures.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvaluationResult, "global", out hv_Measures);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MeanValue.Dispose();
                        HOperatorSet.GetDictTuple(hv_Measures, "mean_" + hv_Mode, out hv_MeanValue);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ValuesPerClass.Dispose();
                        HOperatorSet.GetDictTuple(hv_Measures, hv_Mode + "_per_class", out hv_ValuesPerClass);
                    }
                    hv_MainTitle.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MainTitle = "Mean " + hv_Mode;
                    }
                    hv_ClassTitles.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassTitles = "Class id " + hv_ClassIDs_COPY_INP_TMP;
                    }
                }
                else
                {
                    //Search for evaluated classes.
                    hv_Keys.Dispose();
                    HOperatorSet.GetDictParam(hv_EvaluationResult, "keys", new HTuple(), out hv_Keys);
                    hv_KeysToPlot.Dispose();
                    HOperatorSet.TupleRegexpSelect(hv_Keys, "class_id", out hv_KeysToPlot);
                    hv_ClassIDsStr.Dispose();
                    HOperatorSet.TupleRegexpMatch(hv_KeysToPlot, "class_id_(.*)", out hv_ClassIDsStr);
                    hv_ClassIDs_COPY_INP_TMP.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassIDs_COPY_INP_TMP = hv_ClassIDsStr.TupleNumber()
                            ;
                    }
                    if ((int)(new HTuple((new HTuple(hv_ClassIDs_COPY_INP_TMP.TupleLength())).TupleEqual(
                        1))) != 0)
                    {
                        //We do not need to plot the small pie charts for each class.
                        hv_NumClassCharts.Dispose();
                        hv_NumClassCharts = 0;
                        hv_MainTitle.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MainTitle = (hv_Mode + " for class id ") + (hv_ClassIDs_COPY_INP_TMP.TupleSelect(
                                0));
                        }
                        hv_ClassTitles.Dispose();
                        hv_ClassTitles = new HTuple();
                    }
                    else
                    {
                        hv_NumClassCharts.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_NumClassCharts = new HTuple(hv_ClassIDs_COPY_INP_TMP.TupleLength()
                                );
                        }
                        hv_MainTitle.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MainTitle = "Mean " + hv_Mode;
                        }
                        hv_ClassTitles.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClassTitles = "Class id " + hv_ClassIDs_COPY_INP_TMP;
                        }
                    }
                    hv_ValuesPerClass.Dispose();
                    hv_ValuesPerClass = new HTuple();
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_ClassIDs_COPY_INP_TMP.TupleLength()
                        )) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Measures.Dispose();
                            HOperatorSet.GetDictTuple(hv_EvaluationResult, hv_KeysToPlot.TupleSelect(
                                hv_Index), out hv_Measures);
                        }
                        hv_Value.Dispose();
                        HOperatorSet.GetDictTuple(hv_Measures, hv_Mode, out hv_Value);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_ValuesPerClass = hv_ValuesPerClass.TupleConcat(
                                    hv_Value);
                                hv_ValuesPerClass.Dispose();
                                hv_ValuesPerClass = ExpTmpLocalVar_ValuesPerClass;
                            }
                        }
                    }
                    hv_MeanValue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MeanValue = hv_ValuesPerClass.TupleMean()
                            ;
                    }
                }
                //
                //Open Window and set font.
                hv_WindowWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowWidth = (new HTuple(550)).TupleMax2(
                        (((hv_NumClassCharts.TupleMin2(hv_MaxClassChartsPerRow)) - 1) * hv_ChartColDistance) + (2 * hv_StartCol));
                }
                hv_WindowHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowHeight = (3 * hv_RadiusOverall) + ((((((hv_NumClassCharts.TupleReal()
                        ) / hv_MaxClassChartsPerRow)).TupleCeil()) * 3) * hv_RadiusClass);
                }
                HDevWindowStack.SetActive(hv_WindowHandle);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), 0, 0, hv_WindowWidth,
                        hv_WindowHeight);
                }
                ho_Image.Dispose();
                HOperatorSet.GenImageConst(out ho_Image, "byte", hv_WindowWidth, hv_WindowHeight);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                }
                hv_Font.Dispose();
                HOperatorSet.QueryFont(hv_WindowHandle, out hv_Font);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_Font = (hv_Font.TupleSelect(
                            0)) + "-Bold-15";
                        hv_Font.Dispose();
                        hv_Font = ExpTmpLocalVar_Font;
                    }
                }
                HOperatorSet.SetFont(hv_WindowHandle, hv_Font);
                //
                //Draw the pie-chart.
                hv_Colors.Dispose();
                hv_Colors = new HTuple();
                hv_Colors[0] = "green";
                hv_Colors[1] = "red";
                hv_GenParamPieChart.Dispose();
                HOperatorSet.CreateDict(out hv_GenParamPieChart);
                HOperatorSet.SetDictTuple(hv_GenParamPieChart, "title", hv_MainTitle);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    dev_display_pie_chart(hv_WindowHandle, hv_MeanValue.TupleConcat(1.0 - hv_MeanValue),
                        hv_CenterRowOverall, hv_CenterColOverall, hv_RadiusOverall, hv_Colors,
                        hv_GenParamPieChart);
                }
                //
                //Write description for pie chart.
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Results: ", "image",
                            20, (hv_CenterColOverall + hv_RadiusOverall) + 20, "white", "box", "false");
                    }
                }
                if ((int)(new HTuple(hv_Mode.TupleEqual("precision"))) != 0)
                {
                    hv_Description.Dispose();
                    hv_Description = new HTuple();
                    hv_Description[0] = "precision (TP / (TP + FP))";
                    hv_Description[1] = "false positives";
                }
                else if ((int)(new HTuple(hv_Mode.TupleEqual("recall"))) != 0)
                {
                    hv_Description.Dispose();
                    hv_Description = new HTuple();
                    hv_Description[0] = "recall (TP / (TP + FN))";
                    hv_Description[1] = "false negatives";
                }
                else
                {
                    throw new HalconException("Mode not supported: " + hv_Mode);
                }
                hv_PercentStr.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PercentStr = ((((hv_MeanValue.TupleConcat(
                        1.0 - hv_MeanValue)) * 100)).TupleString(".1f")) + "";
                }
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Description.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), ((hv_PercentStr.TupleSelect(
                                hv_Index)) + "%: ") + (hv_Description.TupleSelect(hv_Index)), "image",
                                30 + ((hv_Index + 1) * 20), (hv_CenterColOverall + hv_RadiusOverall) + 20, hv_Colors.TupleSelect(
                                hv_Index), "box", "false");
                        }
                    }
                }
                //
                //Per class pie charts.
                HTuple end_val90 = hv_NumClassCharts - 1;
                HTuple step_val90 = 1;
                for (hv_Index = 0; hv_Index.Continue(end_val90, step_val90); hv_Index = hv_Index.TupleAdd(step_val90))
                {
                    //Get the position of the class-pie-chart.
                    hv_CenterRow.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CenterRow = hv_StartRow + (((((hv_Index.TupleReal()
                            ) / hv_MaxClassChartsPerRow)).TupleFloor()) * hv_ChartRowDistance);
                    }
                    hv_CenterCol.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CenterCol = hv_StartCol + ((hv_Index % hv_MaxClassChartsPerRow) * hv_ChartColDistance);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_GenParamPieChart, "title", hv_ClassTitles.TupleSelect(
                            hv_Index));
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        dev_display_pie_chart(hv_WindowHandle, ((hv_ValuesPerClass.TupleSelect(hv_Index))).TupleConcat(
                            1.0 - (hv_ValuesPerClass.TupleSelect(hv_Index))), hv_CenterRow, hv_CenterCol,
                            hv_RadiusClass, hv_Colors, hv_GenParamPieChart);
                    }
                }
                //
                //Flush buffer and reset value for 'flush'.
                HOperatorSet.FlushBuffer(hv_WindowHandle);
                HOperatorSet.SetWindowParam(hv_WindowHandle, "flush", hv_FlushValue);
                //
                ho_Image.Dispose();

                hv_ClassIDs_COPY_INP_TMP.Dispose();
                hv_FlushValue.Dispose();
                hv_CenterRowOverall.Dispose();
                hv_CenterColOverall.Dispose();
                hv_RadiusOverall.Dispose();
                hv_MaxClassChartsPerRow.Dispose();
                hv_RadiusClass.Dispose();
                hv_ChartRowDistance.Dispose();
                hv_ChartColDistance.Dispose();
                hv_StartRow.Dispose();
                hv_StartCol.Dispose();
                hv_KeysToPlot.Dispose();
                hv_KeyExists.Dispose();
                hv_NumClassCharts.Dispose();
                hv_Measures.Dispose();
                hv_MeanValue.Dispose();
                hv_ValuesPerClass.Dispose();
                hv_MainTitle.Dispose();
                hv_ClassTitles.Dispose();
                hv_Keys.Dispose();
                hv_ClassIDsStr.Dispose();
                hv_Index.Dispose();
                hv_Value.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_Font.Dispose();
                hv_Colors.Dispose();
                hv_GenParamPieChart.Dispose();
                hv_Description.Dispose();
                hv_PercentStr.Dispose();
                hv_CenterRow.Dispose();
                hv_CenterCol.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Image.Dispose();

                hv_ClassIDs_COPY_INP_TMP.Dispose();
                hv_FlushValue.Dispose();
                hv_CenterRowOverall.Dispose();
                hv_CenterColOverall.Dispose();
                hv_RadiusOverall.Dispose();
                hv_MaxClassChartsPerRow.Dispose();
                hv_RadiusClass.Dispose();
                hv_ChartRowDistance.Dispose();
                hv_ChartColDistance.Dispose();
                hv_StartRow.Dispose();
                hv_StartCol.Dispose();
                hv_KeysToPlot.Dispose();
                hv_KeyExists.Dispose();
                hv_NumClassCharts.Dispose();
                hv_Measures.Dispose();
                hv_MeanValue.Dispose();
                hv_ValuesPerClass.Dispose();
                hv_MainTitle.Dispose();
                hv_ClassTitles.Dispose();
                hv_Keys.Dispose();
                hv_ClassIDsStr.Dispose();
                hv_Index.Dispose();
                hv_Value.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_Font.Dispose();
                hv_Colors.Dispose();
                hv_GenParamPieChart.Dispose();
                hv_Description.Dispose();
                hv_PercentStr.Dispose();
                hv_CenterRow.Dispose();
                hv_CenterCol.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: Display a map of the confidences. 
        public void dev_display_confidence_regions(HObject ho_ImageConfidence, HTuple hv_DrawTransparency,
            out HTuple hv_Colors)
        {




            // Local iconic variables 

            HObject ho_Region = null;

            // Local control variables 

            HTuple hv_NumColors = new HTuple(), hv_WeightsColorsAlpha = new HTuple();
            HTuple hv_ColorIndex = new HTuple(), hv_Threshold = new HTuple();
            HTuple hv_MinGray = new HTuple(), hv_MaxGray = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Region);
            hv_Colors = new HTuple();
            try
            {
                //
                //This procedure displays a map of the confidences
                //given in ImageConfidence as regions.
                //DrawTransparency determines the alpha value of the colors.
                //The used colors are returned.
                //
                //Define colors.
                hv_NumColors.Dispose();
                hv_NumColors = 20;
                hv_Colors.Dispose();
                get_distinct_colors(hv_NumColors, 0, 0, 100, out hv_Colors);
                hv_WeightsColorsAlpha.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WeightsColorsAlpha = hv_Colors + hv_DrawTransparency;
                }
                hv_ColorIndex.Dispose();
                hv_ColorIndex = 0;
                //
                //Threshold the image according to
                //the number of colors and
                //display resulting regions.
                HTuple end_val15 = hv_NumColors - 1;
                HTuple step_val15 = 1;
                for (hv_ColorIndex = 0; hv_ColorIndex.Continue(end_val15, step_val15); hv_ColorIndex = hv_ColorIndex.TupleAdd(step_val15))
                {
                    hv_Threshold.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Threshold = hv_ColorIndex * (1.0 / hv_NumColors);
                    }
                    hv_MinGray.Dispose();
                    hv_MinGray = new HTuple(hv_Threshold);
                    hv_MaxGray.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxGray = hv_Threshold + (1 / hv_NumColors);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_Region.Dispose();
                        HOperatorSet.Threshold(ho_ImageConfidence, out ho_Region, hv_Threshold, hv_Threshold + (1.0 / hv_NumColors));
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_WeightsColorsAlpha.TupleSelect(
                                hv_ColorIndex));
                        }
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_Region, HDevWindowStack.GetActive());
                    }
                }
                ho_Region.Dispose();

                hv_NumColors.Dispose();
                hv_WeightsColorsAlpha.Dispose();
                hv_ColorIndex.Dispose();
                hv_Threshold.Dispose();
                hv_MinGray.Dispose();
                hv_MaxGray.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Region.Dispose();

                hv_NumColors.Dispose();
                hv_WeightsColorsAlpha.Dispose();
                hv_ColorIndex.Dispose();
                hv_Threshold.Dispose();
                hv_MinGray.Dispose();
                hv_MaxGray.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Visualize different images, annotations and inference results for a sample. 
        public void dev_display_dl_data(HTuple hv_DLSample, HTuple hv_DLResult, HTuple hv_DLDatasetInfo,
            HTuple hv_KeysForDisplay, HTuple hv_GenParam, HTuple hv_WindowHandleDict)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Image = null, ho_AnomalyImage = null;
            HObject ho_AnomalyRegion = null, ho_PredictionColorFrame = null;
            HObject ho_ImageHeatmap = null, ho_ImageWeight = null, ho_ImageConfidence = null;
            HObject ho_SegmentationImagGroundTruth = null, ho_SegmentationImageResult = null;
            HObject ho_ImageAbsDiff = null, ho_DiffRegion = null;

            // Local control variables 

            HTuple hv_ThresholdWidth = new HTuple(), hv_ScaleWindows = new HTuple();
            HTuple hv_Font = new HTuple(), hv_FontSize = new HTuple();
            HTuple hv_LineWidth = new HTuple(), hv_MapTransparency = new HTuple();
            HTuple hv_MapColorBarWidth = new HTuple(), hv_AnomalyRegionThreshold = new HTuple();
            HTuple hv_AnomalyClassificationThreshold = new HTuple();
            HTuple hv_AnomalyRegionLabelColor = new HTuple(), hv_AnomalyColorTransparency = new HTuple();
            HTuple hv_AnomalyRegionResultColor = new HTuple(), hv_SegMaxWeight = new HTuple();
            HTuple hv_SegDraw = new HTuple(), hv_SegTransparency = new HTuple();
            HTuple hv_SegExcludeClassIDs = new HTuple(), hv_BboxLabelColor = new HTuple();
            HTuple hv_BboxDisplayConfidence = new HTuple(), hv_BboxTextColor = new HTuple();
            HTuple hv_ShowBottomDesc = new HTuple(), hv_ShowLegend = new HTuple();
            HTuple hv_ShowGroundTruthAnomalyRegions = new HTuple();
            HTuple hv_ShowClassificationIDs = new HTuple(), hv_ShowClassificationColorFrame = new HTuple();
            HTuple hv_ShowLabels = new HTuple(), hv_ShowDirection = new HTuple();
            HTuple hv_HeatmapColorScheme = new HTuple(), hv_GenParamNames = new HTuple();
            HTuple hv_ParamIndex = new HTuple(), hv_GenParamName = new HTuple();
            HTuple hv_GenParamValue = new HTuple(), hv_SampleKeys = new HTuple();
            HTuple hv_ResultKeys = new HTuple(), hv_ImageIDExists = new HTuple();
            HTuple hv_ImageID = new HTuple(), hv_ImageIDString = new HTuple();
            HTuple hv_ImageIDStringBraces = new HTuple(), hv_ImageIDStringCapital = new HTuple();
            HTuple hv_NeededKeys = new HTuple(), hv_Index = new HTuple();
            HTuple hv_DLDatasetInfoKeys = new HTuple(), hv_ClassNames = new HTuple();
            HTuple hv_ClassIDs = new HTuple(), hv_Colors = new HTuple();
            HTuple hv_ClassesLegend = new HTuple(), hv_PrevWindowCoordinates = new HTuple();
            HTuple hv_Keys = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_MetaInfoIndex = new HTuple(), hv_MetaInfo = new HTuple();
            HTuple hv_FlushValues = new HTuple(), hv_WindowHandleKeys = new HTuple();
            HTuple hv_KeyIndex = new HTuple(), hv_WindowHandles = new HTuple();
            HTuple hv_WindowIndex = new HTuple(), hv_FlushValue = new HTuple();
            HTuple hv_WidthImage = new HTuple(), hv_HeightImage = new HTuple();
            HTuple hv_CurrentWindowHandle = new HTuple(), hv_WindowImageRatio = new HTuple();
            HTuple hv_AnomalyLabelGroundTruth = new HTuple(), hv_AnomalyLabelIDGroundTruth = new HTuple();
            HTuple hv_AnomalyRegionExists = new HTuple(), hv_Text = new HTuple();
            HTuple hv_AnomalyScore = new HTuple(), hv_AnomalyClassID = new HTuple();
            HTuple hv_AnomalyRegionGroundTruthExists = new HTuple();
            HTuple hv_PredictionColor = new HTuple(), hv_LineColors = new HTuple();
            HTuple hv_ClassificationLabelIDGroundTruth = new HTuple();
            HTuple hv_ClassificationLabelIDResult = new HTuple(), hv_MarginBottom = new HTuple();
            HTuple hv_WindowCoordinates = new HTuple(), hv_CurrentWindowHeight = new HTuple();
            HTuple hv__ = new HTuple(), hv_MaxHeight = new HTuple();
            HTuple hv_PredictionText = new HTuple(), hv_BoarderOffset = new HTuple();
            HTuple hv_WindowImageRatioHeight = new HTuple(), hv_WindowImageRatioWidth = new HTuple();
            HTuple hv_BoarderOffsetRow = new HTuple(), hv_BoarderOffsetCol = new HTuple();
            HTuple hv_SelectedHeatmapMethod = new HTuple(), hv_DictHeatmap = new HTuple();
            HTuple hv_MethodName = new HTuple(), hv_HeatmapKeys = new HTuple();
            HTuple hv_HeatmapImageName = new HTuple(), hv_TargetClassID = new HTuple();
            HTuple hv_Confidences = new HTuple(), hv_MaxDeviation = new HTuple();
            HTuple hv_ClassificationLabelNameResult = new HTuple();
            HTuple hv_TargetClassConfidence = new HTuple(), hv_ClassificationLabelNamesGroundTruth = new HTuple();
            HTuple hv_BboxIDs = new HTuple(), hv_BboxColors = new HTuple();
            HTuple hv_BboxIDsUniq = new HTuple(), hv_BboxConfidences = new HTuple();
            HTuple hv_TextConf = new HTuple(), hv_BboxClassIndex = new HTuple();
            HTuple hv_BboxColorsResults = new HTuple(), hv_BboxClassIndexUniq = new HTuple();
            HTuple hv_BboxLabelIndex = new HTuple(), hv_BboxColorsBoth = new HTuple();
            HTuple hv_BboxClassLabelIndexUniq = new HTuple(), hv_ColorsSegmentation = new HTuple();
            HTuple hv_DrawMode = new HTuple(), hv_Width = new HTuple();
            HTuple hv_ImageClassIDs = new HTuple(), hv_ImageClassIDsUniq = new HTuple();
            HTuple hv_ColorsResults = new HTuple(), hv_GroundTruthIDs = new HTuple();
            HTuple hv_ResultIDs = new HTuple(), hv_StringSegExcludeClassIDs = new HTuple();
            HTuple hv_StringIndex = new HTuple(), hv_Min = new HTuple();
            HTuple hv_Max = new HTuple(), hv_Range = new HTuple();
            HTuple hv_MinWeight = new HTuple(), hv_WeightsColors = new HTuple();
            HTuple hv_ConfidenceColors = new HTuple(), hv_Indices = new HTuple();
            HTuple hv_WindowHandleKeysNew = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Image);
            HOperatorSet.GenEmptyObj(out ho_AnomalyImage);
            HOperatorSet.GenEmptyObj(out ho_AnomalyRegion);
            HOperatorSet.GenEmptyObj(out ho_PredictionColorFrame);
            HOperatorSet.GenEmptyObj(out ho_ImageHeatmap);
            HOperatorSet.GenEmptyObj(out ho_ImageWeight);
            HOperatorSet.GenEmptyObj(out ho_ImageConfidence);
            HOperatorSet.GenEmptyObj(out ho_SegmentationImagGroundTruth);
            HOperatorSet.GenEmptyObj(out ho_SegmentationImageResult);
            HOperatorSet.GenEmptyObj(out ho_ImageAbsDiff);
            HOperatorSet.GenEmptyObj(out ho_DiffRegion);
            try
            {
                //
                //This procedure displays the content of the provided DLSample and/or DLResult
                //depending on the input string KeysForDisplay.
                //DLDatasetInfo is a dictionary containing the information about the dataset.
                //The visualization can be adapted with GenParam.
                //
                //** Set the default values: ***
                //
                //Define the screen width when a new window row is started.
                hv_ThresholdWidth.Dispose();
                hv_ThresholdWidth = 1024;
                //Since potentially a lot of windows are opened,
                //scale the windows consistently.
                hv_ScaleWindows.Dispose();
                hv_ScaleWindows = 0.8;
                //Set a font and a font size.
                hv_Font.Dispose();
                hv_Font = "mono";
                hv_FontSize.Dispose();
                hv_FontSize = 14;
                //
                hv_LineWidth.Dispose();
                hv_LineWidth = 2;
                hv_MapTransparency.Dispose();
                hv_MapTransparency = "cc";
                hv_MapColorBarWidth.Dispose();
                hv_MapColorBarWidth = 140;
                //
                //Define anomaly detection-specific parameter values.
                hv_AnomalyRegionThreshold.Dispose();
                hv_AnomalyRegionThreshold = -1;
                hv_AnomalyClassificationThreshold.Dispose();
                hv_AnomalyClassificationThreshold = -1;
                hv_AnomalyRegionLabelColor.Dispose();
                hv_AnomalyRegionLabelColor = "#40e0d0";
                hv_AnomalyColorTransparency.Dispose();
                hv_AnomalyColorTransparency = "40";
                hv_AnomalyRegionResultColor.Dispose();
                hv_AnomalyRegionResultColor = "#ff0000c0";
                //
                //Define segmentation-specific parameter values.
                hv_SegMaxWeight.Dispose();
                hv_SegMaxWeight = 0;
                hv_SegDraw.Dispose();
                hv_SegDraw = "fill";
                hv_SegTransparency.Dispose();
                hv_SegTransparency = "aa";
                hv_SegExcludeClassIDs.Dispose();
                hv_SegExcludeClassIDs = new HTuple();
                //
                //Define bounding box-specific parameter values.
                hv_BboxLabelColor.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_BboxLabelColor = new HTuple("#000000") + "99";
                }
                hv_BboxDisplayConfidence.Dispose();
                hv_BboxDisplayConfidence = 1;
                hv_BboxTextColor.Dispose();
                hv_BboxTextColor = "#eeeeee";
                //
                //By default, display a description on the bottom.
                hv_ShowBottomDesc.Dispose();
                hv_ShowBottomDesc = 1;
                //
                //By default, show a legend with class IDs.
                hv_ShowLegend.Dispose();
                hv_ShowLegend = 1;
                //
                //By default, show the anomaly ground truth regions.
                hv_ShowGroundTruthAnomalyRegions.Dispose();
                hv_ShowGroundTruthAnomalyRegions = 1;
                //
                //By default, show class IDs and color frames for classification ground truth/results.
                hv_ShowClassificationIDs.Dispose();
                hv_ShowClassificationIDs = 1;
                hv_ShowClassificationColorFrame.Dispose();
                hv_ShowClassificationColorFrame = 1;
                //
                //By default, show class labels for detection ground truth/results.
                hv_ShowLabels.Dispose();
                hv_ShowLabels = 1;
                //
                //By default, show direction of the ground truth/results instances for detection with instance_type 'rectangle2'.
                hv_ShowDirection.Dispose();
                hv_ShowDirection = 1;
                //
                //By default, use color scheme 'Jet' for the heatmap display.
                hv_HeatmapColorScheme.Dispose();
                hv_HeatmapColorScheme = "jet";
                //** Set user defined values: ***
                //
                //Overwrite default values by given generic parameters.
                if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
                {
                    hv_GenParamNames.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_GenParamNames);
                    for (hv_ParamIndex = 0; (int)hv_ParamIndex <= (int)((new HTuple(hv_GenParamNames.TupleLength()
                        )) - 1); hv_ParamIndex = (int)hv_ParamIndex + 1)
                    {
                        hv_GenParamName.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_GenParamName = hv_GenParamNames.TupleSelect(
                                hv_ParamIndex);
                        }
                        hv_GenParamValue.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, hv_GenParamName, out hv_GenParamValue);
                        if ((int)(new HTuple(hv_GenParamName.TupleEqual("threshold_width"))) != 0)
                        {
                            hv_ThresholdWidth.Dispose();
                            hv_ThresholdWidth = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("scale_windows"))) != 0)
                        {
                            hv_ScaleWindows.Dispose();
                            hv_ScaleWindows = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("font"))) != 0)
                        {
                            hv_Font.Dispose();
                            hv_Font = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("font_size"))) != 0)
                        {
                            hv_FontSize.Dispose();
                            hv_FontSize = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("line_width"))) != 0)
                        {
                            hv_LineWidth.Dispose();
                            hv_LineWidth = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("map_transparency"))) != 0)
                        {
                            hv_MapTransparency.Dispose();
                            hv_MapTransparency = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("map_color_bar_width"))) != 0)
                        {
                            hv_MapColorBarWidth.Dispose();
                            hv_MapColorBarWidth = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("segmentation_max_weight"))) != 0)
                        {
                            hv_SegMaxWeight.Dispose();
                            hv_SegMaxWeight = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("segmentation_draw"))) != 0)
                        {
                            hv_SegDraw.Dispose();
                            hv_SegDraw = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("segmentation_transparency"))) != 0)
                        {
                            hv_SegTransparency.Dispose();
                            hv_SegTransparency = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("segmentation_exclude_class_ids"))) != 0)
                        {
                            hv_SegExcludeClassIDs.Dispose();
                            hv_SegExcludeClassIDs = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("bbox_label_color"))) != 0)
                        {
                            hv_BboxLabelColor.Dispose();
                            hv_BboxLabelColor = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("bbox_display_confidence"))) != 0)
                        {
                            hv_BboxDisplayConfidence.Dispose();
                            hv_BboxDisplayConfidence = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("bbox_text_color"))) != 0)
                        {
                            hv_BboxTextColor.Dispose();
                            hv_BboxTextColor = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("display_bottom_desc"))) != 0)
                        {
                            hv_ShowBottomDesc.Dispose();
                            hv_ShowBottomDesc = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("display_legend"))) != 0)
                        {
                            hv_ShowLegend.Dispose();
                            hv_ShowLegend = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("display_classification_ids"))) != 0)
                        {
                            hv_ShowClassificationIDs.Dispose();
                            hv_ShowClassificationIDs = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("display_classification_color_frame"))) != 0)
                        {
                            hv_ShowClassificationColorFrame.Dispose();
                            hv_ShowClassificationColorFrame = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("display_labels"))) != 0)
                        {
                            hv_ShowLabels.Dispose();
                            hv_ShowLabels = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("display_direction"))) != 0)
                        {
                            hv_ShowDirection.Dispose();
                            hv_ShowDirection = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("heatmap_color_scheme"))) != 0)
                        {
                            hv_HeatmapColorScheme.Dispose();
                            hv_HeatmapColorScheme = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("display_ground_truth_anomaly_regions"))) != 0)
                        {
                            hv_ShowGroundTruthAnomalyRegions.Dispose();
                            hv_ShowGroundTruthAnomalyRegions = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("anomaly_region_threshold"))) != 0)
                        {
                            hv_AnomalyRegionThreshold.Dispose();
                            hv_AnomalyRegionThreshold = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("anomaly_classification_threshold"))) != 0)
                        {
                            hv_AnomalyClassificationThreshold.Dispose();
                            hv_AnomalyClassificationThreshold = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("anomaly_region_label_color"))) != 0)
                        {
                            hv_AnomalyRegionLabelColor.Dispose();
                            hv_AnomalyRegionLabelColor = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("anomaly_region_result_color"))) != 0)
                        {
                            hv_AnomalyRegionResultColor.Dispose();
                            hv_AnomalyRegionResultColor = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("anomaly_color_transparency"))) != 0)
                        {
                            hv_AnomalyColorTransparency.Dispose();
                            hv_AnomalyColorTransparency = new HTuple(hv_GenParamValue);
                        }
                        else
                        {
                            throw new HalconException(("Unknown generic parameter: " + hv_GenParamName) + ".");
                        }
                    }
                }
                //
                //Get the dictionary keys.
                hv_SampleKeys.Dispose();
                HOperatorSet.GetDictParam(hv_DLSample, "keys", new HTuple(), out hv_SampleKeys);
                if ((int)(new HTuple(hv_DLResult.TupleNotEqual(new HTuple()))) != 0)
                {
                    hv_ResultKeys.Dispose();
                    HOperatorSet.GetDictParam(hv_DLResult, "keys", new HTuple(), out hv_ResultKeys);
                }
                //
                //Get image ID if it is available.
                hv_ImageIDExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "image_id", out hv_ImageIDExists);
                if ((int)(hv_ImageIDExists) != 0)
                {
                    hv_ImageID.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "image_id", out hv_ImageID);
                    hv_ImageIDString.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageIDString = "image ID " + hv_ImageID;
                    }
                    hv_ImageIDStringBraces.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageIDStringBraces = ("(image ID " + hv_ImageID) + ")";
                    }
                    hv_ImageIDStringCapital.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageIDStringCapital = "Image ID " + hv_ImageID;
                    }
                }
                else
                {
                    hv_ImageIDString.Dispose();
                    hv_ImageIDString = "";
                    hv_ImageIDStringBraces.Dispose();
                    hv_ImageIDStringBraces = new HTuple(hv_ImageIDString);
                    hv_ImageIDStringCapital.Dispose();
                    hv_ImageIDStringCapital = new HTuple(hv_ImageIDString);
                }
                //
                //Check if DLDatasetInfo is valid.
                if ((int)(new HTuple(hv_DLDatasetInfo.TupleEqual(new HTuple()))) != 0)
                {
                    //If DLDatasetInfo is empty, 'image' is the only key allowed in KeysForDisplay.
                    if ((int)((new HTuple((new HTuple(hv_KeysForDisplay.TupleLength())).TupleNotEqual(
                        1))).TupleOr(new HTuple(((hv_KeysForDisplay.TupleSelect(0))).TupleNotEqual(
                        "image")))) != 0)
                    {
                        throw new HalconException("DLDatasetInfo is needed for requested keys in KeysForDisplay.");
                    }
                }
                else
                {
                    //Check if DLDatasetInfo contains necessary keys.
                    hv_NeededKeys.Dispose();
                    hv_NeededKeys = new HTuple();
                    hv_NeededKeys[0] = "class_names";
                    hv_NeededKeys[1] = "class_ids";
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_NeededKeys.TupleLength()
                        )) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        hv_DLDatasetInfoKeys.Dispose();
                        HOperatorSet.GetDictParam(hv_DLDatasetInfo, "keys", new HTuple(), out hv_DLDatasetInfoKeys);
                        if ((int)(new HTuple(((hv_DLDatasetInfoKeys.TupleFindFirst(hv_NeededKeys.TupleSelect(
                            hv_Index)))).TupleEqual(-1))) != 0)
                        {
                            throw new HalconException(("Key " + (hv_NeededKeys.TupleSelect(
                                hv_Index))) + " is missing in DLDatasetInfo.");
                        }
                    }
                    //
                    //Get the general dataset information, if available.
                    hv_ClassNames.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLDatasetInfo, "class_names", out hv_ClassNames);
                    hv_ClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLDatasetInfo, "class_ids", out hv_ClassIDs);
                    //
                    //Define distinct colors for the classes.
                    hv_Colors.Dispose();
                    get_dl_class_colors(hv_ClassNames, out hv_Colors);
                    //
                    hv_ClassesLegend.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassesLegend = (hv_ClassIDs + " : ") + hv_ClassNames;
                    }
                }
                //
                //** Set window parameters: ***
                //
                //Set previous window coordinates.
                hv_PrevWindowCoordinates.Dispose();
                hv_PrevWindowCoordinates = new HTuple();
                hv_PrevWindowCoordinates[0] = 0;
                hv_PrevWindowCoordinates[1] = 0;
                hv_PrevWindowCoordinates[2] = 0;
                hv_PrevWindowCoordinates[3] = 0;
                hv_PrevWindowCoordinates[4] = 1;
                //
                //Check that the WindowHandleDict is of type dictionary.
                try
                {
                    hv_Keys.Dispose();
                    HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_Keys);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    if ((int)(new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(1401))) != 0)
                    {
                        throw new HalconException("WindowHandleDict has to be of type dictionary. Use create_dict to create an empty dictionary.");
                    }
                    else
                    {
                        throw new HalconException(hv_Exception);
                    }
                }
                //For better usage, add meta information about the window handles in WindowHandleDict.
                hv_MetaInfoIndex.Dispose();
                HOperatorSet.TupleFind(hv_Keys, "meta_information", out hv_MetaInfoIndex);
                if ((int)((new HTuple(hv_MetaInfoIndex.TupleEqual(-1))).TupleOr(new HTuple(hv_MetaInfoIndex.TupleEqual(
                    new HTuple())))) != 0)
                {
                    hv_MetaInfo.Dispose();
                    HOperatorSet.CreateDict(out hv_MetaInfo);
                    HOperatorSet.SetDictTuple(hv_WindowHandleDict, "meta_information", hv_MetaInfo);
                }
                //
                //For each window, set 'flush' to 'false' to avoid flickering.
                hv_FlushValues.Dispose();
                hv_FlushValues = new HTuple();
                hv_WindowHandleKeys.Dispose();
                HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_WindowHandleKeys);
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_WindowHandleKeys.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    //Only consider the WindowHandleKeys that are needed for the current visualization.
                    hv_KeyIndex.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_KeyIndex = hv_KeysForDisplay.TupleFind(
                            hv_WindowHandleKeys.TupleSelect(hv_Index));
                    }
                    if ((int)((new HTuple(hv_KeyIndex.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_KeyIndex.TupleNotEqual(
                        new HTuple())))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_WindowHandles.Dispose();
                            HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKeys.TupleSelect(
                                hv_Index), out hv_WindowHandles);
                        }
                        for (hv_WindowIndex = 0; (int)hv_WindowIndex <= (int)((new HTuple(hv_WindowHandles.TupleLength()
                            )) - 1); hv_WindowIndex = (int)hv_WindowIndex + 1)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_FlushValue.Dispose();
                                HOperatorSet.GetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex),
                                    "flush", out hv_FlushValue);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_FlushValues = hv_FlushValues.TupleConcat(
                                        hv_FlushValue);
                                    hv_FlushValues.Dispose();
                                    hv_FlushValues = ExpTmpLocalVar_FlushValues;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex),
                                    "flush", "false");
                            }
                        }
                    }
                }
                //
                //** Display the data: ***
                //
                //Display data dictionaries.
                for (hv_KeyIndex = 0; (int)hv_KeyIndex <= (int)((new HTuple(hv_KeysForDisplay.TupleLength()
                    )) - 1); hv_KeyIndex = (int)hv_KeyIndex + 1)
                {
                    if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "image"))) != 0)
                    {
                        //
                        //Image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ImageIDStringCapital,
                                    "window", "bottom", "left", "white", "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "anomaly_ground_truth"))) != 0)
                    {
                        //Image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        hv_AnomalyLabelGroundTruth.Dispose(); hv_AnomalyLabelIDGroundTruth.Dispose();
                        get_anomaly_ground_truth_label(hv_SampleKeys, hv_DLSample, out hv_AnomalyLabelGroundTruth,
                            out hv_AnomalyLabelIDGroundTruth);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualize image.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        hv_AnomalyRegionExists.Dispose();
                        hv_AnomalyRegionExists = "false";
                        if ((int)(hv_ShowGroundTruthAnomalyRegions) != 0)
                        {
                            //Show the ground truth region.
                            hv_AnomalyRegionExists.Dispose();
                            dev_display_ground_truth_anomaly_regions(hv_SampleKeys, hv_DLSample,
                                hv_CurrentWindowHandle, hv_LineWidth, hv_AnomalyRegionLabelColor,
                                hv_AnomalyColorTransparency, out hv_AnomalyRegionExists);
                        }
                        //
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Ground truth anomalies " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = ((hv_AnomalyLabelIDGroundTruth + " : '") + hv_AnomalyLabelGroundTruth) + "'";
                            if ((int)((new HTuple((new HTuple(hv_AnomalyRegionExists.TupleEqual("false"))).TupleAnd(
                                new HTuple(hv_AnomalyLabelIDGroundTruth.TupleEqual(1))))).TupleAnd(
                                hv_ShowGroundTruthAnomalyRegions)) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "No 'anomaly_ground_truth' exists!";
                            }
                            //
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", "white", "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "anomaly_result"))) != 0)
                    {
                        //
                        //Get image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        //
                        //Get the anomaly image out of DLResult.
                        ho_AnomalyImage.Dispose(); hv_AnomalyScore.Dispose(); hv_AnomalyClassID.Dispose();
                        get_anomaly_result(out ho_AnomalyImage, hv_ResultKeys, hv_DLResult, out hv_AnomalyScore,
                            out hv_AnomalyClassID);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualize image.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        //Display predicted anomaly regions.
                        if ((int)(new HTuple(hv_AnomalyRegionThreshold.TupleNotEqual(-1))) != 0)
                        {
                            ho_AnomalyRegion.Dispose();
                            dev_display_result_anomaly_regions(ho_AnomalyImage, out ho_AnomalyRegion,
                                hv_CurrentWindowHandle, hv_AnomalyRegionThreshold, hv_LineWidth,
                                hv_AnomalyRegionResultColor);
                        }
                        //
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Detected anomalies " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Results ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            if ((int)(new HTuple(hv_AnomalyClassID.TupleEqual(1))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID + " : 'nok'";
                            }
                            else
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID + " : 'ok'";
                            }
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Anomaly score: " + (hv_AnomalyScore.TupleString(
                                ".2f"));
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if ((int)((new HTuple(hv_AnomalyClassificationThreshold.TupleNotEqual(
                                -1))).TupleOr(new HTuple(hv_AnomalyRegionThreshold.TupleNotEqual(
                                -1)))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Thresholds ";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            }
                            //
                            if ((int)(new HTuple(hv_AnomalyClassificationThreshold.TupleNotEqual(
                                -1))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Classification: " + (hv_AnomalyClassificationThreshold.TupleString(
                                    ".2f"));
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            }
                            if ((int)(new HTuple(hv_AnomalyRegionThreshold.TupleNotEqual(-1))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Segmentation: " + (hv_AnomalyRegionThreshold.TupleString(
                                    ".2f"));
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            }
                            //
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", "white", "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "anomaly_both"))) != 0)
                    {
                        //
                        //Get image, ground truth and results.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        hv_AnomalyLabelGroundTruth.Dispose(); hv_AnomalyLabelIDGroundTruth.Dispose();
                        get_anomaly_ground_truth_label(hv_SampleKeys, hv_DLSample, out hv_AnomalyLabelGroundTruth,
                            out hv_AnomalyLabelIDGroundTruth);
                        ho_AnomalyImage.Dispose(); hv_AnomalyScore.Dispose(); hv_AnomalyClassID.Dispose();
                        get_anomaly_result(out ho_AnomalyImage, hv_ResultKeys, hv_DLResult, out hv_AnomalyScore,
                            out hv_AnomalyClassID);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualize image, ground truth (if available), and result regions.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        hv_AnomalyRegionGroundTruthExists.Dispose();
                        hv_AnomalyRegionGroundTruthExists = "false";
                        if ((int)(hv_ShowGroundTruthAnomalyRegions) != 0)
                        {
                            hv_AnomalyRegionGroundTruthExists.Dispose();
                            dev_display_ground_truth_anomaly_regions(hv_SampleKeys, hv_DLSample,
                                hv_CurrentWindowHandle, hv_LineWidth, hv_AnomalyRegionLabelColor,
                                hv_AnomalyColorTransparency, out hv_AnomalyRegionGroundTruthExists);
                        }
                        //
                        //Display result anomaly regions.
                        ho_AnomalyRegion.Dispose();
                        dev_display_result_anomaly_regions(ho_AnomalyImage, out ho_AnomalyRegion,
                            hv_CurrentWindowHandle, hv_AnomalyRegionThreshold, hv_LineWidth, hv_AnomalyRegionResultColor);
                        //
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "GT and detected anomalies " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Get prediction color.
                        hv_PredictionColor.Dispose();
                        hv_PredictionColor = "white";
                        if ((int)(new HTuple(hv_AnomalyLabelIDGroundTruth.TupleEqual(hv_AnomalyClassID))) != 0)
                        {
                            hv_PredictionColor.Dispose();
                            hv_PredictionColor = "green";
                        }
                        else
                        {
                            hv_PredictionColor.Dispose();
                            hv_PredictionColor = "red";
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Ground truth ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = ((hv_AnomalyLabelIDGroundTruth + " : '") + hv_AnomalyLabelGroundTruth) + "'";
                            if ((int)((new HTuple((new HTuple(hv_AnomalyRegionGroundTruthExists.TupleEqual(
                                "false"))).TupleAnd(new HTuple(hv_AnomalyLabelIDGroundTruth.TupleEqual(
                                1))))).TupleAnd(hv_ShowGroundTruthAnomalyRegions)) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = " No 'anomaly_ground_truth' exists!";
                            }
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Results ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            if ((int)(new HTuple(hv_AnomalyClassID.TupleEqual(1))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID + " : 'nok'";
                            }
                            else
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID + " : 'ok'";
                            }
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Anomaly score: " + (hv_AnomalyScore.TupleString(
                                ".2f"));
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if ((int)((new HTuple(hv_AnomalyClassificationThreshold.TupleNotEqual(
                                -1))).TupleOr(new HTuple(hv_AnomalyRegionThreshold.TupleNotEqual(
                                -1)))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Thresholds ";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            }
                            //
                            if ((int)(new HTuple(hv_AnomalyClassificationThreshold.TupleNotEqual(
                                -1))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Classification: " + (hv_AnomalyClassificationThreshold.TupleString(
                                    ".2f"));
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            }
                            if ((int)(new HTuple(hv_AnomalyRegionThreshold.TupleNotEqual(-1))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Segmentation: " + (hv_AnomalyRegionThreshold.TupleString(
                                    ".2f"));
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            }
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_LineColors.Dispose();
                                HOperatorSet.TupleGenConst(new HTuple(hv_Text.TupleLength()), "white",
                                    out hv_LineColors);
                            }
                            if (hv_LineColors == null)
                                hv_LineColors = new HTuple();
                            hv_LineColors[(new HTuple(hv_LineColors.TupleLength())) - 8] = hv_PredictionColor;
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", hv_LineColors, "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "anomaly_image"))) != 0)
                    {
                        //
                        //Image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        //
                        ho_AnomalyImage.Dispose(); hv_AnomalyScore.Dispose(); hv_AnomalyClassID.Dispose();
                        get_anomaly_result(out ho_AnomalyImage, hv_ResultKeys, hv_DLResult, out hv_AnomalyScore,
                            out hv_AnomalyClassID);
                        //
                        //Read in input image.
                        ho_Image.Dispose();
                        HOperatorSet.GetDictObject(out ho_Image, hv_DLSample, "image");
                        //Add the anomaly image to the input image.
                        {
                            HObject ExpTmpOutVar_0;
                            add_colormap_to_image(ho_AnomalyImage, ho_Image, out ExpTmpOutVar_0, hv_HeatmapColorScheme);
                            ho_AnomalyImage.Dispose();
                            ho_AnomalyImage = ExpTmpOutVar_0;
                        }
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_AnomalyImage, HDevWindowStack.GetActive());
                        }
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Anomaly image " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if ((int)(new HTuple(hv_AnomalyClassID.TupleEqual(1))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID + " : 'nok'";
                            }
                            else
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID + " : 'ok'";
                            }
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Anomaly score: " + (hv_AnomalyScore.TupleString(
                                ".2f"));
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", "white", "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "classification_ground_truth"))) != 0)
                    {
                        //
                        //Ground truth classification image and class label.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        //
                        hv_ClassificationLabelIDGroundTruth.Dispose();
                        get_classification_ground_truth(hv_SampleKeys, hv_DLSample, out hv_ClassificationLabelIDGroundTruth);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        if ((int)(hv_ShowClassificationIDs) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "GT label ID: " + hv_ClassificationLabelIDGroundTruth;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", "white", "box", "false");
                            }
                        }
                        //
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Ground truth classification " + hv_ImageIDStringBraces;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Ground truth class ID " + hv_ImageIDStringBraces;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                        hv_ClassesLegend.TupleSelect(hv_ClassificationLabelIDGroundTruth));
                                    hv_Text.Dispose();
                                    hv_Text = ExpTmpLocalVar_Text;
                                }
                            }
                            //
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                        "top", "left", (new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                                        hv_ClassificationLabelIDGroundTruth)), "box", "false");
                                }
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "classification_result"))) != 0)
                    {
                        //
                        //Ground truth classification image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        //
                        hv_ClassificationLabelIDResult.Dispose();
                        get_classification_result(hv_ResultKeys, hv_DLResult, out hv_ClassificationLabelIDResult);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        //Display the class IDs.
                        if ((int)(hv_ShowClassificationIDs) != 0)
                        {
                            hv_MetaInfo.Dispose();
                            HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
                            hv_MarginBottom.Dispose();
                            HOperatorSet.GetDictTuple(hv_MetaInfo, "classification_result_margin_bottom",
                                out hv_MarginBottom);
                            hv_WindowCoordinates.Dispose();
                            HOperatorSet.GetDictTuple(hv_MetaInfo, "classification_result_window_coordinates",
                                out hv_WindowCoordinates);
                            hv_CurrentWindowHeight.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_CurrentWindowHeight = (hv_WindowCoordinates.TupleSelect(
                                    3)) - (hv_WindowCoordinates.TupleSelect(0));
                            }
                            hv__.Dispose(); hv__.Dispose(); hv__.Dispose(); hv_MaxHeight.Dispose();
                            HOperatorSet.GetFontExtents(hv_CurrentWindowHandle, out hv__, out hv__,
                                out hv__, out hv_MaxHeight);
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Result class ID: " + hv_ClassificationLabelIDResult;
                            }
                            if ((int)(hv_ShowBottomDesc) != 0)
                            {
                                if (HDevWindowStack.IsOpen())
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                            hv_CurrentWindowHeight - ((hv_MarginBottom + hv_MaxHeight) + 10), "left",
                                            "white", "box", "false");
                                    }
                                }
                            }
                            else
                            {
                                if (HDevWindowStack.IsOpen())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                        "bottom", "left", "white", "box", "false");
                                }
                            }
                        }
                        //
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Result classification " + hv_ImageIDStringBraces;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Result class ID " + hv_ImageIDStringBraces;
                            }
                            if ((int)(new HTuple(hv_ClassificationLabelIDResult.TupleEqual(new HTuple()))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "No classification result is given!";
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                            hv_ClassesLegend.TupleSelect(hv_ClassificationLabelIDResult));
                                        hv_Text.Dispose();
                                        hv_Text = ExpTmpLocalVar_Text;
                                    }
                                }
                            }
                            //
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                        "top", "left", (new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                                        hv_ClassificationLabelIDResult)), "box", "false");
                                }
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "classification_both"))) != 0)
                    {
                        //
                        //Ground truth and result classification image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        //
                        hv_ClassificationLabelIDGroundTruth.Dispose();
                        get_classification_ground_truth(hv_SampleKeys, hv_DLSample, out hv_ClassificationLabelIDGroundTruth);
                        hv_ClassificationLabelIDResult.Dispose();
                        get_classification_result(hv_ResultKeys, hv_DLResult, out hv_ClassificationLabelIDResult);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        //
                        //Get prediction color.
                        hv_PredictionColor.Dispose();
                        hv_PredictionColor = "white";
                        if ((int)(new HTuple(hv_ClassificationLabelIDGroundTruth.TupleEqual(hv_ClassificationLabelIDResult))) != 0)
                        {
                            hv_PredictionText.Dispose();
                            hv_PredictionText = "Correct";
                            hv_PredictionColor.Dispose();
                            hv_PredictionColor = "green";
                        }
                        else
                        {
                            hv_PredictionText.Dispose();
                            hv_PredictionText = "Wrong";
                            hv_PredictionColor.Dispose();
                            hv_PredictionColor = "red";
                        }
                        //
                        //Generate prediction color frame and show image.
                        if ((int)(hv_ShowClassificationColorFrame) != 0)
                        {
                            //Create a frame with line width 7 that is completely displayed in the window.
                            hv_BoarderOffset.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_BoarderOffset = 7 / 2.0;
                            }
                            hv_MetaInfo.Dispose();
                            HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
                            hv_WindowImageRatioHeight.Dispose();
                            HOperatorSet.GetDictTuple(hv_MetaInfo, "classification_both_window_image_ratio_height",
                                out hv_WindowImageRatioHeight);
                            hv_WindowImageRatioWidth.Dispose();
                            HOperatorSet.GetDictTuple(hv_MetaInfo, "classification_both_window_image_ratio_width",
                                out hv_WindowImageRatioWidth);
                            hv_BoarderOffsetRow.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_BoarderOffsetRow = hv_BoarderOffset / hv_WindowImageRatioHeight;
                            }
                            hv_BoarderOffsetCol.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_BoarderOffsetCol = hv_BoarderOffset / hv_WindowImageRatioWidth;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_PredictionColorFrame.Dispose();
                                HOperatorSet.GenContourPolygonXld(out ho_PredictionColorFrame, ((((((((hv_BoarderOffsetRow - 0.5)).TupleConcat(
                                    hv_BoarderOffsetRow - 0.5))).TupleConcat((hv_HeightImage + 0.5) - hv_BoarderOffsetRow))).TupleConcat(
                                    (hv_HeightImage + 0.5) - hv_BoarderOffsetRow))).TupleConcat(hv_BoarderOffsetRow - 0.5),
                                    ((((((((hv_BoarderOffsetCol - 0.5)).TupleConcat((hv_WidthImage + 0.5) - hv_BoarderOffsetCol))).TupleConcat(
                                    (hv_WidthImage + 0.5) - hv_BoarderOffsetCol))).TupleConcat(hv_BoarderOffsetCol - 0.5))).TupleConcat(
                                    hv_BoarderOffsetCol - 0.5));
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 7);
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_PredictionColor);
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_PredictionColorFrame, HDevWindowStack.GetActive()
                                    );
                            }
                        }
                        else
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                            }
                        }
                        //
                        if ((int)(hv_ShowClassificationIDs) != 0)
                        {
                            hv_MetaInfo.Dispose();
                            HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_MarginBottom.Dispose();
                                HOperatorSet.GetDictTuple(hv_MetaInfo, (hv_KeysForDisplay.TupleSelect(
                                    hv_KeyIndex)) + "_margin_bottom", out hv_MarginBottom);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowCoordinates.Dispose();
                                HOperatorSet.GetDictTuple(hv_MetaInfo, (hv_KeysForDisplay.TupleSelect(
                                    hv_KeyIndex)) + "_window_coordinates", out hv_WindowCoordinates);
                            }
                            hv_CurrentWindowHeight.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_CurrentWindowHeight = (hv_WindowCoordinates.TupleSelect(
                                    3)) - (hv_WindowCoordinates.TupleSelect(0));
                            }
                            hv__.Dispose(); hv__.Dispose(); hv__.Dispose(); hv_MaxHeight.Dispose();
                            HOperatorSet.GetFontExtents(hv_CurrentWindowHandle, out hv__, out hv__,
                                out hv__, out hv_MaxHeight);
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "GT label ID: " + hv_ClassificationLabelIDGroundTruth;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", "white", "box", "false");
                            }
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Result class ID: " + hv_ClassificationLabelIDResult;
                            }
                            if ((int)(hv_ShowBottomDesc) != 0)
                            {
                                if (HDevWindowStack.IsOpen())
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                            hv_CurrentWindowHeight - ((hv_MarginBottom + hv_MaxHeight) + 10), "left",
                                            "white", "box", "false");
                                    }
                                }
                            }
                            else
                            {
                                if (HDevWindowStack.IsOpen())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                        "bottom", "left", "white", "box", "false");
                                }
                            }
                        }
                        //
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Result/Ground truth classification " + hv_ImageIDStringBraces;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Ground truth class ID " + hv_ImageIDStringBraces;
                            }
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = hv_ClassesLegend.TupleSelect(
                                hv_ClassificationLabelIDGroundTruth);
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Result class ID";
                            if ((int)(new HTuple(hv_ClassificationLabelIDResult.TupleEqual(new HTuple()))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "No classification result is given!";
                            }
                            else
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_ClassesLegend.TupleSelect(
                                    hv_ClassificationLabelIDResult);
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Prediction ";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_PredictionText;
                            }
                            //
                            //Get or open next child window.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_LineColors.Dispose();
                                HOperatorSet.TupleGenConst(new HTuple(hv_Text.TupleLength()), "white",
                                    out hv_LineColors);
                            }
                            if (hv_LineColors == null)
                                hv_LineColors = new HTuple();
                            hv_LineColors[1] = hv_Colors.TupleSelect(hv_ClassificationLabelIDGroundTruth);
                            if ((int)(new HTuple(hv_ClassificationLabelIDResult.TupleNotEqual(new HTuple()))) != 0)
                            {
                                if (hv_LineColors == null)
                                    hv_LineColors = new HTuple();
                                hv_LineColors[5] = hv_Colors.TupleSelect(hv_ClassificationLabelIDResult);
                                if (hv_LineColors == null)
                                    hv_LineColors = new HTuple();
                                hv_LineColors[9] = hv_PredictionColor;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", hv_LineColors, "box", "false");
                            }
                        }
                        //
                    }
                    else if ((int)((new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "heatmap_grad_cam"))).TupleOr(new HTuple(((hv_KeysForDisplay.TupleSelect(
                        hv_KeyIndex))).TupleEqual("heatmap_confidence_based")))) != 0)
                    {
                        //
                        //Display the heatmap image (method 'heatmap_grad_cam' or 'heatmap_confidence_based')
                        //in the selected color scheme.
                        //Retrieve heatmap image, inferred image, and inference results.
                        hv_SelectedHeatmapMethod.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_SelectedHeatmapMethod = hv_KeysForDisplay.TupleSelect(
                                hv_KeyIndex);
                        }
                        if ((int)((new HTuple(((hv_ResultKeys.TupleFind("heatmap_grad_cam"))).TupleNotEqual(
                            -1))).TupleOr(new HTuple(((hv_ResultKeys.TupleFind("heatmap_confidence_based"))).TupleNotEqual(
                            -1)))) != 0)
                        {
                            if ((int)(new HTuple(hv_SelectedHeatmapMethod.TupleEqual("heatmap_grad_cam"))) != 0)
                            {
                                hv_DictHeatmap.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLResult, "heatmap_grad_cam", out hv_DictHeatmap);
                                hv_MethodName.Dispose();
                                hv_MethodName = "Grad-CAM";
                            }
                            else
                            {
                                hv_DictHeatmap.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLResult, "heatmap_confidence_based",
                                    out hv_DictHeatmap);
                                hv_MethodName.Dispose();
                                hv_MethodName = "Confidence based";
                            }
                            hv_HeatmapKeys.Dispose();
                            HOperatorSet.GetDictParam(hv_DictHeatmap, "keys", new HTuple(), out hv_HeatmapKeys);
                            hv_HeatmapImageName.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_HeatmapImageName = hv_HeatmapKeys.TupleRegexpSelect(
                                    "heatmap_image_class_[0-9]*");
                            }
                            hv_TargetClassID.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TargetClassID = hv_HeatmapImageName.TupleRegexpMatch(
                                    "heatmap_image_class_([0-9]+)$");
                            }
                            ho_ImageHeatmap.Dispose();
                            HOperatorSet.GetDictObject(out ho_ImageHeatmap, hv_DictHeatmap, hv_HeatmapImageName);
                        }
                        else
                        {
                            throw new HalconException("Heatmap image could not be found in DLResult.");
                        }
                        //
                        if ((int)(new HTuple(hv_SelectedHeatmapMethod.TupleEqual("heatmap_grad_cam"))) != 0)
                        {
                            //Read in input image.
                            ho_Image.Dispose();
                            HOperatorSet.GetDictObject(out ho_Image, hv_DLSample, "image");
                            //Add the heatmap to the input image.
                            {
                                HObject ExpTmpOutVar_0;
                                add_colormap_to_image(ho_ImageHeatmap, ho_Image, out ExpTmpOutVar_0,
                                    hv_HeatmapColorScheme);
                                ho_ImageHeatmap.Dispose();
                                ho_ImageHeatmap = ExpTmpOutVar_0;
                            }
                        }
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_ImageHeatmap, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_ImageHeatmap, HDevWindowStack.GetActive());
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Classification heatmap " + hv_ImageIDStringBraces;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            hv_ClassNames.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLResult, "classification_class_names",
                                out hv_ClassNames);
                            hv_ClassIDs.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLResult, "classification_class_ids", out hv_ClassIDs);
                            hv_Confidences.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLResult, "classification_confidences",
                                out hv_Confidences);
                            if ((int)(new HTuple(hv_SelectedHeatmapMethod.TupleEqual("heatmap_confidence_based"))) != 0)
                            {
                                hv_MaxDeviation.Dispose();
                                HOperatorSet.GetDictTuple(hv_DictHeatmap, "classification_heatmap_maxdeviation",
                                    out hv_MaxDeviation);
                            }
                            hv_ClassificationLabelNameResult.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClassificationLabelNameResult = hv_ClassNames.TupleSelect(
                                    0);
                            }
                            hv_ClassificationLabelIDResult.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClassificationLabelIDResult = hv_ClassIDs.TupleSelect(
                                    0);
                            }
                            hv_TargetClassConfidence.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TargetClassConfidence = hv_Confidences.TupleSelect(
                                    hv_ClassIDs.TupleFind(hv_TargetClassID.TupleNumber()));
                            }
                            hv_Text.Dispose();
                            hv_Text = "--------- ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Image ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "--------- ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("image_label_id"))).TupleNotEqual(
                                -1))) != 0)
                            {
                                hv_ClassificationLabelIDGroundTruth.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLSample, "image_label_id", out hv_ClassificationLabelIDGroundTruth);
                                hv_ClassificationLabelNamesGroundTruth.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLDatasetInfo, "class_names", out hv_ClassificationLabelNamesGroundTruth);
                                //Get prediction color.
                                if ((int)(new HTuple(hv_ClassificationLabelIDGroundTruth.TupleEqual(
                                    hv_ClassificationLabelIDResult))) != 0)
                                {
                                    hv_PredictionColor.Dispose();
                                    hv_PredictionColor = "green";
                                }
                                else
                                {
                                    hv_PredictionColor.Dispose();
                                    hv_PredictionColor = "red";
                                }
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Ground truth class: ";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_ClassificationLabelNamesGroundTruth.TupleSelect(
                                    hv_ClassificationLabelIDGroundTruth);
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            }
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Predicted class: ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = hv_ClassificationLabelNameResult;
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Confidence: " + (((hv_Confidences.TupleSelect(
                                0))).TupleString(".2f"));
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "--------- ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Heatmap ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "--------- ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Method: " + hv_MethodName;
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Target class: " + hv_TargetClassID;
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Target class confidence: " + (hv_TargetClassConfidence.TupleString(
                                ".2f"));
                            if ((int)(new HTuple(hv_SelectedHeatmapMethod.TupleEqual("heatmap_confidence_based"))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Maximum deviation: " + (hv_MaxDeviation.TupleString(
                                    ".2f"));
                            }
                            //
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_LineColors.Dispose();
                                HOperatorSet.TupleGenConst(new HTuple(hv_Text.TupleLength()), "white",
                                    out hv_LineColors);
                            }
                            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("image_label_id"))).TupleNotEqual(
                                -1))) != 0)
                            {
                                if (hv_LineColors == null)
                                    hv_LineColors = new HTuple();
                                hv_LineColors[8] = hv_PredictionColor;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", hv_LineColors, "box", "false");
                            }
                        }
                        //
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "segmentation_weight"))) != 0)
                    {
                        //
                        //Weight image.
                        ho_ImageWeight.Dispose();
                        get_weight_image(out ho_ImageWeight, hv_SampleKeys, hv_DLSample);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_ImageWeight, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_ImageWeight, HDevWindowStack.GetActive());
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Weight image " + hv_ImageIDStringBraces,
                                        "window", "bottom", "left", "white", "box", "false");
                                }
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "segmentation_confidence"))) != 0)
                    {
                        //
                        //Segmentation confidences.
                        ho_ImageConfidence.Dispose();
                        get_confidence_image(out ho_ImageConfidence, hv_ResultKeys, hv_DLResult);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_ImageConfidence, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_ImageConfidence, HDevWindowStack.GetActive());
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Confidence image " + hv_ImageIDStringBraces,
                                        "window", "bottom", "left", "white", "box", "false");
                                }
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "bbox_ground_truth"))) != 0)
                    {
                        //
                        //Sample bounding boxes on image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        hv_BboxIDs.Dispose();
                        dev_display_ground_truth_detection(hv_DLSample, hv_SampleKeys, hv_LineWidth,
                            hv_ClassIDs, hv_Colors, hv_BboxLabelColor, hv_BboxTextColor, hv_ShowLabels,
                            hv_ShowDirection, hv_CurrentWindowHandle, out hv_BboxIDs);
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Ground truth " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            hv_BboxColors.Dispose();
                            hv_BboxColors = "white";
                            if ((int)(new HTuple(hv_BboxIDs.TupleLength())) != 0)
                            {
                                hv_BboxIDsUniq.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_BboxIDsUniq = ((hv_BboxIDs.TupleSort()
                                        )).TupleUniq();
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                            hv_ClassesLegend.TupleSelect(hv_BboxIDsUniq));
                                        hv_Text.Dispose();
                                        hv_Text = ExpTmpLocalVar_Text;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_BboxColors = hv_BboxColors.TupleConcat(
                                            hv_Colors.TupleSelect(hv_BboxIDsUniq));
                                        hv_BboxColors.Dispose();
                                        hv_BboxColors = ExpTmpLocalVar_BboxColors;
                                    }
                                }
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                            "No ground truth bounding boxes present.");
                                        hv_Text.Dispose();
                                        hv_Text = ExpTmpLocalVar_Text;
                                    }
                                }
                            }
                            //
                            //Get or open next child window.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", hv_BboxColors, "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "bbox_result"))) != 0)
                    {
                        //
                        //Result bounding boxes on image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        if ((int)(new HTuple(((hv_ResultKeys.TupleFind("bbox_confidence"))).TupleNotEqual(
                            -1))) != 0)
                        {
                            hv_BboxConfidences.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLResult, "bbox_confidence", out hv_BboxConfidences);
                        }
                        else
                        {
                            throw new HalconException("Result bounding box data could not be found in DLResult.");
                        }
                        if ((int)(hv_BboxDisplayConfidence) != 0)
                        {
                            hv_TextConf.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TextConf = (" (" + (hv_BboxConfidences.TupleString(
                                    ".2f"))) + ")";
                            }
                        }
                        else
                        {
                            hv_TextConf.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TextConf = HTuple.TupleGenConst(
                                    new HTuple(hv_BboxConfidences.TupleLength()), "");
                            }
                        }
                        hv_BboxClassIndex.Dispose();
                        dev_display_result_detection(hv_DLResult, hv_ResultKeys, hv_LineWidth,
                            hv_ClassIDs, hv_TextConf, hv_Colors, hv_BboxLabelColor, hv_WindowImageRatio,
                            "top", hv_BboxTextColor, hv_ShowLabels, hv_ShowDirection, hv_CurrentWindowHandle,
                            out hv_BboxClassIndex);
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Result bounding boxes " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            hv_BboxColorsResults.Dispose();
                            hv_BboxColorsResults = "white";
                            if ((int)(new HTuple((new HTuple(hv_BboxClassIndex.TupleLength())).TupleGreater(
                                0))) != 0)
                            {
                                hv_BboxClassIndexUniq.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_BboxClassIndexUniq = ((hv_BboxClassIndex.TupleSort()
                                        )).TupleUniq();
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                            hv_ClassesLegend.TupleSelect(hv_BboxClassIndexUniq));
                                        hv_Text.Dispose();
                                        hv_Text = ExpTmpLocalVar_Text;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_BboxColorsResults = hv_BboxColorsResults.TupleConcat(
                                            hv_Colors.TupleSelect(hv_BboxClassIndexUniq));
                                        hv_BboxColorsResults.Dispose();
                                        hv_BboxColorsResults = ExpTmpLocalVar_BboxColorsResults;
                                    }
                                }
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                            "No result bounding boxes present.");
                                        hv_Text.Dispose();
                                        hv_Text = ExpTmpLocalVar_Text;
                                    }
                                }
                            }
                            //
                            //Get or open next child window.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", hv_BboxColorsResults, "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "bbox_both"))) != 0)
                    {
                        //
                        //Ground truth and result bounding boxes on image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        //Visualization.
                        hv_BboxLabelIndex.Dispose();
                        dev_display_ground_truth_detection(hv_DLSample, hv_SampleKeys, hv_LineWidth,
                            hv_ClassIDs, hv_Colors, hv_BboxLabelColor, hv_BboxTextColor, hv_ShowLabels,
                            hv_ShowDirection, hv_CurrentWindowHandle, out hv_BboxLabelIndex);
                        if ((int)(new HTuple(((hv_ResultKeys.TupleFind("bbox_confidence"))).TupleNotEqual(
                            -1))) != 0)
                        {
                            hv_BboxConfidences.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLResult, "bbox_confidence", out hv_BboxConfidences);
                        }
                        else
                        {
                            throw new HalconException("Result bounding box data could not be found in DLResult.");
                        }
                        if ((int)(hv_BboxDisplayConfidence) != 0)
                        {
                            hv_TextConf.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TextConf = (" (" + (hv_BboxConfidences.TupleString(
                                    ".2f"))) + ")";
                            }
                        }
                        else
                        {
                            hv_TextConf.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TextConf = HTuple.TupleGenConst(
                                    new HTuple(hv_BboxConfidences.TupleLength()), "");
                            }
                        }
                        hv_BboxClassIndex.Dispose();
                        dev_display_result_detection(hv_DLResult, hv_ResultKeys, hv_LineWidth,
                            hv_ClassIDs, hv_TextConf, hv_Colors, hv_BboxLabelColor, hv_WindowImageRatio,
                            "bottom", hv_BboxTextColor, hv_ShowLabels, hv_ShowDirection, hv_CurrentWindowHandle,
                            out hv_BboxClassIndex);
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Ground truth and result bounding boxes " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        hv_Text.Dispose();
                        hv_Text = "Ground truth and";
                        if (hv_Text == null)
                            hv_Text = new HTuple();
                        hv_Text[new HTuple(hv_Text.TupleLength())] = "result bounding boxes " + hv_ImageIDStringBraces;
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            hv_BboxColorsBoth.Dispose();
                            hv_BboxColorsBoth = new HTuple();
                            hv_BboxColorsBoth[0] = "white";
                            hv_BboxColorsBoth[1] = "white";
                            if ((int)(new HTuple((new HTuple((new HTuple(hv_BboxClassIndex.TupleLength()
                                )) + (new HTuple(hv_BboxLabelIndex.TupleLength())))).TupleGreater(0))) != 0)
                            {
                                hv_BboxClassLabelIndexUniq.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_BboxClassLabelIndexUniq = ((((hv_BboxClassIndex.TupleConcat(
                                        hv_BboxLabelIndex))).TupleSort())).TupleUniq();
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                            hv_ClassesLegend.TupleSelect(hv_BboxClassLabelIndexUniq));
                                        hv_Text.Dispose();
                                        hv_Text = ExpTmpLocalVar_Text;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_BboxColorsBoth = hv_BboxColorsBoth.TupleConcat(
                                            hv_Colors.TupleSelect(hv_BboxClassLabelIndexUniq));
                                        hv_BboxColorsBoth.Dispose();
                                        hv_BboxColorsBoth = ExpTmpLocalVar_BboxColorsBoth;
                                    }
                                }
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                            "No ground truth nor result bounding boxes present.");
                                        hv_Text.Dispose();
                                        hv_Text = ExpTmpLocalVar_Text;
                                    }
                                }
                            }
                            //
                            //Get or open next child window.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", hv_BboxColorsBoth, "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "segmentation_image_ground_truth"))) != 0)
                    {
                        //
                        //Ground truth segmentation image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        ho_SegmentationImagGroundTruth.Dispose();
                        get_segmentation_image_ground_truth(out ho_SegmentationImagGroundTruth,
                            hv_SampleKeys, hv_DLSample);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        //Display segmentation regions.
                        hv_ColorsSegmentation.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ColorsSegmentation = hv_Colors + hv_SegTransparency;
                        }
                        hv_DrawMode.Dispose();
                        HOperatorSet.GetDraw(hv_CurrentWindowHandle, out hv_DrawMode);
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_SegDraw);
                        }
                        hv_Width.Dispose();
                        HOperatorSet.GetLineWidth(hv_CurrentWindowHandle, out hv_Width);
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidth);
                        }
                        hv_ImageClassIDs.Dispose();
                        dev_display_segmentation_regions(ho_SegmentationImagGroundTruth, hv_ClassIDs,
                            hv_ColorsSegmentation, hv_SegExcludeClassIDs, out hv_ImageClassIDs);
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_Width.TupleInt()
                                    );
                            }
                        }
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Ground truth segmentation " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            hv_ImageClassIDsUniq.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ImageClassIDsUniq = ((hv_ImageClassIDs.TupleSort()
                                    )).TupleUniq();
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                        hv_ClassesLegend.TupleSelect(hv_ImageClassIDsUniq));
                                    hv_Text.Dispose();
                                    hv_Text = ExpTmpLocalVar_Text;
                                }
                            }
                            //
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                        "top", "left", (new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                                        hv_ImageClassIDsUniq)), "box", "false");
                                }
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "segmentation_image_result"))) != 0)
                    {
                        //
                        //Result segmentation on image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        ho_SegmentationImageResult.Dispose();
                        get_segmentation_image_result(out ho_SegmentationImageResult, hv_ResultKeys,
                            hv_DLResult);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        //Display result segmentation regions.
                        hv_ColorsResults.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ColorsResults = hv_Colors + hv_SegTransparency;
                        }
                        hv_DrawMode.Dispose();
                        HOperatorSet.GetDraw(hv_CurrentWindowHandle, out hv_DrawMode);
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_SegDraw);
                        }
                        hv_Width.Dispose();
                        HOperatorSet.GetLineWidth(hv_CurrentWindowHandle, out hv_Width);
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidth);
                        }
                        hv_ImageClassIDs.Dispose();
                        dev_display_segmentation_regions(ho_SegmentationImageResult, hv_ClassIDs,
                            hv_ColorsResults, hv_SegExcludeClassIDs, out hv_ImageClassIDs);
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_Width.TupleInt()
                                    );
                            }
                        }
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Result segmentation " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            hv_ImageClassIDsUniq.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ImageClassIDsUniq = ((hv_ImageClassIDs.TupleSort()
                                    )).TupleUniq();
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                        hv_ClassesLegend.TupleSelect(hv_ImageClassIDsUniq));
                                    hv_Text.Dispose();
                                    hv_Text = ExpTmpLocalVar_Text;
                                }
                            }
                            //
                            //Get or open next child window.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                        "top", "left", (new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                                        hv_ImageClassIDsUniq)), "box", "false");
                                }
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "segmentation_image_both"))) != 0)
                    {
                        //
                        //Ground truth and result segmentation on image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        ho_SegmentationImagGroundTruth.Dispose();
                        get_segmentation_image_ground_truth(out ho_SegmentationImagGroundTruth,
                            hv_SampleKeys, hv_DLSample);
                        ho_SegmentationImageResult.Dispose();
                        get_segmentation_image_result(out ho_SegmentationImageResult, hv_ResultKeys,
                            hv_DLResult);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        //Display regions.
                        hv_ColorsResults.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ColorsResults = hv_Colors + hv_SegTransparency;
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 2);
                        }
                        hv_GroundTruthIDs.Dispose();
                        dev_display_segmentation_regions(ho_SegmentationImagGroundTruth, hv_ClassIDs,
                            hv_ColorsResults, hv_SegExcludeClassIDs, out hv_GroundTruthIDs);
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 6);
                        }
                        hv_ResultIDs.Dispose();
                        dev_display_segmentation_regions(ho_SegmentationImageResult, hv_ClassIDs,
                            hv_ColorsResults, hv_SegExcludeClassIDs, out hv_ResultIDs);
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
                        }
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Ground truth and result segmentation " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            hv_ImageClassIDsUniq.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ImageClassIDsUniq = ((((hv_GroundTruthIDs.TupleConcat(
                                    hv_ResultIDs))).TupleSort())).TupleUniq();
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                        hv_ClassesLegend.TupleSelect(hv_ImageClassIDsUniq));
                                    hv_Text.Dispose();
                                    hv_Text = ExpTmpLocalVar_Text;
                                }
                            }
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[(new HTuple(hv_Text.TupleLength())) + 1] = new HTuple("- thicker line: result, thinner lines: ground truth");
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "  (you may have to zoom in for a more detailed view)";
                            hv_StringSegExcludeClassIDs.Dispose();
                            hv_StringSegExcludeClassIDs = "";
                            for (hv_StringIndex = 0; (int)hv_StringIndex <= (int)((new HTuple(hv_SegExcludeClassIDs.TupleLength()
                                )) - 1); hv_StringIndex = (int)hv_StringIndex + 1)
                            {
                                if ((int)(new HTuple(hv_StringIndex.TupleEqual((new HTuple(hv_SegExcludeClassIDs.TupleLength()
                                    )) - 1))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_StringSegExcludeClassIDs = hv_StringSegExcludeClassIDs + (hv_SegExcludeClassIDs.TupleSelect(
                                                hv_StringIndex));
                                            hv_StringSegExcludeClassIDs.Dispose();
                                            hv_StringSegExcludeClassIDs = ExpTmpLocalVar_StringSegExcludeClassIDs;
                                        }
                                    }
                                }
                                else
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_StringSegExcludeClassIDs = (hv_StringSegExcludeClassIDs + (hv_SegExcludeClassIDs.TupleSelect(
                                                hv_StringIndex))) + new HTuple(", ");
                                            hv_StringSegExcludeClassIDs.Dispose();
                                            hv_StringSegExcludeClassIDs = ExpTmpLocalVar_StringSegExcludeClassIDs;
                                        }
                                    }
                                }
                            }
                            if ((int)(new HTuple(hv_SegExcludeClassIDs.TupleNotEqual(new HTuple()))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = ("- (excluded classID(s) " + hv_StringSegExcludeClassIDs) + " from visualization)";
                            }
                            //
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                        "top", "left", (((new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                                        hv_ImageClassIDsUniq)))).TupleConcat(((new HTuple("white")).TupleConcat(
                                        "white")).TupleConcat("white")), "box", "false");
                                }
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "segmentation_image_diff"))) != 0)
                    {
                        //
                        //Difference of ground truth and result segmentation on image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        ho_SegmentationImagGroundTruth.Dispose();
                        get_segmentation_image_ground_truth(out ho_SegmentationImagGroundTruth,
                            hv_SampleKeys, hv_DLSample);
                        ho_SegmentationImageResult.Dispose();
                        get_segmentation_image_result(out ho_SegmentationImageResult, hv_ResultKeys,
                            hv_DLResult);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        ho_ImageAbsDiff.Dispose();
                        HOperatorSet.AbsDiffImage(ho_SegmentationImagGroundTruth, ho_SegmentationImageResult,
                            out ho_ImageAbsDiff, 1);
                        hv_Min.Dispose(); hv_Max.Dispose(); hv_Range.Dispose();
                        HOperatorSet.MinMaxGray(ho_SegmentationImageResult, ho_ImageAbsDiff, 0,
                            out hv_Min, out hv_Max, out hv_Range);
                        if ((int)(new HTuple(hv_Min.TupleNotEqual(hv_Max))) != 0)
                        {
                            ho_DiffRegion.Dispose();
                            HOperatorSet.Threshold(ho_ImageAbsDiff, out ho_DiffRegion, 0.00001, hv_Max);
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetColor(HDevWindowStack.GetActive(), "#ff0000" + hv_SegTransparency);
                                }
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_DiffRegion, HDevWindowStack.GetActive());
                            }
                        }
                        else
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), "No difference found.",
                                    "window", "top", "left", "black", new HTuple(), new HTuple());
                            }
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Difference of ground truth and result segmentation " + hv_ImageIDStringBraces;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "segmentation_weight_map"))) != 0)
                    {
                        //
                        //Weight map on image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        ho_ImageWeight.Dispose();
                        get_weight_image(out ho_ImageWeight, hv_SampleKeys, hv_DLSample);
                        //
                        if ((int)(new HTuple(hv_SegMaxWeight.TupleEqual(0))) != 0)
                        {
                            //Calculate SegMaxWeight if not given in GenParam.
                            hv_MinWeight.Dispose(); hv_SegMaxWeight.Dispose(); hv_Range.Dispose();
                            HOperatorSet.MinMaxGray(ho_ImageWeight, ho_ImageWeight, 0, out hv_MinWeight,
                                out hv_SegMaxWeight, out hv_Range);
                        }
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, hv_MapColorBarWidth, hv_ScaleWindows, hv_ThresholdWidth,
                                hv_PrevWindowCoordinates, hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(
                                hv_KeyIndex), out hv_CurrentWindowHandle, out hv_WindowImageRatio,
                                out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        hv_WeightsColors.Dispose();
                        dev_display_weight_regions(ho_ImageWeight, hv_MapTransparency, hv_SegMaxWeight,
                            out hv_WeightsColors);
                        dev_display_map_color_bar(hv_WidthImage, hv_HeightImage, hv_MapColorBarWidth,
                            hv_WeightsColors, hv_SegMaxWeight, hv_WindowImageRatio, hv_CurrentWindowHandle);
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Weight map " + hv_ImageIDStringBraces,
                                        "window", "bottom", "left", "white", "box", "false");
                                }
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "segmentation_confidence_map"))) != 0)
                    {
                        //
                        //Segmentation confidence map on image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        ho_ImageConfidence.Dispose();
                        get_confidence_image(out ho_ImageConfidence, hv_ResultKeys, hv_DLResult);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, hv_MapColorBarWidth, hv_ScaleWindows, hv_ThresholdWidth,
                                hv_PrevWindowCoordinates, hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(
                                hv_KeyIndex), out hv_CurrentWindowHandle, out hv_WindowImageRatio,
                                out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        hv_ConfidenceColors.Dispose();
                        dev_display_confidence_regions(ho_ImageConfidence, hv_MapTransparency,
                            out hv_ConfidenceColors);
                        dev_display_map_color_bar(hv_WidthImage, hv_HeightImage, hv_MapColorBarWidth,
                            hv_ConfidenceColors, 1.0, hv_WindowImageRatio, hv_CurrentWindowHandle);
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Confidence map " + hv_ImageIDStringBraces,
                                        "window", "bottom", "left", "white", "box", "false");
                                }
                            }
                        }
                    }
                    else
                    {
                        //Reset flush buffer of existing windows before throwing an exception.
                        hv_WindowHandleKeys.Dispose();
                        HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_WindowHandleKeys);
                        for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_WindowHandleKeys.TupleLength()
                            )) - 1); hv_Index = (int)hv_Index + 1)
                        {
                            //Only consider the WindowHandleKeys that are needed for the current visualization.
                            hv_Indices.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Indices = hv_KeysForDisplay.TupleFind(
                                    hv_WindowHandleKeys.TupleSelect(hv_Index));
                            }
                            if ((int)((new HTuple(hv_Indices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_Indices.TupleNotEqual(
                                new HTuple())))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_WindowHandles.Dispose();
                                    HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKeys.TupleSelect(
                                        hv_Index), out hv_WindowHandles);
                                }
                                for (hv_WindowIndex = 0; (int)hv_WindowIndex <= (int)((new HTuple(hv_WindowHandles.TupleLength()
                                    )) - 1); hv_WindowIndex = (int)hv_WindowIndex + 1)
                                {
                                    //Reset values of windows that have been changed temporarily.
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex),
                                            "flush", hv_FlushValues.TupleSelect(hv_Index));
                                    }
                                }
                            }
                        }
                        throw new HalconException("Key for display unknown: " + (hv_KeysForDisplay.TupleSelect(
                            hv_KeyIndex)));
                    }
                }
                //
                //Display results.
                hv_WindowHandleKeysNew.Dispose();
                HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_WindowHandleKeysNew);
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_WindowHandleKeysNew.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    //Only consider the WindowHandleKeys that are needed for the current visualization.
                    hv_KeyIndex.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_KeyIndex = hv_KeysForDisplay.TupleFind(
                            hv_WindowHandleKeysNew.TupleSelect(hv_Index));
                    }
                    if ((int)((new HTuple(hv_KeyIndex.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_KeyIndex.TupleNotEqual(
                        new HTuple())))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_WindowHandles.Dispose();
                            HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKeysNew.TupleSelect(
                                hv_Index), out hv_WindowHandles);
                        }
                        for (hv_WindowIndex = 0; (int)hv_WindowIndex <= (int)((new HTuple(hv_WindowHandles.TupleLength()
                            )) - 1); hv_WindowIndex = (int)hv_WindowIndex + 1)
                        {
                            //Display content of window handle.
                            if ((int)(new HTuple((new HTuple(hv_WindowHandleKeys.TupleLength())).TupleEqual(
                                new HTuple(hv_WindowHandleKeysNew.TupleLength())))) != 0)
                            {
                                //Reset values of windows that have been changed temporarily.
                                if ((int)(new HTuple(((hv_FlushValues.TupleSelect(hv_WindowIndex))).TupleEqual(
                                    "true"))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.FlushBuffer(hv_WindowHandles.TupleSelect(hv_WindowIndex));
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex),
                                        "flush", hv_FlushValues.TupleSelect(hv_WindowIndex));
                                }
                            }
                            else
                            {
                                //Per default, 'flush' of new windows should be set to 'true'.
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.FlushBuffer(hv_WindowHandles.TupleSelect(hv_WindowIndex));
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex),
                                        "flush", "true");
                                }
                            }
                        }
                    }
                }
                //
                ho_Image.Dispose();
                ho_AnomalyImage.Dispose();
                ho_AnomalyRegion.Dispose();
                ho_PredictionColorFrame.Dispose();
                ho_ImageHeatmap.Dispose();
                ho_ImageWeight.Dispose();
                ho_ImageConfidence.Dispose();
                ho_SegmentationImagGroundTruth.Dispose();
                ho_SegmentationImageResult.Dispose();
                ho_ImageAbsDiff.Dispose();
                ho_DiffRegion.Dispose();

                hv_ThresholdWidth.Dispose();
                hv_ScaleWindows.Dispose();
                hv_Font.Dispose();
                hv_FontSize.Dispose();
                hv_LineWidth.Dispose();
                hv_MapTransparency.Dispose();
                hv_MapColorBarWidth.Dispose();
                hv_AnomalyRegionThreshold.Dispose();
                hv_AnomalyClassificationThreshold.Dispose();
                hv_AnomalyRegionLabelColor.Dispose();
                hv_AnomalyColorTransparency.Dispose();
                hv_AnomalyRegionResultColor.Dispose();
                hv_SegMaxWeight.Dispose();
                hv_SegDraw.Dispose();
                hv_SegTransparency.Dispose();
                hv_SegExcludeClassIDs.Dispose();
                hv_BboxLabelColor.Dispose();
                hv_BboxDisplayConfidence.Dispose();
                hv_BboxTextColor.Dispose();
                hv_ShowBottomDesc.Dispose();
                hv_ShowLegend.Dispose();
                hv_ShowGroundTruthAnomalyRegions.Dispose();
                hv_ShowClassificationIDs.Dispose();
                hv_ShowClassificationColorFrame.Dispose();
                hv_ShowLabels.Dispose();
                hv_ShowDirection.Dispose();
                hv_HeatmapColorScheme.Dispose();
                hv_GenParamNames.Dispose();
                hv_ParamIndex.Dispose();
                hv_GenParamName.Dispose();
                hv_GenParamValue.Dispose();
                hv_SampleKeys.Dispose();
                hv_ResultKeys.Dispose();
                hv_ImageIDExists.Dispose();
                hv_ImageID.Dispose();
                hv_ImageIDString.Dispose();
                hv_ImageIDStringBraces.Dispose();
                hv_ImageIDStringCapital.Dispose();
                hv_NeededKeys.Dispose();
                hv_Index.Dispose();
                hv_DLDatasetInfoKeys.Dispose();
                hv_ClassNames.Dispose();
                hv_ClassIDs.Dispose();
                hv_Colors.Dispose();
                hv_ClassesLegend.Dispose();
                hv_PrevWindowCoordinates.Dispose();
                hv_Keys.Dispose();
                hv_Exception.Dispose();
                hv_MetaInfoIndex.Dispose();
                hv_MetaInfo.Dispose();
                hv_FlushValues.Dispose();
                hv_WindowHandleKeys.Dispose();
                hv_KeyIndex.Dispose();
                hv_WindowHandles.Dispose();
                hv_WindowIndex.Dispose();
                hv_FlushValue.Dispose();
                hv_WidthImage.Dispose();
                hv_HeightImage.Dispose();
                hv_CurrentWindowHandle.Dispose();
                hv_WindowImageRatio.Dispose();
                hv_AnomalyLabelGroundTruth.Dispose();
                hv_AnomalyLabelIDGroundTruth.Dispose();
                hv_AnomalyRegionExists.Dispose();
                hv_Text.Dispose();
                hv_AnomalyScore.Dispose();
                hv_AnomalyClassID.Dispose();
                hv_AnomalyRegionGroundTruthExists.Dispose();
                hv_PredictionColor.Dispose();
                hv_LineColors.Dispose();
                hv_ClassificationLabelIDGroundTruth.Dispose();
                hv_ClassificationLabelIDResult.Dispose();
                hv_MarginBottom.Dispose();
                hv_WindowCoordinates.Dispose();
                hv_CurrentWindowHeight.Dispose();
                hv__.Dispose();
                hv_MaxHeight.Dispose();
                hv_PredictionText.Dispose();
                hv_BoarderOffset.Dispose();
                hv_WindowImageRatioHeight.Dispose();
                hv_WindowImageRatioWidth.Dispose();
                hv_BoarderOffsetRow.Dispose();
                hv_BoarderOffsetCol.Dispose();
                hv_SelectedHeatmapMethod.Dispose();
                hv_DictHeatmap.Dispose();
                hv_MethodName.Dispose();
                hv_HeatmapKeys.Dispose();
                hv_HeatmapImageName.Dispose();
                hv_TargetClassID.Dispose();
                hv_Confidences.Dispose();
                hv_MaxDeviation.Dispose();
                hv_ClassificationLabelNameResult.Dispose();
                hv_TargetClassConfidence.Dispose();
                hv_ClassificationLabelNamesGroundTruth.Dispose();
                hv_BboxIDs.Dispose();
                hv_BboxColors.Dispose();
                hv_BboxIDsUniq.Dispose();
                hv_BboxConfidences.Dispose();
                hv_TextConf.Dispose();
                hv_BboxClassIndex.Dispose();
                hv_BboxColorsResults.Dispose();
                hv_BboxClassIndexUniq.Dispose();
                hv_BboxLabelIndex.Dispose();
                hv_BboxColorsBoth.Dispose();
                hv_BboxClassLabelIndexUniq.Dispose();
                hv_ColorsSegmentation.Dispose();
                hv_DrawMode.Dispose();
                hv_Width.Dispose();
                hv_ImageClassIDs.Dispose();
                hv_ImageClassIDsUniq.Dispose();
                hv_ColorsResults.Dispose();
                hv_GroundTruthIDs.Dispose();
                hv_ResultIDs.Dispose();
                hv_StringSegExcludeClassIDs.Dispose();
                hv_StringIndex.Dispose();
                hv_Min.Dispose();
                hv_Max.Dispose();
                hv_Range.Dispose();
                hv_MinWeight.Dispose();
                hv_WeightsColors.Dispose();
                hv_ConfidenceColors.Dispose();
                hv_Indices.Dispose();
                hv_WindowHandleKeysNew.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Image.Dispose();
                ho_AnomalyImage.Dispose();
                ho_AnomalyRegion.Dispose();
                ho_PredictionColorFrame.Dispose();
                ho_ImageHeatmap.Dispose();
                ho_ImageWeight.Dispose();
                ho_ImageConfidence.Dispose();
                ho_SegmentationImagGroundTruth.Dispose();
                ho_SegmentationImageResult.Dispose();
                ho_ImageAbsDiff.Dispose();
                ho_DiffRegion.Dispose();

                hv_ThresholdWidth.Dispose();
                hv_ScaleWindows.Dispose();
                hv_Font.Dispose();
                hv_FontSize.Dispose();
                hv_LineWidth.Dispose();
                hv_MapTransparency.Dispose();
                hv_MapColorBarWidth.Dispose();
                hv_AnomalyRegionThreshold.Dispose();
                hv_AnomalyClassificationThreshold.Dispose();
                hv_AnomalyRegionLabelColor.Dispose();
                hv_AnomalyColorTransparency.Dispose();
                hv_AnomalyRegionResultColor.Dispose();
                hv_SegMaxWeight.Dispose();
                hv_SegDraw.Dispose();
                hv_SegTransparency.Dispose();
                hv_SegExcludeClassIDs.Dispose();
                hv_BboxLabelColor.Dispose();
                hv_BboxDisplayConfidence.Dispose();
                hv_BboxTextColor.Dispose();
                hv_ShowBottomDesc.Dispose();
                hv_ShowLegend.Dispose();
                hv_ShowGroundTruthAnomalyRegions.Dispose();
                hv_ShowClassificationIDs.Dispose();
                hv_ShowClassificationColorFrame.Dispose();
                hv_ShowLabels.Dispose();
                hv_ShowDirection.Dispose();
                hv_HeatmapColorScheme.Dispose();
                hv_GenParamNames.Dispose();
                hv_ParamIndex.Dispose();
                hv_GenParamName.Dispose();
                hv_GenParamValue.Dispose();
                hv_SampleKeys.Dispose();
                hv_ResultKeys.Dispose();
                hv_ImageIDExists.Dispose();
                hv_ImageID.Dispose();
                hv_ImageIDString.Dispose();
                hv_ImageIDStringBraces.Dispose();
                hv_ImageIDStringCapital.Dispose();
                hv_NeededKeys.Dispose();
                hv_Index.Dispose();
                hv_DLDatasetInfoKeys.Dispose();
                hv_ClassNames.Dispose();
                hv_ClassIDs.Dispose();
                hv_Colors.Dispose();
                hv_ClassesLegend.Dispose();
                hv_PrevWindowCoordinates.Dispose();
                hv_Keys.Dispose();
                hv_Exception.Dispose();
                hv_MetaInfoIndex.Dispose();
                hv_MetaInfo.Dispose();
                hv_FlushValues.Dispose();
                hv_WindowHandleKeys.Dispose();
                hv_KeyIndex.Dispose();
                hv_WindowHandles.Dispose();
                hv_WindowIndex.Dispose();
                hv_FlushValue.Dispose();
                hv_WidthImage.Dispose();
                hv_HeightImage.Dispose();
                hv_CurrentWindowHandle.Dispose();
                hv_WindowImageRatio.Dispose();
                hv_AnomalyLabelGroundTruth.Dispose();
                hv_AnomalyLabelIDGroundTruth.Dispose();
                hv_AnomalyRegionExists.Dispose();
                hv_Text.Dispose();
                hv_AnomalyScore.Dispose();
                hv_AnomalyClassID.Dispose();
                hv_AnomalyRegionGroundTruthExists.Dispose();
                hv_PredictionColor.Dispose();
                hv_LineColors.Dispose();
                hv_ClassificationLabelIDGroundTruth.Dispose();
                hv_ClassificationLabelIDResult.Dispose();
                hv_MarginBottom.Dispose();
                hv_WindowCoordinates.Dispose();
                hv_CurrentWindowHeight.Dispose();
                hv__.Dispose();
                hv_MaxHeight.Dispose();
                hv_PredictionText.Dispose();
                hv_BoarderOffset.Dispose();
                hv_WindowImageRatioHeight.Dispose();
                hv_WindowImageRatioWidth.Dispose();
                hv_BoarderOffsetRow.Dispose();
                hv_BoarderOffsetCol.Dispose();
                hv_SelectedHeatmapMethod.Dispose();
                hv_DictHeatmap.Dispose();
                hv_MethodName.Dispose();
                hv_HeatmapKeys.Dispose();
                hv_HeatmapImageName.Dispose();
                hv_TargetClassID.Dispose();
                hv_Confidences.Dispose();
                hv_MaxDeviation.Dispose();
                hv_ClassificationLabelNameResult.Dispose();
                hv_TargetClassConfidence.Dispose();
                hv_ClassificationLabelNamesGroundTruth.Dispose();
                hv_BboxIDs.Dispose();
                hv_BboxColors.Dispose();
                hv_BboxIDsUniq.Dispose();
                hv_BboxConfidences.Dispose();
                hv_TextConf.Dispose();
                hv_BboxClassIndex.Dispose();
                hv_BboxColorsResults.Dispose();
                hv_BboxClassIndexUniq.Dispose();
                hv_BboxLabelIndex.Dispose();
                hv_BboxColorsBoth.Dispose();
                hv_BboxClassLabelIndexUniq.Dispose();
                hv_ColorsSegmentation.Dispose();
                hv_DrawMode.Dispose();
                hv_Width.Dispose();
                hv_ImageClassIDs.Dispose();
                hv_ImageClassIDsUniq.Dispose();
                hv_ColorsResults.Dispose();
                hv_GroundTruthIDs.Dispose();
                hv_ResultIDs.Dispose();
                hv_StringSegExcludeClassIDs.Dispose();
                hv_StringIndex.Dispose();
                hv_Min.Dispose();
                hv_Max.Dispose();
                hv_Range.Dispose();
                hv_MinWeight.Dispose();
                hv_WeightsColors.Dispose();
                hv_ConfidenceColors.Dispose();
                hv_Indices.Dispose();
                hv_WindowHandleKeysNew.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Classification
        // Short Description: This procedure displays a confusion matrix that can be used interactively to display samples. 
        public void dev_display_dl_interactive_confusion_matrix(HTuple hv_DLDataset, HTuple hv_EvaluationResult,
            HTuple hv_GenParam)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_DisplayMatrix = new HTuple(), hv_DisplayColor = new HTuple();
            HTuple hv_DisplayColumnWidth = new HTuple(), hv_Font = new HTuple();
            HTuple hv_FontSize = new HTuple(), hv_GenParamDevData = new HTuple();
            HTuple hv_GenParamKeysOnlyInteractive = new HTuple(), hv_GenParamKeysCommon = new HTuple();
            HTuple hv_GenParamKeysInteractive = new HTuple(), hv_Index = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_DisplayMatrixExists = new HTuple();
            HTuple hv_DisplayColorExists = new HTuple(), hv_DisplayColumnWidthExists = new HTuple();
            HTuple hv_FontExists = new HTuple(), hv_FontSizeExists = new HTuple();
            HTuple hv_ClassNames = new HTuple(), hv_ClassIDs = new HTuple();
            HTuple hv_EvaluatedSamples = new HTuple(), hv_ImageIDs = new HTuple();
            HTuple hv_ImageLabelIDs = new HTuple(), hv_Predictions = new HTuple();
            HTuple hv_KeyExists = new HTuple(), hv_ConfusionMatrix = new HTuple();
            HTuple hv_ValuesRelative = new HTuple(), hv_NumberFormat = new HTuple();
            HTuple hv_MatrixMaxID = new HTuple(), hv_MaxValue = new HTuple();
            HTuple hv_MaxChars = new HTuple(), hv_Str = new HTuple();
            HTuple hv_IsString = new HTuple(), hv_Length = new HTuple();
            HTuple hv_SubStr = new HTuple(), hv_ClassIDsToNamesMapping = new HTuple();
            HTuple hv_ValueColors = new HTuple(), hv_DiagonalColor = new HTuple();
            HTuple hv_Seq = new HTuple(), hv_DiagonalIndices = new HTuple();
            HTuple hv_WindowHandle = new HTuple(), hv_ColumnNames = new HTuple();
            HTuple hv_RowNames = new HTuple(), hv_AxisTitles = new HTuple();
            HTuple hv_NumRows = new HTuple(), hv_NumColumns = new HTuple();
            HTuple hv_AxisColor = new HTuple(), hv_BoxColor = new HTuple();
            HTuple hv_HighlightColor = new HTuple(), hv_ColStringWidths = new HTuple();
            HTuple hv_MinStringWidth = new HTuple(), hv_MaxStringWidth = new HTuple();
            HTuple hv_StringHeight = new HTuple(), hv_StringIndex = new HTuple();
            HTuple hv__ = new HTuple(), hv_StringWidth = new HTuple();
            HTuple hv_StringHeightTmp = new HTuple(), hv_TitleHeight = new HTuple();
            HTuple hv_AxisTitleHeight = new HTuple(), hv_AxisTitleWidth = new HTuple();
            HTuple hv_RowStart = new HTuple(), hv_RowDistance = new HTuple();
            HTuple hv_RowEnd = new HTuple(), hv_ColumnStart = new HTuple();
            HTuple hv_ColumnOffset = new HTuple(), hv_ColumnEnd = new HTuple();
            HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
            HTuple hv_WidthLimit = new HTuple(), hv_HeightLimit = new HTuple();
            HTuple hv_TextRow = new HTuple(), hv_TextColumn = new HTuple();
            HTuple hv_RowStartTmp = new HTuple(), hv_ColumnDistance = new HTuple();
            HTuple hv_MatrixValues = new HTuple(), hv_MatrixText = new HTuple();
            HTuple hv_MatrixTextWidths = new HTuple(), hv_MatrixTextWidth = new HTuple();
            HTuple hv_ButtonHeight = new HTuple(), hv_ButtonWidth = new HTuple();
            HTuple hv_TextToButtonOffset = new HTuple(), hv_ZeroIndices = new HTuple();
            HTuple hv_NonZeroIndizes = new HTuple(), hv_ContinueTextWidth = new HTuple();
            HTuple hv_ContinueTextHeight = new HTuple(), hv_Row = new HTuple();
            HTuple hv_Column = new HTuple(), hv_WindowWidth = new HTuple();
            HTuple hv_WindowHeight = new HTuple(), hv_SelectedButton = new HTuple();
            HTuple hv_MatrixEntryIndex = new HTuple(), hv_GroundTruthClassID = new HTuple();
            HTuple hv_PredictedClassID = new HTuple(), hv_GTIndices = new HTuple();
            HTuple hv_PredictionIndices = new HTuple(), hv_ImageIDsSelected = new HTuple();
            HTuple hv_WindowHandleDict = new HTuple(), hv_DisplaySamples = new HTuple();
            HTuple hv_DisplayIndex = new HTuple(), hv_DLSamples = new HTuple();
            HTuple hv_DLSampleIndex = new HTuple(), hv_DLSample = new HTuple();
            HTuple hv_DLResult = new HTuple(), hv_WindowHandles = new HTuple();
            HTuple hv_WindowHandleLegend = new HTuple(), hv_DataButtonNames = new HTuple();
            HTuple hv_DataTextRow = new HTuple(), hv_DataTextColumn = new HTuple();
            HTuple hv_DataButtonHeight = new HTuple(), hv_DataButtonWidth = new HTuple();
            HTuple hv_DataValueColors = new HTuple(), hv_DataBoxColor = new HTuple();
            HTuple hv_SelectedDataButton = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure displays a confusion matrix that can be used interactively to display samples.
                //
                //Set generic parameter defaults.
                hv_DisplayMatrix.Dispose();
                hv_DisplayMatrix = "absolute";
                hv_DisplayColor.Dispose();
                hv_DisplayColor = 1;
                hv_DisplayColumnWidth.Dispose();
                hv_DisplayColumnWidth = "equal";
                hv_Font.Dispose();
                hv_Font = "mono";
                hv_FontSize.Dispose();
                hv_FontSize = 14;
                //
                //Handle the generic parameters.
                hv_GenParamDevData.Dispose();
                hv_GenParamDevData = new HTuple();
                if ((int)(new HTuple((new HTuple(hv_GenParam.TupleLength())).TupleGreater(0))) != 0)
                {
                    //
                    //Possible keys for generic parameters of this procedure and common keys with dev_display_dl_data.
                    hv_GenParamKeysOnlyInteractive.Dispose();
                    hv_GenParamKeysOnlyInteractive = new HTuple();
                    hv_GenParamKeysOnlyInteractive[0] = "display_matrix";
                    hv_GenParamKeysOnlyInteractive[1] = "display_color";
                    hv_GenParamKeysOnlyInteractive[2] = "display_column_width";
                    hv_GenParamKeysCommon.Dispose();
                    hv_GenParamKeysCommon = new HTuple();
                    hv_GenParamKeysCommon[0] = "font";
                    hv_GenParamKeysCommon[1] = "font_size";
                    hv_GenParamKeysInteractive.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_GenParamKeysInteractive = new HTuple();
                        hv_GenParamKeysInteractive = hv_GenParamKeysInteractive.TupleConcat(hv_GenParamKeysOnlyInteractive, hv_GenParamKeysCommon);
                    }
                    //All other keys are expected to be generic parameters for dev_display_dl_data.
                    hv_GenParamDevData.Dispose();
                    HOperatorSet.CopyDict(hv_GenParam, new HTuple(), new HTuple(), out hv_GenParamDevData);
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_GenParamKeysOnlyInteractive.TupleLength()
                        )) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        try
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.RemoveDictKey(hv_GenParamDevData, hv_GenParamKeysOnlyInteractive.TupleSelect(
                                    hv_Index));
                            }
                        }
                        // catch (Exception) 
                        catch (HalconException HDevExpDefaultException1)
                        {
                            HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DisplayMatrixExists.Dispose();
                        HOperatorSet.GetDictParam(hv_GenParam, "key_exists", hv_GenParamKeysInteractive.TupleSelect(
                            0), out hv_DisplayMatrixExists);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DisplayColorExists.Dispose();
                        HOperatorSet.GetDictParam(hv_GenParam, "key_exists", hv_GenParamKeysInteractive.TupleSelect(
                            1), out hv_DisplayColorExists);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DisplayColumnWidthExists.Dispose();
                        HOperatorSet.GetDictParam(hv_GenParam, "key_exists", hv_GenParamKeysInteractive.TupleSelect(
                            2), out hv_DisplayColumnWidthExists);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_FontExists.Dispose();
                        HOperatorSet.GetDictParam(hv_GenParam, "key_exists", hv_GenParamKeysInteractive.TupleSelect(
                            3), out hv_FontExists);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_FontSizeExists.Dispose();
                        HOperatorSet.GetDictParam(hv_GenParam, "key_exists", hv_GenParamKeysInteractive.TupleSelect(
                            4), out hv_FontSizeExists);
                    }
                    //Set display matrix.
                    if ((int)(hv_DisplayMatrixExists) != 0)
                    {
                        hv_DisplayMatrix.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "display_matrix", out hv_DisplayMatrix);
                        if ((int)((new HTuple((new HTuple(hv_DisplayMatrix.TupleLength())).TupleNotEqual(
                            1))).TupleOr(new HTuple((new HTuple(((new HTuple("absolute")).TupleConcat(
                            "relative")).TupleFind(hv_DisplayMatrix))).TupleEqual(-1)))) != 0)
                        {
                            throw new HalconException("Invalid value for 'display_matrix'");
                        }
                    }
                    //Set display color.
                    if ((int)(hv_DisplayColorExists) != 0)
                    {
                        hv_DisplayColor.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "display_color", out hv_DisplayColor);
                        if ((int)((new HTuple((new HTuple(hv_DisplayColor.TupleLength())).TupleNotEqual(
                            1))).TupleOr(new HTuple((new HTuple(((new HTuple("true")).TupleConcat(
                            "false")).TupleFind(hv_DisplayColor))).TupleEqual(-1)))) != 0)
                        {
                            throw new HalconException("Invalid value for 'display_color'");
                        }
                        else
                        {
                            if ((int)(new HTuple(hv_DisplayColor.TupleEqual("true"))) != 0)
                            {
                                hv_DisplayColor.Dispose();
                                hv_DisplayColor = 1;
                            }
                            else
                            {
                                hv_DisplayColor.Dispose();
                                hv_DisplayColor = 0;
                            }
                        }
                    }
                    //Set display column width.
                    if ((int)(hv_DisplayColumnWidthExists) != 0)
                    {
                        hv_DisplayColumnWidth.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "display_column_width", out hv_DisplayColumnWidth);
                        if ((int)((new HTuple((new HTuple(hv_DisplayColumnWidth.TupleLength())).TupleNotEqual(
                            1))).TupleOr(new HTuple((new HTuple(((new HTuple("equal")).TupleConcat(
                            "minimal")).TupleFind(hv_DisplayColumnWidth))).TupleEqual(-1)))) != 0)
                        {
                            throw new HalconException("Invalid value for 'display_column_width'");
                        }
                    }
                    //Set font.
                    if ((int)(hv_FontExists) != 0)
                    {
                        hv_Font.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "font", out hv_Font);
                    }
                    //Set font size.
                    if ((int)(hv_FontSizeExists) != 0)
                    {
                        hv_FontSize.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "font_size", out hv_FontSize);
                        if ((int)((new HTuple(hv_FontSize.TupleLess(8))).TupleOr(new HTuple(hv_FontSize.TupleGreater(
                            64)))) != 0)
                        {
                            throw new HalconException(new HTuple("Key 'font_size' for font size has to be in range of [8,64]"));
                        }
                    }
                }
                //
                //Get information from DLDataset and EvaluationResult.
                hv_ClassNames.Dispose();
                HOperatorSet.GetDictTuple(hv_DLDataset, "class_names", out hv_ClassNames);
                hv_ClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_DLDataset, "class_ids", out hv_ClassIDs);
                hv_EvaluatedSamples.Dispose();
                HOperatorSet.GetDictTuple(hv_EvaluationResult, "evaluated_samples", out hv_EvaluatedSamples);
                hv_ImageIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvaluatedSamples, "image_ids", out hv_ImageIDs);
                hv_ImageLabelIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvaluatedSamples, "image_label_ids", out hv_ImageLabelIDs);
                hv_Predictions.Dispose();
                HOperatorSet.GetDictTuple(hv_EvaluatedSamples, "top1_predictions", out hv_Predictions);
                //Get or calculate confusion matrix.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_KeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_EvaluationResult, "key_exists", hv_DisplayMatrix + "_confusion_matrix",
                        out hv_KeyExists);
                }
                if ((int)(hv_KeyExists) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ConfusionMatrix.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvaluationResult, hv_DisplayMatrix + "_confusion_matrix",
                            out hv_ConfusionMatrix);
                    }
                }
                else
                {
                    //Check if all classes are available in the image label IDs.
                    if ((int)(new HTuple(((((hv_ImageLabelIDs.TupleSort())).TupleUniq())).TupleNotEqual(
                        hv_ClassIDs.TupleSort()))) != 0)
                    {
                        throw new HalconException("Not all classes are represented in the ground truth labels. \nPlease check your data split.");
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ConfusionMatrix.Dispose();
                        gen_confusion_matrix(hv_ImageLabelIDs, hv_Predictions, (new HTuple("display_matrix")).TupleConcat(
                            "return_matrix"), (new HTuple("none")).TupleConcat(hv_DisplayMatrix),
                            new HTuple(), out hv_ConfusionMatrix);
                    }
                }
                //
                //Calculate proper number format and convert relative matrix values to percent, if needed.
                if ((int)(new HTuple(hv_DisplayMatrix.TupleEqual("relative"))) != 0)
                {
                    //To avoid overwritting of the values, copy matrix inplace.
                    {
                        HTuple ExpTmpOutVar_0;
                        HOperatorSet.CopyMatrix(hv_ConfusionMatrix, out ExpTmpOutVar_0);
                        hv_ConfusionMatrix.Dispose();
                        hv_ConfusionMatrix = ExpTmpOutVar_0;
                    }
                    hv_ValuesRelative.Dispose();
                    HOperatorSet.GetFullMatrix(hv_ConfusionMatrix, out hv_ValuesRelative);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetFullMatrix(hv_ConfusionMatrix, 100 * hv_ValuesRelative);
                    }
                    hv_NumberFormat.Dispose();
                    hv_NumberFormat = "3.0f";
                }
                else
                {
                    hv_MatrixMaxID.Dispose();
                    HOperatorSet.MaxMatrix(hv_ConfusionMatrix, "full", out hv_MatrixMaxID);
                    hv_MaxValue.Dispose();
                    HOperatorSet.GetFullMatrix(hv_MatrixMaxID, out hv_MaxValue);
                    hv_NumberFormat.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumberFormat = (((((hv_MaxValue.TupleLog10()
                            )).TupleCeil())).TupleInt()) + ".0f";
                    }
                }
                //
                //Cut class names for better visualization and get mapping between class IDs and class names.
                if ((int)(new HTuple(hv_ClassNames.TupleNotEqual(new HTuple()))) != 0)
                {
                    //Cut class names.
                    hv_MaxChars.Dispose();
                    hv_MaxChars = 14;
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_ClassNames.TupleLength()
                        )) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        hv_Str.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Str = hv_ClassNames.TupleSelect(
                                hv_Index);
                        }
                        hv_IsString.Dispose();
                        HOperatorSet.TupleIsString(hv_Str, out hv_IsString);
                        if ((int)(hv_IsString) != 0)
                        {
                            hv_Length.Dispose();
                            HOperatorSet.TupleStrlen(hv_Str, out hv_Length);
                            if ((int)(new HTuple(hv_Length.TupleGreater(hv_MaxChars))) != 0)
                            {
                                hv_SubStr.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_SubStr = (hv_Str.TupleSubstr(
                                        0, hv_MaxChars - 3)) + "...";
                                }
                                if (hv_ClassNames == null)
                                    hv_ClassNames = new HTuple();
                                hv_ClassNames[hv_Index] = hv_SubStr;
                            }
                        }
                    }
                    //Generate mapping.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassIDsToNamesMapping.Dispose();
                        HOperatorSet.TupleGenConst(hv_ClassIDs.TupleMax(), -1, out hv_ClassIDsToNamesMapping);
                    }
                    if (hv_ClassIDsToNamesMapping == null)
                        hv_ClassIDsToNamesMapping = new HTuple();
                    hv_ClassIDsToNamesMapping[hv_ClassIDs] = HTuple.TupleGenSequence(0, (new HTuple(hv_ClassIDs.TupleLength()
                        )) - 1, 1);
                }
                //
                //Get color for matrix entries.
                hv_ValueColors.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ValueColors = HTuple.TupleGenConst(
                        (new HTuple(hv_ClassIDs.TupleLength())) * (new HTuple(hv_ClassIDs.TupleLength()
                        )), "white");
                }
                if ((int)(hv_DisplayColor) != 0)
                {
                    //Display off-diagonal values in red.
                    hv_ValueColors.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ValueColors = HTuple.TupleGenConst(
                            (new HTuple(hv_ClassIDs.TupleLength())) * (new HTuple(hv_ClassIDs.TupleLength()
                            )), "#ff4500");
                    }
                    //Display diagonal values in green.
                    hv_DiagonalColor.Dispose();
                    hv_DiagonalColor = "#00ff00";
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Seq.Dispose();
                        HOperatorSet.TupleGenSequence(0, (new HTuple(hv_ClassIDs.TupleLength())) - 1,
                            1, out hv_Seq);
                    }
                    hv_DiagonalIndices.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DiagonalIndices = ((new HTuple(hv_ClassIDs.TupleLength()
                            )) * hv_Seq) + hv_Seq;
                    }
                    if (hv_ValueColors == null)
                        hv_ValueColors = new HTuple();
                    hv_ValueColors[hv_DiagonalIndices] = hv_DiagonalColor;
                }
                //
                //
                //* Generate and display interactive confusion matrix.
                //
                //Open and set new window.
                HOperatorSet.SetWindowAttr("background_color", "black");
                HOperatorSet.OpenWindow(0, 0, 512, 512, 0, "visible", "", out hv_WindowHandle);
                HDevWindowStack.Push(hv_WindowHandle);
                HDevWindowStack.SetActive(hv_WindowHandle);
                try
                {
                    set_display_font(hv_WindowHandle, hv_FontSize, hv_Font, "false", "false");
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                    }
                    throw new HalconException("No valid font: " + hv_Font);
                }
                //
                hv_ColumnNames.Dispose();
                hv_ColumnNames = new HTuple(hv_ClassNames);
                hv_RowNames.Dispose();
                hv_RowNames = new HTuple(hv_ClassNames);
                hv_AxisTitles.Dispose();
                hv_AxisTitles = new HTuple();
                hv_AxisTitles[0] = "Ground Truth";
                hv_AxisTitles[1] = "Predicted";
                hv_NumRows.Dispose(); hv_NumColumns.Dispose();
                HOperatorSet.GetSizeMatrix(hv_ConfusionMatrix, out hv_NumRows, out hv_NumColumns);
                hv_AxisColor.Dispose();
                hv_AxisColor = "light gray";
                hv_BoxColor.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_BoxColor = HTuple.TupleGenConst(
                        (new HTuple(hv_ClassNames.TupleLength())) * (new HTuple(hv_ClassNames.TupleLength()
                        )), "#333333");
                }
                hv_HighlightColor.Dispose();
                hv_HighlightColor = "#fce9d4";
                //
                //Calculate the width of the name strings.
                hv_ColStringWidths.Dispose();
                hv_ColStringWidths = new HTuple();
                hv_MinStringWidth.Dispose();
                hv_MinStringWidth = 1e3;
                hv_MaxStringWidth.Dispose();
                hv_MaxStringWidth = 0;
                hv_StringHeight.Dispose();
                hv_StringHeight = 0;
                for (hv_StringIndex = 0; (int)hv_StringIndex <= (int)((new HTuple(hv_ClassNames.TupleLength()
                    )) - 1); hv_StringIndex = (int)hv_StringIndex + 1)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv__.Dispose(); hv__.Dispose(); hv_StringWidth.Dispose(); hv_StringHeightTmp.Dispose();
                        HOperatorSet.GetStringExtents(hv_WindowHandle, hv_ClassNames.TupleSelect(
                            hv_StringIndex), out hv__, out hv__, out hv_StringWidth, out hv_StringHeightTmp);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ColStringWidths = hv_ColStringWidths.TupleConcat(
                                hv_StringWidth);
                            hv_ColStringWidths.Dispose();
                            hv_ColStringWidths = ExpTmpLocalVar_ColStringWidths;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_MinStringWidth = hv_MinStringWidth.TupleMin2(
                                hv_StringWidth);
                            hv_MinStringWidth.Dispose();
                            hv_MinStringWidth = ExpTmpLocalVar_MinStringWidth;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_MaxStringWidth = hv_MaxStringWidth.TupleMax2(
                                hv_StringWidth);
                            hv_MaxStringWidth.Dispose();
                            hv_MaxStringWidth = ExpTmpLocalVar_MaxStringWidth;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_StringHeight = hv_StringHeight.TupleMax2(
                                hv_StringHeightTmp);
                            hv_StringHeight.Dispose();
                            hv_StringHeight = ExpTmpLocalVar_StringHeight;
                        }
                    }
                }
                //The columns should have a minimum width for four characters.
                hv__.Dispose(); hv__.Dispose(); hv_StringWidth.Dispose(); hv__.Dispose();
                HOperatorSet.GetStringExtents(hv_WindowHandle, "test", out hv__, out hv__,
                    out hv_StringWidth, out hv__);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_MaxStringWidth = hv_MaxStringWidth.TupleMax2(
                            hv_StringWidth);
                        hv_MaxStringWidth.Dispose();
                        hv_MaxStringWidth = ExpTmpLocalVar_MaxStringWidth;
                    }
                }
                //
                //Set display parameters, e.g., margin borders, row- and column-offsets.
                hv_TitleHeight.Dispose();
                hv_TitleHeight = 0;
                hv_AxisTitleHeight.Dispose();
                hv_AxisTitleHeight = 0;
                hv__.Dispose(); hv__.Dispose(); hv_AxisTitleWidth.Dispose(); hv_AxisTitleHeight.Dispose();
                HOperatorSet.GetStringExtents(hv_WindowHandle, hv_AxisTitles, out hv__, out hv__,
                    out hv_AxisTitleWidth, out hv_AxisTitleHeight);
                hv_RowStart.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RowStart = (80 + hv_TitleHeight) + hv_AxisTitleHeight;
                }
                hv_RowDistance.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RowDistance = hv_StringHeight + 10;
                }
                hv_RowEnd.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RowEnd = hv_StringHeight * 7;
                }
                hv_ColumnStart.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ColumnStart = 50 + hv_MaxStringWidth;
                }
                hv_ColumnOffset.Dispose();
                hv_ColumnOffset = 30;
                hv_ColumnEnd.Dispose();
                hv_ColumnEnd = new HTuple(hv_ColumnOffset);
                //
                //Adapt the window size to fit the confusion matrix.
                if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("minimal"))) != 0)
                {
                    //Every column of the confusion matrix is as narrow as possible
                    //based to the respective string widths.
                    hv_Width.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Width = (((hv_ColStringWidths.TupleSum()
                            ) + (hv_ColumnOffset * hv_NumColumns)) + hv_ColumnStart) + hv_ColumnEnd;
                    }
                }
                else if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("equal"))) != 0)
                {
                    //Every column of the confusion matrix should have the same width.
                    //based on the maximum string width.
                    hv_Width.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Width = (((hv_MaxStringWidth + hv_ColumnOffset) * hv_NumColumns) + hv_ColumnStart) + hv_ColumnEnd;
                    }
                }
                hv_Height.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Height = ((hv_RowDistance * hv_NumRows) + hv_RowStart) + hv_RowEnd;
                }
                //
                //Set reasonable limits for graphics window (adapt if necessary).
                hv_WidthLimit.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WidthLimit = new HTuple();
                    hv_WidthLimit[0] = 450;
                    hv_WidthLimit = hv_WidthLimit.TupleConcat(hv_Width);
                }
                hv_HeightLimit.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HeightLimit = new HTuple();
                    hv_HeightLimit[0] = 250;
                    hv_HeightLimit = hv_HeightLimit.TupleConcat(hv_Height);
                }
                dev_resize_window_fit_size(0, 0, hv_Width, hv_Height, hv_WidthLimit, hv_HeightLimit);
                //
                //Calculate row and column coordinates for display of text and buttons.
                hv_TextRow.Dispose();
                hv_TextRow = new HTuple();
                hv_TextColumn.Dispose();
                hv_TextColumn = new HTuple();
                hv_RowStartTmp.Dispose();
                hv_RowStartTmp = 0;
                hv_ColumnDistance.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ColumnDistance = new HTuple();
                    hv_ColumnDistance[0] = 0;
                    hv_ColumnDistance = hv_ColumnDistance.TupleConcat((((hv_ColStringWidths.TupleSelectRange(
                        0, hv_NumColumns - 2)) + hv_ColumnOffset)).TupleCumul());
                }
                if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("equal"))) != 0)
                {
                    hv_ColumnDistance.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ColumnDistance = HTuple.TupleGenSequence(
                            0, hv_NumColumns - 1, 1) * (hv_MaxStringWidth + hv_ColumnOffset);
                    }
                }
                HTuple end_val208 = hv_NumRows - 1;
                HTuple step_val208 = 1;
                for (hv_Index = 0; hv_Index.Continue(end_val208, step_val208); hv_Index = hv_Index.TupleAdd(step_val208))
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_TextRow = hv_TextRow.TupleConcat(
                                HTuple.TupleGenConst(hv_NumColumns, hv_RowStartTmp));
                            hv_TextRow.Dispose();
                            hv_TextRow = ExpTmpLocalVar_TextRow;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_RowStartTmp = hv_RowStartTmp + hv_RowDistance;
                            hv_RowStartTmp.Dispose();
                            hv_RowStartTmp = ExpTmpLocalVar_RowStartTmp;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_TextColumn = hv_TextColumn.TupleConcat(
                                hv_ColumnDistance);
                            hv_TextColumn.Dispose();
                            hv_TextColumn = ExpTmpLocalVar_TextColumn;
                        }
                    }
                }
                //Display the confusion matrix with a margin from the top and left.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_TextColumn = hv_TextColumn + hv_ColumnStart;
                        hv_TextColumn.Dispose();
                        hv_TextColumn = ExpTmpLocalVar_TextColumn;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_TextRow = hv_TextRow + hv_RowStart;
                        hv_TextRow.Dispose();
                        hv_TextRow = ExpTmpLocalVar_TextRow;
                    }
                }
                //Align the numbers right.
                hv_MatrixValues.Dispose();
                HOperatorSet.GetFullMatrix(hv_ConfusionMatrix, out hv_MatrixValues);
                hv_MatrixText.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_MatrixText = hv_MatrixValues.TupleString(
                        hv_NumberFormat);
                }
                //Calculate button widths and heights.
                hv_MatrixTextWidths.Dispose();
                hv_MatrixTextWidths = new HTuple();
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_MatrixText.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv__.Dispose(); hv__.Dispose(); hv_MatrixTextWidth.Dispose(); hv__.Dispose();
                        HOperatorSet.GetStringExtents(hv_WindowHandle, hv_MatrixText.TupleSelect(
                            hv_Index), out hv__, out hv__, out hv_MatrixTextWidth, out hv__);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_MatrixTextWidths = hv_MatrixTextWidths.TupleConcat(
                                hv_MatrixTextWidth);
                            hv_MatrixTextWidths.Dispose();
                            hv_MatrixTextWidths = ExpTmpLocalVar_MatrixTextWidths;
                        }
                    }
                }
                hv_ButtonHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ButtonHeight = HTuple.TupleGenConst(
                        new HTuple(hv_MatrixText.TupleLength()), hv_StringHeight * 1.5);
                }
                hv_ButtonWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ButtonWidth = HTuple.TupleGenConst(
                        new HTuple(hv_MatrixText.TupleLength()), (hv_MinStringWidth.TupleMax2(0.9 * hv_MinStringWidth)) * 1.2);
                }
                //Calculate offset between button and text column coordinates to keep the entries in the matrix aligned.
                hv_TextToButtonOffset.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TextToButtonOffset = (((hv_ButtonWidth.TupleSelect(
                        0)) / 2) + ((hv_MatrixTextWidths.TupleMax()) / 2)) - (hv_MatrixTextWidths.TupleMin()
                        );
                }
                //
                //Find zero-entries to avoid that they are selectable by a button.
                hv_ZeroIndices.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ZeroIndices = ((hv_MatrixValues.TupleEqualElem(
                        0.0))).TupleFind(1);
                }
                hv_NonZeroIndizes.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NonZeroIndizes = (HTuple.TupleGenSequence(
                        0, (new HTuple(hv_MatrixValues.TupleLength())) - 1, 1)).TupleDifference(hv_ZeroIndices);
                }
                //
                //Add continue button.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_NonZeroIndizes = hv_NonZeroIndizes.TupleConcat(
                            new HTuple(hv_MatrixText.TupleLength()));
                        hv_NonZeroIndizes.Dispose();
                        hv_NonZeroIndizes = ExpTmpLocalVar_NonZeroIndizes;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_MatrixText = hv_MatrixText.TupleConcat(
                            "Continue");
                        hv_MatrixText.Dispose();
                        hv_MatrixText = ExpTmpLocalVar_MatrixText;
                    }
                }
                hv__.Dispose(); hv__.Dispose(); hv_ContinueTextWidth.Dispose(); hv_ContinueTextHeight.Dispose();
                HOperatorSet.GetStringExtents(hv_WindowHandle, "Continue", out hv__, out hv__,
                    out hv_ContinueTextWidth, out hv_ContinueTextHeight);
                hv_Row.Dispose(); hv_Column.Dispose(); hv_WindowWidth.Dispose(); hv_WindowHeight.Dispose();
                HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_Row, out hv_Column, out hv_WindowWidth,
                    out hv_WindowHeight);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_TextRow = hv_TextRow.TupleConcat(
                            (hv_WindowHeight - hv_ContinueTextHeight) - 20);
                        hv_TextRow.Dispose();
                        hv_TextRow = ExpTmpLocalVar_TextRow;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_TextColumn = hv_TextColumn.TupleConcat(
                            (hv_WindowWidth - hv_ContinueTextWidth) - 40);
                        hv_TextColumn.Dispose();
                        hv_TextColumn = ExpTmpLocalVar_TextColumn;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_ButtonHeight = hv_ButtonHeight.TupleConcat(
                            hv_ContinueTextHeight * 1.5);
                        hv_ButtonHeight.Dispose();
                        hv_ButtonHeight = ExpTmpLocalVar_ButtonHeight;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_ButtonWidth = hv_ButtonWidth.TupleConcat(
                            hv_ContinueTextWidth * 1.2);
                        hv_ButtonWidth.Dispose();
                        hv_ButtonWidth = ExpTmpLocalVar_ButtonWidth;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_ValueColors = hv_ValueColors.TupleConcat(
                            "black");
                        hv_ValueColors.Dispose();
                        hv_ValueColors = ExpTmpLocalVar_ValueColors;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_BoxColor = hv_BoxColor.TupleConcat(
                            "#f28d26");
                        hv_BoxColor.Dispose();
                        hv_BoxColor = ExpTmpLocalVar_BoxColor;
                    }
                }
                //
                //Display values of matrix with buttons.
                hv_DisplayMatrix.Dispose();
                hv_DisplayMatrix = 1;
                while ((int)(hv_DisplayMatrix) != 0)
                {
                    //
                    //Display axis titles, row, and column names.
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_AxisTitles.TupleSelect(
                                0), "window", "top", "right", "white", "box", "false");
                        }
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_AxisTitles.TupleSelect(
                                1), "window", "bottom", "left", "white", "box", "false");
                        }
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_RowNames, "window",
                                hv_TextRow.TupleSelect(HTuple.TupleGenSequence(0, hv_NumColumns * (hv_NumRows - 1),
                                hv_NumColumns)), HTuple.TupleGenConst(hv_NumRows, ((hv_TextColumn.TupleSelect(
                                0)) - hv_MaxStringWidth) - hv_ColumnOffset), hv_AxisColor, "box", "false");
                        }
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ColumnNames, "window",
                                HTuple.TupleGenConst(hv_NumColumns, (hv_TextRow.TupleSelect(0)) - hv_RowDistance),
                                hv_TextColumn.TupleSelectRange(0, hv_NumColumns - 1), hv_AxisColor, "box",
                                "false");
                        }
                    }
                    //
                    //Display matrix entries. Zero-entries are displayed as text, all others as buttons.
                    if ((int)(new HTuple(hv_ZeroIndices.TupleNotEqual(-1))) != 0)
                    {
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_MatrixText.TupleSelect(
                                    hv_ZeroIndices), "window", hv_TextRow.TupleSelect(hv_ZeroIndices),
                                    (hv_TextColumn.TupleSelect(hv_ZeroIndices)) + hv_TextToButtonOffset,
                                    hv_ValueColors.TupleSelect(hv_ZeroIndices), "box", "false");
                            }
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SelectedButton.Dispose();
                        dev_disp_button(hv_MatrixText.TupleSelect(hv_NonZeroIndizes), hv_TextRow.TupleSelect(
                            hv_NonZeroIndizes), hv_TextColumn.TupleSelect(hv_NonZeroIndizes), hv_ButtonWidth.TupleSelect(
                            hv_NonZeroIndizes), hv_ButtonHeight.TupleSelect(hv_NonZeroIndizes), hv_ValueColors.TupleSelect(
                            hv_NonZeroIndizes), hv_BoxColor.TupleSelect(hv_NonZeroIndizes), hv_HighlightColor,
                            hv_WindowHandle, out hv_SelectedButton);
                    }
                    //
                    //Display axis titles, row names, column names, and zero-entries again to update screen.
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_AxisTitles.TupleSelect(
                                0), "window", "top", "right", "white", "box", "false");
                        }
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_AxisTitles.TupleSelect(
                                1), "window", "bottom", "left", "white", "box", "false");
                        }
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_RowNames, "window",
                                hv_TextRow.TupleSelect(HTuple.TupleGenSequence(0, hv_NumColumns * (hv_NumRows - 1),
                                hv_NumColumns)), HTuple.TupleGenConst(hv_NumRows, ((hv_TextColumn.TupleSelect(
                                0)) - hv_MaxStringWidth) - hv_ColumnOffset), hv_AxisColor, "box", "false");
                        }
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ColumnNames, "window",
                                HTuple.TupleGenConst(hv_NumColumns, (hv_TextRow.TupleSelect(0)) - hv_RowDistance),
                                hv_TextColumn.TupleSelectRange(0, hv_NumColumns - 1), hv_AxisColor, "box",
                                "false");
                        }
                    }
                    if ((int)(new HTuple(hv_ZeroIndices.TupleNotEqual(-1))) != 0)
                    {
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_MatrixText.TupleSelect(
                                    hv_ZeroIndices), "window", hv_TextRow.TupleSelect(hv_ZeroIndices),
                                    (hv_TextColumn.TupleSelect(hv_ZeroIndices)) + hv_TextToButtonOffset,
                                    hv_ValueColors.TupleSelect(hv_ZeroIndices), "box", "false");
                            }
                        }
                    }
                    //
                    if ((int)(new HTuple(hv_SelectedButton.TupleEqual((new HTuple(hv_NonZeroIndizes.TupleLength()
                        )) - 1))) != 0)
                    {
                        //Continue-button.
                        hv_DisplayMatrix.Dispose();
                        hv_DisplayMatrix = 0;
                        HDevWindowStack.SetActive(hv_WindowHandle);
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                        }
                    }
                    else
                    {
                        //Find correct samples and display them.
                        hv_MatrixEntryIndex.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MatrixEntryIndex = hv_NonZeroIndizes.TupleSelect(
                                hv_SelectedButton);
                        }
                        hv_GroundTruthClassID.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_GroundTruthClassID = hv_MatrixEntryIndex % (new HTuple(hv_ClassIDs.TupleLength()
                                ));
                        }
                        hv_PredictedClassID.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_PredictedClassID = hv_MatrixEntryIndex / (new HTuple(hv_ClassIDs.TupleLength()
                                ));
                        }
                        hv_GTIndices.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_GTIndices = ((hv_ImageLabelIDs.TupleEqualElem(
                                hv_GroundTruthClassID))).TupleFind(1);
                        }
                        hv_PredictionIndices.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_PredictionIndices = ((hv_Predictions.TupleEqualElem(
                                hv_PredictedClassID))).TupleFind(1);
                        }
                        hv_ImageIDsSelected.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ImageIDsSelected = hv_ImageIDs.TupleSelect(
                                hv_GTIndices.TupleIntersection(hv_PredictionIndices));
                        }
                        hv_WindowHandleDict.Dispose();
                        HOperatorSet.CreateDict(out hv_WindowHandleDict);
                        hv_DisplaySamples.Dispose();
                        hv_DisplaySamples = 1;
                        hv_DisplayIndex.Dispose();
                        hv_DisplayIndex = 0;
                        while ((int)(hv_DisplaySamples) != 0)
                        {
                            hv_DLSamples.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLSamples);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_DLSampleIndex.Dispose();
                                find_dl_samples(hv_DLSamples, "image_id", hv_ImageIDsSelected.TupleSelect(
                                    hv_DisplayIndex), "match", out hv_DLSampleIndex);
                            }
                            hv_DLSample.Dispose();
                            read_dl_samples(hv_DLDataset, hv_DLSampleIndex, out hv_DLSample);
                            //Create temporary DLResult for display.
                            hv_DLResult.Dispose();
                            HOperatorSet.CreateDict(out hv_DLResult);
                            HOperatorSet.SetDictTuple(hv_DLResult, "classification_class_ids", hv_PredictedClassID);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_DLResult, "classification_class_names",
                                    hv_ClassNames.TupleSelect(hv_ClassIDsToNamesMapping.TupleSelect(hv_PredictedClassID)));
                            }
                            dev_display_dl_data(hv_DLSample, hv_DLResult, hv_DLDataset, "classification_both",
                                hv_GenParamDevData, hv_WindowHandleDict);
                            //Display buttons.
                            hv_WindowHandles.Dispose();
                            HOperatorSet.GetDictTuple(hv_WindowHandleDict, "classification_both",
                                out hv_WindowHandles);
                            hv_WindowHandleLegend.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowHandleLegend = hv_WindowHandles.TupleSelect(
                                    (new HTuple(hv_WindowHandles.TupleLength())) - 1);
                            }
                            //
                            hv_DataButtonNames.Dispose();
                            hv_DataButtonNames = new HTuple();
                            hv_DataButtonNames[0] = "Previous";
                            hv_DataButtonNames[1] = "Next";
                            hv_DataButtonNames[2] = "Continue";
                            hv__.Dispose(); hv__.Dispose(); hv_ContinueTextWidth.Dispose(); hv_ContinueTextHeight.Dispose();
                            HOperatorSet.GetStringExtents(hv_WindowHandleLegend, "Continue", out hv__,
                                out hv__, out hv_ContinueTextWidth, out hv_ContinueTextHeight);
                            hv_Row.Dispose(); hv_Column.Dispose(); hv_WindowWidth.Dispose(); hv_WindowHeight.Dispose();
                            HOperatorSet.GetWindowExtents(hv_WindowHandleLegend, out hv_Row, out hv_Column,
                                out hv_WindowWidth, out hv_WindowHeight);
                            hv_DataTextRow.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_DataTextRow = HTuple.TupleGenConst(
                                    3, (hv_WindowHeight - hv_ContinueTextHeight) - 20);
                            }
                            hv_DataTextColumn.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_DataTextColumn = new HTuple();
                                hv_DataTextColumn[0] = 20;
                                hv_DataTextColumn = hv_DataTextColumn.TupleConcat((hv_WindowWidth - hv_ContinueTextWidth) / 2);
                                hv_DataTextColumn = hv_DataTextColumn.TupleConcat((hv_WindowWidth - hv_ContinueTextWidth) - 20);
                            }
                            hv_DataButtonHeight.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_DataButtonHeight = HTuple.TupleGenConst(
                                    3, hv_ContinueTextHeight * 1.5);
                            }
                            hv_DataButtonWidth.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_DataButtonWidth = HTuple.TupleGenConst(
                                    3, hv_ContinueTextWidth * 1.2);
                            }
                            hv_DataValueColors.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_DataValueColors = HTuple.TupleGenConst(
                                    3, "black");
                            }
                            hv_DataBoxColor.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_DataBoxColor = HTuple.TupleGenConst(
                                    3, "#f28d26");
                            }
                            hv_SelectedDataButton.Dispose();
                            dev_disp_button(hv_DataButtonNames, hv_DataTextRow, hv_DataTextColumn,
                                hv_DataButtonWidth, hv_DataButtonHeight, hv_DataValueColors, hv_DataBoxColor,
                                hv_HighlightColor, hv_WindowHandleLegend, out hv_SelectedDataButton);
                            //
                            if ((int)(new HTuple(hv_SelectedDataButton.TupleEqual(0))) != 0)
                            {
                                //Previous-button.
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_DisplayIndex = (((new HTuple(hv_ImageIDsSelected.TupleLength()
                                            )) + hv_DisplayIndex) - 1) % (new HTuple(hv_ImageIDsSelected.TupleLength()
                                            ));
                                        hv_DisplayIndex.Dispose();
                                        hv_DisplayIndex = ExpTmpLocalVar_DisplayIndex;
                                    }
                                }
                            }
                            else if ((int)(new HTuple(hv_SelectedDataButton.TupleEqual(
                                1))) != 0)
                            {
                                //Next-button.
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_DisplayIndex = (hv_DisplayIndex + 1) % (new HTuple(hv_ImageIDsSelected.TupleLength()
                                            ));
                                        hv_DisplayIndex.Dispose();
                                        hv_DisplayIndex = ExpTmpLocalVar_DisplayIndex;
                                    }
                                }
                            }
                            else
                            {
                                //Continue-button.
                                hv_DisplaySamples.Dispose();
                                hv_DisplaySamples = 0;
                                dev_close_window_dict(hv_WindowHandleDict);
                            }
                        }
                    }
                }
                //

                hv_DisplayMatrix.Dispose();
                hv_DisplayColor.Dispose();
                hv_DisplayColumnWidth.Dispose();
                hv_Font.Dispose();
                hv_FontSize.Dispose();
                hv_GenParamDevData.Dispose();
                hv_GenParamKeysOnlyInteractive.Dispose();
                hv_GenParamKeysCommon.Dispose();
                hv_GenParamKeysInteractive.Dispose();
                hv_Index.Dispose();
                hv_Exception.Dispose();
                hv_DisplayMatrixExists.Dispose();
                hv_DisplayColorExists.Dispose();
                hv_DisplayColumnWidthExists.Dispose();
                hv_FontExists.Dispose();
                hv_FontSizeExists.Dispose();
                hv_ClassNames.Dispose();
                hv_ClassIDs.Dispose();
                hv_EvaluatedSamples.Dispose();
                hv_ImageIDs.Dispose();
                hv_ImageLabelIDs.Dispose();
                hv_Predictions.Dispose();
                hv_KeyExists.Dispose();
                hv_ConfusionMatrix.Dispose();
                hv_ValuesRelative.Dispose();
                hv_NumberFormat.Dispose();
                hv_MatrixMaxID.Dispose();
                hv_MaxValue.Dispose();
                hv_MaxChars.Dispose();
                hv_Str.Dispose();
                hv_IsString.Dispose();
                hv_Length.Dispose();
                hv_SubStr.Dispose();
                hv_ClassIDsToNamesMapping.Dispose();
                hv_ValueColors.Dispose();
                hv_DiagonalColor.Dispose();
                hv_Seq.Dispose();
                hv_DiagonalIndices.Dispose();
                hv_WindowHandle.Dispose();
                hv_ColumnNames.Dispose();
                hv_RowNames.Dispose();
                hv_AxisTitles.Dispose();
                hv_NumRows.Dispose();
                hv_NumColumns.Dispose();
                hv_AxisColor.Dispose();
                hv_BoxColor.Dispose();
                hv_HighlightColor.Dispose();
                hv_ColStringWidths.Dispose();
                hv_MinStringWidth.Dispose();
                hv_MaxStringWidth.Dispose();
                hv_StringHeight.Dispose();
                hv_StringIndex.Dispose();
                hv__.Dispose();
                hv_StringWidth.Dispose();
                hv_StringHeightTmp.Dispose();
                hv_TitleHeight.Dispose();
                hv_AxisTitleHeight.Dispose();
                hv_AxisTitleWidth.Dispose();
                hv_RowStart.Dispose();
                hv_RowDistance.Dispose();
                hv_RowEnd.Dispose();
                hv_ColumnStart.Dispose();
                hv_ColumnOffset.Dispose();
                hv_ColumnEnd.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_WidthLimit.Dispose();
                hv_HeightLimit.Dispose();
                hv_TextRow.Dispose();
                hv_TextColumn.Dispose();
                hv_RowStartTmp.Dispose();
                hv_ColumnDistance.Dispose();
                hv_MatrixValues.Dispose();
                hv_MatrixText.Dispose();
                hv_MatrixTextWidths.Dispose();
                hv_MatrixTextWidth.Dispose();
                hv_ButtonHeight.Dispose();
                hv_ButtonWidth.Dispose();
                hv_TextToButtonOffset.Dispose();
                hv_ZeroIndices.Dispose();
                hv_NonZeroIndizes.Dispose();
                hv_ContinueTextWidth.Dispose();
                hv_ContinueTextHeight.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_SelectedButton.Dispose();
                hv_MatrixEntryIndex.Dispose();
                hv_GroundTruthClassID.Dispose();
                hv_PredictedClassID.Dispose();
                hv_GTIndices.Dispose();
                hv_PredictionIndices.Dispose();
                hv_ImageIDsSelected.Dispose();
                hv_WindowHandleDict.Dispose();
                hv_DisplaySamples.Dispose();
                hv_DisplayIndex.Dispose();
                hv_DLSamples.Dispose();
                hv_DLSampleIndex.Dispose();
                hv_DLSample.Dispose();
                hv_DLResult.Dispose();
                hv_WindowHandles.Dispose();
                hv_WindowHandleLegend.Dispose();
                hv_DataButtonNames.Dispose();
                hv_DataTextRow.Dispose();
                hv_DataTextColumn.Dispose();
                hv_DataButtonHeight.Dispose();
                hv_DataButtonWidth.Dispose();
                hv_DataValueColors.Dispose();
                hv_DataBoxColor.Dispose();
                hv_SelectedDataButton.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_DisplayMatrix.Dispose();
                hv_DisplayColor.Dispose();
                hv_DisplayColumnWidth.Dispose();
                hv_Font.Dispose();
                hv_FontSize.Dispose();
                hv_GenParamDevData.Dispose();
                hv_GenParamKeysOnlyInteractive.Dispose();
                hv_GenParamKeysCommon.Dispose();
                hv_GenParamKeysInteractive.Dispose();
                hv_Index.Dispose();
                hv_Exception.Dispose();
                hv_DisplayMatrixExists.Dispose();
                hv_DisplayColorExists.Dispose();
                hv_DisplayColumnWidthExists.Dispose();
                hv_FontExists.Dispose();
                hv_FontSizeExists.Dispose();
                hv_ClassNames.Dispose();
                hv_ClassIDs.Dispose();
                hv_EvaluatedSamples.Dispose();
                hv_ImageIDs.Dispose();
                hv_ImageLabelIDs.Dispose();
                hv_Predictions.Dispose();
                hv_KeyExists.Dispose();
                hv_ConfusionMatrix.Dispose();
                hv_ValuesRelative.Dispose();
                hv_NumberFormat.Dispose();
                hv_MatrixMaxID.Dispose();
                hv_MaxValue.Dispose();
                hv_MaxChars.Dispose();
                hv_Str.Dispose();
                hv_IsString.Dispose();
                hv_Length.Dispose();
                hv_SubStr.Dispose();
                hv_ClassIDsToNamesMapping.Dispose();
                hv_ValueColors.Dispose();
                hv_DiagonalColor.Dispose();
                hv_Seq.Dispose();
                hv_DiagonalIndices.Dispose();
                hv_WindowHandle.Dispose();
                hv_ColumnNames.Dispose();
                hv_RowNames.Dispose();
                hv_AxisTitles.Dispose();
                hv_NumRows.Dispose();
                hv_NumColumns.Dispose();
                hv_AxisColor.Dispose();
                hv_BoxColor.Dispose();
                hv_HighlightColor.Dispose();
                hv_ColStringWidths.Dispose();
                hv_MinStringWidth.Dispose();
                hv_MaxStringWidth.Dispose();
                hv_StringHeight.Dispose();
                hv_StringIndex.Dispose();
                hv__.Dispose();
                hv_StringWidth.Dispose();
                hv_StringHeightTmp.Dispose();
                hv_TitleHeight.Dispose();
                hv_AxisTitleHeight.Dispose();
                hv_AxisTitleWidth.Dispose();
                hv_RowStart.Dispose();
                hv_RowDistance.Dispose();
                hv_RowEnd.Dispose();
                hv_ColumnStart.Dispose();
                hv_ColumnOffset.Dispose();
                hv_ColumnEnd.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_WidthLimit.Dispose();
                hv_HeightLimit.Dispose();
                hv_TextRow.Dispose();
                hv_TextColumn.Dispose();
                hv_RowStartTmp.Dispose();
                hv_ColumnDistance.Dispose();
                hv_MatrixValues.Dispose();
                hv_MatrixText.Dispose();
                hv_MatrixTextWidths.Dispose();
                hv_MatrixTextWidth.Dispose();
                hv_ButtonHeight.Dispose();
                hv_ButtonWidth.Dispose();
                hv_TextToButtonOffset.Dispose();
                hv_ZeroIndices.Dispose();
                hv_NonZeroIndizes.Dispose();
                hv_ContinueTextWidth.Dispose();
                hv_ContinueTextHeight.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_SelectedButton.Dispose();
                hv_MatrixEntryIndex.Dispose();
                hv_GroundTruthClassID.Dispose();
                hv_PredictedClassID.Dispose();
                hv_GTIndices.Dispose();
                hv_PredictionIndices.Dispose();
                hv_ImageIDsSelected.Dispose();
                hv_WindowHandleDict.Dispose();
                hv_DisplaySamples.Dispose();
                hv_DisplayIndex.Dispose();
                hv_DLSamples.Dispose();
                hv_DLSampleIndex.Dispose();
                hv_DLSample.Dispose();
                hv_DLResult.Dispose();
                hv_WindowHandles.Dispose();
                hv_WindowHandleLegend.Dispose();
                hv_DataButtonNames.Dispose();
                hv_DataTextRow.Dispose();
                hv_DataTextColumn.Dispose();
                hv_DataButtonHeight.Dispose();
                hv_DataButtonWidth.Dispose();
                hv_DataValueColors.Dispose();
                hv_DataBoxColor.Dispose();
                hv_SelectedDataButton.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection
        // Short Description: Display the ground truth anomaly regions of the given DLSample. 
        public void dev_display_ground_truth_anomaly_regions(HTuple hv_SampleKeys, HTuple hv_DLSample,
            HTuple hv_CurrentWindowHandle, HTuple hv_LineWidth, HTuple hv_AnomalyRegionLabelColor,
            HTuple hv_AnomalyColorTransparency, out HTuple hv_AnomalyRegionExists)
        {



            // Local iconic variables 

            HObject ho_AnomalyImage = null, ho_AnomalyRegion = null;

            // Local control variables 

            HTuple hv_Red = new HTuple(), hv_Green = new HTuple();
            HTuple hv_Blue = new HTuple(), hv_Alpha = new HTuple();
            HTuple hv_InitialColor = new HTuple(), hv_IndexColor = new HTuple();
            HTuple hv_Color_RGBA = new HTuple(), hv_Area = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_AnomalyImage);
            HOperatorSet.GenEmptyObj(out ho_AnomalyRegion);
            hv_AnomalyRegionExists = new HTuple();
            try
            {
                //
                //This procedure visualizes the ground truth anomalies
                //if there is an anomaly_ground_truth in DLSample.
                //
                //Get current set color.
                hv_Red.Dispose(); hv_Green.Dispose(); hv_Blue.Dispose(); hv_Alpha.Dispose();
                HOperatorSet.GetRgba(hv_CurrentWindowHandle, out hv_Red, out hv_Green, out hv_Blue,
                    out hv_Alpha);
                hv_InitialColor.Dispose();
                hv_InitialColor = new HTuple();
                for (hv_IndexColor = 0; (int)hv_IndexColor <= (int)((new HTuple(hv_Red.TupleLength()
                    )) - 1); hv_IndexColor = (int)hv_IndexColor + 1)
                {
                    hv_Color_RGBA.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Color_RGBA = ((("#" + (((hv_Red.TupleSelect(
                            hv_IndexColor))).TupleString("2x"))) + (((hv_Green.TupleSelect(hv_IndexColor))).TupleString(
                            "2x"))) + (((hv_Blue.TupleSelect(hv_IndexColor))).TupleString("2x"))) + (((hv_Alpha.TupleSelect(
                            hv_IndexColor))).TupleString("2x"));
                    }
                    {
                        HTuple ExpTmpOutVar_0;
                        HOperatorSet.TupleRegexpReplace(hv_Color_RGBA, (new HTuple(" ")).TupleConcat(
                            "replace_all"), "0", out ExpTmpOutVar_0);
                        hv_Color_RGBA.Dispose();
                        hv_Color_RGBA = ExpTmpOutVar_0;
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_InitialColor = hv_InitialColor.TupleConcat(
                                hv_Color_RGBA);
                            hv_InitialColor.Dispose();
                            hv_InitialColor = ExpTmpLocalVar_InitialColor;
                        }
                    }
                }
                //
                if ((int)(new HTuple(((hv_SampleKeys.TupleFind("anomaly_ground_truth"))).TupleNotEqual(
                    -1))) != 0)
                {
                    ho_AnomalyImage.Dispose();
                    HOperatorSet.GetDictObject(out ho_AnomalyImage, hv_DLSample, "anomaly_ground_truth");
                    ho_AnomalyRegion.Dispose();
                    HOperatorSet.Threshold(ho_AnomalyImage, out ho_AnomalyRegion, 1, 255);
                    //Get non-empty regions.
                    hv_Area.Dispose();
                    HOperatorSet.RegionFeatures(ho_AnomalyRegion, "area", out hv_Area);
                    if ((int)(new HTuple(hv_Area.TupleGreater(0))) != 0)
                    {
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_AnomalyRegionLabelColor + hv_AnomalyColorTransparency);
                            }
                        }
                        //Display the anomaly region.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_AnomalyRegion, HDevWindowStack.GetActive());
                        }
                    }
                    hv_AnomalyRegionExists.Dispose();
                    hv_AnomalyRegionExists = "true";
                }
                else
                {
                    hv_AnomalyRegionExists.Dispose();
                    hv_AnomalyRegionExists = "false";
                }
                //
                //Reset colors.
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_InitialColor);
                }
                //
                ho_AnomalyImage.Dispose();
                ho_AnomalyRegion.Dispose();

                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();
                hv_Alpha.Dispose();
                hv_InitialColor.Dispose();
                hv_IndexColor.Dispose();
                hv_Color_RGBA.Dispose();
                hv_Area.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_AnomalyImage.Dispose();
                ho_AnomalyRegion.Dispose();

                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();
                hv_Alpha.Dispose();
                hv_InitialColor.Dispose();
                hv_IndexColor.Dispose();
                hv_Color_RGBA.Dispose();
                hv_Area.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: Display the ground truth bounding boxes of DLSample. 
        public void dev_display_ground_truth_detection(HTuple hv_DLSample, HTuple hv_SampleKeys,
            HTuple hv_LineWidthBbox, HTuple hv_ClassIDs, HTuple hv_BboxColors, HTuple hv_BboxLabelColor,
            HTuple hv_TextColor, HTuple hv_ShowLabels, HTuple hv_ShowDirection, HTuple hv_WindowHandle,
            out HTuple hv_BboxIDs)
        {



            // Local iconic variables 

            HObject ho_BboxRectangle = null, ho_OrientationArrows = null;
            HObject ho_RectangleSelected = null, ho_ArrowSelected = null;

            // Local control variables 

            HTuple hv_InstanceType = new HTuple(), hv_BboxRow1 = new HTuple();
            HTuple hv_BboxCol1 = new HTuple(), hv_BboxRow2 = new HTuple();
            HTuple hv_BboxCol2 = new HTuple(), hv_BboxLabels = new HTuple();
            HTuple hv_BboxRow = new HTuple(), hv_BboxCol = new HTuple();
            HTuple hv_BboxLength1 = new HTuple(), hv_BboxLength2 = new HTuple();
            HTuple hv_BboxPhi = new HTuple(), hv_LabelRow = new HTuple();
            HTuple hv_LabelCol = new HTuple(), hv_HeadSize = new HTuple();
            HTuple hv_BboxClassIDs = new HTuple(), hv_ContourStyle = new HTuple();
            HTuple hv_IndexBbox = new HTuple(), hv_ClassID = new HTuple();
            HTuple hv_TxtColor = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_BboxRectangle);
            HOperatorSet.GenEmptyObj(out ho_OrientationArrows);
            HOperatorSet.GenEmptyObj(out ho_RectangleSelected);
            HOperatorSet.GenEmptyObj(out ho_ArrowSelected);
            hv_BboxIDs = new HTuple();
            try
            {
                //
                //This procedure displays the ground truth bounding boxes of DLSample.
                //
                hv_InstanceType.Dispose();
                hv_InstanceType = "rectangle1";
                if ((int)(new HTuple(((hv_SampleKeys.TupleFind("bbox_row1"))).TupleNotEqual(
                    -1))) != 0)
                {
                    hv_BboxRow1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row1", out hv_BboxRow1);
                    hv_BboxCol1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col1", out hv_BboxCol1);
                    hv_BboxRow2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row2", out hv_BboxRow2);
                    hv_BboxCol2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col2", out hv_BboxCol2);
                    hv_BboxLabels.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_label_id", out hv_BboxLabels);
                }
                else if ((int)(new HTuple(((hv_SampleKeys.TupleFind("bbox_phi"))).TupleNotEqual(
                    -1))) != 0)
                {
                    hv_BboxRow.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row", out hv_BboxRow);
                    hv_BboxCol.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col", out hv_BboxCol);
                    hv_BboxLength1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_length1", out hv_BboxLength1);
                    hv_BboxLength2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_length2", out hv_BboxLength2);
                    hv_BboxPhi.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_phi", out hv_BboxPhi);
                    hv_BboxLabels.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_label_id", out hv_BboxLabels);
                    hv_InstanceType.Dispose();
                    hv_InstanceType = "rectangle2";
                }
                else
                {
                    throw new HalconException("Ground truth bounding box data could not be found in DLSample.");
                }
                if ((int)(new HTuple((new HTuple(hv_BboxLabels.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    //Generate bounding box XLDs.
                    if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BboxPhi.Dispose();
                            HOperatorSet.TupleGenConst(new HTuple(hv_BboxRow1.TupleLength()), 0.0,
                                out hv_BboxPhi);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_BboxRectangle.Dispose();
                            HOperatorSet.GenRectangle2ContourXld(out ho_BboxRectangle, 0.5 * (hv_BboxRow1 + hv_BboxRow2),
                                0.5 * (hv_BboxCol1 + hv_BboxCol2), hv_BboxPhi, 0.5 * (hv_BboxCol2 - hv_BboxCol1),
                                0.5 * (hv_BboxRow2 - hv_BboxRow1));
                        }
                        hv_LabelRow.Dispose();
                        hv_LabelRow = new HTuple(hv_BboxRow1);
                        hv_LabelCol.Dispose();
                        hv_LabelCol = new HTuple(hv_BboxCol1);
                    }
                    else
                    {
                        ho_BboxRectangle.Dispose();
                        HOperatorSet.GenRectangle2ContourXld(out ho_BboxRectangle, hv_BboxRow,
                            hv_BboxCol, hv_BboxPhi, hv_BboxLength1, hv_BboxLength2);
                        hv_LabelRow.Dispose();
                        hv_LabelRow = new HTuple(hv_BboxRow);
                        hv_LabelCol.Dispose();
                        hv_LabelCol = new HTuple(hv_BboxCol);
                        if ((int)(hv_ShowDirection) != 0)
                        {
                            hv_HeadSize.Dispose();
                            hv_HeadSize = 20.0;
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_OrientationArrows.Dispose();
                                gen_arrow_contour_xld(out ho_OrientationArrows, hv_BboxRow, hv_BboxCol,
                                    hv_BboxRow - ((hv_BboxLength1 + hv_HeadSize) * (hv_BboxPhi.TupleSin())),
                                    hv_BboxCol + ((hv_BboxLength1 + hv_HeadSize) * (hv_BboxPhi.TupleCos())),
                                    hv_HeadSize, hv_HeadSize);
                            }
                        }
                    }
                    //
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidthBbox);
                    }
                    //
                    //Collect the ClassIDs of the bounding boxes.
                    hv_BboxIDs.Dispose();
                    hv_BboxIDs = new HTuple();
                    hv_BboxClassIDs.Dispose();
                    hv_BboxClassIDs = new HTuple();
                    //
                    //Draw the bounding boxes.
                    hv_ContourStyle.Dispose();
                    HOperatorSet.GetContourStyle(hv_WindowHandle, out hv_ContourStyle);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetContourStyle(HDevWindowStack.GetActive(), "stroke_and_fill");
                    }
                    for (hv_IndexBbox = 0; (int)hv_IndexBbox <= (int)((new HTuple(hv_BboxLabels.TupleLength()
                        )) - 1); hv_IndexBbox = (int)hv_IndexBbox + 1)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_RectangleSelected.Dispose();
                            HOperatorSet.SelectObj(ho_BboxRectangle, out ho_RectangleSelected, hv_IndexBbox + 1);
                        }
                        hv_ClassID.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClassID = hv_ClassIDs.TupleFind(
                                hv_BboxLabels.TupleSelect(hv_IndexBbox));
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_BboxClassIDs = hv_BboxClassIDs.TupleConcat(
                                    hv_ClassID);
                                hv_BboxClassIDs.Dispose();
                                hv_BboxClassIDs = ExpTmpLocalVar_BboxClassIDs;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_BboxIDs = hv_BboxIDs.TupleConcat(
                                    hv_ClassID);
                                hv_BboxIDs.Dispose();
                                hv_BboxIDs = ExpTmpLocalVar_BboxIDs;
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetColor(HDevWindowStack.GetActive(), (hv_BboxColors.TupleSelect(
                                    hv_ClassID)) + "60");
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_RectangleSelected, HDevWindowStack.GetActive()
                                );
                        }
                        if ((int)((new HTuple(hv_InstanceType.TupleEqual("rectangle2"))).TupleAnd(
                            hv_ShowDirection)) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_ArrowSelected.Dispose();
                                HOperatorSet.SelectObj(ho_OrientationArrows, out ho_ArrowSelected, hv_IndexBbox + 1);
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetColor(HDevWindowStack.GetActive(), (hv_BboxColors.TupleSelect(
                                        hv_ClassID)) + "FF");
                                }
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_ArrowSelected, HDevWindowStack.GetActive());
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetColor(HDevWindowStack.GetActive(), (hv_BboxColors.TupleSelect(
                                        hv_ClassID)) + "60");
                                }
                            }
                        }
                    }
                    //
                    //Write text to the bounding boxes.
                    if ((int)(hv_ShowLabels) != 0)
                    {
                        //For better visibility the text is displayed after all bounding boxes are drawn.
                        for (hv_IndexBbox = 0; (int)hv_IndexBbox <= (int)((new HTuple(hv_BboxLabels.TupleLength()
                            )) - 1); hv_IndexBbox = (int)hv_IndexBbox + 1)
                        {
                            hv_ClassID.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClassID = hv_BboxClassIDs.TupleSelect(
                                    hv_IndexBbox);
                            }
                            if ((int)(new HTuple(hv_TextColor.TupleEqual(""))) != 0)
                            {
                                hv_TxtColor.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_TxtColor = hv_BboxColors.TupleSelect(
                                        hv_ClassID);
                                }
                            }
                            else
                            {
                                hv_TxtColor.Dispose();
                                hv_TxtColor = new HTuple(hv_TextColor);
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_BboxLabels.TupleSelect(
                                        hv_IndexBbox), "image", hv_LabelRow.TupleSelect(hv_IndexBbox),
                                        hv_LabelCol.TupleSelect(hv_IndexBbox), hv_TextColor, ((new HTuple("box_color")).TupleConcat(
                                        "shadow")).TupleConcat("border_radius"), hv_BboxLabelColor.TupleConcat(
                                        (new HTuple("false")).TupleConcat(0)));
                                }
                            }
                        }
                    }
                    //
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetContourStyle(HDevWindowStack.GetActive(), hv_ContourStyle);
                    }
                }
                else
                {
                    //Do nothing if there are no ground truth bounding boxes.
                    hv_BboxIDs.Dispose();
                    hv_BboxIDs = new HTuple();
                }
                //
                ho_BboxRectangle.Dispose();
                ho_OrientationArrows.Dispose();
                ho_RectangleSelected.Dispose();
                ho_ArrowSelected.Dispose();

                hv_InstanceType.Dispose();
                hv_BboxRow1.Dispose();
                hv_BboxCol1.Dispose();
                hv_BboxRow2.Dispose();
                hv_BboxCol2.Dispose();
                hv_BboxLabels.Dispose();
                hv_BboxRow.Dispose();
                hv_BboxCol.Dispose();
                hv_BboxLength1.Dispose();
                hv_BboxLength2.Dispose();
                hv_BboxPhi.Dispose();
                hv_LabelRow.Dispose();
                hv_LabelCol.Dispose();
                hv_HeadSize.Dispose();
                hv_BboxClassIDs.Dispose();
                hv_ContourStyle.Dispose();
                hv_IndexBbox.Dispose();
                hv_ClassID.Dispose();
                hv_TxtColor.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_BboxRectangle.Dispose();
                ho_OrientationArrows.Dispose();
                ho_RectangleSelected.Dispose();
                ho_ArrowSelected.Dispose();

                hv_InstanceType.Dispose();
                hv_BboxRow1.Dispose();
                hv_BboxCol1.Dispose();
                hv_BboxRow2.Dispose();
                hv_BboxCol2.Dispose();
                hv_BboxLabels.Dispose();
                hv_BboxRow.Dispose();
                hv_BboxCol.Dispose();
                hv_BboxLength1.Dispose();
                hv_BboxLength2.Dispose();
                hv_BboxPhi.Dispose();
                hv_LabelRow.Dispose();
                hv_LabelCol.Dispose();
                hv_HeadSize.Dispose();
                hv_BboxClassIDs.Dispose();
                hv_ContourStyle.Dispose();
                hv_IndexBbox.Dispose();
                hv_ClassID.Dispose();
                hv_TxtColor.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: Display a color bar next to an image. 
        public void dev_display_map_color_bar(HTuple hv_ImageWidth, HTuple hv_ImageHeight,
            HTuple hv_MapColorBarWidth, HTuple hv_Colors, HTuple hv_MaxValue, HTuple hv_WindowImageRatio,
            HTuple hv_WindowHandle)
        {



            // Local iconic variables 

            HObject ho_Rectangle = null;

            // Local control variables 

            HTuple hv_ClipRegion = new HTuple(), hv_ColorIndex = new HTuple();
            HTuple hv_RectHeight = new HTuple(), hv_DrawMode = new HTuple();
            HTuple hv_Row = new HTuple(), hv_Row1 = new HTuple(), hv_Column1 = new HTuple();
            HTuple hv_Row2 = new HTuple(), hv_Column2 = new HTuple();
            HTuple hv__ = new HTuple(), hv_TextHeight = new HTuple();
            HTuple hv_Index = new HTuple(), hv_Text = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Rectangle);
            try
            {
                //
                //This procedure displays a color bar next to the image
                //specified with ImageWidth and ImageHeight.
                //
                hv_ClipRegion.Dispose();
                HOperatorSet.GetSystem("clip_region", out hv_ClipRegion);
                HOperatorSet.SetSystem("clip_region", "false");
                //
                //Display the color bar.
                hv_ColorIndex.Dispose();
                hv_ColorIndex = 0;
                hv_RectHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RectHeight = (1.0 * hv_ImageHeight) / (new HTuple(hv_Colors.TupleLength()
                        ));
                }
                //Set draw mode to fill
                hv_DrawMode.Dispose();
                HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
                }
                HTuple end_val13 = 0;
                HTuple step_val13 = -hv_RectHeight;
                for (hv_Row = hv_ImageHeight - 1; hv_Row.Continue(end_val13, step_val13); hv_Row = hv_Row.TupleAdd(step_val13))
                {
                    //The color bar consists of multiple rectangle1.
                    hv_Row1.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Row1 = hv_Row - hv_RectHeight;
                    }
                    hv_Column1.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Column1 = hv_ImageWidth + (20 / hv_WindowImageRatio);
                    }
                    hv_Row2.Dispose();
                    hv_Row2 = new HTuple(hv_Row);
                    hv_Column2.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Column2 = (hv_ImageWidth + 20) + (hv_MapColorBarWidth / hv_WindowImageRatio);
                    }
                    ho_Rectangle.Dispose();
                    HOperatorSet.GenRectangle1(out ho_Rectangle, hv_Row1, hv_Column1, hv_Row2,
                        hv_Column2);
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Colors.TupleSelect(
                                hv_ColorIndex));
                        }
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_Rectangle, HDevWindowStack.GetActive());
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ColorIndex = hv_ColorIndex + 1;
                            hv_ColorIndex.Dispose();
                            hv_ColorIndex = ExpTmpLocalVar_ColorIndex;
                        }
                    }
                }
                //
                //Display labels for color bar.
                hv__.Dispose(); hv__.Dispose(); hv__.Dispose(); hv_TextHeight.Dispose();
                HOperatorSet.GetStringExtents(hv_WindowHandle, "0123456789", out hv__, out hv__,
                    out hv__, out hv_TextHeight);
                for (hv_Index = (double)(0); (double)hv_Index <= 1; hv_Index = (double)hv_Index + 0.2)
                {
                    hv_Text.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Text = ((hv_MaxValue - (hv_Index * hv_MaxValue))).TupleString(
                            ".1f");
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "image", hv_Index * (hv_ImageHeight - (2 * (hv_TextHeight / hv_WindowImageRatio))),
                                hv_ImageWidth + (40 / hv_WindowImageRatio), "black", "box", "false");
                        }
                    }
                }
                //
                HOperatorSet.SetSystem("clip_region", hv_ClipRegion);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
                }
                ho_Rectangle.Dispose();

                hv_ClipRegion.Dispose();
                hv_ColorIndex.Dispose();
                hv_RectHeight.Dispose();
                hv_DrawMode.Dispose();
                hv_Row.Dispose();
                hv_Row1.Dispose();
                hv_Column1.Dispose();
                hv_Row2.Dispose();
                hv_Column2.Dispose();
                hv__.Dispose();
                hv_TextHeight.Dispose();
                hv_Index.Dispose();
                hv_Text.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Rectangle.Dispose();

                hv_ClipRegion.Dispose();
                hv_ColorIndex.Dispose();
                hv_RectHeight.Dispose();
                hv_DrawMode.Dispose();
                hv_Row.Dispose();
                hv_Row1.Dispose();
                hv_Column1.Dispose();
                hv_Row2.Dispose();
                hv_Column2.Dispose();
                hv__.Dispose();
                hv_TextHeight.Dispose();
                hv_Index.Dispose();
                hv_Text.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: Display a matrix inside a window 
        public void dev_display_matrix(HTuple hv_Matrix, HTuple hv_ColumnNames, HTuple hv_RowNames,
            HTuple hv_WindowHandle, HTuple hv_GenParam)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_NumRows = new HTuple(), hv_NumColumns = new HTuple();
            HTuple hv_DisplayColumnWidth = new HTuple(), hv_DisplayColor = new HTuple();
            HTuple hv_IdxsNoDisplay = new HTuple(), hv_AxisTitles = new HTuple();
            HTuple hv_ValueColors = new HTuple(), hv_NumberFormat = new HTuple();
            HTuple hv_Title = new HTuple(), hv_AxisColor = new HTuple();
            HTuple hv_GenParamKeys = new HTuple(), hv_KeyExists = new HTuple();
            HTuple hv_ValueTmp = new HTuple(), hv_ColStringWidths = new HTuple();
            HTuple hv_AllNames = new HTuple(), hv_MaxStringWidth = new HTuple();
            HTuple hv_StringIndex = new HTuple(), hv_String = new HTuple();
            HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
            HTuple hv_StringWidth = new HTuple(), hv_StringHeight = new HTuple();
            HTuple hv_TitleHeight = new HTuple(), hv_AxisTitleHeight = new HTuple();
            HTuple hv_TitleAscent = new HTuple(), hv_TitleDescent = new HTuple();
            HTuple hv_TitleWidth = new HTuple(), hv_AxisTitleAscent = new HTuple();
            HTuple hv_AxisTitleDescent = new HTuple(), hv_AxisTitleWidth = new HTuple();
            HTuple hv_RowStart = new HTuple(), hv_RowDistance = new HTuple();
            HTuple hv_RowEnd = new HTuple(), hv_ColumnStart = new HTuple();
            HTuple hv_ColumnOffset = new HTuple(), hv_ColumnEnd = new HTuple();
            HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
            HTuple hv_WidthLimit = new HTuple(), hv_HeightLimit = new HTuple();
            HTuple hv_TextRow = new HTuple(), hv_TextColumn = new HTuple();
            HTuple hv_RowStartTmp = new HTuple(), hv_ColumnDistance = new HTuple();
            HTuple hv_Index = new HTuple(), hv_AxisTitleRowX = new HTuple();
            HTuple hv_MatrixText = new HTuple(), hv_IdxsDisplay = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //Display a matrix in a window.
                //
                //GenParam (all are optional):
                //  - display_column_width: Either 'equal' or 'minimal'. For 'equal', all columns have the same width
                //                          that equals the width of the longest row or column-name.
                //  - display_color:        If true, the values will be displayed with the colors that are given by
                //                          'value_colors'.
                //                          Else, all values are displayed in white.
                //  - idxs_no_display:      Indices of the matrix that should not be displayed. The indices should be
                //                          given in row-major order, according to get_full_matrix. If not given or if
                //                          set to an empty tuple, all matrix values are displayed.
                //  - axis_titles:          Titles for the matrix x- and y-axis that are displayed at the top-right
                //                          and bottom-left of the matrix, respectively. Should be a tuple of length
                //                          two or an empty tuple if no axis titles should be displayed.
                //  - value_colors:         Tuple containing the hex color-string for each value of the matrix. If a
                //                          single value is given, this color is used for all values, else it must have
                //                          the length of the number of values in the matrix. Is ignored if
                //                          display_color is false.
                //  - number_format:        Format of the numbers when they are converted to strings for display.
                //                          Default: 2.0f
                //  - title:                Title of the displayed matrix, if given shown in the top-left.
                //  - row_col_names_color:  Color of column and row names. Default: 'light gray'
                //
                //
                //Get the matrix dimensions.
                hv_NumRows.Dispose(); hv_NumColumns.Dispose();
                HOperatorSet.GetSizeMatrix(hv_Matrix, out hv_NumRows, out hv_NumColumns);
                //Set defaults parameters.
                hv_DisplayColumnWidth.Dispose();
                hv_DisplayColumnWidth = "equal";
                hv_DisplayColor.Dispose();
                hv_DisplayColor = 0;
                hv_IdxsNoDisplay.Dispose();
                hv_IdxsNoDisplay = new HTuple();
                hv_AxisTitles.Dispose();
                hv_AxisTitles = new HTuple();
                hv_ValueColors.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ValueColors = HTuple.TupleGenConst(
                        hv_NumRows * hv_NumColumns, "white");
                }
                hv_NumberFormat.Dispose();
                hv_NumberFormat = "2.0f";
                hv_Title.Dispose();
                hv_Title = new HTuple();
                hv_AxisColor.Dispose();
                hv_AxisColor = "light gray";
                //Get parameters and overwrite
                hv_GenParamKeys.Dispose();
                hv_GenParamKeys = new HTuple();
                hv_GenParamKeys[0] = "display_column_width";
                hv_GenParamKeys[1] = "display_color";
                hv_GenParamKeys[2] = "idxs_no_display";
                hv_GenParamKeys[3] = "axis_titles";
                hv_GenParamKeys[4] = "value_colors";
                hv_GenParamKeys[5] = "number_format";
                hv_GenParamKeys[6] = "title";
                hv_GenParamKeys[7] = "row_col_names_color";
                if ((int)(new HTuple((new HTuple(hv_GenParam.TupleLength())).TupleGreater(0))) != 0)
                {
                    hv_KeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "key_exists", hv_GenParamKeys, out hv_KeyExists);
                    //DisplayColumnWidth.
                    if ((int)(hv_KeyExists.TupleSelect(0)) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "display_column_width", out hv_ValueTmp);
                        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
                            1))).TupleOr(new HTuple((new HTuple(((new HTuple("equal")).TupleConcat(
                            "minimal")).TupleFind(hv_ValueTmp))).TupleEqual(-1)))) != 0)
                        {
                            throw new HalconException("Invalid value for 'display_column_width'");
                        }
                        else
                        {
                            hv_DisplayColumnWidth.Dispose();
                            hv_DisplayColumnWidth = new HTuple(hv_ValueTmp);
                        }
                    }
                    //DisplayColor.
                    if ((int)(hv_KeyExists.TupleSelect(1)) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "display_color", out hv_ValueTmp);
                        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
                            1))).TupleOr(new HTuple((new HTuple(((new HTuple(1)).TupleConcat(0)).TupleFind(
                            hv_ValueTmp))).TupleEqual(-1)))) != 0)
                        {
                            throw new HalconException("Invalid value for 'display_color'");
                        }
                        else
                        {
                            hv_DisplayColor.Dispose();
                            hv_DisplayColor = new HTuple(hv_ValueTmp);
                        }
                    }
                    //ValueIdxsNoDisplay.
                    if ((int)(hv_KeyExists.TupleSelect(2)) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "idxs_no_display", out hv_ValueTmp);
                        if ((int)(new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleGreater(
                            0))) != 0)
                        {
                            if ((int)((new HTuple((new HTuple((new HTuple(((hv_ValueTmp.TupleMin()
                                )).TupleLess(0))).TupleOr(new HTuple(((hv_ValueTmp.TupleMax())).TupleGreater(
                                (hv_NumRows * hv_NumColumns) - 1))))).TupleOr(((hv_ValueTmp.TupleIsInt()
                                )).TupleNot()))).TupleOr(new HTuple((new HTuple(hv_ValueTmp.TupleLength()
                                )).TupleGreater(hv_NumRows * hv_NumColumns)))) != 0)
                            {
                                throw new HalconException("Invalid value for 'idxs_no_display'");
                            }
                        }
                        hv_IdxsNoDisplay.Dispose();
                        hv_IdxsNoDisplay = new HTuple(hv_ValueTmp);
                    }
                    //AxisTitles.
                    if ((int)(hv_KeyExists.TupleSelect(3)) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "axis_titles", out hv_ValueTmp);
                        if ((int)(new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleGreater(
                            0))) != 0)
                        {
                            if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleGreater(
                                2))).TupleOr(new HTuple(((hv_ValueTmp.TupleIsStringElem())).TupleNotEqual(
                                HTuple.TupleGenConst(new HTuple(hv_ValueTmp.TupleLength()), 1))))) != 0)
                            {
                                throw new HalconException("Invalid value for 'axis_titles'");
                            }
                        }
                        hv_AxisTitles.Dispose();
                        hv_AxisTitles = new HTuple(hv_ValueTmp);
                    }
                    //ValueColors.
                    if ((int)(((hv_KeyExists.TupleSelect(4))).TupleAnd(hv_DisplayColor)) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "value_colors", out hv_ValueTmp);
                        if ((int)(new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleGreater(
                            0))) != 0)
                        {
                            if ((int)((new HTuple((new HTuple((new HTuple(hv_ValueTmp.TupleLength()
                                )).TupleNotEqual(hv_NumColumns * hv_NumRows))).TupleAnd(new HTuple((new HTuple(hv_ValueTmp.TupleLength()
                                )).TupleNotEqual(1))))).TupleOr(((hv_ValueTmp.TupleIsString())).TupleNot()
                                )) != 0)
                            {
                                throw new HalconException("Invalid value for 'value_colors'");
                            }
                            if ((int)(new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleEqual(
                                1))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_ValueTmp = HTuple.TupleGenConst(
                                            hv_NumRows * hv_NumColumns, hv_ValueTmp);
                                        hv_ValueTmp.Dispose();
                                        hv_ValueTmp = ExpTmpLocalVar_ValueTmp;
                                    }
                                }
                            }
                        }
                        hv_ValueColors.Dispose();
                        hv_ValueColors = new HTuple(hv_ValueTmp);
                    }
                    //NumberFormat.
                    if ((int)(hv_KeyExists.TupleSelect(5)) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "number_format", out hv_ValueTmp);
                        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
                            1))).TupleOr(((hv_ValueTmp.TupleIsString())).TupleNot())) != 0)
                        {
                            throw new HalconException("Invalid value for 'number_format'");
                        }
                        else
                        {
                            hv_NumberFormat.Dispose();
                            hv_NumberFormat = new HTuple(hv_ValueTmp);
                        }
                    }
                    //Title.
                    if ((int)(hv_KeyExists.TupleSelect(6)) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "title", out hv_ValueTmp);
                        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
                            1))).TupleOr(((hv_ValueTmp.TupleIsString())).TupleNot())) != 0)
                        {
                            throw new HalconException("Invalid value for 'title'");
                        }
                        else
                        {
                            hv_Title.Dispose();
                            hv_Title = new HTuple(hv_ValueTmp);
                        }
                    }
                    //Color of column and row names.
                    if ((int)(hv_KeyExists.TupleSelect(7)) != 0)
                    {
                        hv_ValueTmp.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "row_col_names_color", out hv_ValueTmp);
                        if ((int)((new HTuple((new HTuple(hv_ValueTmp.TupleLength())).TupleNotEqual(
                            1))).TupleOr(((hv_ValueTmp.TupleIsString())).TupleNot())) != 0)
                        {
                            throw new HalconException("Invalid value for 'row_col_names_color'");
                        }
                        else
                        {
                            hv_AxisColor.Dispose();
                            hv_AxisColor = new HTuple(hv_ValueTmp);
                        }
                    }
                }
                //
                //
                //Calculate the width of row and column-name-strings.
                hv_ColStringWidths.Dispose();
                hv_ColStringWidths = new HTuple();
                hv_AllNames.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_AllNames = new HTuple();
                    hv_AllNames = hv_AllNames.TupleConcat(hv_ColumnNames, hv_RowNames);
                }
                hv_MaxStringWidth.Dispose();
                hv_MaxStringWidth = 0;
                for (hv_StringIndex = 0; (int)hv_StringIndex <= (int)((new HTuple(hv_AllNames.TupleLength()
                    )) - 1); hv_StringIndex = (int)hv_StringIndex + 1)
                {
                    hv_String.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_String = hv_AllNames.TupleSelect(
                            hv_StringIndex);
                    }
                    hv_Ascent.Dispose(); hv_Descent.Dispose(); hv_StringWidth.Dispose(); hv_StringHeight.Dispose();
                    HOperatorSet.GetStringExtents(hv_WindowHandle, hv_String, out hv_Ascent,
                        out hv_Descent, out hv_StringWidth, out hv_StringHeight);
                    if ((int)(new HTuple(hv_StringIndex.TupleLess(new HTuple(hv_ColumnNames.TupleLength()
                        )))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_ColStringWidths = hv_ColStringWidths.TupleConcat(
                                    hv_StringWidth);
                                hv_ColStringWidths.Dispose();
                                hv_ColStringWidths = ExpTmpLocalVar_ColStringWidths;
                            }
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_MaxStringWidth = hv_MaxStringWidth.TupleMax2(
                                hv_StringWidth);
                            hv_MaxStringWidth.Dispose();
                            hv_MaxStringWidth = ExpTmpLocalVar_MaxStringWidth;
                        }
                    }
                }
                //The columns should have a minimum width for 4 characters.
                hv_Ascent.Dispose(); hv_Descent.Dispose(); hv_StringWidth.Dispose(); hv_StringHeight.Dispose();
                HOperatorSet.GetStringExtents(hv_WindowHandle, "test", out hv_Ascent, out hv_Descent,
                    out hv_StringWidth, out hv_StringHeight);
                //Update the maximum string width.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_MaxStringWidth = hv_MaxStringWidth.TupleMax2(
                            hv_StringWidth);
                        hv_MaxStringWidth.Dispose();
                        hv_MaxStringWidth = ExpTmpLocalVar_MaxStringWidth;
                    }
                }
                //
                //Set parameters for nice display, e.g. distances from window border, row- and column-offsets,
                //axis titles and title.
                hv_TitleHeight.Dispose();
                hv_TitleHeight = 0;
                hv_AxisTitleHeight.Dispose();
                hv_AxisTitleHeight = 0;
                if ((int)(new HTuple((new HTuple(hv_AxisTitles.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    if ((int)(new HTuple((new HTuple(hv_Title.TupleLength())).TupleGreater(0))) != 0)
                    {
                        hv_TitleAscent.Dispose(); hv_TitleDescent.Dispose(); hv_TitleWidth.Dispose(); hv_TitleHeight.Dispose();
                        HOperatorSet.GetStringExtents(hv_WindowHandle, hv_Title, out hv_TitleAscent,
                            out hv_TitleDescent, out hv_TitleWidth, out hv_TitleHeight);
                        hv_AxisTitleAscent.Dispose(); hv_AxisTitleDescent.Dispose(); hv_AxisTitleWidth.Dispose(); hv_AxisTitleHeight.Dispose();
                        HOperatorSet.GetStringExtents(hv_WindowHandle, hv_AxisTitles, out hv_AxisTitleAscent,
                            out hv_AxisTitleDescent, out hv_AxisTitleWidth, out hv_AxisTitleHeight);
                    }
                }
                hv_RowStart.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RowStart = (80 + hv_TitleHeight) + hv_AxisTitleHeight;
                }
                hv_RowDistance.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RowDistance = hv_StringHeight + 10;
                }
                hv_RowEnd.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RowEnd = hv_StringHeight * 7;
                }
                hv_ColumnStart.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ColumnStart = 50 + hv_MaxStringWidth;
                }
                hv_ColumnOffset.Dispose();
                hv_ColumnOffset = 30;
                hv_ColumnEnd.Dispose();
                hv_ColumnEnd = new HTuple(hv_ColumnOffset);
                //
                //Adapt the window size to fit the confusion matrix.
                if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("minimal"))) != 0)
                {
                    //Every column of the confusion matrix is as narrow as possible
                    //based to the respective string widths.
                    hv_Width.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Width = (((hv_ColStringWidths.TupleSum()
                            ) + (hv_ColumnOffset * hv_NumColumns)) + hv_ColumnStart) + hv_ColumnEnd;
                    }
                }
                else if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("equal"))) != 0)
                {
                    //Every column of the confusion matrix should have the same width.
                    //based on the maximum string width.
                    hv_Width.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Width = (((hv_MaxStringWidth + hv_ColumnOffset) * hv_NumColumns) + hv_ColumnStart) + hv_ColumnEnd;
                    }
                }
                hv_Height.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Height = ((hv_RowDistance * hv_NumRows) + hv_RowStart) + hv_RowEnd;
                }
                HDevWindowStack.SetActive(hv_WindowHandle);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                }
                //
                //Set reasonable limits for graphics window (adapt if necessary).
                hv_WidthLimit.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WidthLimit = new HTuple();
                    hv_WidthLimit[0] = 450;
                    hv_WidthLimit = hv_WidthLimit.TupleConcat(hv_Width);
                }
                hv_HeightLimit.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HeightLimit = new HTuple();
                    hv_HeightLimit[0] = 250;
                    hv_HeightLimit = hv_HeightLimit.TupleConcat(hv_Height);
                }
                dev_resize_window_fit_size(0, 0, hv_Width, hv_Height, hv_WidthLimit, hv_HeightLimit);
                //
                //
                //Calculate row and column coordinates for display of values.
                hv_TextRow.Dispose();
                hv_TextRow = new HTuple();
                hv_TextColumn.Dispose();
                hv_TextColumn = new HTuple();
                hv_RowStartTmp.Dispose();
                hv_RowStartTmp = 0;
                hv_ColumnDistance.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ColumnDistance = new HTuple();
                    hv_ColumnDistance[0] = 0;
                    hv_ColumnDistance = hv_ColumnDistance.TupleConcat((((hv_ColStringWidths.TupleSelectRange(
                        0, hv_NumColumns - 2)) + hv_ColumnOffset)).TupleCumul());
                }
                if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("equal"))) != 0)
                {
                    hv_ColumnDistance.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ColumnDistance = HTuple.TupleGenSequence(
                            0, hv_NumColumns - 1, 1) * (hv_MaxStringWidth + hv_ColumnOffset);
                    }
                }
                HTuple end_val183 = hv_NumRows - 1;
                HTuple step_val183 = 1;
                for (hv_Index = 0; hv_Index.Continue(end_val183, step_val183); hv_Index = hv_Index.TupleAdd(step_val183))
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_TextRow = hv_TextRow.TupleConcat(
                                HTuple.TupleGenConst(hv_NumColumns, hv_RowStartTmp));
                            hv_TextRow.Dispose();
                            hv_TextRow = ExpTmpLocalVar_TextRow;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_RowStartTmp = hv_RowStartTmp + hv_RowDistance;
                            hv_RowStartTmp.Dispose();
                            hv_RowStartTmp = ExpTmpLocalVar_RowStartTmp;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_TextColumn = hv_TextColumn.TupleConcat(
                                hv_ColumnDistance);
                            hv_TextColumn.Dispose();
                            hv_TextColumn = ExpTmpLocalVar_TextColumn;
                        }
                    }
                }
                //Display the confusion matrix with a margin from the top and left.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_TextColumn = hv_TextColumn + hv_ColumnStart;
                        hv_TextColumn.Dispose();
                        hv_TextColumn = ExpTmpLocalVar_TextColumn;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_TextRow = hv_TextRow + hv_RowStart;
                        hv_TextRow.Dispose();
                        hv_TextRow = ExpTmpLocalVar_TextRow;
                    }
                }
                //
                //Display axis titles.
                if ((int)(new HTuple((new HTuple(hv_AxisTitles.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    if ((int)(new HTuple((new HTuple(hv_Title.TupleLength())).TupleGreater(0))) != 0)
                    {
                        hv_TitleAscent.Dispose(); hv_TitleDescent.Dispose(); hv_TitleWidth.Dispose(); hv_TitleHeight.Dispose();
                        HOperatorSet.GetStringExtents(hv_WindowHandle, hv_Title, out hv_TitleAscent,
                            out hv_TitleDescent, out hv_TitleWidth, out hv_TitleHeight);
                        hv_AxisTitleRowX.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_AxisTitleRowX = 1.5 * (hv_TitleHeight.TupleCeil()
                                );
                        }
                    }
                    else
                    {
                        hv_AxisTitleRowX.Dispose();
                        hv_AxisTitleRowX = "top";
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_AxisTitles.TupleSelect(
                                0), "window", hv_AxisTitleRowX, "right", "white", "box", "false");
                        }
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_AxisTitles.TupleSelect(
                                1), "window", "bottom", "left", "white", "box", "false");
                        }
                    }
                }
                //
                //Display title.
                if ((int)(new HTuple((new HTuple(hv_Title.TupleLength())).TupleGreater(0))) != 0)
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Title, "window",
                            "top", "left", "white", "box", "false");
                    }
                }
                //
                //Display row names.
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_RowNames, "window",
                            hv_TextRow.TupleSelect(HTuple.TupleGenSequence(0, hv_NumColumns * (hv_NumRows - 1),
                            hv_NumColumns)), HTuple.TupleGenConst(hv_NumRows, ((hv_TextColumn.TupleSelect(
                            0)) - hv_MaxStringWidth) - hv_ColumnOffset), hv_AxisColor, "box", "false");
                    }
                }
                //
                //Display column names.
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ColumnNames, "window",
                            HTuple.TupleGenConst(hv_NumColumns, (hv_TextRow.TupleSelect(0)) - hv_RowDistance),
                            hv_TextColumn.TupleSelectRange(0, hv_NumColumns - 1), hv_AxisColor, "box",
                            "false");
                    }
                }
                //
                //
                //Align the numbers right.
                hv_MatrixText.Dispose();
                HOperatorSet.GetFullMatrix(hv_Matrix, out hv_MatrixText);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_MatrixText = hv_MatrixText.TupleString(
                            hv_NumberFormat);
                        hv_MatrixText.Dispose();
                        hv_MatrixText = ExpTmpLocalVar_MatrixText;
                    }
                }
                //
                //
                //Handle no-display indices.
                hv_IdxsDisplay.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_IdxsDisplay = (HTuple.TupleGenSequence(
                        0, (new HTuple(hv_MatrixText.TupleLength())) - 1, 1)).TupleDifference(hv_IdxsNoDisplay);
                }
                //
                //Display confusion matrix.
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_MatrixText.TupleSelect(
                            hv_IdxsDisplay), "window", hv_TextRow.TupleSelect(hv_IdxsDisplay), hv_TextColumn.TupleSelect(
                            hv_IdxsDisplay), hv_ValueColors.TupleSelect(hv_IdxsDisplay), "box", "false");
                    }
                }

                hv_NumRows.Dispose();
                hv_NumColumns.Dispose();
                hv_DisplayColumnWidth.Dispose();
                hv_DisplayColor.Dispose();
                hv_IdxsNoDisplay.Dispose();
                hv_AxisTitles.Dispose();
                hv_ValueColors.Dispose();
                hv_NumberFormat.Dispose();
                hv_Title.Dispose();
                hv_AxisColor.Dispose();
                hv_GenParamKeys.Dispose();
                hv_KeyExists.Dispose();
                hv_ValueTmp.Dispose();
                hv_ColStringWidths.Dispose();
                hv_AllNames.Dispose();
                hv_MaxStringWidth.Dispose();
                hv_StringIndex.Dispose();
                hv_String.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_StringWidth.Dispose();
                hv_StringHeight.Dispose();
                hv_TitleHeight.Dispose();
                hv_AxisTitleHeight.Dispose();
                hv_TitleAscent.Dispose();
                hv_TitleDescent.Dispose();
                hv_TitleWidth.Dispose();
                hv_AxisTitleAscent.Dispose();
                hv_AxisTitleDescent.Dispose();
                hv_AxisTitleWidth.Dispose();
                hv_RowStart.Dispose();
                hv_RowDistance.Dispose();
                hv_RowEnd.Dispose();
                hv_ColumnStart.Dispose();
                hv_ColumnOffset.Dispose();
                hv_ColumnEnd.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_WidthLimit.Dispose();
                hv_HeightLimit.Dispose();
                hv_TextRow.Dispose();
                hv_TextColumn.Dispose();
                hv_RowStartTmp.Dispose();
                hv_ColumnDistance.Dispose();
                hv_Index.Dispose();
                hv_AxisTitleRowX.Dispose();
                hv_MatrixText.Dispose();
                hv_IdxsDisplay.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_NumRows.Dispose();
                hv_NumColumns.Dispose();
                hv_DisplayColumnWidth.Dispose();
                hv_DisplayColor.Dispose();
                hv_IdxsNoDisplay.Dispose();
                hv_AxisTitles.Dispose();
                hv_ValueColors.Dispose();
                hv_NumberFormat.Dispose();
                hv_Title.Dispose();
                hv_AxisColor.Dispose();
                hv_GenParamKeys.Dispose();
                hv_KeyExists.Dispose();
                hv_ValueTmp.Dispose();
                hv_ColStringWidths.Dispose();
                hv_AllNames.Dispose();
                hv_MaxStringWidth.Dispose();
                hv_StringIndex.Dispose();
                hv_String.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_StringWidth.Dispose();
                hv_StringHeight.Dispose();
                hv_TitleHeight.Dispose();
                hv_AxisTitleHeight.Dispose();
                hv_TitleAscent.Dispose();
                hv_TitleDescent.Dispose();
                hv_TitleWidth.Dispose();
                hv_AxisTitleAscent.Dispose();
                hv_AxisTitleDescent.Dispose();
                hv_AxisTitleWidth.Dispose();
                hv_RowStart.Dispose();
                hv_RowDistance.Dispose();
                hv_RowEnd.Dispose();
                hv_ColumnStart.Dispose();
                hv_ColumnOffset.Dispose();
                hv_ColumnEnd.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_WidthLimit.Dispose();
                hv_HeightLimit.Dispose();
                hv_TextRow.Dispose();
                hv_TextColumn.Dispose();
                hv_RowStartTmp.Dispose();
                hv_ColumnDistance.Dispose();
                hv_Index.Dispose();
                hv_AxisTitleRowX.Dispose();
                hv_MatrixText.Dispose();
                hv_IdxsDisplay.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: This procedure draws a pie chart into the active window handle. 
        public void dev_display_pie_chart(HTuple hv_WindowHandle, HTuple hv_Ratios, HTuple hv_Row,
            HTuple hv_Column, HTuple hv_Radius, HTuple hv_Colors, HTuple hv_GenParam)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Sectors, ho_Arc = null, ho_Sector = null;

            // Local control variables 

            HTuple hv_Tolerance = new HTuple(), hv_InitialWindowHandle = new HTuple();
            HTuple hv_NoInitialWindow = new HTuple(), hv_Red = new HTuple();
            HTuple hv_Green = new HTuple(), hv_Blue = new HTuple();
            HTuple hv_Alpha = new HTuple(), hv_InitialColor = new HTuple();
            HTuple hv_IndexColor = new HTuple(), hv_Color_RGBA = new HTuple();
            HTuple hv_Title = new HTuple(), hv_TitleColor = new HTuple();
            HTuple hv_TitleKeyExists = new HTuple(), hv_TitleColorKeyExists = new HTuple();
            HTuple hv_GivenTitle = new HTuple(), hv_GivenTitleColor = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_FullCircleAngle = new HTuple();
            HTuple hv_StartAngle = new HTuple(), hv_DrawColors = new HTuple();
            HTuple hv_K = new HTuple(), hv_EndAngle = new HTuple();
            HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
            HTuple hv_HomMat2DIdentity = new HTuple(), hv_HomMat2DRotate = new HTuple();
            HTuple hv_ContourStyle = new HTuple(), hv_Ascent = new HTuple();
            HTuple hv_Descent = new HTuple(), hv_Width = new HTuple();
            HTuple hv_Height = new HTuple();
            HTuple hv_Colors_COPY_INP_TMP = new HTuple(hv_Colors);
            HTuple hv_Ratios_COPY_INP_TMP = new HTuple(hv_Ratios);

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Sectors);
            HOperatorSet.GenEmptyObj(out ho_Arc);
            HOperatorSet.GenEmptyObj(out ho_Sector);
            try
            {
                //
                //Draw a pie-chart into the active window.
                //
                //Check input Ratios.
                if ((int)(new HTuple(((((hv_Ratios_COPY_INP_TMP.TupleLessElem(0.0))).TupleSum()
                    )).TupleGreater(0))) != 0)
                {
                    throw new HalconException("Values of parameter Ratios must be positive.");
                }
                hv_Tolerance.Dispose();
                hv_Tolerance = 0.1;
                if ((int)(new HTuple(((((1 - (hv_Ratios_COPY_INP_TMP.TupleSum()))).TupleAbs()
                    )).TupleGreaterEqual(hv_Tolerance))) != 0)
                {
                    throw new HalconException("Sum of Ratios differs too much from 1.");
                }
                //
                //Get current window handle.
                if (HDevWindowStack.IsOpen())
                {
                    hv_InitialWindowHandle = HDevWindowStack.GetActive();
                }
                //In case there is no open window, no initial values are to be reset.
                hv_NoInitialWindow.Dispose();
                hv_NoInitialWindow = 0;
                if ((int)(new HTuple(hv_InitialWindowHandle.TupleEqual(-1))) != 0)
                {
                    hv_NoInitialWindow.Dispose();
                    hv_NoInitialWindow = 1;
                }
                else
                {
                    //Get current set color.
                    hv_Red.Dispose(); hv_Green.Dispose(); hv_Blue.Dispose(); hv_Alpha.Dispose();
                    HOperatorSet.GetRgba(hv_InitialWindowHandle, out hv_Red, out hv_Green, out hv_Blue,
                        out hv_Alpha);
                    hv_InitialColor.Dispose();
                    hv_InitialColor = new HTuple();
                    for (hv_IndexColor = 0; (int)hv_IndexColor <= (int)((new HTuple(hv_Red.TupleLength()
                        )) - 1); hv_IndexColor = (int)hv_IndexColor + 1)
                    {
                        hv_Color_RGBA.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Color_RGBA = ((("#" + (((hv_Red.TupleSelect(
                                hv_IndexColor))).TupleString("2x"))) + (((hv_Green.TupleSelect(hv_IndexColor))).TupleString(
                                "2x"))) + (((hv_Blue.TupleSelect(hv_IndexColor))).TupleString("2x"))) + (((hv_Alpha.TupleSelect(
                                hv_IndexColor))).TupleString("2x"));
                        }
                        {
                            HTuple ExpTmpOutVar_0;
                            HOperatorSet.TupleRegexpReplace(hv_Color_RGBA, (new HTuple(" ")).TupleConcat(
                                "replace_all"), "0", out ExpTmpOutVar_0);
                            hv_Color_RGBA.Dispose();
                            hv_Color_RGBA = ExpTmpOutVar_0;
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_InitialColor = hv_InitialColor.TupleConcat(
                                    hv_Color_RGBA);
                                hv_InitialColor.Dispose();
                                hv_InitialColor = ExpTmpLocalVar_InitialColor;
                            }
                        }
                    }
                }
                HDevWindowStack.SetActive(hv_WindowHandle);
                //
                //In case no segment colors are specified, generate random colors.
                if ((int)(new HTuple((new HTuple(hv_Colors_COPY_INP_TMP.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    //Generate random colors.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Colors_COPY_INP_TMP.Dispose();
                        get_distinct_colors_dev_display_pie_chart(new HTuple(hv_Ratios_COPY_INP_TMP.TupleLength()
                            ), 1, 0, 220, out hv_Colors_COPY_INP_TMP);
                    }
                }
                //
                //Set default parameters.
                hv_Title.Dispose();
                hv_Title = new HTuple();
                hv_TitleColor.Dispose();
                hv_TitleColor = "white";
                //Get generic parameters.
                if ((int)(new HTuple((new HTuple(hv_GenParam.TupleLength())).TupleGreater(0))) != 0)
                {
                    hv_TitleKeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "key_exists", "title", out hv_TitleKeyExists);
                    hv_TitleColorKeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "key_exists", "title_color", out hv_TitleColorKeyExists);
                    //
                    //Title text.
                    if ((int)(hv_TitleKeyExists) != 0)
                    {
                        hv_GivenTitle.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "title", out hv_GivenTitle);
                        if ((int)((new HTuple(((hv_GivenTitle.TupleIsString())).TupleNot())).TupleOr(
                            new HTuple(((hv_GivenTitle.TupleStrlen())).TupleLess(1)))) != 0)
                        {
                            throw new HalconException("Invalid value for key 'title'");
                        }
                        hv_Title.Dispose();
                        hv_Title = new HTuple(hv_GivenTitle);
                    }
                    //Title color.
                    if ((int)(hv_TitleColorKeyExists) != 0)
                    {
                        hv_GivenTitleColor.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, "title_color", out hv_GivenTitleColor);
                        if ((int)(((hv_GivenTitleColor.TupleIsString())).TupleNot()) != 0)
                        {
                            throw new HalconException("Invalid value for key 'title_color'");
                        }
                        try
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_GivenTitleColor);
                            }
                        }
                        // catch (Exception) 
                        catch (HalconException HDevExpDefaultException1)
                        {
                            HDevExpDefaultException1.ToHTuple(out hv_Exception);
                            throw new HalconException("Invalid value for key 'title_color'");
                        }
                        hv_TitleColor.Dispose();
                        hv_TitleColor = new HTuple(hv_GivenTitleColor);
                    }
                }
                hv_FullCircleAngle.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_FullCircleAngle = 2 * 3.14159;
                }
                hv_StartAngle.Dispose();
                hv_StartAngle = 0;
                //
                //Generate circle-sectors.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_Ratios = hv_Ratios_COPY_INP_TMP / (hv_Ratios_COPY_INP_TMP.TupleSum()
                            );
                        hv_Ratios_COPY_INP_TMP.Dispose();
                        hv_Ratios_COPY_INP_TMP = ExpTmpLocalVar_Ratios;
                    }
                }
                hv_DrawColors.Dispose();
                hv_DrawColors = new HTuple();
                ho_Sectors.Dispose();
                HOperatorSet.GenEmptyObj(out ho_Sectors);
                for (hv_K = 0; (int)hv_K <= (int)((new HTuple(hv_Ratios_COPY_INP_TMP.TupleLength()
                    )) - 1); hv_K = (int)hv_K + 1)
                {
                    if ((int)(new HTuple(((hv_Ratios_COPY_INP_TMP.TupleSelect(hv_K))).TupleGreater(
                        0))) != 0)
                    {
                        hv_EndAngle.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_EndAngle = hv_StartAngle + ((hv_Ratios_COPY_INP_TMP.TupleSelect(
                                hv_K)) * hv_FullCircleAngle);
                        }
                        ho_Arc.Dispose();
                        HOperatorSet.GenCircleContourXld(out ho_Arc, hv_Row, hv_Column, hv_Radius,
                            hv_StartAngle, hv_EndAngle, "positive", 1);
                        hv_Rows.Dispose(); hv_Columns.Dispose();
                        HOperatorSet.GetContourXld(ho_Arc, out hv_Rows, out hv_Columns);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_Sector.Dispose();
                            HOperatorSet.GenContourPolygonXld(out ho_Sector, ((hv_Row.TupleConcat(hv_Rows))).TupleConcat(
                                hv_Row), ((hv_Column.TupleConcat(hv_Columns))).TupleConcat(hv_Column));
                        }
                        hv_StartAngle.Dispose();
                        hv_StartAngle = new HTuple(hv_EndAngle);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_DrawColors = hv_DrawColors.TupleConcat(
                                    hv_Colors_COPY_INP_TMP.TupleSelect(hv_K));
                                hv_DrawColors.Dispose();
                                hv_DrawColors = ExpTmpLocalVar_DrawColors;
                            }
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_Sectors, ho_Sector, out ExpTmpOutVar_0);
                            ho_Sectors.Dispose();
                            ho_Sectors = ExpTmpOutVar_0;
                        }
                    }
                }
                //Rotate 90 degrees such that the first sector starts at the top.
                hv_HomMat2DIdentity.Dispose();
                HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HomMat2DRotate.Dispose();
                    HOperatorSet.HomMat2dRotate(hv_HomMat2DIdentity, 0.25 * hv_FullCircleAngle, hv_Row,
                        hv_Column, out hv_HomMat2DRotate);
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.AffineTransContourXld(ho_Sectors, out ExpTmpOutVar_0, hv_HomMat2DRotate);
                    ho_Sectors.Dispose();
                    ho_Sectors = ExpTmpOutVar_0;
                }
                //
                //Display sectors.
                HDevWindowStack.SetActive(hv_WindowHandle);
                hv_ContourStyle.Dispose();
                HOperatorSet.GetContourStyle(hv_WindowHandle, out hv_ContourStyle);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetContourStyle(HDevWindowStack.GetActive(), "stroke_and_fill");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_DrawColors);
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispObj(ho_Sectors, HDevWindowStack.GetActive());
                }
                //(Optional) title.
                if ((int)(new HTuple(hv_Title.TupleNotEqual(new HTuple()))) != 0)
                {
                    hv_Ascent.Dispose(); hv_Descent.Dispose(); hv_Width.Dispose(); hv_Height.Dispose();
                    HOperatorSet.GetStringExtents(hv_WindowHandle, hv_Title, out hv_Ascent, out hv_Descent,
                        out hv_Width, out hv_Height);
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Title, "image", (((hv_Row - hv_Radius) - hv_Height) - hv_Ascent) - hv_Descent,
                                hv_Column - (hv_Width / 2), hv_TitleColor, "box", "false");
                        }
                    }
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetContourStyle(HDevWindowStack.GetActive(), hv_ContourStyle);
                }
                //
                //Reset original window and colors (and close the window in case there was none open).
                if ((int)(hv_NoInitialWindow) != 0)
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                    }
                }
                else
                {
                    HDevWindowStack.SetActive(hv_InitialWindowHandle);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_InitialColor);
                    }
                }
                ho_Sectors.Dispose();
                ho_Arc.Dispose();
                ho_Sector.Dispose();

                hv_Colors_COPY_INP_TMP.Dispose();
                hv_Ratios_COPY_INP_TMP.Dispose();
                hv_Tolerance.Dispose();
                hv_InitialWindowHandle.Dispose();
                hv_NoInitialWindow.Dispose();
                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();
                hv_Alpha.Dispose();
                hv_InitialColor.Dispose();
                hv_IndexColor.Dispose();
                hv_Color_RGBA.Dispose();
                hv_Title.Dispose();
                hv_TitleColor.Dispose();
                hv_TitleKeyExists.Dispose();
                hv_TitleColorKeyExists.Dispose();
                hv_GivenTitle.Dispose();
                hv_GivenTitleColor.Dispose();
                hv_Exception.Dispose();
                hv_FullCircleAngle.Dispose();
                hv_StartAngle.Dispose();
                hv_DrawColors.Dispose();
                hv_K.Dispose();
                hv_EndAngle.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_HomMat2DIdentity.Dispose();
                hv_HomMat2DRotate.Dispose();
                hv_ContourStyle.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Sectors.Dispose();
                ho_Arc.Dispose();
                ho_Sector.Dispose();

                hv_Colors_COPY_INP_TMP.Dispose();
                hv_Ratios_COPY_INP_TMP.Dispose();
                hv_Tolerance.Dispose();
                hv_InitialWindowHandle.Dispose();
                hv_NoInitialWindow.Dispose();
                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();
                hv_Alpha.Dispose();
                hv_InitialColor.Dispose();
                hv_IndexColor.Dispose();
                hv_Color_RGBA.Dispose();
                hv_Title.Dispose();
                hv_TitleColor.Dispose();
                hv_TitleKeyExists.Dispose();
                hv_TitleColorKeyExists.Dispose();
                hv_GivenTitle.Dispose();
                hv_GivenTitleColor.Dispose();
                hv_Exception.Dispose();
                hv_FullCircleAngle.Dispose();
                hv_StartAngle.Dispose();
                hv_DrawColors.Dispose();
                hv_K.Dispose();
                hv_EndAngle.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_HomMat2DIdentity.Dispose();
                hv_HomMat2DRotate.Dispose();
                hv_ContourStyle.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection
        // Short Description: Display the detected anomaly regions. 
        public void dev_display_result_anomaly_regions(HObject ho_AnomalyImage, out HObject ho_AnomalyRegion,
            HTuple hv_CurrentWindowHandle, HTuple hv_AnomalyRegionThreshold, HTuple hv_LineWidth,
            HTuple hv_AnomalyRegionResultColor)
        {




            // Local iconic variables 

            // Local control variables 

            HTuple hv_Red = new HTuple(), hv_Green = new HTuple();
            HTuple hv_Blue = new HTuple(), hv_Alpha = new HTuple();
            HTuple hv_InitialColor = new HTuple(), hv_IndexColor = new HTuple();
            HTuple hv_Color_RGBA = new HTuple(), hv_Area = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_AnomalyRegion);
            try
            {
                //
                //This procedure displays the result anomaly regions
                //given in DLResult as anomaly_image.
                //
                //Get current set color.
                hv_Red.Dispose(); hv_Green.Dispose(); hv_Blue.Dispose(); hv_Alpha.Dispose();
                HOperatorSet.GetRgba(hv_CurrentWindowHandle, out hv_Red, out hv_Green, out hv_Blue,
                    out hv_Alpha);
                hv_InitialColor.Dispose();
                hv_InitialColor = new HTuple();
                for (hv_IndexColor = 0; (int)hv_IndexColor <= (int)((new HTuple(hv_Red.TupleLength()
                    )) - 1); hv_IndexColor = (int)hv_IndexColor + 1)
                {
                    hv_Color_RGBA.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Color_RGBA = ((("#" + (((hv_Red.TupleSelect(
                            hv_IndexColor))).TupleString("2x"))) + (((hv_Green.TupleSelect(hv_IndexColor))).TupleString(
                            "2x"))) + (((hv_Blue.TupleSelect(hv_IndexColor))).TupleString("2x"))) + (((hv_Alpha.TupleSelect(
                            hv_IndexColor))).TupleString("2x"));
                    }
                    {
                        HTuple ExpTmpOutVar_0;
                        HOperatorSet.TupleRegexpReplace(hv_Color_RGBA, (new HTuple(" ")).TupleConcat(
                            "replace_all"), "0", out ExpTmpOutVar_0);
                        hv_Color_RGBA.Dispose();
                        hv_Color_RGBA = ExpTmpOutVar_0;
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_InitialColor = hv_InitialColor.TupleConcat(
                                hv_Color_RGBA);
                            hv_InitialColor.Dispose();
                            hv_InitialColor = ExpTmpLocalVar_InitialColor;
                        }
                    }
                }
                //
                if ((int)((new HTuple(hv_AnomalyRegionThreshold.TupleGreater(1))).TupleOr(new HTuple(hv_AnomalyRegionThreshold.TupleLess(
                    0)))) != 0)
                {
                    throw new HalconException("Selected 'anomaly_region_threshold' out of range. It must be between 0 and 1.");
                }
                ho_AnomalyRegion.Dispose();
                HOperatorSet.Threshold(ho_AnomalyImage, out ho_AnomalyRegion, hv_AnomalyRegionThreshold,
                    1);
                //
                //Display anomaly regions.
                //Get non-empty regions.
                hv_Area.Dispose();
                HOperatorSet.RegionFeatures(ho_AnomalyRegion, "area", out hv_Area);
                //
                //Display all non-empty class regions in distinct colors.
                if ((int)(new HTuple(hv_Area.TupleGreater(0))) != 0)
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_AnomalyRegionResultColor);
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidth);
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_AnomalyRegion, HDevWindowStack.GetActive());
                    }
                }
                //
                //Reset colors.
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_InitialColor);
                }
                //

                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();
                hv_Alpha.Dispose();
                hv_InitialColor.Dispose();
                hv_IndexColor.Dispose();
                hv_Color_RGBA.Dispose();
                hv_Area.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();
                hv_Alpha.Dispose();
                hv_InitialColor.Dispose();
                hv_IndexColor.Dispose();
                hv_Color_RGBA.Dispose();
                hv_Area.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: Display result bounding boxes. 
        public void dev_display_result_detection(HTuple hv_DLResult, HTuple hv_ResultKeys,
            HTuple hv_LineWidthBbox, HTuple hv_ClassIDs, HTuple hv_TextConf, HTuple hv_Colors,
            HTuple hv_BoxLabelColor, HTuple hv_WindowImageRatio, HTuple hv_TextPositionRow,
            HTuple hv_TextColor, HTuple hv_ShowLabels, HTuple hv_ShowDirection, HTuple hv_WindowHandle,
            out HTuple hv_BboxIDs)
        {



            // Local iconic variables 

            HObject ho_BboxRectangle = null, ho_OrientationArrows = null;
            HObject ho_RectangleSelected = null, ho_ArrowSelected = null;

            // Local control variables 

            HTuple hv_InstanceType = new HTuple(), hv_BboxRow1 = new HTuple();
            HTuple hv_BboxCol1 = new HTuple(), hv_BboxRow2 = new HTuple();
            HTuple hv_BboxCol2 = new HTuple(), hv_BboxClasses = new HTuple();
            HTuple hv_BboxRow = new HTuple(), hv_BboxCol = new HTuple();
            HTuple hv_BboxLength1 = new HTuple(), hv_BboxLength2 = new HTuple();
            HTuple hv_BboxPhi = new HTuple(), hv_LabelRow1 = new HTuple();
            HTuple hv_LabelRow2 = new HTuple(), hv_LabelCol = new HTuple();
            HTuple hv_HeadSize = new HTuple(), hv_DrawMode = new HTuple();
            HTuple hv_Style = new HTuple(), hv_BboxClassIDs = new HTuple();
            HTuple hv_IndexBbox = new HTuple(), hv_ClassID = new HTuple();
            HTuple hv_LineWidth = new HTuple(), hv_Text = new HTuple();
            HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
            HTuple hv__ = new HTuple(), hv_TextRow = new HTuple();
            HTuple hv_TxtColor = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_BboxRectangle);
            HOperatorSet.GenEmptyObj(out ho_OrientationArrows);
            HOperatorSet.GenEmptyObj(out ho_RectangleSelected);
            HOperatorSet.GenEmptyObj(out ho_ArrowSelected);
            hv_BboxIDs = new HTuple();
            try
            {
                //
                //This procedure displays the bounding boxes defined by DLResult.
                //The ClassIDs are necessary to display bounding boxes from the same class
                //always with the same color.
                //
                hv_InstanceType.Dispose();
                hv_InstanceType = "rectangle1";
                if ((int)(new HTuple(((hv_ResultKeys.TupleFind("bbox_row1"))).TupleNotEqual(
                    -1))) != 0)
                {
                    hv_BboxRow1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_row1", out hv_BboxRow1);
                    hv_BboxCol1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_col1", out hv_BboxCol1);
                    hv_BboxRow2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_row2", out hv_BboxRow2);
                    hv_BboxCol2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_col2", out hv_BboxCol2);
                    hv_BboxClasses.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_class_id", out hv_BboxClasses);
                }
                else if ((int)(new HTuple(((hv_ResultKeys.TupleFind("bbox_phi"))).TupleNotEqual(
                    -1))) != 0)
                {
                    hv_BboxRow.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_row", out hv_BboxRow);
                    hv_BboxCol.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_col", out hv_BboxCol);
                    hv_BboxLength1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_length1", out hv_BboxLength1);
                    hv_BboxLength2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_length2", out hv_BboxLength2);
                    hv_BboxPhi.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_phi", out hv_BboxPhi);
                    hv_BboxClasses.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_class_id", out hv_BboxClasses);
                    hv_InstanceType.Dispose();
                    hv_InstanceType = "rectangle2";
                }
                else
                {
                    throw new HalconException("Result bounding box data could not be found in DLResult.");
                }
                if ((int)(new HTuple((new HTuple(hv_BboxClasses.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    //Generate bounding box XLDs.
                    if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BboxPhi.Dispose();
                            HOperatorSet.TupleGenConst(new HTuple(hv_BboxRow1.TupleLength()), 0.0,
                                out hv_BboxPhi);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_BboxRectangle.Dispose();
                            HOperatorSet.GenRectangle2ContourXld(out ho_BboxRectangle, 0.5 * (hv_BboxRow1 + hv_BboxRow2),
                                0.5 * (hv_BboxCol1 + hv_BboxCol2), hv_BboxPhi, 0.5 * (hv_BboxCol2 - hv_BboxCol1),
                                0.5 * (hv_BboxRow2 - hv_BboxRow1));
                        }
                        hv_LabelRow1.Dispose();
                        hv_LabelRow1 = new HTuple(hv_BboxRow1);
                        hv_LabelRow2.Dispose();
                        hv_LabelRow2 = new HTuple(hv_BboxRow2);
                        hv_LabelCol.Dispose();
                        hv_LabelCol = new HTuple(hv_BboxCol1);
                    }
                    else
                    {
                        ho_BboxRectangle.Dispose();
                        HOperatorSet.GenRectangle2ContourXld(out ho_BboxRectangle, hv_BboxRow,
                            hv_BboxCol, hv_BboxPhi, hv_BboxLength1, hv_BboxLength2);
                        hv_LabelRow1.Dispose();
                        hv_LabelRow1 = new HTuple(hv_BboxRow);
                        hv_LabelRow2.Dispose();
                        hv_LabelRow2 = new HTuple(hv_BboxRow);
                        hv_LabelCol.Dispose();
                        hv_LabelCol = new HTuple(hv_BboxCol);
                        if ((int)(hv_ShowDirection) != 0)
                        {
                            hv_HeadSize.Dispose();
                            hv_HeadSize = 20.0;
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_OrientationArrows.Dispose();
                                gen_arrow_contour_xld(out ho_OrientationArrows, hv_BboxRow, hv_BboxCol,
                                    hv_BboxRow - ((hv_BboxLength1 + hv_HeadSize) * (hv_BboxPhi.TupleSin())),
                                    hv_BboxCol + ((hv_BboxLength1 + hv_HeadSize) * (hv_BboxPhi.TupleCos())),
                                    hv_HeadSize, hv_HeadSize);
                            }
                        }
                    }
                    //
                    hv_DrawMode.Dispose();
                    HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
                    }
                    hv_Style.Dispose();
                    HOperatorSet.GetLineStyle(hv_WindowHandle, out hv_Style);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidthBbox);
                    }
                    //
                    //Collect ClassIDs of the bounding boxes.
                    hv_BboxIDs.Dispose();
                    hv_BboxIDs = new HTuple();
                    hv_BboxClassIDs.Dispose();
                    hv_BboxClassIDs = new HTuple();
                    //
                    //Draw bounding boxes.
                    for (hv_IndexBbox = 0; (int)hv_IndexBbox <= (int)((new HTuple(hv_BboxClasses.TupleLength()
                        )) - 1); hv_IndexBbox = (int)hv_IndexBbox + 1)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_RectangleSelected.Dispose();
                            HOperatorSet.SelectObj(ho_BboxRectangle, out ho_RectangleSelected, hv_IndexBbox + 1);
                        }
                        hv_ClassID.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClassID = hv_ClassIDs.TupleFind(
                                hv_BboxClasses.TupleSelect(hv_IndexBbox));
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_BboxClassIDs = hv_BboxClassIDs.TupleConcat(
                                    hv_ClassID);
                                hv_BboxClassIDs.Dispose();
                                hv_BboxClassIDs = ExpTmpLocalVar_BboxClassIDs;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_BboxIDs = hv_BboxIDs.TupleConcat(
                                    hv_ClassID);
                                hv_BboxIDs.Dispose();
                                hv_BboxIDs = ExpTmpLocalVar_BboxIDs;
                            }
                        }
                        hv_LineWidth.Dispose();
                        HOperatorSet.GetLineWidth(hv_WindowHandle, out hv_LineWidth);
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), ((hv_LineWidth + 2)).TupleInt()
                                    );
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetColor(HDevWindowStack.GetActive(), "black");
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_RectangleSelected, HDevWindowStack.GetActive()
                                );
                        }
                        if ((int)((new HTuple(hv_InstanceType.TupleEqual("rectangle2"))).TupleAnd(
                            hv_ShowDirection)) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_ArrowSelected.Dispose();
                                HOperatorSet.SelectObj(ho_OrientationArrows, out ho_ArrowSelected, hv_IndexBbox + 1);
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_ArrowSelected, HDevWindowStack.GetActive());
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidth.TupleInt()
                                    );
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Colors.TupleSelect(
                                    hv_ClassID));
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_RectangleSelected, HDevWindowStack.GetActive()
                                );
                        }
                        if ((int)((new HTuple(hv_InstanceType.TupleEqual("rectangle2"))).TupleAnd(
                            hv_ShowDirection)) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_ArrowSelected, HDevWindowStack.GetActive());
                            }
                        }
                    }
                    //
                    //Draw text of bounding boxes.
                    if ((int)(hv_ShowLabels) != 0)
                    {
                        //For better visibility the text is displayed after all bounding boxes are drawn.
                        for (hv_IndexBbox = 0; (int)hv_IndexBbox <= (int)((new HTuple(hv_BboxClasses.TupleLength()
                            )) - 1); hv_IndexBbox = (int)hv_IndexBbox + 1)
                        {
                            hv_ClassID.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClassID = hv_BboxClassIDs.TupleSelect(
                                    hv_IndexBbox);
                            }
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = (hv_BboxClasses.TupleSelect(
                                    hv_IndexBbox)) + (hv_TextConf.TupleSelect(hv_IndexBbox));
                            }
                            hv_Ascent.Dispose(); hv_Descent.Dispose(); hv__.Dispose(); hv__.Dispose();
                            HOperatorSet.GetStringExtents(hv_WindowHandle, hv_Text, out hv_Ascent,
                                out hv_Descent, out hv__, out hv__);
                            if ((int)(new HTuple(hv_TextPositionRow.TupleEqual("bottom"))) != 0)
                            {
                                hv_TextRow.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_TextRow = (hv_LabelRow2.TupleSelect(
                                        hv_IndexBbox)) - ((hv_Ascent + hv_Descent) / hv_WindowImageRatio);
                                }
                            }
                            else
                            {
                                hv_TextRow.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_TextRow = hv_LabelRow1.TupleSelect(
                                        hv_IndexBbox);
                                }
                            }
                            if ((int)(new HTuple(hv_TextColor.TupleEqual(""))) != 0)
                            {
                                hv_TxtColor.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_TxtColor = hv_Colors.TupleSelect(
                                        hv_ClassID);
                                }
                            }
                            else
                            {
                                hv_TxtColor.Dispose();
                                hv_TxtColor = new HTuple(hv_TextColor);
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "image",
                                        hv_TextRow, hv_LabelCol.TupleSelect(hv_IndexBbox), hv_TxtColor,
                                        ((new HTuple("box_color")).TupleConcat("shadow")).TupleConcat("border_radius"),
                                        hv_BoxLabelColor.TupleConcat((new HTuple("false")).TupleConcat(
                                        0)));
                                }
                            }
                        }
                    }
                    //
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
                    }
                    HOperatorSet.SetLineStyle(hv_WindowHandle, hv_Style);
                }
                else
                {
                    //Do nothing if no results are present.
                    hv_BboxIDs.Dispose();
                    hv_BboxIDs = new HTuple();
                }
                //
                ho_BboxRectangle.Dispose();
                ho_OrientationArrows.Dispose();
                ho_RectangleSelected.Dispose();
                ho_ArrowSelected.Dispose();

                hv_InstanceType.Dispose();
                hv_BboxRow1.Dispose();
                hv_BboxCol1.Dispose();
                hv_BboxRow2.Dispose();
                hv_BboxCol2.Dispose();
                hv_BboxClasses.Dispose();
                hv_BboxRow.Dispose();
                hv_BboxCol.Dispose();
                hv_BboxLength1.Dispose();
                hv_BboxLength2.Dispose();
                hv_BboxPhi.Dispose();
                hv_LabelRow1.Dispose();
                hv_LabelRow2.Dispose();
                hv_LabelCol.Dispose();
                hv_HeadSize.Dispose();
                hv_DrawMode.Dispose();
                hv_Style.Dispose();
                hv_BboxClassIDs.Dispose();
                hv_IndexBbox.Dispose();
                hv_ClassID.Dispose();
                hv_LineWidth.Dispose();
                hv_Text.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv__.Dispose();
                hv_TextRow.Dispose();
                hv_TxtColor.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_BboxRectangle.Dispose();
                ho_OrientationArrows.Dispose();
                ho_RectangleSelected.Dispose();
                ho_ArrowSelected.Dispose();

                hv_InstanceType.Dispose();
                hv_BboxRow1.Dispose();
                hv_BboxCol1.Dispose();
                hv_BboxRow2.Dispose();
                hv_BboxCol2.Dispose();
                hv_BboxClasses.Dispose();
                hv_BboxRow.Dispose();
                hv_BboxCol.Dispose();
                hv_BboxLength1.Dispose();
                hv_BboxLength2.Dispose();
                hv_BboxPhi.Dispose();
                hv_LabelRow1.Dispose();
                hv_LabelRow2.Dispose();
                hv_LabelCol.Dispose();
                hv_HeadSize.Dispose();
                hv_DrawMode.Dispose();
                hv_Style.Dispose();
                hv_BboxClassIDs.Dispose();
                hv_IndexBbox.Dispose();
                hv_ClassID.Dispose();
                hv_LineWidth.Dispose();
                hv_Text.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv__.Dispose();
                hv_TextRow.Dispose();
                hv_TxtColor.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: Display the ground truth/result segmentation as regions. 
        public void dev_display_segmentation_regions(HObject ho_SegmentationImage, HTuple hv_ClassIDs,
            HTuple hv_ColorsSegmentation, HTuple hv_ExcludeClassIDs, out HTuple hv_ImageClassIDs)
        {




            // Local iconic variables 

            HObject ho_Regions, ho_SelectedRegion = null;

            // Local control variables 

            HTuple hv_IncludedClassIDs = new HTuple();
            HTuple hv_Area = new HTuple(), hv_Index = new HTuple();
            HTuple hv_ClassID = new HTuple(), hv_IndexColor = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Regions);
            HOperatorSet.GenEmptyObj(out ho_SelectedRegion);
            hv_ImageClassIDs = new HTuple();
            try
            {
                //
                //This procedure displays the ground truth/result segmentation
                //given in SegmentationImage as regions. The ClassIDs are necessary to
                //display ground truth/result segmentations from the same class
                //always with the same color. It is possible to exclude certain ClassIDs
                //from being displayed. The displayed classes are returned in ImageClassIDs.
                //
                //
                //Remove excluded class IDs from the list.
                hv_IncludedClassIDs.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_IncludedClassIDs = hv_ClassIDs.TupleDifference(
                        hv_ExcludeClassIDs);
                }
                //
                //Get a region for each class ID.
                ho_Regions.Dispose();
                HOperatorSet.Threshold(ho_SegmentationImage, out ho_Regions, hv_IncludedClassIDs,
                    hv_IncludedClassIDs);
                //
                //Get classes with non-empty regions.
                hv_Area.Dispose();
                HOperatorSet.RegionFeatures(ho_Regions, "area", out hv_Area);
                hv_ImageClassIDs.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ImageClassIDs = hv_IncludedClassIDs.TupleSelectMask(
                        hv_Area.TupleGreaterElem(0));
                }
                //
                //Display all non-empty class regions in distinct colors.
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_IncludedClassIDs.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    if ((int)(new HTuple(((hv_Area.TupleSelect(hv_Index))).TupleGreater(0))) != 0)
                    {
                        //Use class ID to determine region color.
                        hv_ClassID.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClassID = hv_IncludedClassIDs.TupleSelect(
                                hv_Index);
                        }
                        hv_IndexColor.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_IndexColor = hv_ClassIDs.TupleFindFirst(
                                hv_ClassID);
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_ColorsSegmentation.TupleSelect(
                                    hv_IndexColor));
                            }
                        }
                        //Display the segmentation region.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_SelectedRegion.Dispose();
                            HOperatorSet.SelectObj(ho_Regions, out ho_SelectedRegion, hv_Index + 1);
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_SelectedRegion, HDevWindowStack.GetActive());
                        }
                    }
                }
                ho_Regions.Dispose();
                ho_SelectedRegion.Dispose();

                hv_IncludedClassIDs.Dispose();
                hv_Area.Dispose();
                hv_Index.Dispose();
                hv_ClassID.Dispose();
                hv_IndexColor.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Regions.Dispose();
                ho_SelectedRegion.Dispose();

                hv_IncludedClassIDs.Dispose();
                hv_Area.Dispose();
                hv_Index.Dispose();
                hv_ClassID.Dispose();
                hv_IndexColor.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: Display a map of weights. 
        public void dev_display_weight_regions(HObject ho_ImageWeight, HTuple hv_DrawTransparency,
            HTuple hv_SegMaxWeight, out HTuple hv_Colors)
        {




            // Local iconic variables 

            HObject ho_Domain, ho_WeightsRegion = null;

            // Local control variables 

            HTuple hv_NumColors = new HTuple(), hv_WeightsColorsAlpha = new HTuple();
            HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
            HTuple hv_GrayVal = new HTuple(), hv_GrayValWeight = new HTuple();
            HTuple hv_ColorIndex = new HTuple(), hv_ClassColor = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Domain);
            HOperatorSet.GenEmptyObj(out ho_WeightsRegion);
            hv_Colors = new HTuple();
            try
            {
                //
                //This procedure displays a map of the weights
                //given in ImageWeight as regions.
                //The transparency can be adjusted.
                //The used colors are returned.
                //
                //Define colors.
                hv_NumColors.Dispose();
                hv_NumColors = 20;
                hv_Colors.Dispose();
                get_distinct_colors(hv_NumColors, 0, 0, 160, out hv_Colors);
                {
                    HTuple ExpTmpOutVar_0;
                    HOperatorSet.TupleInverse(hv_Colors, out ExpTmpOutVar_0);
                    hv_Colors.Dispose();
                    hv_Colors = ExpTmpOutVar_0;
                }
                hv_WeightsColorsAlpha.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WeightsColorsAlpha = hv_Colors + hv_DrawTransparency;
                }
                //
                //Get gay values of ImageWeight.
                ho_Domain.Dispose();
                HOperatorSet.GetDomain(ho_ImageWeight, out ho_Domain);
                hv_Rows.Dispose(); hv_Columns.Dispose();
                HOperatorSet.GetRegionPoints(ho_Domain, out hv_Rows, out hv_Columns);
                hv_GrayVal.Dispose();
                HOperatorSet.GetGrayval(ho_ImageWeight, hv_Rows, hv_Columns, out hv_GrayVal);
                //
                //Check that the gray values of the image
                //are below the specified maximum.
                if ((int)(new HTuple(((hv_GrayVal.TupleMax())).TupleGreater(hv_SegMaxWeight))) != 0)
                {
                    throw new HalconException(((("The maximum weight (" + (hv_GrayVal.TupleMax()
                        )) + ") in the weight image is greater than the given SegMaxWeight (") + hv_SegMaxWeight) + ").");
                }
                //
                while ((int)(new HTuple(hv_GrayVal.TupleNotEqual(new HTuple()))) != 0)
                {
                    //Go through all gray value 'groups',
                    //starting from the maximum.
                    hv_GrayValWeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_GrayValWeight = hv_GrayVal.TupleMax()
                            ;
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_GrayVal = hv_GrayVal.TupleRemove(
                                hv_GrayVal.TupleFind(hv_GrayValWeight));
                            hv_GrayVal.Dispose();
                            hv_GrayVal = ExpTmpLocalVar_GrayVal;
                        }
                    }
                    ho_WeightsRegion.Dispose();
                    HOperatorSet.Threshold(ho_ImageWeight, out ho_WeightsRegion, hv_GrayValWeight,
                        hv_GrayValWeight);
                    //
                    //Visualize the respective group.
                    hv_ColorIndex.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ColorIndex = (((((hv_GrayValWeight / hv_SegMaxWeight) * (hv_NumColors - 1))).TupleCeil()
                            )).TupleInt();
                    }
                    hv_ClassColor.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassColor = hv_WeightsColorsAlpha.TupleSelect(
                            hv_ColorIndex);
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_ClassColor);
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_WeightsRegion, HDevWindowStack.GetActive());
                    }
                }
                ho_Domain.Dispose();
                ho_WeightsRegion.Dispose();

                hv_NumColors.Dispose();
                hv_WeightsColorsAlpha.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_GrayVal.Dispose();
                hv_GrayValWeight.Dispose();
                hv_ColorIndex.Dispose();
                hv_ClassColor.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Domain.Dispose();
                ho_WeightsRegion.Dispose();

                hv_NumColors.Dispose();
                hv_WeightsColorsAlpha.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_GrayVal.Dispose();
                hv_GrayValWeight.Dispose();
                hv_ColorIndex.Dispose();
                hv_ClassColor.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Develop
        // Short Description: Open a new graphics window that preserves the aspect ratio of the given image size. 
        public void dev_open_window_fit_size(HTuple hv_Row, HTuple hv_Column, HTuple hv_Width,
            HTuple hv_Height, HTuple hv_WidthLimit, HTuple hv_HeightLimit, out HTuple hv_WindowHandle)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_MinWidth = new HTuple(), hv_MaxWidth = new HTuple();
            HTuple hv_MinHeight = new HTuple(), hv_MaxHeight = new HTuple();
            HTuple hv_ResizeFactor = new HTuple(), hv_TempWidth = new HTuple();
            HTuple hv_TempHeight = new HTuple(), hv_WindowWidth = new HTuple();
            HTuple hv_WindowHeight = new HTuple();
            // Initialize local and output iconic variables 
            hv_WindowHandle = new HTuple();
            try
            {
                //This procedure open a new graphic window
                //such that it fits into the limits specified by WidthLimit
                //and HeightLimit, but also maintains the correct aspect ratio
                //given by Width and Height.
                //
                //If it is impossible to match the minimum and maximum extent requirements
                //at the same time (f.e. if the image is very long but narrow),
                //the maximum value gets a higher priority.
                //
                //Parse input tuple WidthLimit
                if ((int)((new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_WidthLimit.TupleLess(0)))) != 0)
                {
                    hv_MinWidth.Dispose();
                    hv_MinWidth = 500;
                    hv_MaxWidth.Dispose();
                    hv_MaxWidth = 800;
                }
                else if ((int)(new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
                    1))) != 0)
                {
                    hv_MinWidth.Dispose();
                    hv_MinWidth = 0;
                    hv_MaxWidth.Dispose();
                    hv_MaxWidth = new HTuple(hv_WidthLimit);
                }
                else
                {
                    hv_MinWidth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MinWidth = hv_WidthLimit.TupleSelect(
                            0);
                    }
                    hv_MaxWidth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxWidth = hv_WidthLimit.TupleSelect(
                            1);
                    }
                }
                //Parse input tuple HeightLimit
                if ((int)((new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_HeightLimit.TupleLess(0)))) != 0)
                {
                    hv_MinHeight.Dispose();
                    hv_MinHeight = 400;
                    hv_MaxHeight.Dispose();
                    hv_MaxHeight = 600;
                }
                else if ((int)(new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
                    1))) != 0)
                {
                    hv_MinHeight.Dispose();
                    hv_MinHeight = 0;
                    hv_MaxHeight.Dispose();
                    hv_MaxHeight = new HTuple(hv_HeightLimit);
                }
                else
                {
                    hv_MinHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MinHeight = hv_HeightLimit.TupleSelect(
                            0);
                    }
                    hv_MaxHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxHeight = hv_HeightLimit.TupleSelect(
                            1);
                    }
                }
                //
                //Test, if window size has to be changed.
                hv_ResizeFactor.Dispose();
                hv_ResizeFactor = 1;
                //First, expand window to the minimum extents (if necessary).
                if ((int)((new HTuple(hv_MinWidth.TupleGreater(hv_Width))).TupleOr(new HTuple(hv_MinHeight.TupleGreater(
                    hv_Height)))) != 0)
                {
                    hv_ResizeFactor.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ResizeFactor = (((((hv_MinWidth.TupleReal()
                            ) / hv_Width)).TupleConcat((hv_MinHeight.TupleReal()) / hv_Height))).TupleMax()
                            ;
                    }
                }
                hv_TempWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TempWidth = hv_Width * hv_ResizeFactor;
                }
                hv_TempHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TempHeight = hv_Height * hv_ResizeFactor;
                }
                //Then, shrink window to maximum extents (if necessary).
                if ((int)((new HTuple(hv_MaxWidth.TupleLess(hv_TempWidth))).TupleOr(new HTuple(hv_MaxHeight.TupleLess(
                    hv_TempHeight)))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResizeFactor = hv_ResizeFactor * ((((((hv_MaxWidth.TupleReal()
                                ) / hv_TempWidth)).TupleConcat((hv_MaxHeight.TupleReal()) / hv_TempHeight))).TupleMin()
                                );
                            hv_ResizeFactor.Dispose();
                            hv_ResizeFactor = ExpTmpLocalVar_ResizeFactor;
                        }
                    }
                }
                hv_WindowWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowWidth = hv_Width * hv_ResizeFactor;
                }
                hv_WindowHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowHeight = hv_Height * hv_ResizeFactor;
                }
                //Resize window
                HOperatorSet.SetWindowAttr("background_color", "black");
                HOperatorSet.OpenWindow(hv_Row, hv_Column, hv_WindowWidth, hv_WindowHeight, 0, "visible", "", out hv_WindowHandle);
                HDevWindowStack.Push(hv_WindowHandle);
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_Height - 1, hv_Width - 1);
                    }
                }

                hv_MinWidth.Dispose();
                hv_MaxWidth.Dispose();
                hv_MinHeight.Dispose();
                hv_MaxHeight.Dispose();
                hv_ResizeFactor.Dispose();
                hv_TempWidth.Dispose();
                hv_TempHeight.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_MinWidth.Dispose();
                hv_MaxWidth.Dispose();
                hv_MinHeight.Dispose();
                hv_MaxHeight.Dispose();
                hv_ResizeFactor.Dispose();
                hv_TempWidth.Dispose();
                hv_TempHeight.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Develop
        // Short Description: Resizes a graphics window with a given maximum extent such that it preserves the aspect ratio of a given width and height 
        public void dev_resize_window_fit_size(HTuple hv_Row, HTuple hv_Column, HTuple hv_Width,
            HTuple hv_Height, HTuple hv_WidthLimit, HTuple hv_HeightLimit)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_MinWidth = new HTuple(), hv_MaxWidth = new HTuple();
            HTuple hv_MinHeight = new HTuple(), hv_MaxHeight = new HTuple();
            HTuple hv_ResizeFactor = new HTuple(), hv_TempWidth = new HTuple();
            HTuple hv_TempHeight = new HTuple(), hv_WindowWidth = new HTuple();
            HTuple hv_WindowHeight = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure adjusts the size of the current window
                //such that it fits into the limits specified by WidthLimit
                //and HeightLimit, but also maintains the correct aspect ratio
                //given by Width and Height.
                //
                //If it is impossible to match the minimum and maximum extent requirements
                //at the same time (f.e. if the image is very long but narrow),
                //the maximum value gets a higher priority.
                //
                //Parse input tuple WidthLimit
                if ((int)((new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_WidthLimit.TupleLess(0)))) != 0)
                {
                    hv_MinWidth.Dispose();
                    hv_MinWidth = 500;
                    hv_MaxWidth.Dispose();
                    hv_MaxWidth = 800;
                }
                else if ((int)(new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
                    1))) != 0)
                {
                    hv_MinWidth.Dispose();
                    hv_MinWidth = 0;
                    hv_MaxWidth.Dispose();
                    hv_MaxWidth = new HTuple(hv_WidthLimit);
                }
                else
                {
                    hv_MinWidth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MinWidth = hv_WidthLimit.TupleSelect(
                            0);
                    }
                    hv_MaxWidth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxWidth = hv_WidthLimit.TupleSelect(
                            1);
                    }
                }
                //Parse input tuple HeightLimit
                if ((int)((new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_HeightLimit.TupleLess(0)))) != 0)
                {
                    hv_MinHeight.Dispose();
                    hv_MinHeight = 400;
                    hv_MaxHeight.Dispose();
                    hv_MaxHeight = 600;
                }
                else if ((int)(new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
                    1))) != 0)
                {
                    hv_MinHeight.Dispose();
                    hv_MinHeight = 0;
                    hv_MaxHeight.Dispose();
                    hv_MaxHeight = new HTuple(hv_HeightLimit);
                }
                else
                {
                    hv_MinHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MinHeight = hv_HeightLimit.TupleSelect(
                            0);
                    }
                    hv_MaxHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxHeight = hv_HeightLimit.TupleSelect(
                            1);
                    }
                }
                //
                //Test, if window size has to be changed.
                hv_ResizeFactor.Dispose();
                hv_ResizeFactor = 1;
                //First, expand window to the minimum extents (if necessary).
                if ((int)((new HTuple(hv_MinWidth.TupleGreater(hv_Width))).TupleOr(new HTuple(hv_MinHeight.TupleGreater(
                    hv_Height)))) != 0)
                {
                    hv_ResizeFactor.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ResizeFactor = (((((hv_MinWidth.TupleReal()
                            ) / hv_Width)).TupleConcat((hv_MinHeight.TupleReal()) / hv_Height))).TupleMax()
                            ;
                    }
                }
                hv_TempWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TempWidth = hv_Width * hv_ResizeFactor;
                }
                hv_TempHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TempHeight = hv_Height * hv_ResizeFactor;
                }
                //Then, shrink window to maximum extents (if necessary).
                if ((int)((new HTuple(hv_MaxWidth.TupleLess(hv_TempWidth))).TupleOr(new HTuple(hv_MaxHeight.TupleLess(
                    hv_TempHeight)))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResizeFactor = hv_ResizeFactor * ((((((hv_MaxWidth.TupleReal()
                                ) / hv_TempWidth)).TupleConcat((hv_MaxHeight.TupleReal()) / hv_TempHeight))).TupleMin()
                                );
                            hv_ResizeFactor.Dispose();
                            hv_ResizeFactor = ExpTmpLocalVar_ResizeFactor;
                        }
                    }
                }
                hv_WindowWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowWidth = hv_Width * hv_ResizeFactor;
                }
                hv_WindowHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowHeight = hv_Height * hv_ResizeFactor;
                }
                //Resize window
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_Row, hv_Column,
                        hv_WindowWidth, hv_WindowHeight);
                }
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_Height - 1, hv_Width - 1);
                    }
                }

                hv_MinWidth.Dispose();
                hv_MaxWidth.Dispose();
                hv_MinHeight.Dispose();
                hv_MaxHeight.Dispose();
                hv_ResizeFactor.Dispose();
                hv_TempWidth.Dispose();
                hv_TempHeight.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_MinWidth.Dispose();
                hv_MaxWidth.Dispose();
                hv_MinHeight.Dispose();
                hv_MaxHeight.Dispose();
                hv_ResizeFactor.Dispose();
                hv_TempWidth.Dispose();
                hv_TempHeight.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Develop
        // Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
        public void dev_update_off()
        {

            // Initialize local and output iconic variables 
            //This procedure sets different update settings to 'off'.
            //This is useful to get the best performance and reduce overhead.
            //
            // dev_update_pc(...); only in hdevelop
            // dev_update_var(...); only in hdevelop
            // dev_update_window(...); only in hdevelop


            return;
        }

        // Chapter: Time
        // Short Description: Estimate the remaining time for a task given the current progress. 
        public void estimate_progress(HTuple hv_SecondsStart, HTuple hv_ProgressMin, HTuple hv_ProgressCurrent,
            HTuple hv_ProgressMax, out HTuple hv_SecondsElapsed, out HTuple hv_SecondsRemaining,
            out HTuple hv_ProgressPercent, out HTuple hv_ProgressPerSecond)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_SecondsNow = new HTuple(), hv_Epsilon = new HTuple();
            HTuple hv_ProgressRemaining = new HTuple();
            // Initialize local and output iconic variables 
            hv_SecondsElapsed = new HTuple();
            hv_SecondsRemaining = new HTuple();
            hv_ProgressPercent = new HTuple();
            hv_ProgressPerSecond = new HTuple();
            try
            {
                //
                //This procedure estimates the remaining time in seconds,
                //given a start time and a progress value.
                //
                //Get current time.
                hv_SecondsNow.Dispose();
                HOperatorSet.CountSeconds(out hv_SecondsNow);
                //
                //Get elapsed time span.
                hv_SecondsElapsed.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SecondsElapsed = hv_SecondsNow - hv_SecondsStart;
                }
                //
                //A very small additive constant to avoid division by zero.
                hv_Epsilon.Dispose();
                hv_Epsilon = 1e-6;
                //
                //Estimate remaining time based on elapsed time.
                hv_ProgressRemaining.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ProgressRemaining = hv_ProgressMax - hv_ProgressCurrent;
                }
                hv_ProgressPerSecond.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ProgressPerSecond = (((hv_ProgressCurrent - hv_ProgressMin)).TupleReal()
                        ) / ((hv_SecondsElapsed.TupleReal()) + hv_Epsilon);
                }
                hv_SecondsRemaining.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SecondsRemaining = hv_ProgressRemaining / (hv_ProgressPerSecond + hv_Epsilon);
                }
                //
                //Get current progress in percent.
                hv_ProgressPercent.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ProgressPercent = (100 * (((hv_ProgressCurrent - hv_ProgressMin)).TupleReal()
                        )) / ((((hv_ProgressMax - hv_ProgressMin)).TupleReal()) + hv_Epsilon);
                }

                hv_SecondsNow.Dispose();
                hv_Epsilon.Dispose();
                hv_ProgressRemaining.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_SecondsNow.Dispose();
                hv_Epsilon.Dispose();
                hv_ProgressRemaining.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Evaluate the model given by DLModelHandle on the selected samples of DLDataset. 
        public void evaluate_dl_model(HTuple hv_DLDataset, HTuple hv_DLModelHandle, HTuple hv_SampleSelectMethod,
            HTuple hv_SampleSelectValues, HTuple hv_GenParam, out HTuple hv_EvaluationResult,
            out HTuple hv_EvalParams)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ModelType = new HTuple(), hv_ClassIDs = new HTuple();
            HTuple hv_BatchSize = new HTuple(), hv_InstanceType = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_IgnoreDirection = new HTuple();
            HTuple hv_Measures = new HTuple(), hv_ModelIgnoreClassIDs = new HTuple();
            HTuple hv_ShowProgress = new HTuple(), hv_GenParamKeys = new HTuple();
            HTuple hv_GenParamIndex = new HTuple(), hv_EvaluationType = new HTuple();
            HTuple hv_NumClasses = new HTuple(), hv_EvaluateInstances = new HTuple();
            HTuple hv_IoUThreshold = new HTuple(), hv_MaxNumDetections = new HTuple();
            HTuple hv_AreaRanges = new HTuple(), hv_DetailedEvaluation = new HTuple();
            HTuple hv_AllocationBlockLength = new HTuple(), hv_IgnoreClassIDs = new HTuple();
            HTuple hv_AllIgnoreClassIDs = new HTuple(), hv_EvaluateClassIDs = new HTuple();
            HTuple hv_ClassesToEvaluate = new HTuple(), hv_ClassNames = new HTuple();
            HTuple hv_KeyExists = new HTuple(), hv_ClassIDsToEvaluate = new HTuple();
            HTuple hv_AnomalyNumBins = new HTuple(), hv_AnomalyHistogram = new HTuple();
            HTuple hv_AnomalyMinValue = new HTuple(), hv_AnomalyMaxValue = new HTuple();
            HTuple hv_ClassInfoExists = new HTuple(), hv_DatasetClassIDs = new HTuple();
            HTuple hv_ClassIDsToClassNames = new HTuple(), hv_EvaluateClassNames = new HTuple();
            HTuple hv_DLSamples = new HTuple(), hv_SampleIndices = new HTuple();
            HTuple hv_NumSamples = new HTuple(), hv_NumBatches = new HTuple();
            HTuple hv_RunningMeasures = new HTuple(), hv_Progress = new HTuple();
            HTuple hv_TaskInfo = new HTuple(), hv_SecondsStart = new HTuple();
            HTuple hv_BatchIndex = new HTuple(), hv_BatchStart = new HTuple();
            HTuple hv_BatchEnd = new HTuple(), hv_SamplesIndicesBatch = new HTuple();
            HTuple hv_DLSamplesBatch = new HTuple(), hv_DLResultsBatch = new HTuple();
            HTuple hv_SecondsElapsed = new HTuple(), hv_SecondsRemaining = new HTuple();
            HTuple hv_ProgressPercent = new HTuple(), hv_ProgressPerSecond = new HTuple();
            HTuple hv_TimeElapsedString = new HTuple(), hv_TimeRemainingString = new HTuple();
            // Initialize local and output iconic variables 
            hv_EvaluationResult = new HTuple();
            hv_EvalParams = new HTuple();
            try
            {
                //This procedure applies the model given by DLModelHandle on the selected samples
                //of DLDataset and evaluates the results against the ground truth annotations
                //to calculate evaluation measures.
                //
                //Input:
                // - DLDataset.
                // - DLModelHandle.
                // - SampleSelectMethod: Method by which the samples are selected.
                // - SampleSelectValues: Identifier used to retrieve the samples from the DLDataset
                //                       for the corresponding selection method.
                // - GenParam: Parameters of the evaluation that should be changed from the default.
                //
                //Output:
                // - EvaluationResult: Dictionary containing the output measures.
                // - EvalParams: Dictionary with the used evaluation parameters.
                //
                //** Initialization: ***
                //
                hv_ModelType.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "type", out hv_ModelType);
                if ((int)((new HTuple((new HTuple((new HTuple(hv_ModelType.TupleNotEqual("anomaly_detection"))).TupleAnd(
                    new HTuple(hv_ModelType.TupleNotEqual("classification"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual(
                    "detection"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual("segmentation")))) != 0)
                {
                    throw new HalconException("Unknown model type");
                }
                //
                //Get the class IDs as set in the model.
                if ((int)(new HTuple(hv_ModelType.TupleEqual("anomaly_detection"))) != 0)
                {
                    //Default for anomaly detection is 0,1.
                    hv_ClassIDs.Dispose();
                    hv_ClassIDs = new HTuple();
                    hv_ClassIDs[0] = 0;
                    hv_ClassIDs[1] = 1;
                }
                else
                {
                    hv_ClassIDs.Dispose();
                    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "class_ids", out hv_ClassIDs);
                }
                //
                //Get the batch size as set in the model.
                hv_BatchSize.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "batch_size", out hv_BatchSize);
                //
                //Generate default parameters.
                hv_EvalParams.Dispose();
                create_evaluation_default_param(hv_ModelType, hv_ClassIDs, out hv_EvalParams);
                //
                //Get model specific information.
                if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
                {
                    try
                    {
                        hv_InstanceType.Dispose();
                        HOperatorSet.GetDlModelParam(hv_DLModelHandle, "instance_type", out hv_InstanceType);
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException1)
                    {
                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        hv_InstanceType.Dispose();
                        hv_InstanceType = "rectangle1";
                    }
                    //Overwrite the instance_type.
                    HOperatorSet.SetDictTuple(hv_EvalParams, "instance_type", hv_InstanceType);
                    //For rectangle2 detection with ignore_direction set to false, we also evaluate the
                    //precision of the predicted angle using the Score of Angle Precision (SoAP).
                    if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
                    {
                        hv_IgnoreDirection.Dispose();
                        HOperatorSet.GetDlModelParam(hv_DLModelHandle, "ignore_direction", out hv_IgnoreDirection);
                        if ((int)(new HTuple(hv_IgnoreDirection.TupleEqual("false"))) != 0)
                        {
                            hv_Measures.Dispose();
                            HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_EvalParams, "measures", hv_Measures.TupleConcat(
                                    "soap"));
                            }
                        }
                    }
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("segmentation"))) != 0)
                {
                    hv_ModelIgnoreClassIDs.Dispose();
                    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "ignore_class_ids", out hv_ModelIgnoreClassIDs);
                }
                //
                //By default we do not show the progress of evaluation.
                hv_ShowProgress.Dispose();
                hv_ShowProgress = 0;
                //
                //Set user specified parameters.
                if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
                {
                    hv_GenParamKeys.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_GenParamKeys);
                    for (hv_GenParamIndex = 0; (int)hv_GenParamIndex <= (int)((new HTuple(hv_GenParamKeys.TupleLength()
                        )) - 1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
                    {
                        if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "measures"))) != 0)
                        {
                            //Set measures.
                            hv_Measures.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "measures", out hv_Measures);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "measures", hv_Measures);
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "evaluation_type"))) != 0)
                        {
                            //Set evaluation type.
                            hv_EvaluationType.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "evaluation_type", out hv_EvaluationType);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "evaluation_type", hv_EvaluationType);
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "class_ids"))) != 0)
                        {
                            //Set class ids.
                            hv_ClassIDs.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "class_ids", out hv_ClassIDs);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "class_ids", hv_ClassIDs);
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "num_classes"))) != 0)
                        {
                            //Set number of classes.
                            hv_NumClasses.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "num_classes", out hv_NumClasses);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "num_classes", hv_NumClasses);
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "evaluate_instances"))) != 0)
                        {
                            //Set boolean for instance-based evaluation.
                            hv_EvaluateInstances.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "evaluate_instances", out hv_EvaluateInstances);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "evaluate_instances", hv_EvaluateInstances);
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "show_progress"))) != 0)
                        {
                            //Show the progress of the evaluation.
                            hv_ShowProgress.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "show_progress", out hv_ShowProgress);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ShowProgress = (new HTuple(hv_ShowProgress.TupleEqual(
                                        "true"))).TupleOr(new HTuple(hv_ShowProgress.TupleEqual(1)));
                                    hv_ShowProgress.Dispose();
                                    hv_ShowProgress = ExpTmpLocalVar_ShowProgress;
                                }
                            }
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "iou_threshold"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual("detection")))) != 0)
                        {
                            //Set IoU threshold.
                            hv_IoUThreshold.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "iou_threshold", out hv_IoUThreshold);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "iou_threshold", hv_IoUThreshold);
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "max_num_detections"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual(
                            "detection")))) != 0)
                        {
                            //Set maximal number detections.
                            hv_MaxNumDetections.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "max_num_detections", out hv_MaxNumDetections);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "max_num_detections", hv_MaxNumDetections);
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "area_ranges"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual("detection")))) != 0)
                        {
                            //Set area ranges.
                            hv_AreaRanges.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "area_ranges", out hv_AreaRanges);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "area_ranges", hv_AreaRanges);
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "detailed_evaluation"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual(
                            "detection")))) != 0)
                        {
                            //Set detailed evaluation.
                            hv_DetailedEvaluation.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "detailed_evaluation", out hv_DetailedEvaluation);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "detailed_evaluation", hv_DetailedEvaluation);
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "allocation_block_length"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual(
                            "detection")))) != 0)
                        {
                            //Set length of blocks that are allocated during evaluation.
                            hv_AllocationBlockLength.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "allocation_block_length", out hv_AllocationBlockLength);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "allocation_block_length", hv_AllocationBlockLength);
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "ignore_class_ids"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual("segmentation")))) != 0)
                        {
                            //Set ignore class IDs.
                            hv_IgnoreClassIDs.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "ignore_class_ids", out hv_IgnoreClassIDs);
                            //Merge the specified ignore class IDs with the model ignore class IDs.
                            hv_AllIgnoreClassIDs.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_AllIgnoreClassIDs = ((((hv_ModelIgnoreClassIDs.TupleConcat(
                                    hv_IgnoreClassIDs))).TupleSort())).TupleUniq();
                            }
                            HOperatorSet.SetDictTuple(hv_EvalParams, "ignore_class_ids", hv_AllIgnoreClassIDs);
                            //Remove the ignore class IDs from the model class IDs.
                            hv_EvaluateClassIDs.Dispose();
                            HOperatorSet.TupleDifference(hv_ClassIDs, hv_IgnoreClassIDs, out hv_EvaluateClassIDs);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "class_ids", hv_EvaluateClassIDs);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_EvalParams, "num_classes", new HTuple(hv_EvaluateClassIDs.TupleLength()
                                    ));
                            }
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "class_names_to_evaluate"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual(
                            "classification")))) != 0)
                        {
                            //Class names to be used in evaluation.
                            //To transform the names to IDs later, one has to remember the class names.
                            hv_ClassesToEvaluate.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "class_names_to_evaluate", out hv_ClassesToEvaluate);
                            hv_ClassNames.Dispose();
                            HOperatorSet.GetDlModelParam(hv_DLModelHandle, "class_names", out hv_ClassNames);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "class_names_to_evaluate", hv_ClassesToEvaluate);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "class_names", hv_ClassNames);
                            hv_KeyExists.Dispose();
                            HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "class_ids_to_evaluate",
                                out hv_KeyExists);
                            if ((int)(hv_KeyExists) != 0)
                            {
                                //To avoid inconsistent class names/IDs, remove the older ones.
                                HOperatorSet.RemoveDictKey(hv_EvalParams, "class_ids_to_evaluate");
                            }
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "class_ids_to_evaluate"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual(
                            "classification")))) != 0)
                        {
                            //Class IDs to be used in evaluation.
                            hv_ClassIDsToEvaluate.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "class_ids_to_evaluate", out hv_ClassIDsToEvaluate);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "class_ids_to_evaluate", hv_ClassIDsToEvaluate);
                            hv_KeyExists.Dispose();
                            HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "class_names_to_evaluate",
                                out hv_KeyExists);
                            if ((int)(hv_KeyExists) != 0)
                            {
                                //To avoid inconsistent class names/IDs, remove the older ones.
                                HOperatorSet.RemoveDictKey(hv_EvalParams, "class_names_to_evaluate");
                            }
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "anomaly_num_bins"))) != 0)
                        {
                            //
                            //Set anomaly histogram number of bins.
                            hv_AnomalyNumBins.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "anomaly_num_bins", out hv_AnomalyNumBins);
                            hv_AnomalyHistogram.Dispose();
                            HOperatorSet.GetDictTuple(hv_EvalParams, "anomaly_score_histogram", out hv_AnomalyHistogram);
                            HOperatorSet.SetDictTuple(hv_AnomalyHistogram, "num_bins", hv_AnomalyNumBins);
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "anomaly_min_value"))) != 0)
                        {
                            //
                            //Set anomaly histogram minimum value.
                            hv_AnomalyMinValue.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "anomaly_min_value", out hv_AnomalyMinValue);
                            hv_AnomalyHistogram.Dispose();
                            HOperatorSet.GetDictTuple(hv_EvalParams, "anomaly_score_histogram", out hv_AnomalyHistogram);
                            HOperatorSet.SetDictTuple(hv_AnomalyHistogram, "min", hv_AnomalyMinValue);
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "anomaly_max_value"))) != 0)
                        {
                            //
                            //Set anomaly histogram maximum value.
                            hv_AnomalyMaxValue.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "anomaly_max_value", out hv_AnomalyMaxValue);
                            hv_AnomalyHistogram.Dispose();
                            HOperatorSet.GetDictTuple(hv_EvalParams, "anomaly_score_histogram", out hv_AnomalyHistogram);
                            HOperatorSet.SetDictTuple(hv_AnomalyHistogram, "max", hv_AnomalyMaxValue);
                        }
                        else
                        {
                            throw new HalconException(("Unknown parameter : '" + (hv_GenParamKeys.TupleSelect(
                                hv_GenParamIndex))) + "'");
                        }
                    }
                }
                //
                //Get the class names from the dataset if present.
                hv_ClassInfoExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLDataset, "key_exists", (new HTuple("class_names")).TupleConcat(
                    "class_ids"), out hv_ClassInfoExists);
                if ((int)(new HTuple(((hv_ClassInfoExists.TupleSum())).TupleEqual(new HTuple(hv_ClassInfoExists.TupleLength()
                    )))) != 0)
                {
                    hv_ClassNames.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLDataset, "class_names", out hv_ClassNames);
                    hv_DatasetClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLDataset, "class_ids", out hv_DatasetClassIDs);
                    //Set the class names only for the class IDs that are evaluated.
                    hv_EvaluateClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_EvaluateClassIDs);
                    hv_ClassIDsToClassNames.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassIDsToClassNames = HTuple.TupleGenConst(
                            (hv_DatasetClassIDs.TupleMax()) + 1, "");
                    }
                    if (hv_ClassIDsToClassNames == null)
                        hv_ClassIDsToClassNames = new HTuple();
                    hv_ClassIDsToClassNames[hv_DatasetClassIDs] = hv_ClassNames;
                    hv_EvaluateClassNames.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_EvaluateClassNames = hv_ClassIDsToClassNames.TupleSelect(
                            hv_EvaluateClassIDs);
                    }
                    //Set the class names to EvalParams.
                    HOperatorSet.SetDictTuple(hv_EvalParams, "class_names", hv_EvaluateClassNames);
                }
                //
                //Get indices of samples to read from the dataset.
                hv_DLSamples.Dispose();
                HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLSamples);
                //
                //Check if there are samples present in the dataset.
                if ((int)(new HTuple((new HTuple(hv_DLSamples.TupleLength())).TupleEqual(0))) != 0)
                {
                    throw new HalconException("The provided set of samples in the dataset must be non-empty.");
                }
                //
                //Check for empty SampleSelectValues.
                if ((int)(new HTuple((new HTuple(hv_SampleSelectValues.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    if ((int)(new HTuple(hv_SampleSelectMethod.TupleEqual("image_ids"))) != 0)
                    {
                        throw new HalconException("The provided set of samples of the 'image_ids' selection must be non-empty.");
                    }
                    else if ((int)(new HTuple(hv_SampleSelectMethod.TupleEqual("sample_indices"))) != 0)
                    {
                        throw new HalconException("The provided set of samples of the 'sample_indices' selection must be non-empty.");
                    }
                    else
                    {
                        throw new HalconException("Provide a name for 'split' selection.");
                    }
                }
                //
                //
                //Get the sample indices according to the sample selection method.
                hv_SampleIndices.Dispose();
                hv_SampleIndices = new HTuple();
                if ((int)(new HTuple(hv_SampleSelectMethod.TupleEqual("split"))) != 0)
                {
                    //Get the samples of the split specified.
                    hv_SampleIndices.Dispose();
                    find_dl_samples(hv_DLSamples, "split", hv_SampleSelectValues, "or", out hv_SampleIndices);
                }
                else if ((int)(new HTuple(hv_SampleSelectMethod.TupleEqual("image_ids"))) != 0)
                {
                    //Get the samples specified by 'image_ids'.
                    if ((int)(new HTuple((new HTuple(hv_SampleSelectValues.TupleLength())).TupleGreater(
                        new HTuple(hv_DLSamples.TupleLength())))) != 0)
                    {
                        throw new HalconException("The number of the image ids provided through 'image_id' is invalid.");
                    }
                    hv_SampleIndices.Dispose();
                    find_dl_samples(hv_DLSamples, "image_id", hv_SampleSelectValues, "or", out hv_SampleIndices);
                }
                else if ((int)(new HTuple(hv_SampleSelectMethod.TupleEqual("sample_indices"))) != 0)
                {
                    //Get the samples specified by 'sample_indices'.
                    if ((int)((new HTuple(((hv_SampleSelectValues.TupleMin())).TupleLess(0))).TupleOr(
                        new HTuple(((hv_SampleSelectValues.TupleMax())).TupleGreater((new HTuple(hv_DLSamples.TupleLength()
                        )) - 1)))) != 0)
                    {
                        throw new HalconException("The range of the indices provided through 'sample_indices' is invalid.");
                    }
                    hv_SampleIndices.Dispose();
                    hv_SampleIndices = new HTuple(hv_SampleSelectValues);
                }
                else
                {
                    throw new HalconException(("Unknown sample selection method : '" + hv_SampleSelectMethod) + "'");
                }
                //
                //Get the number of batches.
                hv_NumSamples.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumSamples = new HTuple(hv_SampleIndices.TupleLength()
                        );
                }
                hv_NumBatches.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumBatches = ((((hv_NumSamples / (hv_BatchSize.TupleReal()
                        ))).TupleCeil())).TupleInt();
                }
                //
                //Check for empty samples selected by the selection method.
                if ((int)(new HTuple(hv_NumSamples.TupleEqual(0))) != 0)
                {
                    throw new HalconException(("No samples present in the dataset that are part of the '" + hv_SampleSelectMethod) + "' selection.");
                }
                //
                //
                //** Running measures are initialized according to evaluation method.
                //
                hv_RunningMeasures.Dispose();
                init_running_evaluation_measures(hv_EvalParams, out hv_RunningMeasures);
                //
                //
                //** Apply model to each image and gather evaluation information: ***
                //
                //Initialize progress variables.
                if ((int)(hv_ShowProgress) != 0)
                {
                    hv_Progress.Dispose();
                    hv_Progress = new HTuple();
                    hv_Progress[0] = "Procedure: evaluate_dl_model";
                    hv_Progress[1] = "";
                    hv_Progress[2] = "";
                    hv_Progress[3] = "";
                    if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
                    {
                        hv_TaskInfo.Dispose();
                        hv_TaskInfo = "Task: 1/2: Applying the model and collecting running evaluation measures";
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Progress = hv_Progress.TupleConcat(
                                    hv_TaskInfo);
                                hv_Progress.Dispose();
                                hv_Progress = ExpTmpLocalVar_Progress;
                            }
                        }
                    }
                    hv_SecondsStart.Dispose();
                    HOperatorSet.CountSeconds(out hv_SecondsStart);
                    // dev_inspect_ctrl(...); only in hdevelop
                }
                //
                //Loop batchwise over the samples to be evaluated.
                HTuple end_val249 = hv_NumBatches - 1;
                HTuple step_val249 = 1;
                for (hv_BatchIndex = 0; hv_BatchIndex.Continue(end_val249, step_val249); hv_BatchIndex = hv_BatchIndex.TupleAdd(step_val249))
                {
                    hv_BatchStart.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BatchStart = hv_BatchIndex * hv_BatchSize;
                    }
                    hv_BatchEnd.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BatchEnd = (((hv_BatchStart + hv_BatchSize) - 1)).TupleMin2(
                            hv_NumSamples - 1);
                    }
                    hv_SamplesIndicesBatch.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SamplesIndicesBatch = hv_SampleIndices.TupleSelectRange(
                            hv_BatchStart, hv_BatchEnd);
                    }
                    //
                    //Read samples
                    hv_DLSamplesBatch.Dispose();
                    read_dl_samples(hv_DLDataset, hv_SamplesIndicesBatch, out hv_DLSamplesBatch);
                    //
                    //Apply the model.
                    hv_DLResultsBatch.Dispose();
                    HOperatorSet.ApplyDlModel(hv_DLModelHandle, hv_DLSamplesBatch, new HTuple(),
                        out hv_DLResultsBatch);
                    //
                    //Update the running measures.
                    update_running_evaluation_measures(hv_DLSamplesBatch, hv_DLResultsBatch,
                        hv_EvalParams, hv_RunningMeasures);
                    //
                    //Provide progress information.
                    if ((int)(hv_ShowProgress.TupleAnd((new HTuple(((hv_BatchIndex % 10)).TupleEqual(
                        1))).TupleOr(new HTuple(hv_BatchIndex.TupleEqual(hv_NumBatches - 1))))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_SecondsElapsed.Dispose(); hv_SecondsRemaining.Dispose(); hv_ProgressPercent.Dispose(); hv_ProgressPerSecond.Dispose();
                            estimate_progress(hv_SecondsStart, 0, hv_BatchIndex, hv_NumBatches - 1, out hv_SecondsElapsed,
                                out hv_SecondsRemaining, out hv_ProgressPercent, out hv_ProgressPerSecond);
                        }
                        hv_TimeElapsedString.Dispose();
                        timespan_string(hv_SecondsElapsed, "auto", out hv_TimeElapsedString);
                        hv_TimeRemainingString.Dispose();
                        timespan_string(hv_SecondsRemaining, "top2", out hv_TimeRemainingString);
                        if (hv_Progress == null)
                            hv_Progress = new HTuple();
                        hv_Progress[1] = ("Progress: " + (hv_ProgressPercent.TupleRound())) + " %";
                        if (hv_Progress == null)
                            hv_Progress = new HTuple();
                        hv_Progress[2] = "Time elapsed: " + hv_TimeElapsedString;
                        if (hv_Progress == null)
                            hv_Progress = new HTuple();
                        hv_Progress[3] = "Time left: " + hv_TimeRemainingString;
                    }
                }
                //
                //Provide progress information.
                if ((int)(hv_ShowProgress.TupleAnd(new HTuple(hv_ModelType.TupleEqual("detection")))) != 0)
                {
                    hv_Progress.Dispose();
                    hv_Progress = new HTuple();
                    hv_Progress[0] = "Procedure: evaluate_dl_model";
                    hv_Progress[1] = "";
                    hv_Progress[2] = "";
                    if (hv_Progress == null)
                        hv_Progress = new HTuple();
                    hv_Progress[1] = "Please wait...";
                    if (hv_Progress == null)
                        hv_Progress = new HTuple();
                    hv_Progress[2] = "Task: 2/2: Calculating final evaluation measures";
                }
                //
                //
                //** Do the actual calculation of measures: ***
                //
                hv_EvaluationResult.Dispose();
                calculate_evaluation_measures(hv_RunningMeasures, hv_EvalParams, out hv_EvaluationResult);
                //
                //Close progress inspect.
                if ((int)(hv_ShowProgress) != 0)
                {
                    hv_Progress.Dispose();
                    hv_Progress = "Done.";
                    // dev_close_inspect_ctrl(...); only in hdevelop
                }
                //

                hv_ModelType.Dispose();
                hv_ClassIDs.Dispose();
                hv_BatchSize.Dispose();
                hv_InstanceType.Dispose();
                hv_Exception.Dispose();
                hv_IgnoreDirection.Dispose();
                hv_Measures.Dispose();
                hv_ModelIgnoreClassIDs.Dispose();
                hv_ShowProgress.Dispose();
                hv_GenParamKeys.Dispose();
                hv_GenParamIndex.Dispose();
                hv_EvaluationType.Dispose();
                hv_NumClasses.Dispose();
                hv_EvaluateInstances.Dispose();
                hv_IoUThreshold.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_AllIgnoreClassIDs.Dispose();
                hv_EvaluateClassIDs.Dispose();
                hv_ClassesToEvaluate.Dispose();
                hv_ClassNames.Dispose();
                hv_KeyExists.Dispose();
                hv_ClassIDsToEvaluate.Dispose();
                hv_AnomalyNumBins.Dispose();
                hv_AnomalyHistogram.Dispose();
                hv_AnomalyMinValue.Dispose();
                hv_AnomalyMaxValue.Dispose();
                hv_ClassInfoExists.Dispose();
                hv_DatasetClassIDs.Dispose();
                hv_ClassIDsToClassNames.Dispose();
                hv_EvaluateClassNames.Dispose();
                hv_DLSamples.Dispose();
                hv_SampleIndices.Dispose();
                hv_NumSamples.Dispose();
                hv_NumBatches.Dispose();
                hv_RunningMeasures.Dispose();
                hv_Progress.Dispose();
                hv_TaskInfo.Dispose();
                hv_SecondsStart.Dispose();
                hv_BatchIndex.Dispose();
                hv_BatchStart.Dispose();
                hv_BatchEnd.Dispose();
                hv_SamplesIndicesBatch.Dispose();
                hv_DLSamplesBatch.Dispose();
                hv_DLResultsBatch.Dispose();
                hv_SecondsElapsed.Dispose();
                hv_SecondsRemaining.Dispose();
                hv_ProgressPercent.Dispose();
                hv_ProgressPerSecond.Dispose();
                hv_TimeElapsedString.Dispose();
                hv_TimeRemainingString.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ModelType.Dispose();
                hv_ClassIDs.Dispose();
                hv_BatchSize.Dispose();
                hv_InstanceType.Dispose();
                hv_Exception.Dispose();
                hv_IgnoreDirection.Dispose();
                hv_Measures.Dispose();
                hv_ModelIgnoreClassIDs.Dispose();
                hv_ShowProgress.Dispose();
                hv_GenParamKeys.Dispose();
                hv_GenParamIndex.Dispose();
                hv_EvaluationType.Dispose();
                hv_NumClasses.Dispose();
                hv_EvaluateInstances.Dispose();
                hv_IoUThreshold.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_AllIgnoreClassIDs.Dispose();
                hv_EvaluateClassIDs.Dispose();
                hv_ClassesToEvaluate.Dispose();
                hv_ClassNames.Dispose();
                hv_KeyExists.Dispose();
                hv_ClassIDsToEvaluate.Dispose();
                hv_AnomalyNumBins.Dispose();
                hv_AnomalyHistogram.Dispose();
                hv_AnomalyMinValue.Dispose();
                hv_AnomalyMaxValue.Dispose();
                hv_ClassInfoExists.Dispose();
                hv_DatasetClassIDs.Dispose();
                hv_ClassIDsToClassNames.Dispose();
                hv_EvaluateClassNames.Dispose();
                hv_DLSamples.Dispose();
                hv_SampleIndices.Dispose();
                hv_NumSamples.Dispose();
                hv_NumBatches.Dispose();
                hv_RunningMeasures.Dispose();
                hv_Progress.Dispose();
                hv_TaskInfo.Dispose();
                hv_SecondsStart.Dispose();
                hv_BatchIndex.Dispose();
                hv_BatchStart.Dispose();
                hv_BatchEnd.Dispose();
                hv_SamplesIndicesBatch.Dispose();
                hv_DLSamplesBatch.Dispose();
                hv_DLResultsBatch.Dispose();
                hv_SecondsElapsed.Dispose();
                hv_SecondsRemaining.Dispose();
                hv_ProgressPercent.Dispose();
                hv_ProgressPerSecond.Dispose();
                hv_TimeElapsedString.Dispose();
                hv_TimeRemainingString.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Retrieve the indices of Samples that contain KeyName matching KeyValue according to the Mode set. 
        public void find_dl_samples(HTuple hv_Samples, HTuple hv_KeyName, HTuple hv_KeyValue,
            HTuple hv_Mode, out HTuple hv_SampleIndices)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_NumKeyValues = new HTuple(), hv_SampleIndex = new HTuple();
            HTuple hv_Sample = new HTuple(), hv_KeyExists = new HTuple();
            HTuple hv_Tuple = new HTuple(), hv_Hit = new HTuple();
            HTuple hv_ValueIndex = new HTuple(), hv_Value = new HTuple();
            // Initialize local and output iconic variables 
            hv_SampleIndices = new HTuple();
            try
            {
                //
                //This procedure gets the indices of the samples that contain the
                //requested KeyName matching the requested KeyValue according to the Mode.
                //If there is no match, an empty tuple [] will be returned.
                //
                //Check input parameters.
                if ((int)(new HTuple((new HTuple(hv_KeyName.TupleLength())).TupleNotEqual(1))) != 0)
                {
                    throw new HalconException(new HTuple("Invalid KeyName size: ") + (new HTuple(hv_KeyName.TupleLength()
                        )));
                }
                if ((int)(new HTuple((new HTuple(hv_Mode.TupleLength())).TupleNotEqual(1))) != 0)
                {
                    throw new HalconException(new HTuple("Invalid Mode size: ") + (new HTuple(hv_Mode.TupleLength()
                        )));
                }
                if ((int)((new HTuple((new HTuple(hv_Mode.TupleNotEqual("match"))).TupleAnd(
                    new HTuple(hv_Mode.TupleNotEqual("or"))))).TupleAnd(new HTuple(hv_Mode.TupleNotEqual(
                    "contain")))) != 0)
                {
                    throw new HalconException("Invalid Mode value: " + hv_Mode);
                }
                hv_NumKeyValues.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumKeyValues = new HTuple(hv_KeyValue.TupleLength()
                        );
                }
                if ((int)((new HTuple(hv_Mode.TupleEqual("contain"))).TupleAnd(new HTuple(hv_NumKeyValues.TupleLess(
                    1)))) != 0)
                {
                    throw new HalconException("Invalid KeyValue size for contain Mode: " + hv_NumKeyValues);
                }
                //
                //Find the indices.
                hv_SampleIndices.Dispose();
                hv_SampleIndices = new HTuple();
                for (hv_SampleIndex = 0; (int)hv_SampleIndex <= (int)((new HTuple(hv_Samples.TupleLength()
                    )) - 1); hv_SampleIndex = (int)hv_SampleIndex + 1)
                {
                    hv_Sample.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Sample = hv_Samples.TupleSelect(
                            hv_SampleIndex);
                    }
                    hv_KeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_Sample, "key_exists", hv_KeyName, out hv_KeyExists);
                    if ((int)(hv_KeyExists) != 0)
                    {
                        hv_Tuple.Dispose();
                        HOperatorSet.GetDictTuple(hv_Sample, hv_KeyName, out hv_Tuple);
                        if ((int)(new HTuple(hv_Mode.TupleEqual("match"))) != 0)
                        {
                            //Mode 'match': Tuple must be equal KeyValue.
                            hv_Hit.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Hit = new HTuple(hv_Tuple.TupleEqual(
                                    hv_KeyValue));
                            }
                        }
                        else if ((int)((new HTuple(hv_Mode.TupleEqual("or"))).TupleAnd(
                            new HTuple((new HTuple(hv_Tuple.TupleLength())).TupleEqual(1)))) != 0)
                        {
                            //Mode 'or': Tuple must have only 1 element and it has to be equal to any of KeyValues elements.
                            hv_Hit.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Hit = new HTuple(((hv_KeyValue.TupleFindFirst(
                                    hv_Tuple))).TupleGreaterEqual(0));
                            }
                        }
                        else if ((int)(new HTuple(hv_Mode.TupleEqual("contain"))) != 0)
                        {
                            //Mode 'contain': Tuple must contain any of the elements in KeyValue.
                            HTuple end_val35 = hv_NumKeyValues - 1;
                            HTuple step_val35 = 1;
                            for (hv_ValueIndex = 0; hv_ValueIndex.Continue(end_val35, step_val35); hv_ValueIndex = hv_ValueIndex.TupleAdd(step_val35))
                            {
                                hv_Value.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Value = hv_KeyValue.TupleSelect(
                                        hv_ValueIndex);
                                }
                                hv_Hit.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Hit = new HTuple(((hv_Tuple.TupleFindFirst(
                                        hv_Value))).TupleGreaterEqual(0));
                                }
                                if ((int)(hv_Hit) != 0)
                                {
                                    break;
                                }
                            }
                        }
                        else
                        {
                            //Unsupported configuration.
                            hv_Hit.Dispose();
                            hv_Hit = 0;
                        }
                        if ((int)(hv_Hit) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_SampleIndices = hv_SampleIndices.TupleConcat(
                                        hv_SampleIndex);
                                    hv_SampleIndices.Dispose();
                                    hv_SampleIndices = ExpTmpLocalVar_SampleIndices;
                                }
                            }
                        }
                    }
                }

                hv_NumKeyValues.Dispose();
                hv_SampleIndex.Dispose();
                hv_Sample.Dispose();
                hv_KeyExists.Dispose();
                hv_Tuple.Dispose();
                hv_Hit.Dispose();
                hv_ValueIndex.Dispose();
                hv_Value.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_NumKeyValues.Dispose();
                hv_SampleIndex.Dispose();
                hv_Sample.Dispose();
                hv_KeyExists.Dispose();
                hv_Tuple.Dispose();
                hv_Hit.Dispose();
                hv_ValueIndex.Dispose();
                hv_Value.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: XLD / Creation
        // Short Description: Creates an arrow shaped XLD contour. 
        public void gen_arrow_contour_xld(out HObject ho_Arrow, HTuple hv_Row1, HTuple hv_Column1,
            HTuple hv_Row2, HTuple hv_Column2, HTuple hv_HeadLength, HTuple hv_HeadWidth)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_TempArrow = null;

            // Local control variables 

            HTuple hv_Length = new HTuple(), hv_ZeroLengthIndices = new HTuple();
            HTuple hv_DR = new HTuple(), hv_DC = new HTuple(), hv_HalfHeadWidth = new HTuple();
            HTuple hv_RowP1 = new HTuple(), hv_ColP1 = new HTuple();
            HTuple hv_RowP2 = new HTuple(), hv_ColP2 = new HTuple();
            HTuple hv_Index = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Arrow);
            HOperatorSet.GenEmptyObj(out ho_TempArrow);
            try
            {
                //This procedure generates arrow shaped XLD contours,
                //pointing from (Row1, Column1) to (Row2, Column2).
                //If starting and end point are identical, a contour consisting
                //of a single point is returned.
                //
                //input parameteres:
                //Row1, Column1: Coordinates of the arrows' starting points
                //Row2, Column2: Coordinates of the arrows' end points
                //HeadLength, HeadWidth: Size of the arrow heads in pixels
                //
                //output parameter:
                //Arrow: The resulting XLD contour
                //
                //The input tuples Row1, Column1, Row2, and Column2 have to be of
                //the same length.
                //HeadLength and HeadWidth either have to be of the same length as
                //Row1, Column1, Row2, and Column2 or have to be a single element.
                //If one of the above restrictions is violated, an error will occur.
                //
                //
                //Init
                ho_Arrow.Dispose();
                HOperatorSet.GenEmptyObj(out ho_Arrow);
                //
                //Calculate the arrow length
                hv_Length.Dispose();
                HOperatorSet.DistancePp(hv_Row1, hv_Column1, hv_Row2, hv_Column2, out hv_Length);
                //
                //Mark arrows with identical start and end point
                //(set Length to -1 to avoid division-by-zero exception)
                hv_ZeroLengthIndices.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ZeroLengthIndices = hv_Length.TupleFind(
                        0);
                }
                if ((int)(new HTuple(hv_ZeroLengthIndices.TupleNotEqual(-1))) != 0)
                {
                    if (hv_Length == null)
                        hv_Length = new HTuple();
                    hv_Length[hv_ZeroLengthIndices] = -1;
                }
                //
                //Calculate auxiliary variables.
                hv_DR.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_DR = (1.0 * (hv_Row2 - hv_Row1)) / hv_Length;
                }
                hv_DC.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_DC = (1.0 * (hv_Column2 - hv_Column1)) / hv_Length;
                }
                hv_HalfHeadWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HalfHeadWidth = hv_HeadWidth / 2.0;
                }
                //
                //Calculate end points of the arrow head.
                hv_RowP1.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RowP1 = (hv_Row1 + ((hv_Length - hv_HeadLength) * hv_DR)) + (hv_HalfHeadWidth * hv_DC);
                }
                hv_ColP1.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ColP1 = (hv_Column1 + ((hv_Length - hv_HeadLength) * hv_DC)) - (hv_HalfHeadWidth * hv_DR);
                }
                hv_RowP2.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RowP2 = (hv_Row1 + ((hv_Length - hv_HeadLength) * hv_DR)) - (hv_HalfHeadWidth * hv_DC);
                }
                hv_ColP2.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ColP2 = (hv_Column1 + ((hv_Length - hv_HeadLength) * hv_DC)) + (hv_HalfHeadWidth * hv_DR);
                }
                //
                //Finally create output XLD contour for each input point pair
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Length.TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
                {
                    if ((int)(new HTuple(((hv_Length.TupleSelect(hv_Index))).TupleEqual(-1))) != 0)
                    {
                        //Create_ single points for arrows with identical start and end point
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_TempArrow.Dispose();
                            HOperatorSet.GenContourPolygonXld(out ho_TempArrow, hv_Row1.TupleSelect(
                                hv_Index), hv_Column1.TupleSelect(hv_Index));
                        }
                    }
                    else
                    {
                        //Create arrow contour
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_TempArrow.Dispose();
                            HOperatorSet.GenContourPolygonXld(out ho_TempArrow, ((((((((((hv_Row1.TupleSelect(
                                hv_Index))).TupleConcat(hv_Row2.TupleSelect(hv_Index)))).TupleConcat(
                                hv_RowP1.TupleSelect(hv_Index)))).TupleConcat(hv_Row2.TupleSelect(hv_Index)))).TupleConcat(
                                hv_RowP2.TupleSelect(hv_Index)))).TupleConcat(hv_Row2.TupleSelect(hv_Index)),
                                ((((((((((hv_Column1.TupleSelect(hv_Index))).TupleConcat(hv_Column2.TupleSelect(
                                hv_Index)))).TupleConcat(hv_ColP1.TupleSelect(hv_Index)))).TupleConcat(
                                hv_Column2.TupleSelect(hv_Index)))).TupleConcat(hv_ColP2.TupleSelect(
                                hv_Index)))).TupleConcat(hv_Column2.TupleSelect(hv_Index)));
                        }
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_Arrow, ho_TempArrow, out ExpTmpOutVar_0);
                        ho_Arrow.Dispose();
                        ho_Arrow = ExpTmpOutVar_0;
                    }
                }
                ho_TempArrow.Dispose();

                hv_Length.Dispose();
                hv_ZeroLengthIndices.Dispose();
                hv_DR.Dispose();
                hv_DC.Dispose();
                hv_HalfHeadWidth.Dispose();
                hv_RowP1.Dispose();
                hv_ColP1.Dispose();
                hv_RowP2.Dispose();
                hv_ColP2.Dispose();
                hv_Index.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_TempArrow.Dispose();

                hv_Length.Dispose();
                hv_ZeroLengthIndices.Dispose();
                hv_DR.Dispose();
                hv_DC.Dispose();
                hv_HalfHeadWidth.Dispose();
                hv_RowP1.Dispose();
                hv_ColP1.Dispose();
                hv_RowP2.Dispose();
                hv_ColP2.Dispose();
                hv_Index.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Classification
        // Short Description: Compute a confusion matrix, which an be visualized and/or returned. 
        public void gen_confusion_matrix(HTuple hv_GroundTruthLabels, HTuple hv_PredictedClasses,
            HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple hv_WindowHandle, out HTuple hv_ConfusionMatrix)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_DisplayMatrix = new HTuple(), hv_ReturnMatrix = new HTuple();
            HTuple hv_DisplayColor = new HTuple(), hv_DisplayColumnWidth = new HTuple();
            HTuple hv_GenParamIndex = new HTuple(), hv_CalculateRelativeMatrix = new HTuple();
            HTuple hv_Classes = new HTuple(), hv_NumClasses = new HTuple();
            HTuple hv_AbsoluteMatrixID = new HTuple(), hv_RelativeMatrixID = new HTuple();
            HTuple hv_ColumnMatrix = new HTuple(), hv_Class = new HTuple();
            HTuple hv_ThisLabel = new HTuple(), hv_NumClassGroundTruth = new HTuple();
            HTuple hv_RowMatrix = new HTuple(), hv_PredictedClass = new HTuple();
            HTuple hv_ThisPredictedClass = new HTuple(), hv_NumMatches = new HTuple();
            HTuple hv_RelativeError = new HTuple(), hv_StringWidths = new HTuple();
            HTuple hv_StringIndex = new HTuple(), hv_String = new HTuple();
            HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
            HTuple hv_StringWidth = new HTuple(), hv_StringHeight = new HTuple();
            HTuple hv_MaxStringWidth = new HTuple(), hv_RowStart = new HTuple();
            HTuple hv_RowDistance = new HTuple(), hv_RowEnd = new HTuple();
            HTuple hv_ColumnStart = new HTuple(), hv_ColumnOffset = new HTuple();
            HTuple hv_ColumnEnd = new HTuple(), hv_Width = new HTuple();
            HTuple hv_Height = new HTuple(), hv_WidthLimit = new HTuple();
            HTuple hv_HeightLimit = new HTuple(), hv_TextRow = new HTuple();
            HTuple hv_TextColumn = new HTuple(), hv_Index = new HTuple();
            HTuple hv_Text = new HTuple(), hv_Row = new HTuple(), hv_Column = new HTuple();
            HTuple hv_AbsoluteTransposedMatrixID = new HTuple(), hv_MatrixText = new HTuple();
            HTuple hv_MatrixMaxID = new HTuple(), hv_MaxValue = new HTuple();
            HTuple hv_StringConversion = new HTuple(), hv_RelativeTransposedMatrixID = new HTuple();
            HTuple hv_TextColor = new HTuple(), hv_RelativeValues = new HTuple();
            HTuple hv_Thresholds = new HTuple(), hv_Colors = new HTuple();
            HTuple hv_Greater = new HTuple(), hv_Indices = new HTuple();
            HTuple hv_DiagonalIndex = new HTuple(), hv_Value = new HTuple();
            // Initialize local and output iconic variables 
            hv_ConfusionMatrix = new HTuple();
            try
            {
                //This procedure computes a confusion matrix.
                //Therefore, it compares the classes
                //assigned in GroundTruthLabels and PredictedClasses.
                //The resulting confusion matrix can be
                //visualized, returned, or both.
                //In each case, the output can be changed
                //via generic parameters using GenParamName and GenParamValue.
                //For the visualization, the graphics window
                //must be specified with WindowHandle.
                //
                if ((int)(new HTuple((new HTuple(hv_GroundTruthLabels.TupleLength())).TupleNotEqual(
                    new HTuple(hv_PredictedClasses.TupleLength())))) != 0)
                {
                    throw new HalconException("Number of ground truth labels and predicted classes must be equal.");
                }
                //
                //Set generic parameter defaults.
                hv_DisplayMatrix.Dispose();
                hv_DisplayMatrix = "absolute";
                hv_ReturnMatrix.Dispose();
                hv_ReturnMatrix = "absolute";
                hv_DisplayColor.Dispose();
                hv_DisplayColor = "true";
                hv_DisplayColumnWidth.Dispose();
                hv_DisplayColumnWidth = "minimal";
                //
                //Parse generic parameters.
                for (hv_GenParamIndex = 0; (int)hv_GenParamIndex <= (int)((new HTuple(hv_GenParamName.TupleLength()
                    )) - 1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
                {
                    if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "display_matrix"))) != 0)
                    {
                        //Set 'display_matrix'.
                        hv_DisplayMatrix.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_DisplayMatrix = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "return_matrix"))) != 0)
                    {
                        //Set 'return_matrix'.
                        hv_ReturnMatrix.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ReturnMatrix = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "display_color"))) != 0)
                    {
                        //Set 'display_color'.
                        hv_DisplayColor.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_DisplayColor = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "display_column_width"))) != 0)
                    {
                        //Set 'display_column_width'.
                        hv_DisplayColumnWidth.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_DisplayColumnWidth = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                    }
                    else
                    {
                        throw new HalconException(("Unknown generic parameter: '" + (hv_GenParamName.TupleSelect(
                            hv_GenParamIndex))) + "'");
                    }
                }
                //
                if ((int)((new HTuple((new HTuple(hv_DisplayMatrix.TupleEqual("relative"))).TupleOr(
                    new HTuple(hv_ReturnMatrix.TupleEqual("relative"))))).TupleOr(new HTuple(hv_DisplayColor.TupleEqual(
                    "true")))) != 0)
                {
                    hv_CalculateRelativeMatrix.Dispose();
                    hv_CalculateRelativeMatrix = 1;
                }
                else
                {
                    hv_CalculateRelativeMatrix.Dispose();
                    hv_CalculateRelativeMatrix = 0;
                }
                //
                //Calculate the confusion matrix with absolute values
                //and the confusion matrix with relative errors.
                //We start with an empty matrix
                //and add the number of matching labels.
                hv_Classes.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Classes = ((hv_GroundTruthLabels.TupleSort()
                        )).TupleUniq();
                }
                hv_NumClasses.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumClasses = new HTuple(hv_Classes.TupleLength()
                        );
                }
                hv_AbsoluteMatrixID.Dispose();
                HOperatorSet.CreateMatrix(hv_NumClasses, hv_NumClasses, 0, out hv_AbsoluteMatrixID);
                if ((int)(hv_CalculateRelativeMatrix) != 0)
                {
                    hv_RelativeMatrixID.Dispose();
                    HOperatorSet.CreateMatrix(hv_NumClasses, hv_NumClasses, 0, out hv_RelativeMatrixID);
                }
                HTuple end_val55 = hv_NumClasses - 1;
                HTuple step_val55 = 1;
                for (hv_ColumnMatrix = 0; hv_ColumnMatrix.Continue(end_val55, step_val55); hv_ColumnMatrix = hv_ColumnMatrix.TupleAdd(step_val55))
                {
                    hv_Class.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Class = hv_Classes.TupleSelect(
                            hv_ColumnMatrix);
                    }
                    hv_ThisLabel.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ThisLabel = hv_GroundTruthLabels.TupleEqualElem(
                            hv_Class);
                    }
                    if ((int)(hv_CalculateRelativeMatrix) != 0)
                    {
                        //Obtain the number of ground truth labels per class.
                        hv_NumClassGroundTruth.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_NumClassGroundTruth = hv_ThisLabel.TupleSum()
                                ;
                        }
                    }
                    HTuple end_val62 = hv_NumClasses - 1;
                    HTuple step_val62 = 1;
                    for (hv_RowMatrix = 0; hv_RowMatrix.Continue(end_val62, step_val62); hv_RowMatrix = hv_RowMatrix.TupleAdd(step_val62))
                    {
                        //Select classes for this row/column.
                        hv_PredictedClass.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_PredictedClass = hv_Classes.TupleSelect(
                                hv_RowMatrix);
                        }
                        //Check whether the input data
                        //corresponds to these classes.
                        hv_ThisPredictedClass.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ThisPredictedClass = hv_PredictedClasses.TupleEqualElem(
                                hv_PredictedClass);
                        }
                        //Count the number of elements where the predicted class
                        //matches the ground truth label.
                        hv_NumMatches.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_NumMatches = ((((hv_ThisLabel + hv_ThisPredictedClass)).TupleEqualElem(
                                2))).TupleSum();
                        }
                        //Set value in matrix.
                        HOperatorSet.SetValueMatrix(hv_AbsoluteMatrixID, hv_RowMatrix, hv_ColumnMatrix,
                            hv_NumMatches);
                        if ((int)(hv_CalculateRelativeMatrix) != 0)
                        {
                            if ((int)(new HTuple(hv_NumClassGroundTruth.TupleGreater(0))) != 0)
                            {
                                hv_RelativeError.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_RelativeError = (hv_NumMatches.TupleReal()
                                        ) / hv_NumClassGroundTruth;
                                }
                            }
                            else
                            {
                                hv_RelativeError.Dispose();
                                hv_RelativeError = 0;
                            }
                            HOperatorSet.SetValueMatrix(hv_RelativeMatrixID, hv_RowMatrix, hv_ColumnMatrix,
                                hv_RelativeError);
                        }
                    }
                }
                //
                //Return the result.
                if ((int)(new HTuple(hv_ReturnMatrix.TupleEqual("absolute"))) != 0)
                {
                    hv_ConfusionMatrix.Dispose();
                    HOperatorSet.CopyMatrix(hv_AbsoluteMatrixID, out hv_ConfusionMatrix);
                }
                else if ((int)(new HTuple(hv_ReturnMatrix.TupleEqual("relative"))) != 0)
                {
                    hv_ConfusionMatrix.Dispose();
                    HOperatorSet.CopyMatrix(hv_RelativeMatrixID, out hv_ConfusionMatrix);
                }
                else if ((int)(new HTuple(hv_ReturnMatrix.TupleEqual("none"))) != 0)
                {
                    //No matrix is returned.
                }
                else
                {
                    throw new HalconException("Unsupported mode for 'return_matrix'");
                }
                //
                //Display the matrix.
                if ((int)(new HTuple(hv_DisplayMatrix.TupleNotEqual("none"))) != 0)
                {
                    //
                    //Find maximal string width and set display position parameters.
                    hv_StringWidths.Dispose();
                    hv_StringWidths = new HTuple();
                    //Get the string width of each class.
                    for (hv_StringIndex = 0; (int)hv_StringIndex <= (int)((new HTuple(hv_Classes.TupleLength()
                        )) - 1); hv_StringIndex = (int)hv_StringIndex + 1)
                    {
                        hv_String.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_String = hv_Classes.TupleSelect(
                                hv_StringIndex);
                        }
                        hv_Ascent.Dispose(); hv_Descent.Dispose(); hv_StringWidth.Dispose(); hv_StringHeight.Dispose();
                        HOperatorSet.GetStringExtents(hv_WindowHandle, hv_String, out hv_Ascent,
                            out hv_Descent, out hv_StringWidth, out hv_StringHeight);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_StringWidths = hv_StringWidths.TupleConcat(
                                    hv_StringWidth);
                                hv_StringWidths.Dispose();
                                hv_StringWidths = ExpTmpLocalVar_StringWidths;
                            }
                        }
                    }
                    //The columns should have a minimum width for 4 characters.
                    hv_Ascent.Dispose(); hv_Descent.Dispose(); hv_StringWidth.Dispose(); hv_StringHeight.Dispose();
                    HOperatorSet.GetStringExtents(hv_WindowHandle, "test", out hv_Ascent, out hv_Descent,
                        out hv_StringWidth, out hv_StringHeight);
                    hv_MaxStringWidth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxStringWidth = ((hv_StringWidths.TupleMax()
                            )).TupleMax2(hv_StringWidth);
                    }
                    //Get the maximum string width
                    //and resize the window accordingly.
                    hv_RowStart.Dispose();
                    hv_RowStart = 80;
                    hv_RowDistance.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_RowDistance = hv_StringHeight + 10;
                    }
                    hv_RowEnd.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_RowEnd = hv_StringHeight * 7;
                    }
                    hv_ColumnStart.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ColumnStart = 50 + hv_MaxStringWidth;
                    }
                    hv_ColumnOffset.Dispose();
                    hv_ColumnOffset = 20;
                    hv_ColumnEnd.Dispose();
                    hv_ColumnEnd = new HTuple(hv_ColumnOffset);
                    //
                    //Adapt the window size to fit the confusion matrix.
                    if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("minimal"))) != 0)
                    {
                        //Every column of the confusion matrix is as narrow as possible
                        //based to the respective string widths.
                        hv_Width.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Width = (((hv_StringWidths.TupleSum()
                                ) + (hv_ColumnOffset * hv_NumClasses)) + hv_ColumnStart) + hv_ColumnEnd;
                        }
                    }
                    else if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("equal"))) != 0)
                    {
                        //Every column of the confusion matrix should have the same width.
                        //based on the maximum string width.
                        hv_Width.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Width = (((hv_MaxStringWidth + hv_ColumnOffset) * hv_NumClasses) + hv_ColumnStart) + hv_ColumnEnd;
                        }
                    }
                    else
                    {
                        throw new HalconException("");
                    }
                    hv_Height.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Height = ((hv_RowDistance * hv_NumClasses) + hv_RowStart) + hv_RowEnd;
                    }
                    HDevWindowStack.SetActive(hv_WindowHandle);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                    }
                    //
                    //Set reasonable limits for graphics window (adapt if necessary).
                    hv_WidthLimit.Dispose();
                    hv_WidthLimit = new HTuple();
                    hv_WidthLimit[0] = 450;
                    hv_WidthLimit[1] = 1920;
                    hv_HeightLimit.Dispose();
                    hv_HeightLimit = new HTuple();
                    hv_HeightLimit[0] = 250;
                    hv_HeightLimit[1] = 1080;
                    if ((int)((new HTuple(hv_Width.TupleGreater(hv_WidthLimit.TupleSelect(1)))).TupleOr(
                        new HTuple(hv_Height.TupleGreater(hv_HeightLimit.TupleSelect(1))))) != 0)
                    {
                        throw new HalconException("Confusion Matrix does not fit into graphics window. Please adapt font and/or size limits.");
                    }
                    dev_resize_window_fit_size(0, 0, hv_Width, hv_Height, hv_WidthLimit, hv_HeightLimit);
                    //
                    //Get display coordinates.
                    //Get row coordinates for display.
                    hv_TextRow.Dispose();
                    hv_TextRow = new HTuple();
                    HTuple end_val145 = hv_NumClasses - 1;
                    HTuple step_val145 = 1;
                    for (hv_ColumnMatrix = 0; hv_ColumnMatrix.Continue(end_val145, step_val145); hv_ColumnMatrix = hv_ColumnMatrix.TupleAdd(step_val145))
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_TextRow = hv_TextRow.TupleConcat(
                                    HTuple.TupleGenSequence(0, (hv_NumClasses - 1) * hv_RowDistance, hv_RowDistance));
                                hv_TextRow.Dispose();
                                hv_TextRow = ExpTmpLocalVar_TextRow;
                            }
                        }
                    }
                    //Get column coordinates for display.
                    hv_TextColumn.Dispose();
                    hv_TextColumn = new HTuple();
                    HTuple end_val150 = hv_NumClasses - 1;
                    HTuple step_val150 = 1;
                    for (hv_Index = 0; hv_Index.Continue(end_val150, step_val150); hv_Index = hv_Index.TupleAdd(step_val150))
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_TextColumn = hv_TextColumn.TupleConcat(
                                    HTuple.TupleGenConst(hv_NumClasses, hv_ColumnStart));
                                hv_TextColumn.Dispose();
                                hv_TextColumn = ExpTmpLocalVar_TextColumn;
                            }
                        }
                        if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("minimal"))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ColumnStart = (hv_ColumnStart + (hv_StringWidths.TupleSelect(
                                        hv_Index))) + hv_ColumnOffset;
                                    hv_ColumnStart.Dispose();
                                    hv_ColumnStart = ExpTmpLocalVar_ColumnStart;
                                }
                            }
                        }
                        else if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual(
                            "equal"))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ColumnStart = (hv_ColumnStart + hv_MaxStringWidth) + hv_ColumnOffset;
                                    hv_ColumnStart.Dispose();
                                    hv_ColumnStart = ExpTmpLocalVar_ColumnStart;
                                }
                            }
                        }
                    }
                    //Display the confusion matrix with a margin from the top.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_TextRow = hv_TextRow + hv_RowStart;
                            hv_TextRow.Dispose();
                            hv_TextRow = ExpTmpLocalVar_TextRow;
                        }
                    }
                    //Display axis titles.
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Ground truth labels",
                            "window", "top", "right", "white", "box", "false");
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Predicted classes",
                            "window", "bottom", "left", "white", "box", "false");
                    }
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Classes.TupleLength()
                        )) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = hv_Classes.TupleSelect(
                                hv_Index);
                        }
                        //Display predicted class names.
                        hv_Row.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Row = hv_TextRow.TupleSelect(
                                hv_Index);
                        }
                        hv_Column.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Column = ((hv_TextColumn.TupleSelect(
                                0)) - hv_MaxStringWidth) - hv_ColumnOffset;
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                hv_Row, hv_Column, "light gray", "box", "false");
                        }
                        //Display ground truth label names.
                        hv_Row.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Row = (hv_TextRow.TupleSelect(
                                0)) - hv_RowDistance;
                        }
                        hv_Column.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Column = hv_TextColumn.TupleSelect(
                                hv_Index * hv_NumClasses);
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                hv_Row, hv_Column, "light gray", "box", "false");
                        }
                    }
                    //
                    //Get the confusion matrix values for display.
                    if ((int)(new HTuple(hv_DisplayMatrix.TupleEqual("absolute"))) != 0)
                    {
                        //Displayed matrix corresponds to the transposed returned matrix.
                        hv_AbsoluteTransposedMatrixID.Dispose();
                        HOperatorSet.TransposeMatrix(hv_AbsoluteMatrixID, out hv_AbsoluteTransposedMatrixID);
                        hv_MatrixText.Dispose();
                        HOperatorSet.GetFullMatrix(hv_AbsoluteTransposedMatrixID, out hv_MatrixText);
                        HOperatorSet.ClearMatrix(hv_AbsoluteTransposedMatrixID);
                        //Align the numbers right.
                        hv_MatrixMaxID.Dispose();
                        HOperatorSet.MaxMatrix(hv_AbsoluteMatrixID, "full", out hv_MatrixMaxID);
                        hv_MaxValue.Dispose();
                        HOperatorSet.GetFullMatrix(hv_MatrixMaxID, out hv_MaxValue);
                        HOperatorSet.ClearMatrix(hv_MatrixMaxID);
                        hv_StringConversion.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_StringConversion = (((((hv_MaxValue.TupleLog10()
                                )).TupleCeil())).TupleInt()) + ".0f";
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_MatrixText = hv_MatrixText.TupleString(
                                    hv_StringConversion);
                                hv_MatrixText.Dispose();
                                hv_MatrixText = ExpTmpLocalVar_MatrixText;
                            }
                        }
                    }
                    else
                    {
                        //Displayed matrix corresponds to the transposed returned matrix.
                        hv_RelativeTransposedMatrixID.Dispose();
                        HOperatorSet.TransposeMatrix(hv_RelativeMatrixID, out hv_RelativeTransposedMatrixID);
                        hv_MatrixText.Dispose();
                        HOperatorSet.GetFullMatrix(hv_RelativeTransposedMatrixID, out hv_MatrixText);
                        HOperatorSet.ClearMatrix(hv_RelativeTransposedMatrixID);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_MatrixText = hv_MatrixText.TupleString(
                                    ".2f");
                                hv_MatrixText.Dispose();
                                hv_MatrixText = ExpTmpLocalVar_MatrixText;
                            }
                        }
                    }
                    //Set color for displayed confusion matrix.
                    if ((int)(new HTuple(hv_DisplayColor.TupleEqual("true"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TextColor.Dispose();
                            HOperatorSet.TupleGenConst(new HTuple(hv_MatrixText.TupleLength()), "#666666",
                                out hv_TextColor);
                        }
                        //Use the relative values to adapt the color of the text.
                        hv_RelativeTransposedMatrixID.Dispose();
                        HOperatorSet.TransposeMatrix(hv_RelativeMatrixID, out hv_RelativeTransposedMatrixID);
                        hv_RelativeValues.Dispose();
                        HOperatorSet.GetFullMatrix(hv_RelativeTransposedMatrixID, out hv_RelativeValues);
                        HOperatorSet.ClearMatrix(hv_RelativeTransposedMatrixID);
                        //Set the colors and respective thresholds for the off-diagonal values.
                        hv_Thresholds.Dispose();
                        hv_Thresholds = new HTuple();
                        hv_Thresholds[0] = 0.0;
                        hv_Thresholds[1] = 0.05;
                        hv_Thresholds[2] = 0.1;
                        hv_Thresholds[3] = 0.2;
                        hv_Colors.Dispose();
                        hv_Colors = new HTuple();
                        hv_Colors[0] = "#8C4D4D";
                        hv_Colors[1] = "#B33333";
                        hv_Colors[2] = "#D91A1A";
                        hv_Colors[3] = "#FF0000";
                        for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Thresholds.TupleLength()
                            )) - 1); hv_Index = (int)hv_Index + 1)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Greater.Dispose();
                                HOperatorSet.TupleGreaterElem(hv_RelativeValues, hv_Thresholds.TupleSelect(
                                    hv_Index), out hv_Greater);
                            }
                            hv_Indices.Dispose();
                            HOperatorSet.TupleFind(hv_Greater, 1, out hv_Indices);
                            if ((int)(new HTuple(hv_Indices.TupleNotEqual(-1))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HTuple ExpTmpOutVar_0;
                                    HOperatorSet.TupleReplace(hv_TextColor, hv_Indices, hv_Colors.TupleSelect(
                                        hv_Index), out ExpTmpOutVar_0);
                                    hv_TextColor.Dispose();
                                    hv_TextColor = ExpTmpOutVar_0;
                                }
                            }
                            else
                            {
                                break;
                            }
                        }
                        //Set the colors and respective thresholds for the diagonal values.
                        hv_Thresholds.Dispose();
                        hv_Thresholds = new HTuple();
                        hv_Thresholds[0] = -0.01;
                        hv_Thresholds[1] = 0.60;
                        hv_Thresholds[2] = 0.80;
                        hv_Thresholds[3] = 0.90;
                        hv_Thresholds[4] = 0.95;
                        hv_Thresholds[5] = 0.98;
                        hv_Colors.Dispose();
                        hv_Colors = new HTuple();
                        hv_Colors[0] = "#666666";
                        hv_Colors[1] = "#508650";
                        hv_Colors[2] = "#419C41";
                        hv_Colors[3] = "#2BBD2B";
                        hv_Colors[4] = "#15DE15";
                        hv_Colors[5] = "#00FF00";
                        HTuple end_val216 = hv_NumClasses - 1;
                        HTuple step_val216 = 1;
                        for (hv_DiagonalIndex = 0; hv_DiagonalIndex.Continue(end_val216, step_val216); hv_DiagonalIndex = hv_DiagonalIndex.TupleAdd(step_val216))
                        {
                            hv_Value.Dispose();
                            HOperatorSet.GetValueMatrix(hv_RelativeMatrixID, hv_DiagonalIndex, hv_DiagonalIndex,
                                out hv_Value);
                            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Thresholds.TupleLength()
                                )) - 1); hv_Index = (int)hv_Index + 1)
                            {
                                if ((int)(new HTuple(hv_Value.TupleGreater(hv_Thresholds.TupleSelect(
                                    hv_Index)))) != 0)
                                {
                                    if (hv_TextColor == null)
                                        hv_TextColor = new HTuple();
                                    hv_TextColor[hv_DiagonalIndex * (hv_NumClasses + 1)] = hv_Colors.TupleSelect(
                                        hv_Index);
                                }
                                else
                                {
                                    break;
                                }
                            }
                        }
                    }
                    else
                    {
                        //Default value for the text color.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TextColor.Dispose();
                            HOperatorSet.TupleGenConst(new HTuple(hv_MatrixText.TupleLength()), "white",
                                out hv_TextColor);
                        }
                    }
                    //
                    //Display confusion matrix.
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_MatrixText, "window",
                            hv_TextRow, hv_TextColumn, hv_TextColor, "box", "false");
                    }
                    //
                    //Clean up.
                    if ((int)(hv_CalculateRelativeMatrix) != 0)
                    {
                        HOperatorSet.ClearMatrix(hv_RelativeMatrixID);
                    }
                    HOperatorSet.ClearMatrix(hv_AbsoluteMatrixID);
                }

                hv_DisplayMatrix.Dispose();
                hv_ReturnMatrix.Dispose();
                hv_DisplayColor.Dispose();
                hv_DisplayColumnWidth.Dispose();
                hv_GenParamIndex.Dispose();
                hv_CalculateRelativeMatrix.Dispose();
                hv_Classes.Dispose();
                hv_NumClasses.Dispose();
                hv_AbsoluteMatrixID.Dispose();
                hv_RelativeMatrixID.Dispose();
                hv_ColumnMatrix.Dispose();
                hv_Class.Dispose();
                hv_ThisLabel.Dispose();
                hv_NumClassGroundTruth.Dispose();
                hv_RowMatrix.Dispose();
                hv_PredictedClass.Dispose();
                hv_ThisPredictedClass.Dispose();
                hv_NumMatches.Dispose();
                hv_RelativeError.Dispose();
                hv_StringWidths.Dispose();
                hv_StringIndex.Dispose();
                hv_String.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_StringWidth.Dispose();
                hv_StringHeight.Dispose();
                hv_MaxStringWidth.Dispose();
                hv_RowStart.Dispose();
                hv_RowDistance.Dispose();
                hv_RowEnd.Dispose();
                hv_ColumnStart.Dispose();
                hv_ColumnOffset.Dispose();
                hv_ColumnEnd.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_WidthLimit.Dispose();
                hv_HeightLimit.Dispose();
                hv_TextRow.Dispose();
                hv_TextColumn.Dispose();
                hv_Index.Dispose();
                hv_Text.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();
                hv_AbsoluteTransposedMatrixID.Dispose();
                hv_MatrixText.Dispose();
                hv_MatrixMaxID.Dispose();
                hv_MaxValue.Dispose();
                hv_StringConversion.Dispose();
                hv_RelativeTransposedMatrixID.Dispose();
                hv_TextColor.Dispose();
                hv_RelativeValues.Dispose();
                hv_Thresholds.Dispose();
                hv_Colors.Dispose();
                hv_Greater.Dispose();
                hv_Indices.Dispose();
                hv_DiagonalIndex.Dispose();
                hv_Value.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_DisplayMatrix.Dispose();
                hv_ReturnMatrix.Dispose();
                hv_DisplayColor.Dispose();
                hv_DisplayColumnWidth.Dispose();
                hv_GenParamIndex.Dispose();
                hv_CalculateRelativeMatrix.Dispose();
                hv_Classes.Dispose();
                hv_NumClasses.Dispose();
                hv_AbsoluteMatrixID.Dispose();
                hv_RelativeMatrixID.Dispose();
                hv_ColumnMatrix.Dispose();
                hv_Class.Dispose();
                hv_ThisLabel.Dispose();
                hv_NumClassGroundTruth.Dispose();
                hv_RowMatrix.Dispose();
                hv_PredictedClass.Dispose();
                hv_ThisPredictedClass.Dispose();
                hv_NumMatches.Dispose();
                hv_RelativeError.Dispose();
                hv_StringWidths.Dispose();
                hv_StringIndex.Dispose();
                hv_String.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_StringWidth.Dispose();
                hv_StringHeight.Dispose();
                hv_MaxStringWidth.Dispose();
                hv_RowStart.Dispose();
                hv_RowDistance.Dispose();
                hv_RowEnd.Dispose();
                hv_ColumnStart.Dispose();
                hv_ColumnOffset.Dispose();
                hv_ColumnEnd.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_WidthLimit.Dispose();
                hv_HeightLimit.Dispose();
                hv_TextRow.Dispose();
                hv_TextColumn.Dispose();
                hv_Index.Dispose();
                hv_Text.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();
                hv_AbsoluteTransposedMatrixID.Dispose();
                hv_MatrixText.Dispose();
                hv_MatrixMaxID.Dispose();
                hv_MaxValue.Dispose();
                hv_StringConversion.Dispose();
                hv_RelativeTransposedMatrixID.Dispose();
                hv_TextColor.Dispose();
                hv_RelativeValues.Dispose();
                hv_Thresholds.Dispose();
                hv_Colors.Dispose();
                hv_Greater.Dispose();
                hv_Indices.Dispose();
                hv_DiagonalIndex.Dispose();
                hv_Value.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Classification
        // Short Description: Return the confidence based heatmap of a deep learning classification in DLResult. 
        public void gen_dl_model_classification_heatmap(HTuple hv_DLModelHandle, HTuple hv_DLSample,
            HTuple hv_DLResult, HTuple hv_GenParam)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Image, ho_KeyValueObject = null, ho_Partition;
            HObject ho_RegionGrid, ho_OccludedRegions, ho_ImageR = null;
            HObject ho_ImageG = null, ho_ImageB = null, ho_ImagesOccluded = null;
            HObject ho_OccludedRegion = null, ho_ImageOccluded = null, ho_HeatmapRegions;
            HObject ho_PartsSelected = null, ho_HeatmapRegion = null, ho_HeatmapRegionsNegative;
            HObject ho_HeatmapRegionNegative = null, ho_BinRegion = null;
            HObject ho_Heatmap;

            // Local control variables 

            HTuple hv_FeatureSize = new HTuple(), hv_SamplingSize = new HTuple();
            HTuple hv_TargetClassID = new HTuple(), hv_GenParamKeys = new HTuple();
            HTuple hv_Keys = new HTuple(), hv_KeyIndex = new HTuple();
            HTuple hv_IsInteger = new HTuple(), hv_NumInputChannels = new HTuple();
            HTuple hv_NumImageChannels = new HTuple(), hv_ConfidenceValuesExist = new HTuple();
            HTuple hv_DLResultTmp = new HTuple(), hv_DLResultKeys = new HTuple();
            HTuple hv_KeyValueTuple = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_SampleClassIds = new HTuple(), hv_TargetClassIDIndex = new HTuple();
            HTuple hv_SampleClassNames = new HTuple(), hv_TargetClassName = new HTuple();
            HTuple hv_SampleConfidences = new HTuple(), hv_TargetConfidence = new HTuple();
            HTuple hv_ClipRegionSettingBefore = new HTuple(), hv_HeightRegion = new HTuple();
            HTuple hv_WidthRegion = new HTuple(), hv_RatioRegion = new HTuple();
            HTuple hv_SamplingSizeUsed = new HTuple(), hv_Width = new HTuple();
            HTuple hv_Height = new HTuple(), hv_CenterRows = new HTuple();
            HTuple hv_CenterColumns = new HTuple(), hv_NumRegions = new HTuple();
            HTuple hv_Confidences = new HTuple(), hv_MeanGray = new HTuple();
            HTuple hv_DeviationGray = new HTuple(), hv_MeanRed = new HTuple();
            HTuple hv_DeviationRed = new HTuple(), hv_MeanGreen = new HTuple();
            HTuple hv_DeviationGreen = new HTuple(), hv_MeanBlue = new HTuple();
            HTuple hv_DeviationBlue = new HTuple(), hv_BatchSize = new HTuple();
            HTuple hv_BatchIndex = new HTuple(), hv_BatchIndices = new HTuple();
            HTuple hv_Index = new HTuple(), hv_Mean = new HTuple();
            HTuple hv_NumImagesOccluded = new HTuple(), hv_DLSampleImagesOccluded = new HTuple();
            HTuple hv_DLResultImagesOccluded = new HTuple(), hv_IndexOccluded = new HTuple();
            HTuple hv_OccSampleClassIDs = new HTuple(), hv_OccSampleConfidences = new HTuple();
            HTuple hv_Area = new HTuple(), hv_AveragingCenterRows = new HTuple();
            HTuple hv_AveragingCenterColumns = new HTuple(), hv_PartitionConfidences = new HTuple();
            HTuple hv_PartIndex = new HTuple(), hv_ConfidenceIndices = new HTuple();
            HTuple hv_ConfidenceDeviations = new HTuple(), hv_MaxDeviation = new HTuple();
            HTuple hv_NumBins = new HTuple(), hv_Step = new HTuple();
            HTuple hv_End = new HTuple(), hv_Factor = new HTuple();
            HTuple hv_Lesser = new HTuple(), hv_Greater = new HTuple();
            HTuple hv_IndicesInBin = new HTuple(), hv_WidthImage = new HTuple();
            HTuple hv_HeightImage = new HTuple(), hv_WindowHandleTmp = new HTuple();
            HTuple hv_Colors = new HTuple(), hv_BinIndex = new HTuple();
            HTuple hv_ActualColor = new HTuple(), hv_HeatmapParameters = new HTuple();
            HTuple hv_HeatmapResult = new HTuple(), hv_HeatmapImageName = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Image);
            HOperatorSet.GenEmptyObj(out ho_KeyValueObject);
            HOperatorSet.GenEmptyObj(out ho_Partition);
            HOperatorSet.GenEmptyObj(out ho_RegionGrid);
            HOperatorSet.GenEmptyObj(out ho_OccludedRegions);
            HOperatorSet.GenEmptyObj(out ho_ImageR);
            HOperatorSet.GenEmptyObj(out ho_ImageG);
            HOperatorSet.GenEmptyObj(out ho_ImageB);
            HOperatorSet.GenEmptyObj(out ho_ImagesOccluded);
            HOperatorSet.GenEmptyObj(out ho_OccludedRegion);
            HOperatorSet.GenEmptyObj(out ho_ImageOccluded);
            HOperatorSet.GenEmptyObj(out ho_HeatmapRegions);
            HOperatorSet.GenEmptyObj(out ho_PartsSelected);
            HOperatorSet.GenEmptyObj(out ho_HeatmapRegion);
            HOperatorSet.GenEmptyObj(out ho_HeatmapRegionsNegative);
            HOperatorSet.GenEmptyObj(out ho_HeatmapRegionNegative);
            HOperatorSet.GenEmptyObj(out ho_BinRegion);
            HOperatorSet.GenEmptyObj(out ho_Heatmap);
            try
            {
                //
                //This procedure generates a heatmap for an image which is classified
                //with the deep learning model DLModelHandle. The generated heatmap is
                //returned in DLResult and can be displayed in the procedure
                //dev_display_dl_data afterwards.
                //The procedure can be adjusted with generic parameters using
                //the dict GenParam.
                //The calculation of this heatmap bases on the confidence value differences.
                //
                //Please note that the heatmap is intended for visual inspection.
                //Therefore, the resulting regions and confidence values are not
                //returned.
                //
                //Set default parameters.
                hv_FeatureSize.Dispose();
                hv_FeatureSize = 30;
                hv_SamplingSize.Dispose();
                hv_SamplingSize = 7;
                hv_TargetClassID.Dispose();
                hv_TargetClassID = new HTuple();
                //
                //Set user specific parameters.
                if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
                {
                    hv_GenParamKeys.Dispose();
                    hv_GenParamKeys = new HTuple();
                    hv_GenParamKeys[0] = "feature_size";
                    hv_GenParamKeys[1] = "sampling_size";
                    hv_GenParamKeys[2] = "target_class_id";
                    hv_Keys.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_Keys);
                    for (hv_KeyIndex = 0; (int)hv_KeyIndex <= (int)((new HTuple(hv_Keys.TupleLength()
                        )) - 1); hv_KeyIndex = (int)hv_KeyIndex + 1)
                    {
                        //Check the key is allowed.
                        if ((int)(new HTuple(((hv_GenParamKeys.TupleFind(hv_Keys.TupleSelect(hv_KeyIndex)))).TupleEqual(
                            -1))) != 0)
                        {
                            throw new HalconException(("Invalid GenParam key '" + (hv_Keys.TupleSelect(
                                hv_KeyIndex))) + "'");
                            //Retrieve the set value.
                        }
                        else if ((int)(new HTuple(((hv_Keys.TupleSelect(hv_KeyIndex))).TupleEqual(
                            "feature_size"))) != 0)
                        {
                            //Set feature size.
                            hv_FeatureSize.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "feature_size", out hv_FeatureSize);
                        }
                        else if ((int)(new HTuple(((hv_Keys.TupleSelect(hv_KeyIndex))).TupleEqual(
                            "sampling_size"))) != 0)
                        {
                            //Set sampling size.
                            hv_SamplingSize.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "sampling_size", out hv_SamplingSize);
                        }
                        else if ((int)(new HTuple(((hv_Keys.TupleSelect(hv_KeyIndex))).TupleEqual(
                            "target_class_id"))) != 0)
                        {
                            //Set target class ID.
                            hv_TargetClassID.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "target_class_id", out hv_TargetClassID);
                            if ((int)(new HTuple(hv_TargetClassID.TupleNotEqual(new HTuple()))) != 0)
                            {
                                //Check if target class ID is an integer.
                                hv_IsInteger.Dispose();
                                HOperatorSet.TupleIsInt(hv_TargetClassID, out hv_IsInteger);
                                if ((int)(hv_IsInteger.TupleNot()) != 0)
                                {
                                    throw new HalconException("The \"target_class_id\" must be an integer.");
                                }
                            }
                        }
                    }
                }
                //
                //Check the input parameters.
                if ((int)(new HTuple((new HTuple(hv_DLSample.TupleLength())).TupleNotEqual(
                    1))) != 0)
                {
                    throw new HalconException("Please use only a single sample dictionary as input.");
                }
                if ((int)(new HTuple(hv_SamplingSize.TupleLess(1))) != 0)
                {
                    throw new HalconException(("The \"sampling_size\" (" + hv_SamplingSize) + ") must be greater than zero.");
                }
                if ((int)(new HTuple(hv_FeatureSize.TupleLess(1))) != 0)
                {
                    throw new HalconException(("The \"feature_size\" (" + hv_FeatureSize) + ") must be greater than zero.");
                }
                if ((int)(new HTuple(hv_SamplingSize.TupleGreaterEqual(hv_FeatureSize))) != 0)
                {
                    throw new HalconException(((("The \"sampling_size\" (" + hv_SamplingSize) + ") must be smaller than the \"feature_size\" (") + hv_FeatureSize) + ")");
                }
                hv_NumInputChannels.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "image_num_channels", out hv_NumInputChannels);
                ho_Image.Dispose();
                HOperatorSet.GetDictObject(out ho_Image, hv_DLSample, "image");
                hv_NumImageChannels.Dispose();
                HOperatorSet.CountChannels(ho_Image, out hv_NumImageChannels);
                if ((int)(new HTuple(hv_NumImageChannels.TupleNotEqual(hv_NumInputChannels))) != 0)
                {
                    throw new HalconException((((("The number of image channels (" + hv_NumImageChannels) + ") does not match ") + "the number of input channels expected by the classifier (") + hv_NumInputChannels) + ")");
                }
                dev_update_off();
                //
                //Check if the result dictionary contains confidence values.
                //In case it does not, an additional inference step is needed.
                //Else we can skip this step and directly read out the values.
                hv_ConfidenceValuesExist.Dispose();
                HOperatorSet.GetDictParam(hv_DLResult, "key_exists", "confidences", out hv_ConfidenceValuesExist);
                if ((int)(hv_ConfidenceValuesExist.TupleNot()) != 0)
                {
                    hv_DLResultTmp.Dispose();
                    HOperatorSet.ApplyDlModel(hv_DLModelHandle, hv_DLSample, new HTuple(), out hv_DLResultTmp);
                    hv_DLResultKeys.Dispose();
                    HOperatorSet.GetDictParam(hv_DLResultTmp, "keys", new HTuple(), out hv_DLResultKeys);
                    //The operator apply_dl_model creates a new result dictionary.
                    //The results need to be copied in order to have them in the procedure parameter dictionary.
                    for (hv_KeyIndex = 0; (int)hv_KeyIndex <= (int)((new HTuple(hv_DLResultKeys.TupleLength()
                        )) - 1); hv_KeyIndex = (int)hv_KeyIndex + 1)
                    {
                        try
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_KeyValueTuple.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLResultTmp, hv_DLResultKeys.TupleSelect(
                                    hv_KeyIndex), out hv_KeyValueTuple);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_DLResult, hv_DLResultKeys.TupleSelect(hv_KeyIndex),
                                    hv_KeyValueTuple);
                            }
                        }
                        // catch (Exception) 
                        catch (HalconException HDevExpDefaultException1)
                        {
                            HDevExpDefaultException1.ToHTuple(out hv_Exception);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_KeyValueObject.Dispose();
                                HOperatorSet.GetDictObject(out ho_KeyValueObject, hv_DLResultTmp, hv_DLResultKeys.TupleSelect(
                                    hv_KeyIndex));
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictObject(ho_KeyValueObject, hv_DLResult, hv_DLResultKeys.TupleSelect(
                                    hv_KeyIndex));
                            }
                        }
                    }
                }
                //Get the predicted class and its confidence value
                //for the original (unoccluded) image.
                hv_SampleClassIds.Dispose();
                HOperatorSet.GetDictTuple(hv_DLResult, "classification_class_ids", out hv_SampleClassIds);
                if ((int)(new HTuple(hv_TargetClassID.TupleEqual(new HTuple()))) != 0)
                {
                    hv_TargetClassIDIndex.Dispose();
                    hv_TargetClassIDIndex = 0;
                    hv_TargetClassID.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TargetClassID = hv_SampleClassIds.TupleSelect(
                            0);
                    }
                }
                else
                {
                    hv_TargetClassIDIndex.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TargetClassIDIndex = hv_SampleClassIds.TupleFind(
                            hv_TargetClassID);
                    }
                    if ((int)(new HTuple(hv_TargetClassIDIndex.TupleEqual(-1))) != 0)
                    {
                        throw new HalconException(("Selected \"target_class_id\" " + hv_TargetClassID) + " must be in the range of the classification_class_ids of DLResult.");
                    }
                }
                hv_TargetClassID.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TargetClassID = hv_SampleClassIds.TupleSelect(
                        hv_TargetClassIDIndex);
                }
                hv_SampleClassNames.Dispose();
                HOperatorSet.GetDictTuple(hv_DLResult, "classification_class_names", out hv_SampleClassNames);
                hv_TargetClassName.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TargetClassName = hv_SampleClassNames.TupleSelect(
                        hv_TargetClassIDIndex);
                }
                hv_SampleConfidences.Dispose();
                HOperatorSet.GetDictTuple(hv_DLResult, "classification_confidences", out hv_SampleConfidences);
                hv_TargetConfidence.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TargetConfidence = hv_SampleConfidences.TupleSelect(
                        hv_TargetClassIDIndex);
                }
                hv_ClipRegionSettingBefore.Dispose();
                HOperatorSet.GetSystem("clip_region", out hv_ClipRegionSettingBefore);
                HOperatorSet.SetSystem("clip_region", "false");
                //
                //Partition the image into rectangular regions. The height and width of the
                //rectangles are approximately equal to sampling_size.
                ho_Partition.Dispose();
                HOperatorSet.PartitionRectangle(ho_Image, out ho_Partition, hv_SamplingSize,
                    hv_SamplingSize);
                hv_HeightRegion.Dispose(); hv_WidthRegion.Dispose(); hv_RatioRegion.Dispose();
                HOperatorSet.HeightWidthRatio(ho_Partition, out hv_HeightRegion, out hv_WidthRegion,
                    out hv_RatioRegion);
                //
                //Generate a set of regions to be occluded based on the center coordinates
                //and the dimensions of these rectangles. Depending on the values of
                //feature_size and sampling_size, these regions may overlap.
                hv_SamplingSizeUsed.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SamplingSizeUsed = ((hv_HeightRegion.TupleConcat(
                        hv_WidthRegion))).TupleMedian();
                }
                hv_Width.Dispose(); hv_Height.Dispose();
                HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_RegionGrid.Dispose();
                    HOperatorSet.GenGridRegion(out ho_RegionGrid, hv_SamplingSizeUsed, hv_SamplingSizeUsed,
                        "points", hv_Width + 1, hv_Height + 1);
                }
                hv_CenterRows.Dispose(); hv_CenterColumns.Dispose();
                HOperatorSet.GetRegionPoints(ho_RegionGrid, out hv_CenterRows, out hv_CenterColumns);
                hv_NumRegions.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumRegions = new HTuple(hv_CenterRows.TupleLength()
                        );
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_OccludedRegions.Dispose();
                    HOperatorSet.GenCircle(out ho_OccludedRegions, hv_CenterRows, hv_CenterColumns,
                        HTuple.TupleGenConst(hv_NumRegions, hv_FeatureSize / 2));
                }
                //
                //Generate and classify the occluded images.
                hv_Confidences.Dispose();
                hv_Confidences = new HTuple();
                if ((int)(new HTuple(hv_NumInputChannels.TupleEqual(1))) != 0)
                {
                    hv_MeanGray.Dispose(); hv_DeviationGray.Dispose();
                    HOperatorSet.Intensity(ho_OccludedRegions, ho_Image, out hv_MeanGray, out hv_DeviationGray);
                }
                else
                {
                    ho_ImageR.Dispose(); ho_ImageG.Dispose(); ho_ImageB.Dispose();
                    HOperatorSet.Decompose3(ho_Image, out ho_ImageR, out ho_ImageG, out ho_ImageB
                        );
                    hv_MeanRed.Dispose(); hv_DeviationRed.Dispose();
                    HOperatorSet.Intensity(ho_OccludedRegions, ho_ImageR, out hv_MeanRed, out hv_DeviationRed);
                    hv_MeanGreen.Dispose(); hv_DeviationGreen.Dispose();
                    HOperatorSet.Intensity(ho_OccludedRegions, ho_ImageG, out hv_MeanGreen, out hv_DeviationGreen);
                    hv_MeanBlue.Dispose(); hv_DeviationBlue.Dispose();
                    HOperatorSet.Intensity(ho_OccludedRegions, ho_ImageB, out hv_MeanBlue, out hv_DeviationBlue);
                }
                hv_BatchSize.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "batch_size", out hv_BatchSize);
                HTuple end_val133 = ((hv_NumRegions / hv_BatchSize)).TupleInt()
                    ;
                HTuple step_val133 = 1;
                for (hv_BatchIndex = 0; hv_BatchIndex.Continue(end_val133, step_val133); hv_BatchIndex = hv_BatchIndex.TupleAdd(step_val133))
                {
                    ho_ImagesOccluded.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_ImagesOccluded);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BatchIndices.Dispose();
                        HOperatorSet.TupleGenSequence((hv_BatchIndex * hv_BatchSize) + 1, (((((hv_BatchIndex + 1) * hv_BatchSize)).TupleConcat(
                            hv_NumRegions))).TupleMin(), 1, out hv_BatchIndices);
                    }
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_BatchIndices.TupleLength()
                        )) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_OccludedRegion.Dispose();
                            HOperatorSet.SelectObj(ho_OccludedRegions, out ho_OccludedRegion, hv_BatchIndices.TupleSelect(
                                hv_Index));
                        }
                        if ((int)(new HTuple(hv_NumInputChannels.TupleEqual(1))) != 0)
                        {
                            hv_Mean.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Mean = hv_MeanGray.TupleSelect(
                                    (hv_BatchIndices.TupleSelect(hv_Index)) - 1);
                            }
                        }
                        else
                        {
                            hv_Mean.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Mean = new HTuple();
                                hv_Mean = hv_Mean.TupleConcat(hv_MeanRed.TupleSelect(
                                    (hv_BatchIndices.TupleSelect(hv_Index)) - 1));
                                hv_Mean = hv_Mean.TupleConcat(hv_MeanGreen.TupleSelect(
                                    (hv_BatchIndices.TupleSelect(hv_Index)) - 1));
                                hv_Mean = hv_Mean.TupleConcat(hv_MeanBlue.TupleSelect(
                                    (hv_BatchIndices.TupleSelect(hv_Index)) - 1));
                            }
                        }
                        ho_ImageOccluded.Dispose();
                        HOperatorSet.PaintRegion(ho_OccludedRegion, ho_Image, out ho_ImageOccluded,
                            hv_Mean, "fill");
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_ImagesOccluded, ho_ImageOccluded, out ExpTmpOutVar_0
                                );
                            ho_ImagesOccluded.Dispose();
                            ho_ImagesOccluded = ExpTmpOutVar_0;
                        }
                    }
                    //
                    //For each occluded image, get the confidence
                    //for the predicted class of the original image.
                    hv_NumImagesOccluded.Dispose();
                    HOperatorSet.CountObj(ho_ImagesOccluded, out hv_NumImagesOccluded);
                    if ((int)(new HTuple(hv_NumImagesOccluded.TupleGreater(0))) != 0)
                    {
                        hv_DLSampleImagesOccluded.Dispose();
                        gen_dl_samples_from_images(ho_ImagesOccluded, out hv_DLSampleImagesOccluded);
                        hv_DLResultImagesOccluded.Dispose();
                        HOperatorSet.ApplyDlModel(hv_DLModelHandle, hv_DLSampleImagesOccluded,
                            new HTuple(), out hv_DLResultImagesOccluded);
                        HTuple end_val153 = hv_NumImagesOccluded - 1;
                        HTuple step_val153 = 1;
                        for (hv_IndexOccluded = 0; hv_IndexOccluded.Continue(end_val153, step_val153); hv_IndexOccluded = hv_IndexOccluded.TupleAdd(step_val153))
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_OccSampleClassIDs.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLResultImagesOccluded.TupleSelect(hv_IndexOccluded),
                                    "classification_class_ids", out hv_OccSampleClassIDs);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_OccSampleConfidences.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLResultImagesOccluded.TupleSelect(hv_IndexOccluded),
                                    "classification_confidences", out hv_OccSampleConfidences);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_Confidences = hv_Confidences.TupleConcat(
                                        hv_OccSampleConfidences.TupleSelect(hv_OccSampleClassIDs.TupleFind(
                                        hv_TargetClassID)));
                                    hv_Confidences.Dispose();
                                    hv_Confidences = ExpTmpLocalVar_Confidences;
                                }
                            }
                        }
                    }
                }
                //
                //Since it is too expensive to compute the confidence value
                //for each individual pixel, we work with a subsampling of the image.
                //The distance between two sampling points is controlled
                //by the parameter 'sampling_size'. For each sampling point,
                //we average over the confidence values of all images
                //which were occluded with a regions to which this point belongs.
                hv_Area.Dispose(); hv_AveragingCenterRows.Dispose(); hv_AveragingCenterColumns.Dispose();
                HOperatorSet.AreaCenter(ho_Partition, out hv_Area, out hv_AveragingCenterRows,
                    out hv_AveragingCenterColumns);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PartitionConfidences.Dispose();
                    HOperatorSet.TupleGenConst(new HTuple(hv_AveragingCenterRows.TupleLength()),
                        0, out hv_PartitionConfidences);
                }
                for (hv_PartIndex = 0; (int)hv_PartIndex <= (int)((new HTuple(hv_AveragingCenterRows.TupleLength()
                    )) - 1); hv_PartIndex = (int)hv_PartIndex + 1)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ConfidenceIndices.Dispose();
                        HOperatorSet.GetRegionIndex(ho_OccludedRegions, ((hv_AveragingCenterRows.TupleSelect(
                            hv_PartIndex))).TupleInt(), ((hv_AveragingCenterColumns.TupleSelect(hv_PartIndex))).TupleInt()
                            , out hv_ConfidenceIndices);
                    }
                    if (hv_PartitionConfidences == null)
                        hv_PartitionConfidences = new HTuple();
                    hv_PartitionConfidences[hv_PartIndex] = ((hv_Confidences.TupleSelect(hv_ConfidenceIndices - 1))).TupleMean()
                        ;
                }
                //
                //Compute the deviation from the original confidence value and its maximum absolute value.
                hv_ConfidenceDeviations.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ConfidenceDeviations = hv_TargetConfidence - hv_PartitionConfidences;
                }
                hv_MaxDeviation.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_MaxDeviation = ((hv_ConfidenceDeviations.TupleAbs()
                        )).TupleMax();
                }
                //
                //The heatmap is categorized into 'bins'. The regions where the deviation
                //is highest are in the first bin, the regions where the deviation
                //is lowest are in the last bin. This is done separately for deviations with
                //positive and negative sign.
                hv_NumBins.Dispose();
                hv_NumBins = 10;
                hv_Step.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Step = 1 / (hv_NumBins.TupleReal()
                        );
                }
                hv_End.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_End = 1 - ((hv_NumBins - 1) * hv_Step);
                }
                ho_HeatmapRegions.Dispose();
                HOperatorSet.GenEmptyObj(out ho_HeatmapRegions);
                HTuple end_val186 = hv_End;
                HTuple step_val186 = -hv_Step;
                for (hv_Factor = 1; hv_Factor.Continue(end_val186, step_val186); hv_Factor = hv_Factor.TupleAdd(step_val186))
                {
                    hv_Lesser.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Lesser = hv_ConfidenceDeviations.TupleLessEqualElem(
                            hv_MaxDeviation * hv_Factor);
                    }
                    hv_Greater.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Greater = hv_ConfidenceDeviations.TupleGreaterElem(
                            hv_MaxDeviation * (hv_Factor - hv_Step));
                    }
                    hv_IndicesInBin.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_IndicesInBin = ((hv_Lesser + hv_Greater)).TupleFind(
                            2);
                    }
                    if ((int)(new HTuple(hv_IndicesInBin.TupleNotEqual(-1))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_PartsSelected.Dispose();
                            HOperatorSet.SelectObj(ho_Partition, out ho_PartsSelected, hv_IndicesInBin + 1);
                        }
                        ho_HeatmapRegion.Dispose();
                        HOperatorSet.Union1(ho_PartsSelected, out ho_HeatmapRegion);
                    }
                    else
                    {
                        ho_HeatmapRegion.Dispose();
                        HOperatorSet.GenEmptyRegion(out ho_HeatmapRegion);
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_HeatmapRegions, ho_HeatmapRegion, out ExpTmpOutVar_0
                            );
                        ho_HeatmapRegions.Dispose();
                        ho_HeatmapRegions = ExpTmpOutVar_0;
                    }
                }
                ho_HeatmapRegionsNegative.Dispose();
                HOperatorSet.GenEmptyObj(out ho_HeatmapRegionsNegative);
                HTuple end_val199 = hv_End;
                HTuple step_val199 = -hv_Step;
                for (hv_Factor = 1; hv_Factor.Continue(end_val199, step_val199); hv_Factor = hv_Factor.TupleAdd(step_val199))
                {
                    hv_Lesser.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Lesser = hv_ConfidenceDeviations.TupleLessElem(
                            (-hv_MaxDeviation) * (hv_Factor - hv_Step));
                    }
                    hv_Greater.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Greater = hv_ConfidenceDeviations.TupleGreaterEqualElem(
                            (-hv_MaxDeviation) * hv_Factor);
                    }
                    hv_IndicesInBin.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_IndicesInBin = ((hv_Lesser + hv_Greater)).TupleFind(
                            2);
                    }
                    if ((int)(new HTuple(hv_IndicesInBin.TupleNotEqual(-1))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_PartsSelected.Dispose();
                            HOperatorSet.SelectObj(ho_Partition, out ho_PartsSelected, hv_IndicesInBin + 1);
                        }
                        ho_HeatmapRegionNegative.Dispose();
                        HOperatorSet.Union1(ho_PartsSelected, out ho_HeatmapRegionNegative);
                    }
                    else
                    {
                        ho_HeatmapRegionNegative.Dispose();
                        HOperatorSet.GenEmptyRegion(out ho_HeatmapRegionNegative);
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_HeatmapRegionsNegative, ho_HeatmapRegionNegative,
                            out ExpTmpOutVar_0);
                        ho_HeatmapRegionsNegative.Dispose();
                        ho_HeatmapRegionsNegative = ExpTmpOutVar_0;
                    }
                }
                //
                //Visualize the heatmap.
                hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                hv_WindowHandleTmp.Dispose();
                HOperatorSet.OpenWindow(0, 0, hv_WidthImage, hv_HeightImage, 0, "buffer", "",
                    out hv_WindowHandleTmp);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetPart(hv_WindowHandleTmp, 0, 0, hv_HeightImage - 1, hv_WidthImage - 1);
                }
                HOperatorSet.DispObj(ho_Image, hv_WindowHandleTmp);
                //
                //For regions for which the confidence decreased, generate a color palette
                //from red to yellow with 66% transparency
                hv_Colors.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Colors = (((
                        (new HTuple("#ff3300")).TupleConcat("#ff6600")).TupleConcat("#ff9900")).TupleConcat(
                        "#ffcc00")).TupleConcat("#ffff00") + "66";
                }
                for (hv_BinIndex = 1; (int)hv_BinIndex <= 5; hv_BinIndex = (int)hv_BinIndex + 1)
                {
                    ho_BinRegion.Dispose();
                    HOperatorSet.SelectObj(ho_HeatmapRegions, out ho_BinRegion, hv_BinIndex);
                    hv_ActualColor.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ActualColor = hv_Colors.TupleSelect(
                            hv_BinIndex - 1);
                    }
                    HOperatorSet.SetColor(hv_WindowHandleTmp, hv_ActualColor);
                    HOperatorSet.DispRegion(ho_BinRegion, hv_WindowHandleTmp);
                }
                //For regions for which the confidence increased, generate a color palette
                //from blue to cyan with 66% transparency
                hv_Colors.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Colors = (((
                        (new HTuple("#0033ff")).TupleConcat("#0066ff")).TupleConcat("#0099ff")).TupleConcat(
                        "#00ccff")).TupleConcat("#00ffff") + "66";
                }
                for (hv_BinIndex = 1; (int)hv_BinIndex <= 5; hv_BinIndex = (int)hv_BinIndex + 1)
                {
                    ho_BinRegion.Dispose();
                    HOperatorSet.SelectObj(ho_HeatmapRegionsNegative, out ho_BinRegion, hv_BinIndex);
                    hv_ActualColor.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ActualColor = hv_Colors.TupleSelect(
                            hv_BinIndex - 1);
                    }
                    HOperatorSet.SetColor(hv_WindowHandleTmp, hv_ActualColor);
                    HOperatorSet.DispRegion(ho_BinRegion, hv_WindowHandleTmp);
                }
                //
                //Get the actual window content.
                ho_Heatmap.Dispose();
                HOperatorSet.DumpWindowImage(out ho_Heatmap, hv_WindowHandleTmp);
                HOperatorSet.CloseWindow(hv_WindowHandleTmp);
                HOperatorSet.SetSystem("clip_region", hv_ClipRegionSettingBefore);
                //Set the heatmap and its parameters in the result dictionary.
                hv_HeatmapParameters.Dispose();
                HOperatorSet.CreateDict(out hv_HeatmapParameters);
                HOperatorSet.SetDictTuple(hv_HeatmapParameters, "feature_size", hv_FeatureSize);
                HOperatorSet.SetDictTuple(hv_HeatmapParameters, "sampling_size", hv_SamplingSize);
                hv_HeatmapResult.Dispose();
                HOperatorSet.CreateDict(out hv_HeatmapResult);
                hv_HeatmapImageName.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HeatmapImageName = "heatmap_image_class_" + hv_TargetClassID;
                }
                HOperatorSet.SetDictObject(ho_Heatmap, hv_HeatmapResult, hv_HeatmapImageName);
                HOperatorSet.SetDictTuple(hv_HeatmapResult, "classification_heatmap_maxdeviation",
                    hv_MaxDeviation);
                HOperatorSet.SetDictTuple(hv_HeatmapResult, "heatmap_parameters", hv_HeatmapParameters);
                HOperatorSet.SetDictTuple(hv_DLResult, "heatmap_confidence_based", hv_HeatmapResult);
                ho_Image.Dispose();
                ho_KeyValueObject.Dispose();
                ho_Partition.Dispose();
                ho_RegionGrid.Dispose();
                ho_OccludedRegions.Dispose();
                ho_ImageR.Dispose();
                ho_ImageG.Dispose();
                ho_ImageB.Dispose();
                ho_ImagesOccluded.Dispose();
                ho_OccludedRegion.Dispose();
                ho_ImageOccluded.Dispose();
                ho_HeatmapRegions.Dispose();
                ho_PartsSelected.Dispose();
                ho_HeatmapRegion.Dispose();
                ho_HeatmapRegionsNegative.Dispose();
                ho_HeatmapRegionNegative.Dispose();
                ho_BinRegion.Dispose();
                ho_Heatmap.Dispose();

                hv_FeatureSize.Dispose();
                hv_SamplingSize.Dispose();
                hv_TargetClassID.Dispose();
                hv_GenParamKeys.Dispose();
                hv_Keys.Dispose();
                hv_KeyIndex.Dispose();
                hv_IsInteger.Dispose();
                hv_NumInputChannels.Dispose();
                hv_NumImageChannels.Dispose();
                hv_ConfidenceValuesExist.Dispose();
                hv_DLResultTmp.Dispose();
                hv_DLResultKeys.Dispose();
                hv_KeyValueTuple.Dispose();
                hv_Exception.Dispose();
                hv_SampleClassIds.Dispose();
                hv_TargetClassIDIndex.Dispose();
                hv_SampleClassNames.Dispose();
                hv_TargetClassName.Dispose();
                hv_SampleConfidences.Dispose();
                hv_TargetConfidence.Dispose();
                hv_ClipRegionSettingBefore.Dispose();
                hv_HeightRegion.Dispose();
                hv_WidthRegion.Dispose();
                hv_RatioRegion.Dispose();
                hv_SamplingSizeUsed.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_CenterRows.Dispose();
                hv_CenterColumns.Dispose();
                hv_NumRegions.Dispose();
                hv_Confidences.Dispose();
                hv_MeanGray.Dispose();
                hv_DeviationGray.Dispose();
                hv_MeanRed.Dispose();
                hv_DeviationRed.Dispose();
                hv_MeanGreen.Dispose();
                hv_DeviationGreen.Dispose();
                hv_MeanBlue.Dispose();
                hv_DeviationBlue.Dispose();
                hv_BatchSize.Dispose();
                hv_BatchIndex.Dispose();
                hv_BatchIndices.Dispose();
                hv_Index.Dispose();
                hv_Mean.Dispose();
                hv_NumImagesOccluded.Dispose();
                hv_DLSampleImagesOccluded.Dispose();
                hv_DLResultImagesOccluded.Dispose();
                hv_IndexOccluded.Dispose();
                hv_OccSampleClassIDs.Dispose();
                hv_OccSampleConfidences.Dispose();
                hv_Area.Dispose();
                hv_AveragingCenterRows.Dispose();
                hv_AveragingCenterColumns.Dispose();
                hv_PartitionConfidences.Dispose();
                hv_PartIndex.Dispose();
                hv_ConfidenceIndices.Dispose();
                hv_ConfidenceDeviations.Dispose();
                hv_MaxDeviation.Dispose();
                hv_NumBins.Dispose();
                hv_Step.Dispose();
                hv_End.Dispose();
                hv_Factor.Dispose();
                hv_Lesser.Dispose();
                hv_Greater.Dispose();
                hv_IndicesInBin.Dispose();
                hv_WidthImage.Dispose();
                hv_HeightImage.Dispose();
                hv_WindowHandleTmp.Dispose();
                hv_Colors.Dispose();
                hv_BinIndex.Dispose();
                hv_ActualColor.Dispose();
                hv_HeatmapParameters.Dispose();
                hv_HeatmapResult.Dispose();
                hv_HeatmapImageName.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Image.Dispose();
                ho_KeyValueObject.Dispose();
                ho_Partition.Dispose();
                ho_RegionGrid.Dispose();
                ho_OccludedRegions.Dispose();
                ho_ImageR.Dispose();
                ho_ImageG.Dispose();
                ho_ImageB.Dispose();
                ho_ImagesOccluded.Dispose();
                ho_OccludedRegion.Dispose();
                ho_ImageOccluded.Dispose();
                ho_HeatmapRegions.Dispose();
                ho_PartsSelected.Dispose();
                ho_HeatmapRegion.Dispose();
                ho_HeatmapRegionsNegative.Dispose();
                ho_HeatmapRegionNegative.Dispose();
                ho_BinRegion.Dispose();
                ho_Heatmap.Dispose();

                hv_FeatureSize.Dispose();
                hv_SamplingSize.Dispose();
                hv_TargetClassID.Dispose();
                hv_GenParamKeys.Dispose();
                hv_Keys.Dispose();
                hv_KeyIndex.Dispose();
                hv_IsInteger.Dispose();
                hv_NumInputChannels.Dispose();
                hv_NumImageChannels.Dispose();
                hv_ConfidenceValuesExist.Dispose();
                hv_DLResultTmp.Dispose();
                hv_DLResultKeys.Dispose();
                hv_KeyValueTuple.Dispose();
                hv_Exception.Dispose();
                hv_SampleClassIds.Dispose();
                hv_TargetClassIDIndex.Dispose();
                hv_SampleClassNames.Dispose();
                hv_TargetClassName.Dispose();
                hv_SampleConfidences.Dispose();
                hv_TargetConfidence.Dispose();
                hv_ClipRegionSettingBefore.Dispose();
                hv_HeightRegion.Dispose();
                hv_WidthRegion.Dispose();
                hv_RatioRegion.Dispose();
                hv_SamplingSizeUsed.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_CenterRows.Dispose();
                hv_CenterColumns.Dispose();
                hv_NumRegions.Dispose();
                hv_Confidences.Dispose();
                hv_MeanGray.Dispose();
                hv_DeviationGray.Dispose();
                hv_MeanRed.Dispose();
                hv_DeviationRed.Dispose();
                hv_MeanGreen.Dispose();
                hv_DeviationGreen.Dispose();
                hv_MeanBlue.Dispose();
                hv_DeviationBlue.Dispose();
                hv_BatchSize.Dispose();
                hv_BatchIndex.Dispose();
                hv_BatchIndices.Dispose();
                hv_Index.Dispose();
                hv_Mean.Dispose();
                hv_NumImagesOccluded.Dispose();
                hv_DLSampleImagesOccluded.Dispose();
                hv_DLResultImagesOccluded.Dispose();
                hv_IndexOccluded.Dispose();
                hv_OccSampleClassIDs.Dispose();
                hv_OccSampleConfidences.Dispose();
                hv_Area.Dispose();
                hv_AveragingCenterRows.Dispose();
                hv_AveragingCenterColumns.Dispose();
                hv_PartitionConfidences.Dispose();
                hv_PartIndex.Dispose();
                hv_ConfidenceIndices.Dispose();
                hv_ConfidenceDeviations.Dispose();
                hv_MaxDeviation.Dispose();
                hv_NumBins.Dispose();
                hv_Step.Dispose();
                hv_End.Dispose();
                hv_Factor.Dispose();
                hv_Lesser.Dispose();
                hv_Greater.Dispose();
                hv_IndicesInBin.Dispose();
                hv_WidthImage.Dispose();
                hv_HeightImage.Dispose();
                hv_WindowHandleTmp.Dispose();
                hv_Colors.Dispose();
                hv_BinIndex.Dispose();
                hv_ActualColor.Dispose();
                hv_HeatmapParameters.Dispose();
                hv_HeatmapResult.Dispose();
                hv_HeatmapImageName.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Store the given images in a tuple of dictionaries DLSamples. 
        public void gen_dl_samples_from_images(HObject ho_Images, out HTuple hv_DLSampleBatch)
        {



            // Local iconic variables 

            HObject ho_Image = null;

            // Local control variables 

            HTuple hv_NumImages = new HTuple(), hv_ImageIndex = new HTuple();
            HTuple hv_DLSample = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Image);
            hv_DLSampleBatch = new HTuple();
            try
            {
                //
                //This procedure creates DLSampleBatch, a tuple
                //containing a dictionary DLSample
                //for every image given in Images.
                //
                //Initialize output tuple.
                hv_NumImages.Dispose();
                HOperatorSet.CountObj(ho_Images, out hv_NumImages);
                hv_DLSampleBatch.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_DLSampleBatch = HTuple.TupleGenConst(
                        hv_NumImages, -1);
                }
                //
                //Loop through all given images.
                HTuple end_val10 = hv_NumImages - 1;
                HTuple step_val10 = 1;
                for (hv_ImageIndex = 0; hv_ImageIndex.Continue(end_val10, step_val10); hv_ImageIndex = hv_ImageIndex.TupleAdd(step_val10))
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_Image.Dispose();
                        HOperatorSet.SelectObj(ho_Images, out ho_Image, hv_ImageIndex + 1);
                    }
                    //Create DLSample from image.
                    hv_DLSample.Dispose();
                    HOperatorSet.CreateDict(out hv_DLSample);
                    HOperatorSet.SetDictObject(ho_Image, hv_DLSample, "image");
                    //
                    //Collect the DLSamples.
                    if (hv_DLSampleBatch == null)
                        hv_DLSampleBatch = new HTuple();
                    hv_DLSampleBatch[hv_ImageIndex] = hv_DLSample;
                }
                ho_Image.Dispose();

                hv_NumImages.Dispose();
                hv_ImageIndex.Dispose();
                hv_DLSample.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Image.Dispose();

                hv_NumImages.Dispose();
                hv_ImageIndex.Dispose();
                hv_DLSample.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection
        // Short Description: Get the ground truth anomaly label and label ID. 
        public void get_anomaly_ground_truth_label(HTuple hv_SampleKeys, HTuple hv_DLSample,
            out HTuple hv_AnomalyLabelGroundTruth, out HTuple hv_AnomalyLabelIDGroundTruth)
        {


            // Initialize local and output iconic variables 
            hv_AnomalyLabelGroundTruth = new HTuple();
            hv_AnomalyLabelIDGroundTruth = new HTuple();
            //
            //This procedure returns the anomaly ground truth label.
            //
            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("anomaly_label"))).TupleNotEqual(
                -1))) != 0)
            {
                hv_AnomalyLabelGroundTruth.Dispose();
                HOperatorSet.GetDictTuple(hv_DLSample, "anomaly_label", out hv_AnomalyLabelGroundTruth);
            }
            else
            {
                throw new HalconException("Ground truth class label cannot be found in DLSample.");
            }
            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("anomaly_label_id"))).TupleNotEqual(
                -1))) != 0)
            {
                hv_AnomalyLabelIDGroundTruth.Dispose();
                HOperatorSet.GetDictTuple(hv_DLSample, "anomaly_label_id", out hv_AnomalyLabelIDGroundTruth);
            }
            else
            {
                throw new HalconException("Ground truth class label id cannot be found in DLSample.");
            }
            //


            return;
        }

        // Chapter: Deep Learning / Anomaly Detection
        // Short Description: Get the anomaly image out of DLResult. 
        public void get_anomaly_result(out HObject ho_AnomalyImage, HTuple hv_ResultKeys,
            HTuple hv_DLResult, out HTuple hv_AnomalyScore, out HTuple hv_AnomalyClassID)
        {



            // Local control variables 

            HTuple hv_AnomalyImageExists = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_AnomalyImage);
            hv_AnomalyScore = new HTuple();
            hv_AnomalyClassID = new HTuple();
            try
            {
                //
                //This procedure returns the anomaly image of DLResult.
                //
                if ((int)(new HTuple(((hv_ResultKeys.TupleFind("anomaly_image"))).TupleNotEqual(
                    -1))) != 0)
                {
                    hv_AnomalyImageExists.Dispose();
                    HOperatorSet.GetDictParam(hv_DLResult, "key_exists", "anomaly_image", out hv_AnomalyImageExists);
                    if ((int)(hv_AnomalyImageExists) != 0)
                    {
                        ho_AnomalyImage.Dispose();
                        HOperatorSet.GetDictObject(out ho_AnomalyImage, hv_DLResult, "anomaly_image");
                    }
                    else
                    {
                        throw new HalconException("Result anomaly image could not be found in DLResult.");
                    }
                }
                else
                {
                    throw new HalconException("Result anomaly image could not be found in DLResult.");
                }
                //
                //This procedure returns the anomaly score of DLResult.
                //
                if ((int)(new HTuple(((hv_ResultKeys.TupleFind("anomaly_score"))).TupleNotEqual(
                    -1))) != 0)
                {
                    hv_AnomalyScore.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "anomaly_score", out hv_AnomalyScore);
                }
                else
                {
                    throw new HalconException("Result anomaly score could not be found in DLResult.");
                }
                //
                //This procedure returns the anomaly class id of DLResult.
                //
                if ((int)(new HTuple(((hv_ResultKeys.TupleFind("anomaly_class_id"))).TupleNotEqual(
                    -1))) != 0)
                {
                    hv_AnomalyClassID.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "anomaly_class_id", out hv_AnomalyClassID);
                }
                else
                {
                    throw new HalconException("Result anomaly class ID could not be found in DLResult.");
                }

                hv_AnomalyImageExists.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_AnomalyImageExists.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Window
        // Short Description: Get the next child window that can be used for visualization. 
        public void get_child_window(HTuple hv_HeightImage, HTuple hv_Font, HTuple hv_FontSize,
            HTuple hv_Text, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict,
            HTuple hv_WindowHandleKey, out HTuple hv_WindowImageRatio, out HTuple hv_PrevWindowCoordinatesOut)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_OpenNewWindow = new HTuple(), hv_WindowHandles = new HTuple();
            HTuple hv_ParentWindowHandle = new HTuple(), hv_ChildWindowHandle = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_MetaInfo = new HTuple();
            HTuple hv_WindowRow = new HTuple(), hv_WindowColumn = new HTuple();
            HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
            // Initialize local and output iconic variables 
            hv_WindowImageRatio = new HTuple();
            hv_PrevWindowCoordinatesOut = new HTuple();
            try
            {
                //
                //This procedure returns the next child window that
                //is used for visualization. If ReuseWindows is true
                //and WindowHandleList is suitable, the window handles
                //that are passed over are used. Else, this procedure
                //opens a new window, either next to the last ones, or
                //in a new row.
                //
                //First, check if the requested window is already available.
                hv_OpenNewWindow.Dispose();
                hv_OpenNewWindow = 0;
                try
                {
                    hv_WindowHandles.Dispose();
                    HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, out hv_WindowHandles);
                    hv_ParentWindowHandle.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ParentWindowHandle = hv_WindowHandles.TupleSelect(
                            0);
                    }
                    hv_ChildWindowHandle.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ChildWindowHandle = hv_WindowHandles.TupleSelect(
                            1);
                    }
                    //Check if window handle is valid.
                    try
                    {
                        HOperatorSet.FlushBuffer(hv_ChildWindowHandle);
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException2)
                    {
                        HDevExpDefaultException2.ToHTuple(out hv_Exception);
                        //Since there is something wrong with the current window, create a new one.
                        hv_OpenNewWindow.Dispose();
                        hv_OpenNewWindow = 1;
                    }
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    hv_OpenNewWindow.Dispose();
                    hv_OpenNewWindow = 1;
                }
                //
                //Get next child window.
                if ((int)(hv_OpenNewWindow.TupleNot()) != 0)
                {
                    //
                    //If possible, reuse existing window handles.
                    HDevWindowStack.SetActive(hv_ChildWindowHandle);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                    }
                    set_display_font(hv_ChildWindowHandle, hv_FontSize, hv_Font, "true", "false");
                    //
                    hv_MetaInfo.Dispose();
                    HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
                    //
                    //Get previous window coordinates.
                    hv_WindowRow.Dispose(); hv_WindowColumn.Dispose(); hv_WindowWidth.Dispose(); hv_WindowHeight.Dispose();
                    HOperatorSet.GetWindowExtents(hv_ParentWindowHandle, out hv_WindowRow, out hv_WindowColumn,
                        out hv_WindowWidth, out hv_WindowHeight);
                    hv_WindowImageRatio.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_WindowImageRatio = hv_WindowHeight / (hv_HeightImage * 1.0);
                    }
                    //
                    try
                    {
                        //
                        //Get WindowImageRatio from parent window.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_WindowImageRatio.Dispose();
                            HOperatorSet.GetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_window_image_ratio_height",
                                out hv_WindowImageRatio);
                        }
                        //
                        //Get previous window coordinates.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_PrevWindowCoordinatesOut.Dispose();
                            HOperatorSet.GetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_child_window_coordinates",
                                out hv_PrevWindowCoordinatesOut);
                        }
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException1)
                    {
                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        //
                        //Set WindowImageRatio from parent window.
                        hv_WindowRow.Dispose(); hv_WindowColumn.Dispose(); hv_WindowWidth.Dispose(); hv_WindowHeight.Dispose();
                        HOperatorSet.GetWindowExtents(hv_ParentWindowHandle, out hv_WindowRow,
                            out hv_WindowColumn, out hv_WindowWidth, out hv_WindowHeight);
                        hv_WindowImageRatio.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_WindowImageRatio = hv_WindowHeight / (hv_HeightImage * 1.0);
                        }
                        //
                        //Set previous window coordinates.
                        if (hv_PrevWindowCoordinatesOut == null)
                            hv_PrevWindowCoordinatesOut = new HTuple();
                        hv_PrevWindowCoordinatesOut[0] = hv_WindowRow;
                        if (hv_PrevWindowCoordinatesOut == null)
                            hv_PrevWindowCoordinatesOut = new HTuple();
                        hv_PrevWindowCoordinatesOut[1] = hv_WindowColumn;
                        if (hv_PrevWindowCoordinatesOut == null)
                            hv_PrevWindowCoordinatesOut = new HTuple();
                        hv_PrevWindowCoordinatesOut[2] = hv_WindowWidth;
                        if (hv_PrevWindowCoordinatesOut == null)
                            hv_PrevWindowCoordinatesOut = new HTuple();
                        hv_PrevWindowCoordinatesOut[3] = hv_WindowHeight;
                    }
                }
                else
                {
                    //
                    //Open a new child window.
                    hv_ChildWindowHandle.Dispose(); hv_PrevWindowCoordinatesOut.Dispose();
                    open_child_window(hv_ParentWindowHandle, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                        hv_WindowHandleDict, hv_WindowHandleKey, out hv_ChildWindowHandle, out hv_PrevWindowCoordinatesOut);
                    HOperatorSet.SetWindowParam(hv_ChildWindowHandle, "flush", "false");
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, hv_ParentWindowHandle.TupleConcat(
                            hv_ChildWindowHandle));
                    }
                }
                //

                hv_OpenNewWindow.Dispose();
                hv_WindowHandles.Dispose();
                hv_ParentWindowHandle.Dispose();
                hv_ChildWindowHandle.Dispose();
                hv_Exception.Dispose();
                hv_MetaInfo.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowColumn.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_OpenNewWindow.Dispose();
                hv_WindowHandles.Dispose();
                hv_ParentWindowHandle.Dispose();
                hv_ChildWindowHandle.Dispose();
                hv_Exception.Dispose();
                hv_MetaInfo.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowColumn.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Classification
        // Short Description: Get the ground truth classification label id. 
        public void get_classification_ground_truth(HTuple hv_SampleKeys, HTuple hv_DLSample,
            out HTuple hv_ClassificationLabelIDGroundTruth)
        {


            // Initialize local and output iconic variables 
            hv_ClassificationLabelIDGroundTruth = new HTuple();
            //
            //This procedure returns the classification ground truth label ID.
            //
            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("image_label_id"))).TupleNotEqual(
                -1))) != 0)
            {
                hv_ClassificationLabelIDGroundTruth.Dispose();
                HOperatorSet.GetDictTuple(hv_DLSample, "image_label_id", out hv_ClassificationLabelIDGroundTruth);
            }
            else
            {
                throw new HalconException("Ground truth class label cannot be found in DLSample.");
            }
            //


            return;
        }

        // Chapter: Deep Learning / Classification
        // Short Description: Get the predicted classification class ID. 
        public void get_classification_result(HTuple hv_ResultKeys, HTuple hv_DLResult,
            out HTuple hv_ClassificationClassID)
        {



            // Local iconic variables 
            // Initialize local and output iconic variables 
            hv_ClassificationClassID = new HTuple();
            //
            //This procedure returns the predicted classification class ID.
            //
            if ((int)(new HTuple(((hv_ResultKeys.TupleFind("classification_class_ids"))).TupleNotEqual(
                -1))) != 0)
            {
                hv_ClassificationClassID.Dispose();
                HOperatorSet.GetDictTuple(hv_DLResult, "classification_class_ids", out hv_ClassificationClassID);
                if ((int)(new HTuple((new HTuple(hv_ClassificationClassID.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ClassificationClassID = hv_ClassificationClassID.TupleSelect(
                                0);
                            hv_ClassificationClassID.Dispose();
                            hv_ClassificationClassID = ExpTmpLocalVar_ClassificationClassID;
                        }
                    }
                }
            }
            else
            {
                throw new HalconException("Key entry 'classification_class_ids' could not be found in DLResult.");
            }
            //


            return;
        }

        // Chapter: Deep Learning / Semantic Segmentation
        // Short Description: Get the confidences of the segmentation result. 
        public void get_confidence_image(out HObject ho_ImageConfidence, HTuple hv_ResultKeys,
            HTuple hv_DLResult)
        {


            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ImageConfidence);
            //
            //This procedure returns confidences of the segmentation result.
            //
            if ((int)(new HTuple(((hv_ResultKeys.TupleFind("segmentation_confidence"))).TupleNotEqual(
                -1))) != 0)
            {
                ho_ImageConfidence.Dispose();
                HOperatorSet.GetDictObject(out ho_ImageConfidence, hv_DLResult, "segmentation_confidence");
            }
            else if ((int)(new HTuple(((hv_ResultKeys.TupleFind("segmentation_confidences"))).TupleNotEqual(
                -1))) != 0)
            {
                ho_ImageConfidence.Dispose();
                HOperatorSet.GetDictObject(out ho_ImageConfidence, hv_DLResult, "segmentation_confidences");
            }
            else
            {
                throw new HalconException("Confidence image could not be found in DLSample.");
            }


            return;
        }

        // Chapter: Deep Learning / Model
        // Short Description: Generate NumColors distinct colors 
        public void get_distinct_colors(HTuple hv_NumColors, HTuple hv_Random, HTuple hv_StartColor,
            HTuple hv_EndColor, out HTuple hv_Colors)
        {



            // Local iconic variables 

            HObject ho_HLSImageH, ho_HLSImageL, ho_HLSImageS;
            HObject ho_ImageR, ho_ImageG, ho_ImageB;

            // Local control variables 

            HTuple hv_IsString = new HTuple(), hv_Hue = new HTuple();
            HTuple hv_Lightness = new HTuple(), hv_Saturation = new HTuple();
            HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
            HTuple hv_Red = new HTuple(), hv_Green = new HTuple();
            HTuple hv_Blue = new HTuple();
            HTuple hv_EndColor_COPY_INP_TMP = new HTuple(hv_EndColor);
            HTuple hv_Random_COPY_INP_TMP = new HTuple(hv_Random);

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_HLSImageH);
            HOperatorSet.GenEmptyObj(out ho_HLSImageL);
            HOperatorSet.GenEmptyObj(out ho_HLSImageS);
            HOperatorSet.GenEmptyObj(out ho_ImageR);
            HOperatorSet.GenEmptyObj(out ho_ImageG);
            HOperatorSet.GenEmptyObj(out ho_ImageB);
            hv_Colors = new HTuple();
            try
            {
                //
                //We get distinct color-values first in HLS color-space.
                //Assumes hue [0, EndColor), lightness [0, 1), saturation [0, 1).
                //
                //Parameter checks.
                //NumColors.
                if ((int)(new HTuple(hv_NumColors.TupleLess(1))) != 0)
                {
                    throw new HalconException("NumColors should be at least 1");
                }
                if ((int)(((hv_NumColors.TupleIsInt())).TupleNot()) != 0)
                {
                    throw new HalconException("NumColors should be of type int");
                }
                if ((int)(new HTuple((new HTuple(hv_NumColors.TupleLength())).TupleNotEqual(
                    1))) != 0)
                {
                    throw new HalconException("NumColors should have length 1");
                }
                //Random.
                if ((int)((new HTuple(hv_Random_COPY_INP_TMP.TupleNotEqual(0))).TupleAnd(new HTuple(hv_Random_COPY_INP_TMP.TupleNotEqual(
                    1)))) != 0)
                {
                    hv_IsString.Dispose();
                    HOperatorSet.TupleIsString(hv_Random_COPY_INP_TMP, out hv_IsString);
                    if ((int)(hv_IsString) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Random = (new HTuple(hv_Random_COPY_INP_TMP.TupleEqual(
                                    "true"))).TupleOr("false");
                                hv_Random_COPY_INP_TMP.Dispose();
                                hv_Random_COPY_INP_TMP = ExpTmpLocalVar_Random;
                            }
                        }
                    }
                    else
                    {
                        throw new HalconException("Random should be either true or false");
                    }
                }
                //StartColor.
                if ((int)(new HTuple((new HTuple(hv_StartColor.TupleLength())).TupleNotEqual(
                    1))) != 0)
                {
                    throw new HalconException("StartColor should have length 1");
                }
                if ((int)((new HTuple(hv_StartColor.TupleLess(0))).TupleOr(new HTuple(hv_StartColor.TupleGreater(
                    255)))) != 0)
                {
                    throw new HalconException(new HTuple("StartColor should be in the range [0, 255]"));
                }
                if ((int)(((hv_StartColor.TupleIsInt())).TupleNot()) != 0)
                {
                    throw new HalconException("StartColor should be of type int");
                }
                //EndColor.
                if ((int)(new HTuple((new HTuple(hv_EndColor_COPY_INP_TMP.TupleLength())).TupleNotEqual(
                    1))) != 0)
                {
                    throw new HalconException("EndColor should have length 1");
                }
                if ((int)((new HTuple(hv_EndColor_COPY_INP_TMP.TupleLess(0))).TupleOr(new HTuple(hv_EndColor_COPY_INP_TMP.TupleGreater(
                    255)))) != 0)
                {
                    throw new HalconException(new HTuple("EndColor should be in the range [0, 255]"));
                }
                if ((int)(((hv_EndColor_COPY_INP_TMP.TupleIsInt())).TupleNot()) != 0)
                {
                    throw new HalconException("EndColor should be of type int");
                }
                //
                //Color generation.
                if ((int)(new HTuple(hv_StartColor.TupleGreater(hv_EndColor_COPY_INP_TMP))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_EndColor = hv_EndColor_COPY_INP_TMP + 255;
                            hv_EndColor_COPY_INP_TMP.Dispose();
                            hv_EndColor_COPY_INP_TMP = ExpTmpLocalVar_EndColor;
                        }
                    }
                }
                if ((int)(new HTuple(hv_NumColors.TupleNotEqual(1))) != 0)
                {
                    hv_Hue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Hue = (hv_StartColor + (((((hv_EndColor_COPY_INP_TMP - hv_StartColor) * ((HTuple.TupleGenSequence(
                            0, hv_NumColors - 1, 1)).TupleReal())) / (((hv_NumColors - 1)).TupleReal()))).TupleInt()
                            )) % 255;
                    }
                }
                else
                {
                    hv_Hue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Hue = ((hv_StartColor.TupleConcat(
                            hv_EndColor_COPY_INP_TMP))).TupleMean();
                    }
                }
                if ((int)(hv_Random_COPY_INP_TMP) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Hue = hv_Hue.TupleSelect(
                                (HTuple.TupleRand(hv_NumColors)).TupleSortIndex());
                            hv_Hue.Dispose();
                            hv_Hue = ExpTmpLocalVar_Hue;
                        }
                    }
                    hv_Lightness.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Lightness = ((((5.0 + HTuple.TupleRand(
                            hv_NumColors)) * 255.0) / 10.0)).TupleInt();
                    }
                    hv_Saturation.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Saturation = ((((9.0 + HTuple.TupleRand(
                            hv_NumColors)) * 255.0) / 10.0)).TupleInt();
                    }
                }
                else
                {
                    hv_Lightness.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Lightness = ((HTuple.TupleGenConst(
                            hv_NumColors, 0.55) * 255.0)).TupleInt();
                    }
                    hv_Saturation.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Saturation = ((HTuple.TupleGenConst(
                            hv_NumColors, 0.95) * 255.0)).TupleInt();
                    }
                }
                //
                //Write colors to a 3-channel image in order to transform easier.
                ho_HLSImageH.Dispose();
                HOperatorSet.GenImageConst(out ho_HLSImageH, "byte", 1, hv_NumColors);
                ho_HLSImageL.Dispose();
                HOperatorSet.GenImageConst(out ho_HLSImageL, "byte", 1, hv_NumColors);
                ho_HLSImageS.Dispose();
                HOperatorSet.GenImageConst(out ho_HLSImageS, "byte", 1, hv_NumColors);
                hv_Rows.Dispose(); hv_Columns.Dispose();
                HOperatorSet.GetRegionPoints(ho_HLSImageH, out hv_Rows, out hv_Columns);
                HOperatorSet.SetGrayval(ho_HLSImageH, hv_Rows, hv_Columns, hv_Hue);
                HOperatorSet.SetGrayval(ho_HLSImageL, hv_Rows, hv_Columns, hv_Lightness);
                HOperatorSet.SetGrayval(ho_HLSImageS, hv_Rows, hv_Columns, hv_Saturation);
                //
                //Convert from HLS to RGB.
                ho_ImageR.Dispose(); ho_ImageG.Dispose(); ho_ImageB.Dispose();
                HOperatorSet.TransToRgb(ho_HLSImageH, ho_HLSImageL, ho_HLSImageS, out ho_ImageR,
                    out ho_ImageG, out ho_ImageB, "hls");
                //
                //Get RGB-values and transform to Hex.
                hv_Red.Dispose();
                HOperatorSet.GetGrayval(ho_ImageR, hv_Rows, hv_Columns, out hv_Red);
                hv_Green.Dispose();
                HOperatorSet.GetGrayval(ho_ImageG, hv_Rows, hv_Columns, out hv_Green);
                hv_Blue.Dispose();
                HOperatorSet.GetGrayval(ho_ImageB, hv_Rows, hv_Columns, out hv_Blue);
                hv_Colors.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Colors = (("#" + (hv_Red.TupleString(
                        "02x"))) + (hv_Green.TupleString("02x"))) + (hv_Blue.TupleString("02x"));
                }
                ho_HLSImageH.Dispose();
                ho_HLSImageL.Dispose();
                ho_HLSImageS.Dispose();
                ho_ImageR.Dispose();
                ho_ImageG.Dispose();
                ho_ImageB.Dispose();

                hv_EndColor_COPY_INP_TMP.Dispose();
                hv_Random_COPY_INP_TMP.Dispose();
                hv_IsString.Dispose();
                hv_Hue.Dispose();
                hv_Lightness.Dispose();
                hv_Saturation.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();

                return;
                //
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_HLSImageH.Dispose();
                ho_HLSImageL.Dispose();
                ho_HLSImageS.Dispose();
                ho_ImageR.Dispose();
                ho_ImageG.Dispose();
                ho_ImageB.Dispose();

                hv_EndColor_COPY_INP_TMP.Dispose();
                hv_Random_COPY_INP_TMP.Dispose();
                hv_IsString.Dispose();
                hv_Hue.Dispose();
                hv_Lightness.Dispose();
                hv_Saturation.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Generate NumColors distinct colors 
        public void get_distinct_colors_dev_display_pie_chart(HTuple hv_NumColors, HTuple hv_Random,
            HTuple hv_StartColor, HTuple hv_EndColor, out HTuple hv_Colors)
        {



            // Local iconic variables 

            HObject ho_HLSImageH, ho_HLSImageL, ho_HLSImageS;
            HObject ho_ImageR, ho_ImageG, ho_ImageB;

            // Local control variables 

            HTuple hv_IsString = new HTuple(), hv_Hue = new HTuple();
            HTuple hv_Lightness = new HTuple(), hv_Saturation = new HTuple();
            HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
            HTuple hv_Red = new HTuple(), hv_Green = new HTuple();
            HTuple hv_Blue = new HTuple();
            HTuple hv_EndColor_COPY_INP_TMP = new HTuple(hv_EndColor);
            HTuple hv_Random_COPY_INP_TMP = new HTuple(hv_Random);

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_HLSImageH);
            HOperatorSet.GenEmptyObj(out ho_HLSImageL);
            HOperatorSet.GenEmptyObj(out ho_HLSImageS);
            HOperatorSet.GenEmptyObj(out ho_ImageR);
            HOperatorSet.GenEmptyObj(out ho_ImageG);
            HOperatorSet.GenEmptyObj(out ho_ImageB);
            hv_Colors = new HTuple();
            try
            {
                //
                //We get distinct color-values first in HLS color-space.
                //Assumes hue [0, EndColor), lightness [0, 1), saturation [0, 1).
                //
                //Parameter checks.
                //NumColors.
                if ((int)(new HTuple(hv_NumColors.TupleLess(1))) != 0)
                {
                    throw new HalconException("NumColors should be at least 1");
                }
                if ((int)(((hv_NumColors.TupleIsInt())).TupleNot()) != 0)
                {
                    throw new HalconException("NumColors should be of type int");
                }
                if ((int)(new HTuple((new HTuple(hv_NumColors.TupleLength())).TupleNotEqual(
                    1))) != 0)
                {
                    throw new HalconException("NumColors should have length 1");
                }
                //Random.
                if ((int)((new HTuple(hv_Random_COPY_INP_TMP.TupleNotEqual(0))).TupleAnd(new HTuple(hv_Random_COPY_INP_TMP.TupleNotEqual(
                    1)))) != 0)
                {
                    hv_IsString.Dispose();
                    HOperatorSet.TupleIsString(hv_Random_COPY_INP_TMP, out hv_IsString);
                    if ((int)(hv_IsString) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Random = (new HTuple(hv_Random_COPY_INP_TMP.TupleEqual(
                                    "true"))).TupleOr("false");
                                hv_Random_COPY_INP_TMP.Dispose();
                                hv_Random_COPY_INP_TMP = ExpTmpLocalVar_Random;
                            }
                        }
                    }
                    else
                    {
                        throw new HalconException("Random should be either true or false");
                    }
                }
                //StartColor.
                if ((int)(new HTuple((new HTuple(hv_StartColor.TupleLength())).TupleNotEqual(
                    1))) != 0)
                {
                    throw new HalconException("StartColor should have length 1");
                }
                if ((int)((new HTuple(hv_StartColor.TupleLess(0))).TupleOr(new HTuple(hv_StartColor.TupleGreater(
                    255)))) != 0)
                {
                    throw new HalconException(new HTuple("StartColor should be in the range [0, 255]"));
                }
                if ((int)(((hv_StartColor.TupleIsInt())).TupleNot()) != 0)
                {
                    throw new HalconException("StartColor should be of type int");
                }
                //EndColor.
                if ((int)(new HTuple((new HTuple(hv_EndColor_COPY_INP_TMP.TupleLength())).TupleNotEqual(
                    1))) != 0)
                {
                    throw new HalconException("EndColor should have length 1");
                }
                if ((int)((new HTuple(hv_EndColor_COPY_INP_TMP.TupleLess(0))).TupleOr(new HTuple(hv_EndColor_COPY_INP_TMP.TupleGreater(
                    255)))) != 0)
                {
                    throw new HalconException(new HTuple("EndColor should be in the range [0, 255]"));
                }
                if ((int)(((hv_EndColor_COPY_INP_TMP.TupleIsInt())).TupleNot()) != 0)
                {
                    throw new HalconException("EndColor should be of type int");
                }
                //
                //Color generation.
                if ((int)(new HTuple(hv_StartColor.TupleGreater(hv_EndColor_COPY_INP_TMP))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_EndColor = hv_EndColor_COPY_INP_TMP + 255;
                            hv_EndColor_COPY_INP_TMP.Dispose();
                            hv_EndColor_COPY_INP_TMP = ExpTmpLocalVar_EndColor;
                        }
                    }
                }
                if ((int)(new HTuple(hv_NumColors.TupleNotEqual(1))) != 0)
                {
                    hv_Hue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Hue = (hv_StartColor + (((((hv_EndColor_COPY_INP_TMP - hv_StartColor) * ((HTuple.TupleGenSequence(
                            0, hv_NumColors - 1, 1)).TupleReal())) / (((hv_NumColors - 1)).TupleReal()))).TupleInt()
                            )) % 255;
                    }
                }
                else
                {
                    hv_Hue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Hue = ((hv_StartColor.TupleConcat(
                            hv_EndColor_COPY_INP_TMP))).TupleMean();
                    }
                }
                if ((int)(hv_Random_COPY_INP_TMP) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Hue = hv_Hue.TupleSelect(
                                (HTuple.TupleRand(hv_NumColors)).TupleSortIndex());
                            hv_Hue.Dispose();
                            hv_Hue = ExpTmpLocalVar_Hue;
                        }
                    }
                    hv_Lightness.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Lightness = ((((5.0 + HTuple.TupleRand(
                            hv_NumColors)) * 255.0) / 10.0)).TupleInt();
                    }
                    hv_Saturation.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Saturation = ((((9.0 + HTuple.TupleRand(
                            hv_NumColors)) * 255.0) / 10.0)).TupleInt();
                    }
                }
                else
                {
                    hv_Lightness.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Lightness = ((HTuple.TupleGenConst(
                            hv_NumColors, 0.55) * 255.0)).TupleInt();
                    }
                    hv_Saturation.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Saturation = ((HTuple.TupleGenConst(
                            hv_NumColors, 0.95) * 255.0)).TupleInt();
                    }
                }
                //
                //Write colors to a 3-channel image in order to transform easier.
                ho_HLSImageH.Dispose();
                HOperatorSet.GenImageConst(out ho_HLSImageH, "byte", 1, hv_NumColors);
                ho_HLSImageL.Dispose();
                HOperatorSet.GenImageConst(out ho_HLSImageL, "byte", 1, hv_NumColors);
                ho_HLSImageS.Dispose();
                HOperatorSet.GenImageConst(out ho_HLSImageS, "byte", 1, hv_NumColors);
                hv_Rows.Dispose(); hv_Columns.Dispose();
                HOperatorSet.GetRegionPoints(ho_HLSImageH, out hv_Rows, out hv_Columns);
                HOperatorSet.SetGrayval(ho_HLSImageH, hv_Rows, hv_Columns, hv_Hue);
                HOperatorSet.SetGrayval(ho_HLSImageL, hv_Rows, hv_Columns, hv_Lightness);
                HOperatorSet.SetGrayval(ho_HLSImageS, hv_Rows, hv_Columns, hv_Saturation);
                //
                //Convert from HLS to RGB.
                ho_ImageR.Dispose(); ho_ImageG.Dispose(); ho_ImageB.Dispose();
                HOperatorSet.TransToRgb(ho_HLSImageH, ho_HLSImageL, ho_HLSImageS, out ho_ImageR,
                    out ho_ImageG, out ho_ImageB, "hls");
                //
                //Get RGB-values and transform to Hex.
                hv_Red.Dispose();
                HOperatorSet.GetGrayval(ho_ImageR, hv_Rows, hv_Columns, out hv_Red);
                hv_Green.Dispose();
                HOperatorSet.GetGrayval(ho_ImageG, hv_Rows, hv_Columns, out hv_Green);
                hv_Blue.Dispose();
                HOperatorSet.GetGrayval(ho_ImageB, hv_Rows, hv_Columns, out hv_Blue);
                hv_Colors.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Colors = (("#" + (hv_Red.TupleString(
                        "02x"))) + (hv_Green.TupleString("02x"))) + (hv_Blue.TupleString("02x"));
                }
                ho_HLSImageH.Dispose();
                ho_HLSImageL.Dispose();
                ho_HLSImageS.Dispose();
                ho_ImageR.Dispose();
                ho_ImageG.Dispose();
                ho_ImageB.Dispose();

                hv_EndColor_COPY_INP_TMP.Dispose();
                hv_Random_COPY_INP_TMP.Dispose();
                hv_IsString.Dispose();
                hv_Hue.Dispose();
                hv_Lightness.Dispose();
                hv_Saturation.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();

                return;
                //
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_HLSImageH.Dispose();
                ho_HLSImageL.Dispose();
                ho_HLSImageS.Dispose();
                ho_ImageR.Dispose();
                ho_ImageG.Dispose();
                ho_ImageB.Dispose();

                hv_EndColor_COPY_INP_TMP.Dispose();
                hv_Random_COPY_INP_TMP.Dispose();
                hv_IsString.Dispose();
                hv_Hue.Dispose();
                hv_Lightness.Dispose();
                hv_Saturation.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Generates certain colors for different ClassNames 
        public void get_dl_class_colors(HTuple hv_ClassNames, out HTuple hv_Colors)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_NumColors = new HTuple(), hv_ColorsRainbow = new HTuple();
            HTuple hv_ClassNamesGood = new HTuple(), hv_IndexFind = new HTuple();
            HTuple hv_GoodIdx = new HTuple(), hv_CurrentColor = new HTuple();
            HTuple hv_GreenIdx = new HTuple();
            // Initialize local and output iconic variables 
            hv_Colors = new HTuple();
            try
            {
                //
                //This procedure returns for each class a certain color.
                //
                //Define distinct colors for the classes.
                hv_NumColors.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumColors = new HTuple(hv_ClassNames.TupleLength()
                        );
                }
                //Get distinct colors without randomness makes neighboring colors look very similar.
                //We use a workaround to get deterministic colors where subsequent colors are distinguishable.
                hv_ColorsRainbow.Dispose();
                get_distinct_colors(hv_NumColors, 0, 0, 200, out hv_ColorsRainbow);
                {
                    HTuple ExpTmpOutVar_0;
                    HOperatorSet.TupleInverse(hv_ColorsRainbow, out ExpTmpOutVar_0);
                    hv_ColorsRainbow.Dispose();
                    hv_ColorsRainbow = ExpTmpOutVar_0;
                }
                hv_Colors.Dispose();
                make_neighboring_colors_distinguishable(hv_ColorsRainbow, out hv_Colors);
                //If a class 'OK','ok', 'good' or 'GOOD' is present set this class to green.
                //Only the first occurrence found is set to a green shade.
                hv_ClassNamesGood.Dispose();
                hv_ClassNamesGood = new HTuple();
                hv_ClassNamesGood[0] = "good";
                hv_ClassNamesGood[1] = "GOOD";
                hv_ClassNamesGood[2] = "ok";
                hv_ClassNamesGood[3] = "OK";
                for (hv_IndexFind = 0; (int)hv_IndexFind <= (int)((new HTuple(hv_ClassNamesGood.TupleLength()
                    )) - 1); hv_IndexFind = (int)hv_IndexFind + 1)
                {
                    hv_GoodIdx.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_GoodIdx = hv_ClassNames.TupleFindFirst(
                            hv_ClassNamesGood.TupleSelect(hv_IndexFind));
                    }
                    if ((int)((new HTuple(hv_GoodIdx.TupleNotEqual(-1))).TupleAnd(new HTuple((new HTuple(hv_ClassNames.TupleLength()
                        )).TupleLessEqual(8)))) != 0)
                    {
                        //If number of classes is <= 8, swap color with a green color.
                        hv_CurrentColor.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentColor = hv_Colors.TupleSelect(
                                hv_GoodIdx);
                        }
                        hv_GreenIdx.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_GreenIdx = (new HTuple((new HTuple(hv_ClassNames.TupleLength()
                                )) / 2.0)).TupleFloor();
                        }
                        //Set to pure green.
                        if (hv_Colors == null)
                            hv_Colors = new HTuple();
                        hv_Colors[hv_GoodIdx] = "#00ff00";
                        //Write original color to a green entry.
                        if (hv_Colors == null)
                            hv_Colors = new HTuple();
                        hv_Colors[hv_GreenIdx] = hv_CurrentColor;
                        break;
                    }
                    else if ((int)((new HTuple(hv_GoodIdx.TupleNotEqual(-1))).TupleAnd(
                        new HTuple((new HTuple(hv_ClassNames.TupleLength())).TupleGreater(8)))) != 0)
                    {
                        //If number of classes is larger than 8, set the respective color to green.
                        if (hv_Colors == null)
                            hv_Colors = new HTuple();
                        hv_Colors[hv_GoodIdx] = "#00ff00";
                        break;
                    }
                }

                hv_NumColors.Dispose();
                hv_ColorsRainbow.Dispose();
                hv_ClassNamesGood.Dispose();
                hv_IndexFind.Dispose();
                hv_GoodIdx.Dispose();
                hv_CurrentColor.Dispose();
                hv_GreenIdx.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_NumColors.Dispose();
                hv_ColorsRainbow.Dispose();
                hv_ClassNamesGood.Dispose();
                hv_IndexFind.Dispose();
                hv_GoodIdx.Dispose();
                hv_CurrentColor.Dispose();
                hv_GreenIdx.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Get the image of a sample. 
        public void get_image(out HObject ho_Image, HTuple hv_SampleKeys, HTuple hv_DLSample)
        {


            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Image);
            //
            //This procedure returns the image of a sample.
            //
            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("image"))).TupleNotEqual(-1))) != 0)
            {
                ho_Image.Dispose();
                HOperatorSet.GetDictObject(out ho_Image, hv_DLSample, "image");
            }
            else
            {
                throw new HalconException("Image could not be found in DLSample.");
            }


            return;
        }

        // Chapter: Graphics / Window
        // Short Description: Get the next window that can be used for visualization. 
        public void get_next_window(HTuple hv_Font, HTuple hv_FontSize, HTuple hv_ShowBottomDesc,
            HTuple hv_WidthImage, HTuple hv_HeightImage, HTuple hv_MapColorBarWidth, HTuple hv_ScaleWindows,
            HTuple hv_ThresholdWidth, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict,
            HTuple hv_WindowHandleKey, out HTuple hv_CurrentWindowHandle, out HTuple hv_WindowImageRatioHeight,
            out HTuple hv_PrevWindowCoordinatesOut)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_OpenNewWindow = new HTuple(), hv_WindowHandles = new HTuple();
            HTuple hv_Value = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
            HTuple hv__ = new HTuple(), hv_MarginBottom = new HTuple();
            HTuple hv_WindowImageRatioWidth = new HTuple(), hv_SetPartRow2 = new HTuple();
            HTuple hv_SetPartColumn2 = new HTuple(), hv_MetaInfo = new HTuple();
            // Initialize local and output iconic variables 
            hv_CurrentWindowHandle = new HTuple();
            hv_WindowImageRatioHeight = new HTuple();
            hv_PrevWindowCoordinatesOut = new HTuple();
            try
            {
                //
                //This procedure returns the next window that
                //is used for visualization. If ReuseWindows is true
                //and WindowHandleList is suitable, the window handles
                //that are passed over are used. Else, this procedure
                //opens a new window, either next to the last ones, or
                //in a new row.
                //
                //First, check if the requested window is already available.
                hv_OpenNewWindow.Dispose();
                hv_OpenNewWindow = 0;
                try
                {
                    hv_WindowHandles.Dispose();
                    HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, out hv_WindowHandles);
                    hv_CurrentWindowHandle.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentWindowHandle = hv_WindowHandles.TupleSelect(
                            0);
                    }
                    //Check if window handle is valid.
                    try
                    {
                        hv_Value.Dispose();
                        HOperatorSet.GetWindowParam(hv_CurrentWindowHandle, "flush", out hv_Value);
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException2)
                    {
                        HDevExpDefaultException2.ToHTuple(out hv_Exception);
                        //If there is something wrong with the current window, create a new one.
                        hv_OpenNewWindow.Dispose();
                        hv_OpenNewWindow = 1;
                        HOperatorSet.RemoveDictKey(hv_WindowHandleDict, hv_WindowHandleKey);
                    }
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    hv_OpenNewWindow.Dispose();
                    hv_OpenNewWindow = 1;
                }
                //
                //Get next window.
                if ((int)(hv_OpenNewWindow.TupleNot()) != 0)
                {
                    //
                    //If possible, reuse existing window handles.
                    HDevWindowStack.SetActive(hv_CurrentWindowHandle);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                    }
                    set_display_font(hv_CurrentWindowHandle, hv_FontSize, hv_Font, "true", "false");
                    //
                    //Calculate MarginBottom.
                    if ((int)(hv_ShowBottomDesc) != 0)
                    {
                        hv_Ascent.Dispose(); hv_Descent.Dispose(); hv__.Dispose(); hv__.Dispose();
                        HOperatorSet.GetStringExtents(hv_CurrentWindowHandle, "test_string", out hv_Ascent,
                            out hv_Descent, out hv__, out hv__);
                        hv_MarginBottom.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MarginBottom = ((2 * 12) + hv_Ascent) + hv_Descent;
                        }
                    }
                    else
                    {
                        hv_MarginBottom.Dispose();
                        hv_MarginBottom = 0;
                    }
                    //
                    //Get and set meta information for current window.
                    hv_WindowImageRatioHeight.Dispose(); hv_WindowImageRatioWidth.Dispose(); hv_SetPartRow2.Dispose(); hv_SetPartColumn2.Dispose(); hv_PrevWindowCoordinatesOut.Dispose();
                    update_window_meta_information(hv_CurrentWindowHandle, hv_WidthImage, hv_HeightImage,
                        0, 0, hv_MapColorBarWidth, hv_MarginBottom, out hv_WindowImageRatioHeight,
                        out hv_WindowImageRatioWidth, out hv_SetPartRow2, out hv_SetPartColumn2,
                        out hv_PrevWindowCoordinatesOut);
                    //
                    //Update meta information.
                    hv_MetaInfo.Dispose();
                    HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_window_image_ratio_height",
                            hv_WindowImageRatioHeight);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_window_image_ratio_width",
                            hv_WindowImageRatioWidth);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_set_part_row2",
                            hv_SetPartRow2);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_set_part_column2",
                            hv_SetPartColumn2);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_margin_bottom",
                            hv_MarginBottom);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_map_color_bar_with",
                            hv_MapColorBarWidth);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_window_coordinates",
                            hv_PrevWindowCoordinatesOut);
                    }
                }
                else
                {
                    //
                    //Open a new window.
                    hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatioHeight.Dispose(); hv_PrevWindowCoordinatesOut.Dispose();
                    open_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                        hv_HeightImage, hv_MapColorBarWidth, hv_ScaleWindows, hv_ThresholdWidth,
                        hv_PrevWindowCoordinates, hv_WindowHandleDict, hv_WindowHandleKey, out hv_CurrentWindowHandle,
                        out hv_WindowImageRatioHeight, out hv_PrevWindowCoordinatesOut);
                    HOperatorSet.SetWindowParam(hv_CurrentWindowHandle, "flush", "false");
                }
                //

                hv_OpenNewWindow.Dispose();
                hv_WindowHandles.Dispose();
                hv_Value.Dispose();
                hv_Exception.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv__.Dispose();
                hv_MarginBottom.Dispose();
                hv_WindowImageRatioWidth.Dispose();
                hv_SetPartRow2.Dispose();
                hv_SetPartColumn2.Dispose();
                hv_MetaInfo.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_OpenNewWindow.Dispose();
                hv_WindowHandles.Dispose();
                hv_Value.Dispose();
                hv_Exception.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv__.Dispose();
                hv_MarginBottom.Dispose();
                hv_WindowImageRatioWidth.Dispose();
                hv_SetPartRow2.Dispose();
                hv_SetPartColumn2.Dispose();
                hv_MetaInfo.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Semantic Segmentation
        // Short Description: Get the ground truth segmentation image. 
        public void get_segmentation_image_ground_truth(out HObject ho_SegmentationImagGroundTruth,
            HTuple hv_SampleKeys, HTuple hv_DLSample)
        {


            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_SegmentationImagGroundTruth);
            //
            //This procedure returns the ground truth segmentation image.
            //
            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("segmentation_image"))).TupleNotEqual(
                -1))) != 0)
            {
                ho_SegmentationImagGroundTruth.Dispose();
                HOperatorSet.GetDictObject(out ho_SegmentationImagGroundTruth, hv_DLSample,
                    "segmentation_image");
            }
            else
            {
                throw new HalconException("Ground truth segmentation image could not be found in DLSample.");
            }


            return;
        }

        // Chapter: Deep Learning / Semantic Segmentation
        // Short Description: Get the predicted segmentation result image. 
        public void get_segmentation_image_result(out HObject ho_SegmentationImageResult,
            HTuple hv_ResultKeys, HTuple hv_DLResult)
        {


            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_SegmentationImageResult);
            //
            //This procedure returns the predicted segmentation result image.
            //
            if ((int)(new HTuple(((hv_ResultKeys.TupleFind("segmentation_image"))).TupleNotEqual(
                -1))) != 0)
            {
                ho_SegmentationImageResult.Dispose();
                HOperatorSet.GetDictObject(out ho_SegmentationImageResult, hv_DLResult, "segmentation_image");
            }
            else
            {
                throw new HalconException("Result segmentation data could not be found in DLSample.");
            }


            return;
        }

        // Chapter: Deep Learning / Semantic Segmentation
        // Short Description: Get the weight image of a sample. 
        public void get_weight_image(out HObject ho_ImageWeight, HTuple hv_SampleKeys,
            HTuple hv_DLSample)
        {


            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ImageWeight);
            //
            //This procedure returns the segmentation weight image of a sample.
            //
            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("weight_image"))).TupleNotEqual(
                -1))) != 0)
            {
                ho_ImageWeight.Dispose();
                HOperatorSet.GetDictObject(out ho_ImageWeight, hv_DLSample, "weight_image");
            }
            else
            {
                throw new HalconException("Weight image could not be found in DLSample.");
            }


            return;
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Initialize the dictionary RunningMeasures for the evaluation. 
        public void init_running_evaluation_measures(HTuple hv_EvalParams, out HTuple hv_RunningMeasures)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Valid = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_NumClasses = new HTuple(), hv_EvaluationType = new HTuple();
            HTuple hv_Measures = new HTuple(), hv_ClassIDs = new HTuple();
            HTuple hv_InstanceType = new HTuple(), hv_EvalOrientation = new HTuple();
            HTuple hv_AllocationBlockLength = new HTuple(), hv_IoUThreshs = new HTuple();
            HTuple hv_MaxNumDetections = new HTuple(), hv_AreaRanges = new HTuple();
            HTuple hv_AreaNames = new HTuple(), hv_MinAreas = new HTuple();
            HTuple hv_MaxAreas = new HTuple(), hv_DetailedEvaluation = new HTuple();
            HTuple hv_MaxNumIdx = new HTuple(), hv_MaxNum = new HTuple();
            HTuple hv_CurrentRunningMeasure = new HTuple(), hv_AreaIdx = new HTuple();
            HTuple hv_AreaRunningMeasure = new HTuple(), hv_I = new HTuple();
            HTuple hv_IoURunningMeasure = new HTuple(), hv_ClsIdx = new HTuple();
            HTuple hv_ClassRunningMeasures = new HTuple(), hv_Confidence = new HTuple();
            HTuple hv_IgnoreClassIDs = new HTuple(), hv_CalcConfMatrix = new HTuple();
            HTuple hv_MatrixSize = new HTuple(), hv_PixelConfusionMatrix = new HTuple();
            HTuple hv_MaxId = new HTuple(), hv_ClsIDToClsIdx = new HTuple();
            HTuple hv_TP = new HTuple(), hv_FP = new HTuple(), hv_FN = new HTuple();
            // Initialize local and output iconic variables 
            hv_RunningMeasures = new HTuple();
            try
            {
                //
                //This procedure initializes the dictionary RunningMeasures for evaluation.
                //It uses the evaluation parameters to initialize the running measures accordingly.
                //
                //The structure of RunningMeasures depends on the entry 'evaluate_instances' in the dictionary EvalParams.
                //
                //The dictionary RunningMeasures can be updated based on the per-batch/per-image evaluation results.
                //
                hv_RunningMeasures.Dispose();
                HOperatorSet.CreateDict(out hv_RunningMeasures);
                //Check that the necessary evaluation parameters exist.
                hv_Valid.Dispose(); hv_Exception.Dispose();
                validate_evaluation_param(hv_EvalParams, out hv_Valid, out hv_Exception);
                if ((int)(hv_Valid.TupleNot()) != 0)
                {
                    throw new HalconException(new HTuple("Invalid EvalParams, ") + hv_Exception);
                }
                //
                //Get general evaluation parameters.
                hv_NumClasses.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
                hv_EvaluationType.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "evaluation_type", out hv_EvaluationType);
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                hv_ClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                //
                if ((int)(new HTuple(hv_EvaluationType.TupleEqual("anomaly_detection"))) != 0)
                {
                    //RunningMeasures contains:
                    //- image_ids:          IDs of the images.
                    //- anomaly_label_ids:  Class IDs of ground truth labels.
                    //- anomaly_scores:     Predicted image level anomaly scores.
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_ids", new HTuple());
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "anomaly_label_ids", new HTuple());
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "anomaly_scores", new HTuple());
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("classification"))) != 0)
                {
                    //RunningMeasures contains:
                    //- image_ids:          IDs of the images.
                    //- image_label_ids:    Class IDs of ground truth labels.
                    //- top1_predictions:   Class IDs of the top predicted class.
                    //- topk_predictions:   Class IDs of top-K predicted classes.
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_ids", new HTuple());
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_label_ids", new HTuple());
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "top1_predictions", new HTuple());
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "topk_predictions", new HTuple());
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("detection"))) != 0)
                {
                    //RunningMeasures contains:
                    //For each maximal number of regions (MaxNumDetections):
                    // - For each area range (AreaRanges):
                    //   -- confidence:     Confidence (score) of each result.
                    //   -- num_gt:         Total number of ground truth instances per class.
                    //   -- num_pred:       Total number of predictions per class.
                    //   -- num_gt_ignore:  Number of ignored ground truth instances per class.
                    //   -- for each IoU-threshold:
                    //      --- For each class:
                    //          ---- is_tp:                  TP/FP assignment of result.
                    //          ---- ignore:                 Ignore/Not-Ignore assignment of result.
                    //          ---- abs_orientation_diff (for instance_type 'rectangle2' with measure SoAP):
                    //                                       Absolute orientation difference of the result.
                    //
                    //Check if the orientation difference is to be evaluated.
                    hv_InstanceType.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "instance_type", out hv_InstanceType);
                    hv_EvalOrientation.Dispose();
                    hv_EvalOrientation = 0;
                    if ((int)((new HTuple(hv_InstanceType.TupleEqual("rectangle2"))).TupleAnd(
                        (new HTuple(((hv_Measures.TupleFind("soap"))).TupleNotEqual(-1))).TupleOr(
                        new HTuple(((hv_Measures.TupleFind("all"))).TupleNotEqual(-1))))) != 0)
                    {
                        hv_EvalOrientation.Dispose();
                        hv_EvalOrientation = 1;
                    }
                    //
                    //Calculating the measures confidence, is_tp, ignore, and abs_orientation_diff,
                    //arrays are allocated with -1 in blocks of AllocationBlockLength
                    //(thus, if a block is filled, the next block is allocated).
                    //Otherwise the arrays have to be concatenated which is rather slow.
                    //The actual length of the array is garnered in num_pred.
                    hv_AllocationBlockLength.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "allocation_block_length", out hv_AllocationBlockLength);
                    hv_IoUThreshs.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "iou_threshold", out hv_IoUThreshs);
                    hv_MaxNumDetections.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "max_num_detections", out hv_MaxNumDetections);
                    hv_AreaRanges.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "area_ranges", out hv_AreaRanges);
                    //AreaRanges is a dictionary containing 'name', 'min_area', 'max_area'.
                    hv_AreaNames.Dispose();
                    HOperatorSet.GetDictTuple(hv_AreaRanges, "name", out hv_AreaNames);
                    hv_MinAreas.Dispose();
                    HOperatorSet.GetDictTuple(hv_AreaRanges, "min", out hv_MinAreas);
                    hv_MaxAreas.Dispose();
                    HOperatorSet.GetDictTuple(hv_AreaRanges, "max", out hv_MaxAreas);
                    //Check if a detailed evaluation will be performed.
                    hv_DetailedEvaluation.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "detailed_evaluation", out hv_DetailedEvaluation);
                    //Set a result dictionary for each maximal number of detections and IoU-threshold.
                    for (hv_MaxNumIdx = 0; (int)hv_MaxNumIdx <= (int)((new HTuple(hv_MaxNumDetections.TupleLength()
                        )) - 1); hv_MaxNumIdx = (int)hv_MaxNumIdx + 1)
                    {
                        hv_MaxNum.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MaxNum = hv_MaxNumDetections.TupleSelect(
                                hv_MaxNumIdx);
                        }
                        hv_CurrentRunningMeasure.Dispose();
                        HOperatorSet.CreateDict(out hv_CurrentRunningMeasure);
                        for (hv_AreaIdx = 0; (int)hv_AreaIdx <= (int)((new HTuple(hv_AreaNames.TupleLength()
                            )) - 1); hv_AreaIdx = (int)hv_AreaIdx + 1)
                        {
                            hv_AreaRunningMeasure.Dispose();
                            HOperatorSet.CreateDict(out hv_AreaRunningMeasure);
                            for (hv_I = 0; (int)hv_I <= (int)((new HTuple(hv_IoUThreshs.TupleLength()
                                )) - 1); hv_I = (int)hv_I + 1)
                            {
                                hv_IoURunningMeasure.Dispose();
                                HOperatorSet.CreateDict(out hv_IoURunningMeasure);
                                HTuple end_val84 = hv_NumClasses - 1;
                                HTuple step_val84 = 1;
                                for (hv_ClsIdx = 0; hv_ClsIdx.Continue(end_val84, step_val84); hv_ClsIdx = hv_ClsIdx.TupleAdd(step_val84))
                                {
                                    hv_ClassRunningMeasures.Dispose();
                                    HOperatorSet.CreateDict(out hv_ClassRunningMeasures);
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_tp", HTuple.TupleGenConst(
                                            hv_AllocationBlockLength, -1));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "ignore", HTuple.TupleGenConst(
                                            hv_AllocationBlockLength, -1));
                                    }
                                    if ((int)(hv_EvalOrientation) != 0)
                                    {
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "abs_orientation_diff",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                    }
                                    if ((int)(hv_DetailedEvaluation) != 0)
                                    {
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_fp_class",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_fp_background",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_fp_localization",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_fp_duplicate",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_fp_multiple",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                        if ((int)(hv_EvalOrientation) != 0)
                                        {
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "abs_orientation_diff_class",
                                                    HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                            }
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "abs_orientation_diff_localization",
                                                    HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                            }
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "abs_orientation_diff_duplicate",
                                                    HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                            }
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "abs_orientation_diff_multiple",
                                                    HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                            }
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_IoURunningMeasure, "image_ids_with_false_negatives",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_IoURunningMeasure, "image_ids_with_false_positives",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                        HOperatorSet.SetDictTuple(hv_IoURunningMeasure, "num_image_ids_with_false_negatives",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_IoURunningMeasure, "num_image_ids_with_false_positives",
                                            0);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_IoURunningMeasure, "class_" + (hv_ClassIDs.TupleSelect(
                                            hv_ClsIdx)), hv_ClassRunningMeasures);
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_AreaRunningMeasure, "iou_" + ((("" + (hv_IoUThreshs.TupleSelect(
                                        hv_I)))).TupleRegexpReplace("\\.", "")), hv_IoURunningMeasure);
                                }
                            }
                            hv_Confidence.Dispose();
                            HOperatorSet.CreateDict(out hv_Confidence);
                            HTuple end_val113 = hv_NumClasses - 1;
                            HTuple step_val113 = 1;
                            for (hv_ClsIdx = 0; hv_ClsIdx.Continue(end_val113, step_val113); hv_ClsIdx = hv_ClsIdx.TupleAdd(step_val113))
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_Confidence, "class_" + (hv_ClassIDs.TupleSelect(
                                        hv_ClsIdx)), HTuple.TupleGenConst(hv_AllocationBlockLength, -1.0));
                                }
                            }
                            HOperatorSet.SetDictTuple(hv_AreaRunningMeasure, "confidence", hv_Confidence);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_AreaRunningMeasure, "num_gt", HTuple.TupleGenConst(
                                    hv_NumClasses, 0));
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_AreaRunningMeasure, "num_pred", HTuple.TupleGenConst(
                                    hv_NumClasses, 0));
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_AreaRunningMeasure, "num_gt_ignore", HTuple.TupleGenConst(
                                    hv_NumClasses, 0));
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_CurrentRunningMeasure, "area_" + (hv_AreaNames.TupleSelect(
                                    hv_AreaIdx)), hv_AreaRunningMeasure);
                            }
                        }
                        if ((int)(new HTuple(hv_MaxNum.TupleEqual(-1))) != 0)
                        {
                            hv_MaxNum.Dispose();
                            hv_MaxNum = "all";
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_RunningMeasures, "max_num_detections_" + hv_MaxNum,
                                hv_CurrentRunningMeasure);
                        }
                    }
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("segmentation"))) != 0)
                {
                    //RunningMeasures contains:
                    //if confusion matrix in Measures (slower but more information).
                    // - confusion matrix per pixel.
                    //else:
                    // - TP/FP/FN (pixel numbers per class).
                    //
                    //Incorporate ignore class IDs.
                    hv_IgnoreClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "ignore_class_ids", out hv_IgnoreClassIDs);
                    //
                    //Check if we need to compute/update the confusion matrix.
                    hv_CalcConfMatrix.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CalcConfMatrix = (new HTuple(((hv_Measures.TupleFind(
                            "pixel_confusion_matrix"))).TupleGreater(-1))).TupleOr(new HTuple(((hv_Measures.TupleFind(
                            "all"))).TupleGreater(-1)));
                    }
                    if ((int)(hv_CalcConfMatrix) != 0)
                    {
                        //Define the size of the confusion matrix.
                        hv_MatrixSize.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MatrixSize = hv_NumClasses + (new HTuple((new HTuple(hv_IgnoreClassIDs.TupleLength()
                                )).TupleGreater(0)));
                        }
                        hv_PixelConfusionMatrix.Dispose();
                        HOperatorSet.CreateMatrix(hv_MatrixSize, hv_MatrixSize, 0, out hv_PixelConfusionMatrix);
                        HOperatorSet.SetDictTuple(hv_RunningMeasures, "pixel_confusion_matrix",
                            hv_PixelConfusionMatrix);
                        //
                        //If the class IDs are not running indices from 0 to NumClasses we
                        //define a mapping from class IDs to class indices.
                        if ((int)((new HTuple(hv_ClassIDs.TupleNotEqual(HTuple.TupleGenSequence(
                            0, (new HTuple(hv_ClassIDs.TupleLength())) - 1, 1)))).TupleOr(new HTuple((new HTuple(hv_IgnoreClassIDs.TupleLength()
                            )).TupleGreater(0)))) != 0)
                        {
                            //Get the max ID that can occur.
                            hv_MaxId.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_MaxId = (hv_ClassIDs.TupleMax()
                                    ) + (new HTuple((new HTuple(hv_IgnoreClassIDs.TupleLength())).TupleGreater(
                                    0)));
                            }
                            //Define the basic mapping.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClsIDToClsIdx.Dispose();
                                HOperatorSet.TupleGenConst(hv_MaxId + 1, -1, out hv_ClsIDToClsIdx);
                            }
                            if (hv_ClsIDToClsIdx == null)
                                hv_ClsIDToClsIdx = new HTuple();
                            hv_ClsIDToClsIdx[hv_ClassIDs] = HTuple.TupleGenSequence(0, (new HTuple(hv_ClassIDs.TupleLength()
                                )) - 1, 1);
                            //Map ignore IDs to the next higher one.
                            if (hv_ClsIDToClsIdx == null)
                                hv_ClsIDToClsIdx = new HTuple();
                            hv_ClsIDToClsIdx[hv_IgnoreClassIDs] = (hv_ClsIDToClsIdx.TupleMax()) + 1;
                            //Set the mapping to the evaluation parameters.
                            HOperatorSet.SetDictTuple(hv_EvalParams, "class_id_mapping", hv_ClsIDToClsIdx);
                        }
                    }
                    else
                    {
                        hv_TP.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TP = HTuple.TupleGenConst(
                                hv_NumClasses, 0);
                        }
                        hv_FP.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FP = HTuple.TupleGenConst(
                                hv_NumClasses, 0);
                        }
                        hv_FN.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FN = HTuple.TupleGenConst(
                                hv_NumClasses, 0);
                        }
                        HOperatorSet.SetDictTuple(hv_RunningMeasures, "tp", hv_TP);
                        HOperatorSet.SetDictTuple(hv_RunningMeasures, "fp", hv_FP);
                        HOperatorSet.SetDictTuple(hv_RunningMeasures, "fn", hv_FN);
                    }
                }
                //

                hv_Valid.Dispose();
                hv_Exception.Dispose();
                hv_NumClasses.Dispose();
                hv_EvaluationType.Dispose();
                hv_Measures.Dispose();
                hv_ClassIDs.Dispose();
                hv_InstanceType.Dispose();
                hv_EvalOrientation.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_IoUThreshs.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_MaxNumIdx.Dispose();
                hv_MaxNum.Dispose();
                hv_CurrentRunningMeasure.Dispose();
                hv_AreaIdx.Dispose();
                hv_AreaRunningMeasure.Dispose();
                hv_I.Dispose();
                hv_IoURunningMeasure.Dispose();
                hv_ClsIdx.Dispose();
                hv_ClassRunningMeasures.Dispose();
                hv_Confidence.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_CalcConfMatrix.Dispose();
                hv_MatrixSize.Dispose();
                hv_PixelConfusionMatrix.Dispose();
                hv_MaxId.Dispose();
                hv_ClsIDToClsIdx.Dispose();
                hv_TP.Dispose();
                hv_FP.Dispose();
                hv_FN.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Valid.Dispose();
                hv_Exception.Dispose();
                hv_NumClasses.Dispose();
                hv_EvaluationType.Dispose();
                hv_Measures.Dispose();
                hv_ClassIDs.Dispose();
                hv_InstanceType.Dispose();
                hv_EvalOrientation.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_IoUThreshs.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_MaxNumIdx.Dispose();
                hv_MaxNum.Dispose();
                hv_CurrentRunningMeasure.Dispose();
                hv_AreaIdx.Dispose();
                hv_AreaRunningMeasure.Dispose();
                hv_I.Dispose();
                hv_IoURunningMeasure.Dispose();
                hv_ClsIdx.Dispose();
                hv_ClassRunningMeasures.Dispose();
                hv_Confidence.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_CalcConfMatrix.Dispose();
                hv_MatrixSize.Dispose();
                hv_PixelConfusionMatrix.Dispose();
                hv_MaxId.Dispose();
                hv_ClsIDToClsIdx.Dispose();
                hv_TP.Dispose();
                hv_FP.Dispose();
                hv_FN.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: shuffles the input colors in a deterministic way 
        public void make_neighboring_colors_distinguishable(HTuple hv_ColorsRainbow, out HTuple hv_Colors)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_NumColors = new HTuple(), hv_NumChunks = new HTuple();
            HTuple hv_NumLeftOver = new HTuple(), hv_ColorsPerChunk = new HTuple();
            HTuple hv_StartIdx = new HTuple(), hv_S = new HTuple();
            HTuple hv_EndIdx = new HTuple(), hv_IdxsLeft = new HTuple();
            HTuple hv_IdxsRight = new HTuple();
            // Initialize local and output iconic variables 
            hv_Colors = new HTuple();
            try
            {
                //
                //Shuffle the input colors in a deterministic way
                //to make adjacent colors more distinguishable.
                //Neighboring colors from the input are distributed to every NumChunks
                //position in the output.
                //Depending on the number of colors, increase NumChunks.
                hv_NumColors.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumColors = new HTuple(hv_ColorsRainbow.TupleLength()
                        );
                }
                if ((int)(new HTuple(hv_NumColors.TupleGreaterEqual(8))) != 0)
                {
                    hv_NumChunks.Dispose();
                    hv_NumChunks = 3;
                    if ((int)(new HTuple(hv_NumColors.TupleGreaterEqual(40))) != 0)
                    {
                        hv_NumChunks.Dispose();
                        hv_NumChunks = 6;
                    }
                    else if ((int)(new HTuple(hv_NumColors.TupleGreaterEqual(20))) != 0)
                    {
                        hv_NumChunks.Dispose();
                        hv_NumChunks = 4;
                    }
                    hv_Colors.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Colors = HTuple.TupleGenConst(
                            hv_NumColors, -1);
                    }
                    //Check if the Number of Colors is dividable by NumChunks.
                    hv_NumLeftOver.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumLeftOver = hv_NumColors % hv_NumChunks;
                    }
                    hv_ColorsPerChunk.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ColorsPerChunk = ((hv_NumColors / hv_NumChunks)).TupleInt()
                            ;
                    }
                    hv_StartIdx.Dispose();
                    hv_StartIdx = 0;
                    HTuple end_val19 = hv_NumChunks - 1;
                    HTuple step_val19 = 1;
                    for (hv_S = 0; hv_S.Continue(end_val19, step_val19); hv_S = hv_S.TupleAdd(step_val19))
                    {
                        hv_EndIdx.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_EndIdx = (hv_StartIdx + hv_ColorsPerChunk) - 1;
                        }
                        if ((int)(new HTuple(hv_S.TupleLess(hv_NumLeftOver))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_EndIdx = hv_EndIdx + 1;
                                    hv_EndIdx.Dispose();
                                    hv_EndIdx = ExpTmpLocalVar_EndIdx;
                                }
                            }
                        }
                        hv_IdxsLeft.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_IdxsLeft = HTuple.TupleGenSequence(
                                hv_S, hv_NumColors - 1, hv_NumChunks);
                        }
                        hv_IdxsRight.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_IdxsRight = HTuple.TupleGenSequence(
                                hv_StartIdx, hv_EndIdx, 1);
                        }
                        if (hv_Colors == null)
                            hv_Colors = new HTuple();
                        hv_Colors[HTuple.TupleGenSequence(hv_S, hv_NumColors - 1, hv_NumChunks)] = hv_ColorsRainbow.TupleSelectRange(
                            hv_StartIdx, hv_EndIdx);
                        hv_StartIdx.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_StartIdx = hv_EndIdx + 1;
                        }
                    }
                }
                else
                {
                    hv_Colors.Dispose();
                    hv_Colors = new HTuple(hv_ColorsRainbow);
                }

                hv_NumColors.Dispose();
                hv_NumChunks.Dispose();
                hv_NumLeftOver.Dispose();
                hv_ColorsPerChunk.Dispose();
                hv_StartIdx.Dispose();
                hv_S.Dispose();
                hv_EndIdx.Dispose();
                hv_IdxsLeft.Dispose();
                hv_IdxsRight.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_NumColors.Dispose();
                hv_NumChunks.Dispose();
                hv_NumLeftOver.Dispose();
                hv_ColorsPerChunk.Dispose();
                hv_StartIdx.Dispose();
                hv_S.Dispose();
                hv_EndIdx.Dispose();
                hv_IdxsLeft.Dispose();
                hv_IdxsRight.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Window
        // Short Description: Open a window next to the given WindowHandleFather.  
        public void open_child_window(HTuple hv_WindowHandleFather, HTuple hv_Font, HTuple hv_FontSize,
            HTuple hv_Text, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict,
            HTuple hv_WindowHandleKey, out HTuple hv_WindowHandleChild, out HTuple hv_PrevWindowCoordinatesOut)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_StringWidth = new HTuple(), hv_IndexText = new HTuple();
            HTuple hv__ = new HTuple(), hv_TextWidth = new HTuple();
            HTuple hv_WindowRow = new HTuple(), hv_WindowColumn = new HTuple();
            HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
            HTuple hv_MetaInfo = new HTuple();
            // Initialize local and output iconic variables 
            hv_WindowHandleChild = new HTuple();
            hv_PrevWindowCoordinatesOut = new HTuple();
            try
            {
                //
                //This procedure opens a window next to the given WindowHandleFather.
                //
                //Get the maximum width of the text to be displayed.
                //The width should be at leat 200.
                hv_StringWidth.Dispose();
                hv_StringWidth = 150;
                for (hv_IndexText = 0; (int)hv_IndexText <= (int)((new HTuple(hv_Text.TupleLength()
                    )) - 1); hv_IndexText = (int)hv_IndexText + 1)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv__.Dispose(); hv__.Dispose(); hv_TextWidth.Dispose(); hv__.Dispose();
                        HOperatorSet.GetStringExtents(hv_WindowHandleFather, hv_Text.TupleSelect(
                            hv_IndexText), out hv__, out hv__, out hv_TextWidth, out hv__);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_StringWidth = hv_StringWidth.TupleMax2(
                                hv_TextWidth);
                            hv_StringWidth.Dispose();
                            hv_StringWidth = ExpTmpLocalVar_StringWidth;
                        }
                    }
                }
                //
                //Define window coordinates.
                hv_WindowRow.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowRow = hv_PrevWindowCoordinates.TupleSelect(
                        0);
                }
                hv_WindowColumn.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowColumn = ((hv_PrevWindowCoordinates.TupleSelect(
                        1)) + (hv_PrevWindowCoordinates.TupleSelect(2))) + 5;
                }
                hv_WindowWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowWidth = hv_StringWidth + (2 * 12.0);
                }
                hv_WindowHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowHeight = hv_PrevWindowCoordinates.TupleSelect(
                        3);
                }
                //
                HOperatorSet.SetWindowAttr("background_color", "black");
                HOperatorSet.OpenWindow(hv_WindowRow, hv_WindowColumn, hv_WindowWidth, hv_WindowHeight, 0, "visible", "", out hv_WindowHandleChild);
                HDevWindowStack.Push(hv_WindowHandleChild);
                set_display_font(hv_WindowHandleChild, hv_FontSize, hv_Font, "true", "false");
                //
                //Return the coordinates of the new window.
                hv_PrevWindowCoordinatesOut.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PrevWindowCoordinatesOut = new HTuple();
                    hv_PrevWindowCoordinatesOut = hv_PrevWindowCoordinatesOut.TupleConcat(hv_WindowRow, hv_WindowColumn, hv_WindowWidth, hv_WindowHeight);
                }
                //
                //Set some meta information about the new child window handle.
                hv_MetaInfo.Dispose();
                HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_child_window_coordinates",
                        hv_PrevWindowCoordinatesOut);
                }
                HOperatorSet.SetDictTuple(hv_WindowHandleDict, "meta_information", hv_MetaInfo);
                //

                hv_StringWidth.Dispose();
                hv_IndexText.Dispose();
                hv__.Dispose();
                hv_TextWidth.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowColumn.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_MetaInfo.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_StringWidth.Dispose();
                hv_IndexText.Dispose();
                hv__.Dispose();
                hv_TextWidth.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowColumn.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_MetaInfo.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Window
        // Short Description: Open a new window, either next to the last ones, or in a new row. 
        public void open_next_window(HTuple hv_Font, HTuple hv_FontSize, HTuple hv_ShowBottomDesc,
            HTuple hv_WidthImage, HTuple hv_HeightImage, HTuple hv_MapColorBarWidth, HTuple hv_ScaleWindows,
            HTuple hv_ThresholdWidth, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict,
            HTuple hv_WindowHandleKey, out HTuple hv_WindowHandleNew, out HTuple hv_WindowImageRatioHeight,
            out HTuple hv_PrevWindowCoordinatesOut)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_PrevWindowRow = new HTuple(), hv_PrevWindowColumn = new HTuple();
            HTuple hv_PrevWindowWidth = new HTuple(), hv_PrevWindowHeight = new HTuple();
            HTuple hv_WindowRow = new HTuple(), hv_WindowColumn = new HTuple();
            HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
            HTuple hv__ = new HTuple(), hv_MarginBottom = new HTuple();
            HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
            HTuple hv_WindowImageRatioWidth = new HTuple(), hv_SetPartRow2 = new HTuple();
            HTuple hv_SetPartColumn2 = new HTuple(), hv_MetaInfo = new HTuple();
            // Initialize local and output iconic variables 
            hv_WindowHandleNew = new HTuple();
            hv_WindowImageRatioHeight = new HTuple();
            hv_PrevWindowCoordinatesOut = new HTuple();
            try
            {
                //
                //This procedure opens a new window, either next to
                //the last ones, or in a new row.
                //
                //Get coordinates of previous window.
                hv_PrevWindowRow.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PrevWindowRow = hv_PrevWindowCoordinates.TupleSelect(
                        0);
                }
                hv_PrevWindowColumn.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PrevWindowColumn = hv_PrevWindowCoordinates.TupleSelect(
                        1);
                }
                hv_PrevWindowWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PrevWindowWidth = hv_PrevWindowCoordinates.TupleSelect(
                        2);
                }
                hv_PrevWindowHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PrevWindowHeight = hv_PrevWindowCoordinates.TupleSelect(
                        3);
                }
                //
                if ((int)(new HTuple(((hv_PrevWindowColumn + hv_PrevWindowWidth)).TupleGreater(
                    hv_ThresholdWidth))) != 0)
                {
                    //Open window in new row.
                    hv_WindowRow.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_WindowRow = (hv_PrevWindowRow + hv_PrevWindowHeight) + 55;
                    }
                    hv_WindowColumn.Dispose();
                    hv_WindowColumn = 0;
                }
                else
                {
                    //Open window in same row.
                    hv_WindowRow.Dispose();
                    hv_WindowRow = new HTuple(hv_PrevWindowRow);
                    hv_WindowColumn.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_WindowColumn = hv_PrevWindowColumn + hv_PrevWindowWidth;
                    }
                    if ((int)(new HTuple(hv_WindowColumn.TupleNotEqual(0))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_WindowColumn = hv_WindowColumn + 5;
                                hv_WindowColumn.Dispose();
                                hv_WindowColumn = ExpTmpLocalVar_WindowColumn;
                            }
                        }
                    }
                }
                //
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowHandleNew.Dispose();
                    dev_open_window_fit_size(hv_WindowRow, hv_WindowColumn, hv_WidthImage, hv_HeightImage,
                        (new HTuple(500)).TupleConcat(800) * hv_ScaleWindows, (new HTuple(400)).TupleConcat(
                        600) * hv_ScaleWindows, out hv_WindowHandleNew);
                }
                set_display_font(hv_WindowHandleNew, hv_FontSize, hv_Font, "true", "false");
                //
                //Add MarginBottom and MapColorBarWidth to window.
                if ((int)(hv_ShowBottomDesc) != 0)
                {
                    hv_Ascent.Dispose(); hv_Descent.Dispose(); hv__.Dispose(); hv__.Dispose();
                    HOperatorSet.GetStringExtents(hv_WindowHandleNew, "Test_string", out hv_Ascent,
                        out hv_Descent, out hv__, out hv__);
                    hv_MarginBottom.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MarginBottom = ((2 * 12) + hv_Ascent) + hv_Descent;
                    }
                }
                else
                {
                    hv_MarginBottom.Dispose();
                    hv_MarginBottom = 0;
                }
                hv__.Dispose(); hv__.Dispose(); hv_WindowWidth.Dispose(); hv_WindowHeight.Dispose();
                HOperatorSet.GetWindowExtents(hv_WindowHandleNew, out hv__, out hv__, out hv_WindowWidth,
                    out hv_WindowHeight);
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_WindowRow,
                            hv_WindowColumn, hv_WindowWidth + hv_MapColorBarWidth, hv_WindowHeight + hv_MarginBottom);
                    }
                }
                //
                //Get and set meta information of new window handle.
                hv_WindowImageRatioHeight.Dispose(); hv_WindowImageRatioWidth.Dispose(); hv_SetPartRow2.Dispose(); hv_SetPartColumn2.Dispose(); hv_PrevWindowCoordinatesOut.Dispose();
                update_window_meta_information(hv_WindowHandleNew, hv_WidthImage, hv_HeightImage,
                    hv_WindowRow, hv_WindowColumn, hv_MapColorBarWidth, hv_MarginBottom, out hv_WindowImageRatioHeight,
                    out hv_WindowImageRatioWidth, out hv_SetPartRow2, out hv_SetPartColumn2,
                    out hv_PrevWindowCoordinatesOut);
                //
                //Set window handle and some meta information about the new window handle.
                HOperatorSet.SetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, hv_WindowHandleNew);
                hv_MetaInfo.Dispose();
                HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_window_image_ratio_height",
                        hv_WindowImageRatioHeight);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_window_image_ratio_width",
                        hv_WindowImageRatioWidth);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_set_part_row2",
                        hv_SetPartRow2);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_set_part_column2",
                        hv_SetPartColumn2);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_margin_bottom",
                        hv_MarginBottom);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_map_color_bar_with",
                        hv_MapColorBarWidth);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_window_coordinates",
                        hv_PrevWindowCoordinatesOut);
                }
                HOperatorSet.SetDictTuple(hv_WindowHandleDict, "meta_information", hv_MetaInfo);
                //

                hv_PrevWindowRow.Dispose();
                hv_PrevWindowColumn.Dispose();
                hv_PrevWindowWidth.Dispose();
                hv_PrevWindowHeight.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowColumn.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv__.Dispose();
                hv_MarginBottom.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_WindowImageRatioWidth.Dispose();
                hv_SetPartRow2.Dispose();
                hv_SetPartColumn2.Dispose();
                hv_MetaInfo.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_PrevWindowRow.Dispose();
                hv_PrevWindowColumn.Dispose();
                hv_PrevWindowWidth.Dispose();
                hv_PrevWindowHeight.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowColumn.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv__.Dispose();
                hv_MarginBottom.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_WindowImageRatioWidth.Dispose();
                hv_SetPartRow2.Dispose();
                hv_SetPartColumn2.Dispose();
                hv_MetaInfo.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Read the dictionaries DLSamples from files. 
        public void read_dl_samples(HTuple hv_DLDataset, HTuple hv_SampleIndices, out HTuple hv_DLSampleBatch)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_DatasetSamples = new HTuple(), hv_MinIndex = new HTuple();
            HTuple hv_MaxIndex = new HTuple(), hv_KeyDirExists = new HTuple();
            HTuple hv_DictDir = new HTuple(), hv_DLSamplesProc = new HTuple();
            HTuple hv_ImageIndex = new HTuple(), hv_KeyFileExists = new HTuple();
            HTuple hv_ImageID = new HTuple(), hv_FileNameRelative = new HTuple();
            HTuple hv_FileNameSample = new HTuple(), hv_FileExists = new HTuple();
            HTuple hv_DictPath = new HTuple(), hv_DLSample = new HTuple();
            HTuple hv_Exception = new HTuple();
            // Initialize local and output iconic variables 
            hv_DLSampleBatch = new HTuple();
            try
            {
                //
                //This procedure reads a batch of DLSample dictionaries from disk.
                //The wanted samples are selected from a DLDataset by their indices.
                //The indices of the wanted samples are handed over in SampleIndices.
                //It returns the tuple of read-in dictionaries in DLSampleBatch.
                //
                //Sanity checks of inputs.
                //
                if ((int)(new HTuple((new HTuple(hv_SampleIndices.TupleLength())).TupleLessEqual(
                    0))) != 0)
                {
                    //Check the length of selected indices.
                    throw new HalconException(new HTuple("Invalid length of SelectedIndices: ") + (new HTuple(hv_SampleIndices.TupleLength()
                        )));
                }
                else
                {
                    //Get the samples from the DLDataset.
                    hv_DatasetSamples.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DatasetSamples);
                    //Get min and max value of given indices.
                    hv_MinIndex.Dispose();
                    HOperatorSet.TupleMin(hv_SampleIndices, out hv_MinIndex);
                    hv_MaxIndex.Dispose();
                    HOperatorSet.TupleMax(hv_SampleIndices, out hv_MaxIndex);
                    if ((int)((new HTuple(hv_MinIndex.TupleLess(0))).TupleOr(new HTuple(hv_MaxIndex.TupleGreater(
                        (new HTuple(hv_DatasetSamples.TupleLength())) - 1)))) != 0)
                    {
                        //Check the value range of the provided indices.
                        throw new HalconException("The given SampleIndices are not within the range of available samples in DLDataset.");
                    }
                }
                //
                //Check if the key dlsample_dir is given.
                hv_KeyDirExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLDataset, "key_exists", "dlsample_dir", out hv_KeyDirExists);
                //
                if ((int)(hv_KeyDirExists) != 0)
                {
                    //
                    //Get the dlsample_dir.
                    hv_DictDir.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLDataset, "dlsample_dir", out hv_DictDir);
                    //Get the samples to be processed.
                    hv_DLSamplesProc.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DLSamplesProc = hv_DatasetSamples.TupleSelect(
                            hv_SampleIndices);
                    }
                    //
                    //Initialize DLSampleBatch tuple.
                    hv_DLSampleBatch.Dispose();
                    hv_DLSampleBatch = new HTuple();
                    //
                    //Read in all DLSamples into the batch.
                    for (hv_ImageIndex = 0; (int)hv_ImageIndex <= (int)((new HTuple(hv_SampleIndices.TupleLength()
                        )) - 1); hv_ImageIndex = (int)hv_ImageIndex + 1)
                    {
                        //Check if dlsample key exist.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_KeyFileExists.Dispose();
                            HOperatorSet.GetDictParam(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                                "key_exists", "dlsample_file_name", out hv_KeyFileExists);
                        }
                        //
                        if ((int)(hv_KeyFileExists.TupleNot()) != 0)
                        {
                            //
                            //If the key does not exist, check if a corresponding file exists.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ImageID.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                                    "image_id", out hv_ImageID);
                            }
                            hv_FileNameRelative.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_FileNameRelative = hv_ImageID + "_dlsample.hdict";
                            }
                            hv_FileNameSample.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_FileNameSample = (hv_DictDir + "/") + hv_FileNameRelative;
                            }
                            //
                            hv_FileExists.Dispose();
                            HOperatorSet.FileExists(hv_FileNameSample, out hv_FileExists);
                            if ((int)(hv_FileExists) != 0)
                            {
                                //If it exists, create corresponding key.
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                                        "dlsample_file_name", hv_FileNameRelative);
                                }
                            }
                            else
                            {
                                //If not, throw an error.
                                throw new HalconException("No 'dlsample_file_name' and hdict file available for image ID " + hv_ImageID);
                            }
                            //
                        }
                        //
                        //If dlsample dictionary is available for reading, read it.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_DictPath.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                                "dlsample_file_name", out hv_DictPath);
                        }
                        try
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_DLSample.Dispose();
                                HOperatorSet.ReadDict((hv_DictDir + "/") + hv_DictPath, new HTuple(), new HTuple(),
                                    out hv_DLSample);
                            }
                        }
                        // catch (Exception) 
                        catch (HalconException HDevExpDefaultException1)
                        {
                            HDevExpDefaultException1.ToHTuple(out hv_Exception);
                            throw new HalconException((((("An error has occurred while reading " + hv_DictDir) + "/") + hv_DictPath) + new HTuple(" , HALCON error # ")) + (hv_Exception.TupleSelect(
                                0)));
                        }
                        //Add it to the DLSampleBatch.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_DLSampleBatch = hv_DLSampleBatch.TupleConcat(
                                    hv_DLSample);
                                hv_DLSampleBatch.Dispose();
                                hv_DLSampleBatch = ExpTmpLocalVar_DLSampleBatch;
                            }
                        }
                        //
                    }
                }
                else
                {
                    throw new HalconException("The dataset needs to include the key 'dlsample_dir' for reading a DLSample from file.");
                }


                hv_DatasetSamples.Dispose();
                hv_MinIndex.Dispose();
                hv_MaxIndex.Dispose();
                hv_KeyDirExists.Dispose();
                hv_DictDir.Dispose();
                hv_DLSamplesProc.Dispose();
                hv_ImageIndex.Dispose();
                hv_KeyFileExists.Dispose();
                hv_ImageID.Dispose();
                hv_FileNameRelative.Dispose();
                hv_FileNameSample.Dispose();
                hv_FileExists.Dispose();
                hv_DictPath.Dispose();
                hv_DLSample.Dispose();
                hv_Exception.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_DatasetSamples.Dispose();
                hv_MinIndex.Dispose();
                hv_MaxIndex.Dispose();
                hv_KeyDirExists.Dispose();
                hv_DictDir.Dispose();
                hv_DLSamplesProc.Dispose();
                hv_ImageIndex.Dispose();
                hv_KeyFileExists.Dispose();
                hv_ImageID.Dispose();
                hv_FileNameRelative.Dispose();
                hv_FileNameSample.Dispose();
                hv_FileExists.Dispose();
                hv_DictPath.Dispose();
                hv_DLSample.Dispose();
                hv_Exception.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Filters / Arithmetic
        // Short Description: Scale the gray values of an image from the interval [Min,Max] to [0,255] 
        public void scale_image_range(HObject ho_Image, out HObject ho_ImageScaled, HTuple hv_Min,
            HTuple hv_Max)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_ImageSelected = null, ho_SelectedChannel = null;
            HObject ho_LowerRegion = null, ho_UpperRegion = null, ho_ImageSelectedScaled = null;

            // Local copy input parameter variables 
            HObject ho_Image_COPY_INP_TMP;
            ho_Image_COPY_INP_TMP = new HObject(ho_Image);



            // Local control variables 

            HTuple hv_LowerLimit = new HTuple(), hv_UpperLimit = new HTuple();
            HTuple hv_Mult = new HTuple(), hv_Add = new HTuple(), hv_NumImages = new HTuple();
            HTuple hv_ImageIndex = new HTuple(), hv_Channels = new HTuple();
            HTuple hv_ChannelIndex = new HTuple(), hv_MinGray = new HTuple();
            HTuple hv_MaxGray = new HTuple(), hv_Range = new HTuple();
            HTuple hv_Max_COPY_INP_TMP = new HTuple(hv_Max);
            HTuple hv_Min_COPY_INP_TMP = new HTuple(hv_Min);

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ImageScaled);
            HOperatorSet.GenEmptyObj(out ho_ImageSelected);
            HOperatorSet.GenEmptyObj(out ho_SelectedChannel);
            HOperatorSet.GenEmptyObj(out ho_LowerRegion);
            HOperatorSet.GenEmptyObj(out ho_UpperRegion);
            HOperatorSet.GenEmptyObj(out ho_ImageSelectedScaled);
            try
            {
                //Convenience procedure to scale the gray values of the
                //input image Image from the interval [Min,Max]
                //to the interval [0,255] (default).
                //Gray values < 0 or > 255 (after scaling) are clipped.
                //
                //If the image shall be scaled to an interval different from [0,255],
                //this can be achieved by passing tuples with 2 values [From, To]
                //as Min and Max.
                //Example:
                //scale_image_range(Image:ImageScaled:[100,50],[200,250])
                //maps the gray values of Image from the interval [100,200] to [50,250].
                //All other gray values will be clipped.
                //
                //input parameters:
                //Image: the input image
                //Min: the minimum gray value which will be mapped to 0
                //     If a tuple with two values is given, the first value will
                //     be mapped to the second value.
                //Max: The maximum gray value which will be mapped to 255
                //     If a tuple with two values is given, the first value will
                //     be mapped to the second value.
                //
                //Output parameter:
                //ImageScale: the resulting scaled image.
                //
                if ((int)(new HTuple((new HTuple(hv_Min_COPY_INP_TMP.TupleLength())).TupleEqual(
                    2))) != 0)
                {
                    hv_LowerLimit.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_LowerLimit = hv_Min_COPY_INP_TMP.TupleSelect(
                            1);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Min = hv_Min_COPY_INP_TMP.TupleSelect(
                                0);
                            hv_Min_COPY_INP_TMP.Dispose();
                            hv_Min_COPY_INP_TMP = ExpTmpLocalVar_Min;
                        }
                    }
                }
                else
                {
                    hv_LowerLimit.Dispose();
                    hv_LowerLimit = 0.0;
                }
                if ((int)(new HTuple((new HTuple(hv_Max_COPY_INP_TMP.TupleLength())).TupleEqual(
                    2))) != 0)
                {
                    hv_UpperLimit.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_UpperLimit = hv_Max_COPY_INP_TMP.TupleSelect(
                            1);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Max = hv_Max_COPY_INP_TMP.TupleSelect(
                                0);
                            hv_Max_COPY_INP_TMP.Dispose();
                            hv_Max_COPY_INP_TMP = ExpTmpLocalVar_Max;
                        }
                    }
                }
                else
                {
                    hv_UpperLimit.Dispose();
                    hv_UpperLimit = 255.0;
                }
                //
                //Calculate scaling parameters.
                hv_Mult.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Mult = (((hv_UpperLimit - hv_LowerLimit)).TupleReal()
                        ) / (hv_Max_COPY_INP_TMP - hv_Min_COPY_INP_TMP);
                }
                hv_Add.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Add = ((-hv_Mult) * hv_Min_COPY_INP_TMP) + hv_LowerLimit;
                }
                //
                //Scale image.
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ScaleImage(ho_Image_COPY_INP_TMP, out ExpTmpOutVar_0, hv_Mult,
                        hv_Add);
                    ho_Image_COPY_INP_TMP.Dispose();
                    ho_Image_COPY_INP_TMP = ExpTmpOutVar_0;
                }
                //
                //Clip gray values if necessary.
                //This must be done for each image and channel separately.
                ho_ImageScaled.Dispose();
                HOperatorSet.GenEmptyObj(out ho_ImageScaled);
                hv_NumImages.Dispose();
                HOperatorSet.CountObj(ho_Image_COPY_INP_TMP, out hv_NumImages);
                HTuple end_val49 = hv_NumImages;
                HTuple step_val49 = 1;
                for (hv_ImageIndex = 1; hv_ImageIndex.Continue(end_val49, step_val49); hv_ImageIndex = hv_ImageIndex.TupleAdd(step_val49))
                {
                    ho_ImageSelected.Dispose();
                    HOperatorSet.SelectObj(ho_Image_COPY_INP_TMP, out ho_ImageSelected, hv_ImageIndex);
                    hv_Channels.Dispose();
                    HOperatorSet.CountChannels(ho_ImageSelected, out hv_Channels);
                    HTuple end_val52 = hv_Channels;
                    HTuple step_val52 = 1;
                    for (hv_ChannelIndex = 1; hv_ChannelIndex.Continue(end_val52, step_val52); hv_ChannelIndex = hv_ChannelIndex.TupleAdd(step_val52))
                    {
                        ho_SelectedChannel.Dispose();
                        HOperatorSet.AccessChannel(ho_ImageSelected, out ho_SelectedChannel, hv_ChannelIndex);
                        hv_MinGray.Dispose(); hv_MaxGray.Dispose(); hv_Range.Dispose();
                        HOperatorSet.MinMaxGray(ho_SelectedChannel, ho_SelectedChannel, 0, out hv_MinGray,
                            out hv_MaxGray, out hv_Range);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_LowerRegion.Dispose();
                            HOperatorSet.Threshold(ho_SelectedChannel, out ho_LowerRegion, ((hv_MinGray.TupleConcat(
                                hv_LowerLimit))).TupleMin(), hv_LowerLimit);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_UpperRegion.Dispose();
                            HOperatorSet.Threshold(ho_SelectedChannel, out ho_UpperRegion, hv_UpperLimit,
                                ((hv_UpperLimit.TupleConcat(hv_MaxGray))).TupleMax());
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.PaintRegion(ho_LowerRegion, ho_SelectedChannel, out ExpTmpOutVar_0,
                                hv_LowerLimit, "fill");
                            ho_SelectedChannel.Dispose();
                            ho_SelectedChannel = ExpTmpOutVar_0;
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.PaintRegion(ho_UpperRegion, ho_SelectedChannel, out ExpTmpOutVar_0,
                                hv_UpperLimit, "fill");
                            ho_SelectedChannel.Dispose();
                            ho_SelectedChannel = ExpTmpOutVar_0;
                        }
                        if ((int)(new HTuple(hv_ChannelIndex.TupleEqual(1))) != 0)
                        {
                            ho_ImageSelectedScaled.Dispose();
                            HOperatorSet.CopyObj(ho_SelectedChannel, out ho_ImageSelectedScaled,
                                1, 1);
                        }
                        else
                        {
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.AppendChannel(ho_ImageSelectedScaled, ho_SelectedChannel,
                                    out ExpTmpOutVar_0);
                                ho_ImageSelectedScaled.Dispose();
                                ho_ImageSelectedScaled = ExpTmpOutVar_0;
                            }
                        }
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_ImageScaled, ho_ImageSelectedScaled, out ExpTmpOutVar_0
                            );
                        ho_ImageScaled.Dispose();
                        ho_ImageScaled = ExpTmpOutVar_0;
                    }
                }
                ho_Image_COPY_INP_TMP.Dispose();
                ho_ImageSelected.Dispose();
                ho_SelectedChannel.Dispose();
                ho_LowerRegion.Dispose();
                ho_UpperRegion.Dispose();
                ho_ImageSelectedScaled.Dispose();

                hv_Max_COPY_INP_TMP.Dispose();
                hv_Min_COPY_INP_TMP.Dispose();
                hv_LowerLimit.Dispose();
                hv_UpperLimit.Dispose();
                hv_Mult.Dispose();
                hv_Add.Dispose();
                hv_NumImages.Dispose();
                hv_ImageIndex.Dispose();
                hv_Channels.Dispose();
                hv_ChannelIndex.Dispose();
                hv_MinGray.Dispose();
                hv_MaxGray.Dispose();
                hv_Range.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Image_COPY_INP_TMP.Dispose();
                ho_ImageSelected.Dispose();
                ho_SelectedChannel.Dispose();
                ho_LowerRegion.Dispose();
                ho_UpperRegion.Dispose();
                ho_ImageSelectedScaled.Dispose();

                hv_Max_COPY_INP_TMP.Dispose();
                hv_Min_COPY_INP_TMP.Dispose();
                hv_LowerLimit.Dispose();
                hv_UpperLimit.Dispose();
                hv_Mult.Dispose();
                hv_Add.Dispose();
                hv_NumImages.Dispose();
                hv_ImageIndex.Dispose();
                hv_Channels.Dispose();
                hv_ChannelIndex.Dispose();
                hv_MinGray.Dispose();
                hv_MaxGray.Dispose();
                hv_Range.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Text
        // Short Description: Set font independent of OS 
        public void set_display_font(HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font,
            HTuple hv_Bold, HTuple hv_Slant)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_OS = new HTuple(), hv_Fonts = new HTuple();
            HTuple hv_Style = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_AvailableFonts = new HTuple(), hv_Fdx = new HTuple();
            HTuple hv_Indices = new HTuple();
            HTuple hv_Font_COPY_INP_TMP = new HTuple(hv_Font);
            HTuple hv_Size_COPY_INP_TMP = new HTuple(hv_Size);

            // Initialize local and output iconic variables 
            try
            {
                //This procedure sets the text font of the current window with
                //the specified attributes.
                //
                //Input parameters:
                //WindowHandle: The graphics window for which the font will be set
                //Size: The font size. If Size=-1, the default of 16 is used.
                //Bold: If set to 'true', a bold font is used
                //Slant: If set to 'true', a slanted font is used
                //
                hv_OS.Dispose();
                HOperatorSet.GetSystem("operating_system", out hv_OS);
                if ((int)((new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
                    new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(-1)))) != 0)
                {
                    hv_Size_COPY_INP_TMP.Dispose();
                    hv_Size_COPY_INP_TMP = 16;
                }
                if ((int)(new HTuple(((hv_OS.TupleSubstr(0, 2))).TupleEqual("Win"))) != 0)
                {
                    //Restore previous behaviour
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Size = ((1.13677 * hv_Size_COPY_INP_TMP)).TupleInt()
                                ;
                            hv_Size_COPY_INP_TMP.Dispose();
                            hv_Size_COPY_INP_TMP = ExpTmpLocalVar_Size;
                        }
                    }
                }
                else
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Size = hv_Size_COPY_INP_TMP.TupleInt()
                                ;
                            hv_Size_COPY_INP_TMP.Dispose();
                            hv_Size_COPY_INP_TMP = ExpTmpLocalVar_Size;
                        }
                    }
                }
                if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("Courier"))) != 0)
                {
                    hv_Fonts.Dispose();
                    hv_Fonts = new HTuple();
                    hv_Fonts[0] = "Courier";
                    hv_Fonts[1] = "Courier 10 Pitch";
                    hv_Fonts[2] = "Courier New";
                    hv_Fonts[3] = "CourierNew";
                    hv_Fonts[4] = "Liberation Mono";
                }
                else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("mono"))) != 0)
                {
                    hv_Fonts.Dispose();
                    hv_Fonts = new HTuple();
                    hv_Fonts[0] = "Consolas";
                    hv_Fonts[1] = "Menlo";
                    hv_Fonts[2] = "Courier";
                    hv_Fonts[3] = "Courier 10 Pitch";
                    hv_Fonts[4] = "FreeMono";
                    hv_Fonts[5] = "Liberation Mono";
                }
                else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("sans"))) != 0)
                {
                    hv_Fonts.Dispose();
                    hv_Fonts = new HTuple();
                    hv_Fonts[0] = "Luxi Sans";
                    hv_Fonts[1] = "DejaVu Sans";
                    hv_Fonts[2] = "FreeSans";
                    hv_Fonts[3] = "Arial";
                    hv_Fonts[4] = "Liberation Sans";
                }
                else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("serif"))) != 0)
                {
                    hv_Fonts.Dispose();
                    hv_Fonts = new HTuple();
                    hv_Fonts[0] = "Times New Roman";
                    hv_Fonts[1] = "Luxi Serif";
                    hv_Fonts[2] = "DejaVu Serif";
                    hv_Fonts[3] = "FreeSerif";
                    hv_Fonts[4] = "Utopia";
                    hv_Fonts[5] = "Liberation Serif";
                }
                else
                {
                    hv_Fonts.Dispose();
                    hv_Fonts = new HTuple(hv_Font_COPY_INP_TMP);
                }
                hv_Style.Dispose();
                hv_Style = "";
                if ((int)(new HTuple(hv_Bold.TupleEqual("true"))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Style = hv_Style + "Bold";
                            hv_Style.Dispose();
                            hv_Style = ExpTmpLocalVar_Style;
                        }
                    }
                }
                else if ((int)(new HTuple(hv_Bold.TupleNotEqual("false"))) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "Wrong value of control parameter Bold";
                    throw new HalconException(hv_Exception);
                }
                if ((int)(new HTuple(hv_Slant.TupleEqual("true"))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Style = hv_Style + "Italic";
                            hv_Style.Dispose();
                            hv_Style = ExpTmpLocalVar_Style;
                        }
                    }
                }
                else if ((int)(new HTuple(hv_Slant.TupleNotEqual("false"))) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "Wrong value of control parameter Slant";
                    throw new HalconException(hv_Exception);
                }
                if ((int)(new HTuple(hv_Style.TupleEqual(""))) != 0)
                {
                    hv_Style.Dispose();
                    hv_Style = "Normal";
                }
                hv_AvailableFonts.Dispose();
                HOperatorSet.QueryFont(hv_WindowHandle, out hv_AvailableFonts);
                hv_Font_COPY_INP_TMP.Dispose();
                hv_Font_COPY_INP_TMP = "";
                for (hv_Fdx = 0; (int)hv_Fdx <= (int)((new HTuple(hv_Fonts.TupleLength())) - 1); hv_Fdx = (int)hv_Fdx + 1)
                {
                    hv_Indices.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Indices = hv_AvailableFonts.TupleFind(
                            hv_Fonts.TupleSelect(hv_Fdx));
                    }
                    if ((int)(new HTuple((new HTuple(hv_Indices.TupleLength())).TupleGreater(
                        0))) != 0)
                    {
                        if ((int)(new HTuple(((hv_Indices.TupleSelect(0))).TupleGreaterEqual(0))) != 0)
                        {
                            hv_Font_COPY_INP_TMP.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Font_COPY_INP_TMP = hv_Fonts.TupleSelect(
                                    hv_Fdx);
                            }
                            break;
                        }
                    }
                }
                if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual(""))) != 0)
                {
                    throw new HalconException("Wrong value of control parameter Font");
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_Font = (((hv_Font_COPY_INP_TMP + "-") + hv_Style) + "-") + hv_Size_COPY_INP_TMP;
                        hv_Font_COPY_INP_TMP.Dispose();
                        hv_Font_COPY_INP_TMP = ExpTmpLocalVar_Font;
                    }
                }
                HOperatorSet.SetFont(hv_WindowHandle, hv_Font_COPY_INP_TMP);

                hv_Font_COPY_INP_TMP.Dispose();
                hv_Size_COPY_INP_TMP.Dispose();
                hv_OS.Dispose();
                hv_Fonts.Dispose();
                hv_Style.Dispose();
                hv_Exception.Dispose();
                hv_AvailableFonts.Dispose();
                hv_Fdx.Dispose();
                hv_Indices.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Font_COPY_INP_TMP.Dispose();
                hv_Size_COPY_INP_TMP.Dispose();
                hv_OS.Dispose();
                hv_Fonts.Dispose();
                hv_Style.Dispose();
                hv_Exception.Dispose();
                hv_AvailableFonts.Dispose();
                hv_Fdx.Dispose();
                hv_Indices.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Time
        // Short Description: Create a formatted string of a time span. 
        public void timespan_string(HTuple hv_TotalSeconds, HTuple hv_Format, out HTuple hv_TimeString)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Seconds = new HTuple(), hv_TotalMinutes = new HTuple();
            HTuple hv_Minutes = new HTuple(), hv_TotalHours = new HTuple();
            HTuple hv_Hours = new HTuple(), hv_Days = new HTuple();
            HTuple hv_TotalSeconds_COPY_INP_TMP = new HTuple(hv_TotalSeconds);

            // Initialize local and output iconic variables 
            hv_TimeString = new HTuple();
            try
            {
                //
                //This procedure creates a readable representation of a time span
                //given the elapsed time in seconds.
                //
                //Ensure that the input is an integer.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_TotalSeconds = hv_TotalSeconds_COPY_INP_TMP.TupleInt()
                            ;
                        hv_TotalSeconds_COPY_INP_TMP.Dispose();
                        hv_TotalSeconds_COPY_INP_TMP = ExpTmpLocalVar_TotalSeconds;
                    }
                }
                //
                hv_Seconds.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Seconds = hv_TotalSeconds_COPY_INP_TMP % 60;
                }
                //
                hv_TotalMinutes.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TotalMinutes = hv_TotalSeconds_COPY_INP_TMP / 60;
                }
                hv_Minutes.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Minutes = hv_TotalMinutes % 60;
                }
                //
                hv_TotalHours.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TotalHours = hv_TotalSeconds_COPY_INP_TMP / 3600;
                }
                hv_Hours.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Hours = hv_TotalHours % 24;
                }
                //
                hv_Days.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Days = hv_TotalSeconds_COPY_INP_TMP / 86400;
                }
                //
                if ((int)(new HTuple(hv_Format.TupleEqual("auto"))) != 0)
                {
                    //Print the highest non-zero unit and all remaining sub-units.
                    if ((int)(new HTuple(hv_Days.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (((((((hv_Days.TupleString(
                                "d")) + "d ") + (hv_Hours.TupleString("d"))) + "h ") + (hv_Minutes.TupleString(
                                "d"))) + "m ") + (hv_Seconds.TupleString("d"))) + "s";
                        }
                    }
                    else if ((int)(new HTuple(hv_Hours.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (((((hv_Hours.TupleString(
                                "d")) + "h ") + (hv_Minutes.TupleString("d"))) + "m ") + (hv_Seconds.TupleString(
                                "d"))) + "s";
                        }
                    }
                    else if ((int)(new HTuple(hv_Minutes.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (((hv_Minutes.TupleString(
                                "d")) + "m ") + (hv_Seconds.TupleString("d"))) + "s";
                        }
                    }
                    else
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (hv_Seconds.TupleString(
                                "d")) + "s";
                        }
                    }
                }
                else if ((int)(new HTuple(hv_Format.TupleEqual("top1"))) != 0)
                {
                    //Print the highest non-zero unit.
                    if ((int)(new HTuple(hv_Days.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (hv_Days.TupleString(
                                "d")) + "d";
                        }
                    }
                    else if ((int)(new HTuple(hv_Hours.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (hv_Hours.TupleString(
                                "d")) + "h";
                        }
                    }
                    else if ((int)(new HTuple(hv_Minutes.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (hv_Minutes.TupleString(
                                "d")) + "m";
                        }
                    }
                    else
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (hv_Seconds.TupleString(
                                "d")) + "s";
                        }
                    }
                }
                else if ((int)(new HTuple(hv_Format.TupleEqual("top2"))) != 0)
                {
                    //Print the highest non-zero unit and the following sub-unit.
                    if ((int)(new HTuple(hv_Days.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (((hv_Days.TupleString(
                                "d")) + "d ") + (hv_Hours.TupleString("d"))) + "h";
                        }
                    }
                    else if ((int)(new HTuple(hv_Hours.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (((hv_Hours.TupleString(
                                "d")) + "h ") + (hv_Minutes.TupleString("d"))) + "m";
                        }
                    }
                    else if ((int)(new HTuple(hv_Minutes.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (((hv_Minutes.TupleString(
                                "d")) + "m ") + (hv_Seconds.TupleString("d"))) + "s";
                        }
                    }
                    else
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (hv_Seconds.TupleString(
                                "d")) + "s";
                        }
                    }
                }
                else if ((int)(new HTuple(hv_Format.TupleEqual("dhms"))) != 0)
                {
                    //Print a Days-Hours-Minutes-Seconds string.
                    hv_TimeString.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TimeString = (((((((hv_Days.TupleString(
                            "d")) + "d ") + (hv_Hours.TupleString("d"))) + "h ") + (hv_Minutes.TupleString(
                            "d"))) + "m ") + (hv_Seconds.TupleString("d"))) + "s";
                    }
                }
                else if ((int)(new HTuple(hv_Format.TupleEqual("hms"))) != 0)
                {
                    //Print a Hours-Minutes-Seconds string, where hours can be >= 24.
                    hv_TimeString.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TimeString = (((((hv_TotalHours.TupleString(
                            "d")) + "h ") + (hv_Minutes.TupleString("d"))) + "m ") + (hv_Seconds.TupleString(
                            "d"))) + "s";
                    }
                }
                else
                {
                    throw new HalconException("Unknown format string.");
                }
                //

                hv_TotalSeconds_COPY_INP_TMP.Dispose();
                hv_Seconds.Dispose();
                hv_TotalMinutes.Dispose();
                hv_Minutes.Dispose();
                hv_TotalHours.Dispose();
                hv_Hours.Dispose();
                hv_Days.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_TotalSeconds_COPY_INP_TMP.Dispose();
                hv_Seconds.Dispose();
                hv_TotalMinutes.Dispose();
                hv_Minutes.Dispose();
                hv_TotalHours.Dispose();
                hv_Hours.Dispose();
                hv_Days.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Update RunningMeasures by evaluating Samples and corresponding Results. 
        public void update_running_evaluation_measures(HTuple hv_Samples, HTuple hv_Results,
            HTuple hv_EvalParams, HTuple hv_RunningMeasures)
        {



            // Local control variables 

            HTuple hv_EvaluationType = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure updates the running measures depending on the evaluation type.
                hv_EvaluationType.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "evaluation_type", out hv_EvaluationType);
                if ((int)(new HTuple(hv_EvaluationType.TupleEqual("anomaly_detection"))) != 0)
                {
                    update_running_image_anomaly_measures(hv_Samples, hv_Results, hv_EvalParams,
                        hv_RunningMeasures);
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("classification"))) != 0)
                {
                    update_running_image_classification_measures(hv_Samples, hv_Results, hv_EvalParams,
                        hv_RunningMeasures);
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("detection"))) != 0)
                {
                    update_running_instance_measures(hv_Samples, hv_Results, hv_EvalParams, hv_RunningMeasures);
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("segmentation"))) != 0)
                {
                    update_running_pixel_measures(hv_Samples, hv_Results, hv_EvalParams, hv_RunningMeasures);
                }
                //

                hv_EvaluationType.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_EvaluationType.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection
        // Short Description: Update running measures for an image anomaly detection evaluation. 
        public void update_running_image_anomaly_measures(HTuple hv_Samples, HTuple hv_Results,
            HTuple hv_EvalParams, HTuple hv_RunningMeasures)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ImageIDs = new HTuple(), hv_AnomalyLabelIDs = new HTuple();
            HTuple hv_AnomalyScores = new HTuple(), hv_SampleIndex = new HTuple();
            HTuple hv_Sample = new HTuple(), hv_ImageID = new HTuple();
            HTuple hv_AnomalyLabelID = new HTuple(), hv_Result = new HTuple();
            HTuple hv_AnomalyScore = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure updates the RunningMeasures for an evaluation for anomaly detection.
                //
                //These measures are stored in the dictionary RunningMeasures and
                //updated by incorporating the Results the model obtained for the Samples.
                //
                //
                //Get image ids.
                hv_ImageIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "image_ids", out hv_ImageIDs);
                //Get anomaly label ids.
                hv_AnomalyLabelIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "anomaly_label_ids", out hv_AnomalyLabelIDs);
                //Get anomaly scores.
                hv_AnomalyScores.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "anomaly_scores", out hv_AnomalyScores);
                //
                //Loop over all samples and update running measures accordingly.
                for (hv_SampleIndex = 0; (int)hv_SampleIndex <= (int)((new HTuple(hv_Samples.TupleLength()
                    )) - 1); hv_SampleIndex = (int)hv_SampleIndex + 1)
                {
                    hv_Sample.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Sample = hv_Samples.TupleSelect(
                            hv_SampleIndex);
                    }
                    hv_ImageID.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "image_id", out hv_ImageID);
                    hv_AnomalyLabelID.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "anomaly_label_id", out hv_AnomalyLabelID);
                    hv_Result.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Result = hv_Results.TupleSelect(
                            hv_SampleIndex);
                    }
                    hv_AnomalyScore.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "anomaly_score", out hv_AnomalyScore);
                    //
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ImageIDs = hv_ImageIDs.TupleConcat(
                                hv_ImageID);
                            hv_ImageIDs.Dispose();
                            hv_ImageIDs = ExpTmpLocalVar_ImageIDs;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_AnomalyLabelIDs = hv_AnomalyLabelIDs.TupleConcat(
                                hv_AnomalyLabelID);
                            hv_AnomalyLabelIDs.Dispose();
                            hv_AnomalyLabelIDs = ExpTmpLocalVar_AnomalyLabelIDs;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_AnomalyScores = hv_AnomalyScores.TupleConcat(
                                hv_AnomalyScore);
                            hv_AnomalyScores.Dispose();
                            hv_AnomalyScores = ExpTmpLocalVar_AnomalyScores;
                        }
                    }
                }
                //
                //Set image ids in running measures.
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_ids", hv_ImageIDs);
                //Set anomaly label ids in running measures.
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "anomaly_label_ids", hv_AnomalyLabelIDs);
                //Set anomaly scores in running measures.
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "anomaly_scores", hv_AnomalyScores);
                //

                hv_ImageIDs.Dispose();
                hv_AnomalyLabelIDs.Dispose();
                hv_AnomalyScores.Dispose();
                hv_SampleIndex.Dispose();
                hv_Sample.Dispose();
                hv_ImageID.Dispose();
                hv_AnomalyLabelID.Dispose();
                hv_Result.Dispose();
                hv_AnomalyScore.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ImageIDs.Dispose();
                hv_AnomalyLabelIDs.Dispose();
                hv_AnomalyScores.Dispose();
                hv_SampleIndex.Dispose();
                hv_Sample.Dispose();
                hv_ImageID.Dispose();
                hv_AnomalyLabelID.Dispose();
                hv_Result.Dispose();
                hv_AnomalyScore.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Update running measures for an image classification evaluation. 
        public void update_running_image_classification_measures(HTuple hv_Samples, HTuple hv_Results,
            HTuple hv_EvalParams, HTuple hv_RunningMeasures)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_RegExpTopKError = new HTuple(), hv_Measures = new HTuple();
            HTuple hv_K = new HTuple(), hv_M = new HTuple(), hv_ComputeTopKError = new HTuple();
            HTuple hv_ImageIDs = new HTuple(), hv_ImageLabelIDs = new HTuple();
            HTuple hv_Top1Prediction = new HTuple(), hv_TopKPredictionDicts = new HTuple();
            HTuple hv_Index = new HTuple(), hv_Sample = new HTuple();
            HTuple hv_ImageID = new HTuple(), hv_ImageLabelID = new HTuple();
            HTuple hv_Result = new HTuple(), hv_PredictedClassIDs = new HTuple();
            HTuple hv_TopKPrediction = new HTuple(), hv_TopKPredictionDict = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure updates the RunningMeasures for an evaluation for classification.
                //
                //To avoid memory, only save first K predictions per sample.
                hv_RegExpTopKError.Dispose();
                hv_RegExpTopKError = "top([0-9]+)_error";
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                hv_K.Dispose();
                hv_K = 1;
                for (hv_M = 0; (int)hv_M <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_M = (int)hv_M + 1)
                {
                    hv_ComputeTopKError.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ComputeTopKError = ((hv_Measures.TupleSelect(
                            hv_M))).TupleRegexpTest(hv_RegExpTopKError);
                    }
                    if ((int)(hv_ComputeTopKError) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_K = hv_K.TupleMax2(
                                    ((((hv_Measures.TupleSelect(hv_M))).TupleRegexpMatch(hv_RegExpTopKError))).TupleNumber()
                                    );
                                hv_K.Dispose();
                                hv_K = ExpTmpLocalVar_K;
                            }
                        }
                    }
                }
                //
                //Extend tuples in RunningMeasures with new results.
                hv_ImageIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "image_ids", out hv_ImageIDs);
                hv_ImageLabelIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "image_label_ids", out hv_ImageLabelIDs);
                hv_Top1Prediction.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "top1_predictions", out hv_Top1Prediction);
                hv_TopKPredictionDicts.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "topk_predictions", out hv_TopKPredictionDicts);
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Samples.TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
                {
                    hv_Sample.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Sample = hv_Samples.TupleSelect(
                            hv_Index);
                    }
                    hv_ImageID.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "image_id", out hv_ImageID);
                    hv_ImageLabelID.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "image_label_id", out hv_ImageLabelID);
                    hv_Result.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Result = hv_Results.TupleSelect(
                            hv_Index);
                    }
                    hv_PredictedClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "classification_class_ids", out hv_PredictedClassIDs);
                    hv_TopKPrediction.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TopKPrediction = hv_PredictedClassIDs.TupleSelectRange(
                            0, hv_K - 1);
                    }
                    hv_TopKPredictionDict.Dispose();
                    HOperatorSet.CreateDict(out hv_TopKPredictionDict);
                    HOperatorSet.SetDictTuple(hv_TopKPredictionDict, "predictions", hv_TopKPrediction);
                    //
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ImageIDs = hv_ImageIDs.TupleConcat(
                                hv_ImageID);
                            hv_ImageIDs.Dispose();
                            hv_ImageIDs = ExpTmpLocalVar_ImageIDs;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ImageLabelIDs = hv_ImageLabelIDs.TupleConcat(
                                hv_ImageLabelID);
                            hv_ImageLabelIDs.Dispose();
                            hv_ImageLabelIDs = ExpTmpLocalVar_ImageLabelIDs;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Top1Prediction = hv_Top1Prediction.TupleConcat(
                                hv_TopKPrediction.TupleSelect(0));
                            hv_Top1Prediction.Dispose();
                            hv_Top1Prediction = ExpTmpLocalVar_Top1Prediction;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_TopKPredictionDicts = hv_TopKPredictionDicts.TupleConcat(
                                hv_TopKPredictionDict);
                            hv_TopKPredictionDicts.Dispose();
                            hv_TopKPredictionDicts = ExpTmpLocalVar_TopKPredictionDicts;
                        }
                    }
                }
                //
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_ids", hv_ImageIDs);
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_label_ids", hv_ImageLabelIDs);
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "top1_predictions", hv_Top1Prediction);
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "topk_predictions", hv_TopKPredictionDicts);
                //

                hv_RegExpTopKError.Dispose();
                hv_Measures.Dispose();
                hv_K.Dispose();
                hv_M.Dispose();
                hv_ComputeTopKError.Dispose();
                hv_ImageIDs.Dispose();
                hv_ImageLabelIDs.Dispose();
                hv_Top1Prediction.Dispose();
                hv_TopKPredictionDicts.Dispose();
                hv_Index.Dispose();
                hv_Sample.Dispose();
                hv_ImageID.Dispose();
                hv_ImageLabelID.Dispose();
                hv_Result.Dispose();
                hv_PredictedClassIDs.Dispose();
                hv_TopKPrediction.Dispose();
                hv_TopKPredictionDict.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_RegExpTopKError.Dispose();
                hv_Measures.Dispose();
                hv_K.Dispose();
                hv_M.Dispose();
                hv_ComputeTopKError.Dispose();
                hv_ImageIDs.Dispose();
                hv_ImageLabelIDs.Dispose();
                hv_Top1Prediction.Dispose();
                hv_TopKPredictionDicts.Dispose();
                hv_Index.Dispose();
                hv_Sample.Dispose();
                hv_ImageID.Dispose();
                hv_ImageLabelID.Dispose();
                hv_Result.Dispose();
                hv_PredictedClassIDs.Dispose();
                hv_TopKPrediction.Dispose();
                hv_TopKPredictionDict.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Update running measures for an instance-based evaluation. 
        public void update_running_instance_measures(HTuple hv_Samples, HTuple hv_Results,
            HTuple hv_EvalParams, HTuple hv_RunningMeasures)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_MaxNumDetections = new HTuple();
            HTuple hv_AreaRanges = new HTuple(), hv_IoUThresholds = new HTuple();
            HTuple hv_InstanceType = new HTuple(), hv_ClassIDs = new HTuple();
            HTuple hv_NumClasses = new HTuple(), hv_Measures = new HTuple();
            HTuple hv_AreaNames = new HTuple(), hv_MinAreas = new HTuple();
            HTuple hv_MaxAreas = new HTuple(), hv_NumAreaRanges = new HTuple();
            HTuple hv_AllocationBlockLength = new HTuple(), hv_DetailedEvaluation = new HTuple();
            HTuple hv_KeyExists = new HTuple(), hv_ClassIDToClassIdx = new HTuple();
            HTuple hv_EvaluateOrientation = new HTuple(), hv_SIdx = new HTuple();
            HTuple hv_CurrentSample = new HTuple(), hv_CurrentResult = new HTuple();
            HTuple hv_GtClassIDs = new HTuple(), hv_ResClassIDs = new HTuple();
            HTuple hv_NumGT = new HTuple(), hv_NumRes = new HTuple();
            HTuple hv_Confidences = new HTuple(), hv_ResSortIndices = new HTuple();
            HTuple hv_GtAreas = new HTuple(), hv_ResAreas = new HTuple();
            HTuple hv_IoUs = new HTuple(), hv_GtPhis = new HTuple();
            HTuple hv_ResPhis = new HTuple(), hv_MDIdx = new HTuple();
            HTuple hv_MaxNum = new HTuple(), hv_MaxNumStr = new HTuple();
            HTuple hv_CurrentRunningMeasures = new HTuple(), hv_AreaIdx = new HTuple();
            HTuple hv_MinArea = new HTuple(), hv_MaxArea = new HTuple();
            HTuple hv_AreaName = new HTuple(), hv_AreaRunningMeasures = new HTuple();
            HTuple hv_GtIgnore = new HTuple(), hv_GtIgnoreInds = new HTuple();
            HTuple hv_PerClassNumGt = new HTuple(), hv_PerClassNumPred = new HTuple();
            HTuple hv_PerClassConfidences = new HTuple(), hv_PerClassNumGtIgnore = new HTuple();
            HTuple hv_SampleHasFP = new HTuple(), hv_SampleHasFN = new HTuple();
            HTuple hv_ClsIdx = new HTuple(), hv_CurrentClassID = new HTuple();
            HTuple hv_CurrentGtIdxs = new HTuple(), hv_CurrentNumGt = new HTuple();
            HTuple hv_CurrentGtIgnore = new HTuple(), hv_CurrentNumGtIgnore = new HTuple();
            HTuple hv_CurrentNumGtNoIgnore = new HTuple(), hv_CurrentResIdxs = new HTuple();
            HTuple hv_CurrentNumRes = new HTuple(), hv_CurrentResAreas = new HTuple();
            HTuple hv_OldNumPred = new HTuple(), hv_CurrentClassConfidences = new HTuple();
            HTuple hv_GtSortIdx = new HTuple(), hv_CurrentResPhis = new HTuple();
            HTuple hv_CurrentGtPhis = new HTuple(), hv_ITIdx = new HTuple();
            HTuple hv_GtMatched = new HTuple(), hv_ResMatched = new HTuple();
            HTuple hv_ResAbsOrientationDiff = new HTuple(), hv_ResIgnore = new HTuple();
            HTuple hv_ResIdx = new HTuple(), hv_CurrentIoU = new HTuple();
            HTuple hv_MatchIdx = new HTuple(), hv_GtIdx = new HTuple();
            HTuple hv_AreaIgnore = new HTuple(), hv_PerIoUMeasure = new HTuple();
            HTuple hv_PerClassMeasures = new HTuple(), hv_CurrentIsTP = new HTuple();
            HTuple hv_CurrentIgnore = new HTuple(), hv_CurrentAbsOrientationDiff = new HTuple();
            HTuple hv_GtMatchedNoIgnore = new HTuple(), hv_ResIsFPClass = new HTuple();
            HTuple hv_ResIsFPBackground = new HTuple(), hv_ResIsFPLocalization = new HTuple();
            HTuple hv_ResIsFPDuplicate = new HTuple(), hv_ResIsFPMultiple = new HTuple();
            HTuple hv_ResAbsOrientationDiffClass = new HTuple(), hv_ResAbsOrientationDiffLocalization = new HTuple();
            HTuple hv_ResAbsOrientationDiffDuplicate = new HTuple();
            HTuple hv_ResAbsOrientationDiffMultiple = new HTuple();
            HTuple hv_FPResIdxsThisClass = new HTuple(), hv_FPResIdxsAllResults = new HTuple();
            HTuple hv_GTIdxsNotToIgnore = new HTuple(), hv_MaxIoU = new HTuple();
            HTuple hv_IoUsWithGT = new HTuple(), hv_MaxIdx = new HTuple();
            HTuple hv_GTClassIDMaxIoU = new HTuple(), hv_AbsOrientationDiff = new HTuple();
            HTuple hv_IsFPClass = new HTuple(), hv_IsFPBackground = new HTuple();
            HTuple hv_IsFPLocalization = new HTuple(), hv_IsFPDuplicate = new HTuple();
            HTuple hv_IsFPMultiple = new HTuple(), hv_AbsOrientationDiffMultiple = new HTuple();
            HTuple hv_AbsOrientationDiffDuplicate = new HTuple(), hv_AbsOrientationDiffLocalization = new HTuple();
            HTuple hv_AbsOrientationDiffClass = new HTuple(), hv_CurrentImageID = new HTuple();
            HTuple hv_ImageIDsWithFN = new HTuple(), hv_NumImageIDsWithFN = new HTuple();
            HTuple hv_ImageIDsWithFP = new HTuple(), hv_NumImageIDsWithFP = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure updates the RunningMeasures
                //for an instance-based evaluation for detection.
                //These measures are stored in the dictionary RunningMeasures and
                //updated by incorporating the Results the model obtained for the Samples.
                //
                dev_update_off();
                //Get the necessary evaluation parameters.
                hv_MaxNumDetections.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "max_num_detections", out hv_MaxNumDetections);
                hv_AreaRanges.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "area_ranges", out hv_AreaRanges);
                hv_IoUThresholds.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "iou_threshold", out hv_IoUThresholds);
                hv_InstanceType.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "instance_type", out hv_InstanceType);
                hv_ClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                hv_NumClasses.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                //
                //Get the area parameters: name, min, and max.
                hv_AreaNames.Dispose();
                HOperatorSet.GetDictTuple(hv_AreaRanges, "name", out hv_AreaNames);
                hv_MinAreas.Dispose();
                HOperatorSet.GetDictTuple(hv_AreaRanges, "min", out hv_MinAreas);
                hv_MaxAreas.Dispose();
                HOperatorSet.GetDictTuple(hv_AreaRanges, "max", out hv_MaxAreas);
                hv_NumAreaRanges.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumAreaRanges = (new HTuple(hv_AreaNames.TupleLength()
                        )) - 1;
                }
                //
                //Get the allocation length for extending tuples.
                hv_AllocationBlockLength.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "allocation_block_length", out hv_AllocationBlockLength);
                //
                //Check if a detailed evaluation should be done.
                hv_DetailedEvaluation.Dispose();
                hv_DetailedEvaluation = 0;
                hv_KeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "detailed_evaluation",
                    out hv_KeyExists);
                if ((int)(hv_KeyExists.TupleSelect(0)) != 0)
                {
                    hv_DetailedEvaluation.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "detailed_evaluation", out hv_DetailedEvaluation);
                }
                if ((int)(hv_DetailedEvaluation) != 0)
                {
                    //We need a mapping from class IDs to class indices
                    hv_ClassIDToClassIdx.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassIDToClassIdx = HTuple.TupleGenConst(
                            (hv_ClassIDs.TupleMax()) + 1, -1);
                    }
                    if (hv_ClassIDToClassIdx == null)
                        hv_ClassIDToClassIdx = new HTuple();
                    hv_ClassIDToClassIdx[hv_ClassIDs] = HTuple.TupleGenSequence(0, hv_NumClasses - 1, 1);
                }
                //
                //Check if the orientation is to be evaluated.
                hv_EvaluateOrientation.Dispose();
                hv_EvaluateOrientation = 0;
                if ((int)((new HTuple(hv_InstanceType.TupleEqual("rectangle2"))).TupleAnd((new HTuple(((hv_Measures.TupleFind(
                    "soap"))).TupleNotEqual(-1))).TupleOr(new HTuple(((hv_Measures.TupleFind(
                    "all"))).TupleNotEqual(-1))))) != 0)
                {
                    hv_EvaluateOrientation.Dispose();
                    hv_EvaluateOrientation = 1;
                }
                //
                //Go through samples.
                for (hv_SIdx = 0; (int)hv_SIdx <= (int)((new HTuple(hv_Samples.TupleLength())) - 1); hv_SIdx = (int)hv_SIdx + 1)
                {
                    //
                    hv_CurrentSample.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentSample = hv_Samples.TupleSelect(
                            hv_SIdx);
                    }
                    hv_CurrentResult.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentResult = hv_Results.TupleSelect(
                            hv_SIdx);
                    }
                    //
                    //* Get classes.
                    hv_GtClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_CurrentSample, "bbox_label_id", out hv_GtClassIDs);
                    hv_ResClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_CurrentResult, "bbox_class_id", out hv_ResClassIDs);
                    hv_NumGT.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumGT = new HTuple(hv_GtClassIDs.TupleLength()
                            );
                    }
                    hv_NumRes.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumRes = new HTuple(hv_ResClassIDs.TupleLength()
                            );
                    }
                    //
                    //* Get result confidences and sort them in descending order.
                    hv_Confidences.Dispose();
                    HOperatorSet.GetDictTuple(hv_CurrentResult, "bbox_confidence", out hv_Confidences);
                    hv_ResSortIndices.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ResSortIndices = ((-hv_Confidences)).TupleSortIndex()
                            ;
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Confidences = hv_Confidences.TupleSelect(
                                hv_ResSortIndices);
                            hv_Confidences.Dispose();
                            hv_Confidences = ExpTmpLocalVar_Confidences;
                        }
                    }
                    //Sort the result class IDs.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResClassIDs = hv_ResClassIDs.TupleSelect(
                                hv_ResSortIndices);
                            hv_ResClassIDs.Dispose();
                            hv_ResClassIDs = ExpTmpLocalVar_ResClassIDs;
                        }
                    }
                    //
                    //Compute the IoUs of the instances.
                    hv_GtAreas.Dispose(); hv_ResAreas.Dispose(); hv_IoUs.Dispose();
                    area_iou(hv_CurrentSample, hv_CurrentResult, hv_InstanceType, hv_ResSortIndices,
                        out hv_GtAreas, out hv_ResAreas, out hv_IoUs);
                    //
                    if ((int)(hv_EvaluateOrientation) != 0)
                    {
                        hv_GtPhis.Dispose();
                        HOperatorSet.GetDictTuple(hv_CurrentSample, "bbox_phi", out hv_GtPhis);
                        hv_ResPhis.Dispose();
                        HOperatorSet.GetDictTuple(hv_CurrentResult, "bbox_phi", out hv_ResPhis);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_ResPhis = hv_ResPhis.TupleSelect(
                                    hv_ResSortIndices);
                                hv_ResPhis.Dispose();
                                hv_ResPhis = ExpTmpLocalVar_ResPhis;
                            }
                        }
                    }
                    //Loop over the maximal number of detections.
                    for (hv_MDIdx = 0; (int)hv_MDIdx <= (int)((new HTuple(hv_MaxNumDetections.TupleLength()
                        )) - 1); hv_MDIdx = (int)hv_MDIdx + 1)
                    {
                        hv_MaxNum.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MaxNum = hv_MaxNumDetections.TupleSelect(
                                hv_MDIdx);
                        }
                        hv_MaxNumStr.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MaxNumStr = "" + hv_MaxNum;
                        }
                        if ((int)(new HTuple(hv_MaxNum.TupleEqual(-1))) != 0)
                        {
                            hv_MaxNumStr.Dispose();
                            hv_MaxNumStr = "all";
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentRunningMeasures.Dispose();
                            HOperatorSet.GetDictTuple(hv_RunningMeasures, "max_num_detections_" + hv_MaxNumStr,
                                out hv_CurrentRunningMeasures);
                        }
                        //
                        //Loop over the area ranges.
                        for (hv_AreaIdx = 0; (int)hv_AreaIdx <= (int)((new HTuple(hv_AreaNames.TupleLength()
                            )) - 1); hv_AreaIdx = (int)hv_AreaIdx + 1)
                        {
                            //
                            //Get information about the current area range.
                            hv_MinArea.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_MinArea = hv_MinAreas.TupleSelect(
                                    hv_AreaIdx);
                            }
                            hv_MaxArea.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_MaxArea = hv_MaxAreas.TupleSelect(
                                    hv_AreaIdx);
                            }
                            hv_AreaName.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_AreaName = hv_AreaNames.TupleSelect(
                                    hv_AreaIdx);
                            }
                            //
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_AreaRunningMeasures.Dispose();
                                HOperatorSet.GetDictTuple(hv_CurrentRunningMeasures, "area_" + hv_AreaName,
                                    out hv_AreaRunningMeasures);
                            }
                            //
                            //Set ignore-flag for ground truth instances.
                            hv_GtIgnore.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_GtIgnore = HTuple.TupleGenConst(
                                    hv_NumGT, 0);
                            }
                            //
                            //Ignore ground truth instances with area outside the area range.
                            if ((int)(new HTuple(hv_NumGT.TupleGreater(0))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_GtIgnoreInds.Dispose();
                                    HOperatorSet.TupleFind(((hv_GtAreas.TupleLessElem(hv_MinArea))).TupleOr(
                                        hv_GtAreas.TupleGreaterElem(hv_MaxArea)), 1, out hv_GtIgnoreInds);
                                }
                                if ((int)(new HTuple(hv_GtIgnoreInds.TupleGreater(-1))) != 0)
                                {
                                    if (hv_GtIgnore == null)
                                        hv_GtIgnore = new HTuple();
                                    hv_GtIgnore[hv_GtIgnoreInds] = 1;
                                }
                            }
                            //
                            hv_PerClassNumGt.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_gt", out hv_PerClassNumGt);
                            hv_PerClassNumPred.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_pred", out hv_PerClassNumPred);
                            hv_PerClassConfidences.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "confidence", out hv_PerClassConfidences);
                            hv_PerClassNumGtIgnore.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_gt_ignore", out hv_PerClassNumGtIgnore);
                            //
                            if ((int)(hv_DetailedEvaluation) != 0)
                            {
                                //Store if a sample has at least one false positive or false negative (for each IoU threshold).
                                hv_SampleHasFP.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_SampleHasFP = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_SampleHasFN.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_SampleHasFN = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                            }
                            //
                            //Loop over the classes.
                            HTuple end_val112 = hv_NumClasses - 1;
                            HTuple step_val112 = 1;
                            for (hv_ClsIdx = 0; hv_ClsIdx.Continue(end_val112, step_val112); hv_ClsIdx = hv_ClsIdx.TupleAdd(step_val112))
                            {
                                hv_CurrentClassID.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentClassID = hv_ClassIDs.TupleSelect(
                                        hv_ClsIdx);
                                }
                                //
                                //Get the ground truth for this class.
                                hv_CurrentGtIdxs.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentGtIdxs = hv_GtClassIDs.TupleFind(
                                        hv_CurrentClassID);
                                }
                                if ((int)(new HTuple(hv_CurrentGtIdxs.TupleEqual(-1))) != 0)
                                {
                                    hv_CurrentGtIdxs.Dispose();
                                    hv_CurrentGtIdxs = new HTuple();
                                }
                                hv_CurrentNumGt.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentNumGt = new HTuple(hv_CurrentGtIdxs.TupleLength()
                                        );
                                }
                                //
                                //Get ground truth ignore for this class.
                                hv_CurrentGtIgnore.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentGtIgnore = hv_GtIgnore.TupleSelect(
                                        hv_CurrentGtIdxs);
                                }
                                if ((int)(new HTuple((new HTuple(hv_CurrentGtIgnore.TupleLength())).TupleEqual(
                                    0))) != 0)
                                {
                                    hv_CurrentNumGtIgnore.Dispose();
                                    hv_CurrentNumGtIgnore = 0;
                                }
                                else
                                {
                                    hv_CurrentNumGtIgnore.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_CurrentNumGtIgnore = hv_CurrentGtIgnore.TupleSum()
                                            ;
                                    }
                                }
                                //
                                //Number of gt for this class and without ignore.
                                hv_CurrentNumGtNoIgnore.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentNumGtNoIgnore = hv_CurrentNumGt - hv_CurrentNumGtIgnore;
                                }
                                //
                                //Get results for this class.
                                hv_CurrentResIdxs.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentResIdxs = hv_ResClassIDs.TupleFind(
                                        hv_CurrentClassID);
                                }
                                if ((int)(new HTuple(hv_CurrentResIdxs.TupleEqual(-1))) != 0)
                                {
                                    hv_CurrentResIdxs.Dispose();
                                    hv_CurrentResIdxs = new HTuple();
                                }
                                hv_CurrentNumRes.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentNumRes = hv_MaxNum.TupleMin2(
                                        new HTuple(hv_CurrentResIdxs.TupleLength()));
                                }
                                //MaxNum -1 corresponds to taking all results.
                                if ((int)(new HTuple(hv_MaxNum.TupleEqual(-1))) != 0)
                                {
                                    hv_CurrentNumRes.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_CurrentNumRes = new HTuple(hv_CurrentResIdxs.TupleLength()
                                            );
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_CurrentResIdxs = hv_CurrentResIdxs.TupleSelectRange(
                                            0, hv_CurrentNumRes - 1);
                                        hv_CurrentResIdxs.Dispose();
                                        hv_CurrentResIdxs = ExpTmpLocalVar_CurrentResIdxs;
                                    }
                                }
                                //
                                //Get areas of the current results.
                                hv_CurrentResAreas.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentResAreas = hv_ResAreas.TupleSelect(
                                        hv_CurrentResIdxs);
                                }
                                //
                                //Update the confidences, num_gt and num_pred for this class.
                                hv_OldNumPred.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_OldNumPred = hv_PerClassNumPred.TupleSelect(
                                        hv_ClsIdx);
                                }
                                if (hv_PerClassNumGt == null)
                                    hv_PerClassNumGt = new HTuple();
                                hv_PerClassNumGt[hv_ClsIdx] = (hv_PerClassNumGt.TupleSelect(hv_ClsIdx)) + hv_CurrentNumGt;
                                if (hv_PerClassNumGtIgnore == null)
                                    hv_PerClassNumGtIgnore = new HTuple();
                                hv_PerClassNumGtIgnore[hv_ClsIdx] = (hv_PerClassNumGtIgnore.TupleSelect(
                                    hv_ClsIdx)) + hv_CurrentNumGtIgnore;
                                if (hv_PerClassNumPred == null)
                                    hv_PerClassNumPred = new HTuple();
                                hv_PerClassNumPred[hv_ClsIdx] = (hv_PerClassNumPred.TupleSelect(hv_ClsIdx)) + hv_CurrentNumRes;
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentClassConfidences.Dispose();
                                    HOperatorSet.GetDictTuple(hv_PerClassConfidences, "class_" + (hv_ClassIDs.TupleSelect(
                                        hv_ClsIdx)), out hv_CurrentClassConfidences);
                                }
                                //Confidences are allocated in blocks of AllocationBlockLength. Therefore, we have to check
                                //if the allocated block is long enough, otherwise allocate a new block.
                                if ((int)(new HTuple(((hv_PerClassNumPred.TupleSelect(hv_ClsIdx))).TupleGreater(
                                    new HTuple(hv_CurrentClassConfidences.TupleLength())))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_CurrentClassConfidences = hv_CurrentClassConfidences.TupleConcat(
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                            hv_CurrentClassConfidences.Dispose();
                                            hv_CurrentClassConfidences = ExpTmpLocalVar_CurrentClassConfidences;
                                        }
                                    }
                                }
                                if (hv_CurrentClassConfidences == null)
                                    hv_CurrentClassConfidences = new HTuple();
                                hv_CurrentClassConfidences[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                    hv_ClsIdx)) - 1, 1)] = hv_Confidences.TupleSelect(hv_CurrentResIdxs);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_PerClassConfidences, "class_" + (hv_ClassIDs.TupleSelect(
                                        hv_ClsIdx)), hv_CurrentClassConfidences);
                                }
                                //
                                //Sort the ground truth: Non-ignored instances first.
                                hv_GtSortIdx.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_GtSortIdx = hv_CurrentGtIgnore.TupleSortIndex()
                                        ;
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_CurrentGtIgnore = hv_CurrentGtIgnore.TupleSelect(
                                            hv_GtSortIdx);
                                        hv_CurrentGtIgnore.Dispose();
                                        hv_CurrentGtIgnore = ExpTmpLocalVar_CurrentGtIgnore;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_CurrentGtIdxs = hv_CurrentGtIdxs.TupleSelect(
                                            hv_GtSortIdx);
                                        hv_CurrentGtIdxs.Dispose();
                                        hv_CurrentGtIdxs = ExpTmpLocalVar_CurrentGtIdxs;
                                    }
                                }
                                //
                                //Get orientations of result and ground truth instances.
                                if ((int)(hv_EvaluateOrientation) != 0)
                                {
                                    hv_CurrentResPhis.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_CurrentResPhis = hv_ResPhis.TupleSelect(
                                            hv_CurrentResIdxs);
                                    }
                                    hv_CurrentGtPhis.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_CurrentGtPhis = hv_GtPhis.TupleSelect(
                                            hv_CurrentGtIdxs);
                                    }
                                }
                                //
                                if ((int)(new HTuple(hv_CurrentNumRes.TupleGreater(0))) != 0)
                                {
                                    //Loop over IoU thresholds.
                                    for (hv_ITIdx = 0; (int)hv_ITIdx <= (int)((new HTuple(hv_IoUThresholds.TupleLength()
                                        )) - 1); hv_ITIdx = (int)hv_ITIdx + 1)
                                    {
                                        //We check which ground truth and
                                        //result instance can be matched.
                                        hv_GtMatched.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_GtMatched = HTuple.TupleGenConst(
                                                hv_CurrentNumGt, 0);
                                        }
                                        hv_ResMatched.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_ResMatched = HTuple.TupleGenConst(
                                                hv_CurrentNumRes, 0);
                                        }
                                        //
                                        if ((int)(hv_EvaluateOrientation) != 0)
                                        {
                                            //Initialize the absolute orientation difference to -1.
                                            hv_ResAbsOrientationDiff.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ResAbsOrientationDiff = HTuple.TupleGenConst(
                                                    hv_CurrentNumRes, -1);
                                            }
                                        }
                                        //Store which detections should be ignored.
                                        hv_ResIgnore.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_ResIgnore = HTuple.TupleGenConst(
                                                hv_CurrentNumRes, 0);
                                        }
                                        HTuple end_val187 = hv_CurrentNumRes - 1;
                                        HTuple step_val187 = 1;
                                        for (hv_ResIdx = 0; hv_ResIdx.Continue(end_val187, step_val187); hv_ResIdx = hv_ResIdx.TupleAdd(step_val187))
                                        {
                                            //Set the currently best achieved IoU to the IoU threshold and
                                            //initialize the matching index.
                                            hv_CurrentIoU.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_CurrentIoU = ((hv_IoUThresholds.TupleSelect(
                                                    hv_ITIdx))).TupleMin2(1 - 1.0e-10);
                                            }
                                            hv_MatchIdx.Dispose();
                                            hv_MatchIdx = -1;
                                            //Loop over ground truth.
                                            HTuple end_val193 = hv_CurrentNumGt - 1;
                                            HTuple step_val193 = 1;
                                            for (hv_GtIdx = 0; hv_GtIdx.Continue(end_val193, step_val193); hv_GtIdx = hv_GtIdx.TupleAdd(step_val193))
                                            {
                                                //Continue if this ground truth has already been matched.
                                                if ((int)(hv_GtMatched.TupleSelect(hv_GtIdx)) != 0)
                                                {
                                                    continue;
                                                }
                                                //Stop if matched with non-ignored ground truth and current ground truth is on ignore.
                                                if ((int)(new HTuple(hv_MatchIdx.TupleGreater(-1))) != 0)
                                                {
                                                    if ((int)((new HTuple(((hv_CurrentGtIgnore.TupleSelect(hv_MatchIdx))).TupleEqual(
                                                        0))).TupleAnd(new HTuple(((hv_CurrentGtIgnore.TupleSelect(
                                                        hv_GtIdx))).TupleEqual(1)))) != 0)
                                                    {
                                                        break;
                                                    }
                                                }
                                                //Continue if IoU is not better than a previous match.
                                                if ((int)(new HTuple(((hv_IoUs.TupleSelect(((hv_CurrentGtIdxs.TupleSelect(
                                                    hv_GtIdx)) * hv_NumRes) + (hv_CurrentResIdxs.TupleSelect(hv_ResIdx))))).TupleLess(
                                                    hv_CurrentIoU))) != 0)
                                                {
                                                    continue;
                                                }
                                                //We got a new best match, store it.
                                                hv_CurrentIoU.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_CurrentIoU = hv_IoUs.TupleSelect(
                                                        ((hv_CurrentGtIdxs.TupleSelect(hv_GtIdx)) * hv_NumRes) + (hv_CurrentResIdxs.TupleSelect(
                                                        hv_ResIdx)));
                                                }
                                                hv_MatchIdx.Dispose();
                                                hv_MatchIdx = new HTuple(hv_GtIdx);
                                            }
                                            //If a match has been made we store it for both ground truth and result.
                                            if ((int)(new HTuple(hv_MatchIdx.TupleNotEqual(-1))) != 0)
                                            {
                                                //In COCO they use the IDs of GT and Res, we just use 1
                                                //to indicate the matching, but don't store which one has been matched.
                                                if (hv_ResMatched == null)
                                                    hv_ResMatched = new HTuple();
                                                hv_ResMatched[hv_ResIdx] = 1;
                                                if (hv_GtMatched == null)
                                                    hv_GtMatched = new HTuple();
                                                hv_GtMatched[hv_MatchIdx] = 1;
                                                if (hv_ResIgnore == null)
                                                    hv_ResIgnore = new HTuple();
                                                hv_ResIgnore[hv_ResIdx] = hv_CurrentGtIgnore.TupleSelect(hv_MatchIdx);
                                                //
                                                if ((int)(hv_EvaluateOrientation) != 0)
                                                {
                                                    //Set the absolute orientation difference.
                                                    if (hv_ResAbsOrientationDiff == null)
                                                        hv_ResAbsOrientationDiff = new HTuple();
                                                    hv_ResAbsOrientationDiff[hv_ResIdx] = (((hv_CurrentResPhis.TupleSelect(
                                                        hv_ResIdx)) - (hv_CurrentGtPhis.TupleSelect(hv_MatchIdx)))).TupleAbs()
                                                        ;
                                                    if ((int)(new HTuple(((hv_ResAbsOrientationDiff.TupleSelect(
                                                        hv_ResIdx))).TupleGreater((new HTuple(180)).TupleRad()
                                                        ))) != 0)
                                                    {
                                                        if (hv_ResAbsOrientationDiff == null)
                                                            hv_ResAbsOrientationDiff = new HTuple();
                                                        hv_ResAbsOrientationDiff[hv_ResIdx] = ((new HTuple(360)).TupleRad()
                                                            ) - (hv_ResAbsOrientationDiff.TupleSelect(hv_ResIdx));
                                                    }
                                                }
                                            }
                                        }
                                        //Ignore the unmatched results that are outside of the current area range.
                                        hv_AreaIgnore.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_AreaIgnore = ((hv_CurrentResAreas.TupleLessElem(
                                                hv_MinArea))).TupleOr(hv_CurrentResAreas.TupleGreaterElem(hv_MaxArea));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_ResIgnore = (new HTuple(((hv_ResMatched.TupleEqualElem(
                                                    -1))).TupleAnd(hv_AreaIgnore.TupleEqualElem(1)))).TupleOr(hv_ResIgnore);
                                                hv_ResIgnore.Dispose();
                                                hv_ResIgnore = ExpTmpLocalVar_ResIgnore;
                                            }
                                        }
                                        //True positives are the matched results.
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_PerIoUMeasure.Dispose();
                                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                                hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUMeasure);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_PerClassMeasures.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "class_" + (hv_ClassIDs.TupleSelect(
                                                hv_ClsIdx)), out hv_PerClassMeasures);
                                        }
                                        hv_CurrentIsTP.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_tp", out hv_CurrentIsTP);
                                        //As for confidences, check if we have to allocate a new block.
                                        if ((int)(new HTuple(((hv_PerClassNumPred.TupleSelect(hv_ClsIdx))).TupleGreater(
                                            new HTuple(hv_CurrentIsTP.TupleLength())))) != 0)
                                        {
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                {
                                                    HTuple
                                                      ExpTmpLocalVar_CurrentIsTP = hv_CurrentIsTP.TupleConcat(
                                                        HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                    hv_CurrentIsTP.Dispose();
                                                    hv_CurrentIsTP = ExpTmpLocalVar_CurrentIsTP;
                                                }
                                            }
                                        }
                                        if (hv_CurrentIsTP == null)
                                            hv_CurrentIsTP = new HTuple();
                                        hv_CurrentIsTP[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                            hv_ClsIdx)) - 1, 1)] = hv_ResMatched;
                                        HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_tp", hv_CurrentIsTP);
                                        //Set the ignored results.
                                        hv_CurrentIgnore.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerClassMeasures, "ignore", out hv_CurrentIgnore);
                                        if ((int)(new HTuple(((hv_PerClassNumPred.TupleSelect(hv_ClsIdx))).TupleGreater(
                                            new HTuple(hv_CurrentIgnore.TupleLength())))) != 0)
                                        {
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                {
                                                    HTuple
                                                      ExpTmpLocalVar_CurrentIgnore = hv_CurrentIgnore.TupleConcat(
                                                        HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                    hv_CurrentIgnore.Dispose();
                                                    hv_CurrentIgnore = ExpTmpLocalVar_CurrentIgnore;
                                                }
                                            }
                                        }
                                        if (hv_CurrentIgnore == null)
                                            hv_CurrentIgnore = new HTuple();
                                        hv_CurrentIgnore[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                            hv_ClsIdx)) - 1, 1)] = hv_ResIgnore;
                                        HOperatorSet.SetDictTuple(hv_PerClassMeasures, "ignore", hv_CurrentIgnore);
                                        //Set the absolute orientation difference.
                                        if ((int)(hv_EvaluateOrientation) != 0)
                                        {
                                            hv_CurrentAbsOrientationDiff.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerClassMeasures, "abs_orientation_diff",
                                                out hv_CurrentAbsOrientationDiff);
                                            if ((int)(new HTuple(((hv_PerClassNumPred.TupleSelect(hv_ClsIdx))).TupleGreater(
                                                new HTuple(hv_CurrentAbsOrientationDiff.TupleLength())))) != 0)
                                            {
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_CurrentAbsOrientationDiff = hv_CurrentAbsOrientationDiff.TupleConcat(
                                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                        hv_CurrentAbsOrientationDiff.Dispose();
                                                        hv_CurrentAbsOrientationDiff = ExpTmpLocalVar_CurrentAbsOrientationDiff;
                                                    }
                                                }
                                            }
                                            if (hv_CurrentAbsOrientationDiff == null)
                                                hv_CurrentAbsOrientationDiff = new HTuple();
                                            hv_CurrentAbsOrientationDiff[HTuple.TupleGenSequence(hv_OldNumPred,
                                                (hv_PerClassNumPred.TupleSelect(hv_ClsIdx)) - 1, 1)] = hv_ResAbsOrientationDiff;
                                            HOperatorSet.SetDictTuple(hv_PerClassMeasures, "abs_orientation_diff",
                                                hv_CurrentAbsOrientationDiff);
                                        }
                                        //
                                        //Beginning of detailed evaluation processing (optional).
                                        //
                                        if ((int)(hv_DetailedEvaluation) != 0)
                                        {
                                            //Check if there have been false negatives.
                                            if ((int)(new HTuple(hv_CurrentNumGtNoIgnore.TupleGreater(0))) != 0)
                                            {
                                                hv_GtMatchedNoIgnore.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_GtMatchedNoIgnore = hv_GtMatched.TupleAnd(
                                                        hv_CurrentGtIgnore.TupleNot());
                                                }
                                                if ((int)(new HTuple(((hv_GtMatchedNoIgnore.TupleSum())).TupleLess(
                                                    hv_CurrentNumGtNoIgnore))) != 0)
                                                {
                                                    if (hv_SampleHasFN == null)
                                                        hv_SampleHasFN = new HTuple();
                                                    hv_SampleHasFN[hv_ITIdx] = 1;
                                                }
                                            }
                                            //
                                            //Initialize the detailed running measures.
                                            hv_ResIsFPClass.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ResIsFPClass = HTuple.TupleGenConst(
                                                    hv_CurrentNumRes, -1);
                                            }
                                            hv_ResIsFPBackground.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ResIsFPBackground = HTuple.TupleGenConst(
                                                    hv_CurrentNumRes, 0);
                                            }
                                            hv_ResIsFPLocalization.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ResIsFPLocalization = HTuple.TupleGenConst(
                                                    hv_CurrentNumRes, 0);
                                            }
                                            hv_ResIsFPDuplicate.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ResIsFPDuplicate = HTuple.TupleGenConst(
                                                    hv_CurrentNumRes, 0);
                                            }
                                            hv_ResIsFPMultiple.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ResIsFPMultiple = HTuple.TupleGenConst(
                                                    hv_CurrentNumRes, 0);
                                            }
                                            //
                                            //Initialize detailed running measures for orientation difference.
                                            if ((int)(hv_EvaluateOrientation) != 0)
                                            {
                                                hv_ResAbsOrientationDiffClass.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_ResAbsOrientationDiffClass = HTuple.TupleGenConst(
                                                        hv_CurrentNumRes, -1);
                                                }
                                                hv_ResAbsOrientationDiffLocalization.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_ResAbsOrientationDiffLocalization = HTuple.TupleGenConst(
                                                        hv_CurrentNumRes, -1);
                                                }
                                                hv_ResAbsOrientationDiffDuplicate.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_ResAbsOrientationDiffDuplicate = HTuple.TupleGenConst(
                                                        hv_CurrentNumRes, -1);
                                                }
                                                hv_ResAbsOrientationDiffMultiple.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_ResAbsOrientationDiffMultiple = HTuple.TupleGenConst(
                                                        hv_CurrentNumRes, -1);
                                                }
                                            }
                                            //Check if there have been false positives.
                                            if ((int)(new HTuple(((hv_ResMatched.TupleSum())).TupleLess(hv_CurrentNumRes))) != 0)
                                            {
                                                if (hv_SampleHasFP == null)
                                                    hv_SampleHasFP = new HTuple();
                                                hv_SampleHasFP[hv_ITIdx] = 1;
                                                //
                                                //For each false positive, find out what was the reason for being false positive:
                                                hv_FPResIdxsThisClass.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_FPResIdxsThisClass = hv_ResMatched.TupleFind(
                                                        0);
                                                }
                                                hv_FPResIdxsAllResults.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_FPResIdxsAllResults = hv_CurrentResIdxs.TupleSelect(
                                                        hv_FPResIdxsThisClass);
                                                }
                                                hv_GTIdxsNotToIgnore.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_GTIdxsNotToIgnore = hv_GtIgnore.TupleFind(
                                                        0);
                                                }
                                                for (hv_ResIdx = 0; (int)hv_ResIdx <= (int)((new HTuple(hv_FPResIdxsThisClass.TupleLength()
                                                    )) - 1); hv_ResIdx = (int)hv_ResIdx + 1)
                                                {
                                                    if ((int)(((hv_ResIgnore.TupleSelect(hv_FPResIdxsThisClass.TupleSelect(
                                                        hv_ResIdx)))).TupleNot()) != 0)
                                                    {
                                                        if ((int)((new HTuple((new HTuple(hv_GTIdxsNotToIgnore.TupleLength()
                                                            )).TupleEqual(0))).TupleOr(new HTuple(hv_GTIdxsNotToIgnore.TupleEqual(
                                                            -1)))) != 0)
                                                        {
                                                            //No GT instances or all GT instances are ignored.
                                                            //Thus, any detection is a background detection
                                                            hv_MaxIoU.Dispose();
                                                            hv_MaxIoU = 0.0;
                                                        }
                                                        else
                                                        {
                                                            //We have GT instances to consider.
                                                            hv_IoUsWithGT.Dispose();
                                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                            {
                                                                hv_IoUsWithGT = hv_IoUs.TupleSelect(
                                                                    (hv_GTIdxsNotToIgnore * hv_NumRes) + (hv_FPResIdxsAllResults.TupleSelect(
                                                                    hv_ResIdx)));
                                                            }
                                                            hv_MaxIoU.Dispose();
                                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                            {
                                                                hv_MaxIoU = hv_IoUsWithGT.TupleMax()
                                                                    ;
                                                            }
                                                            //It is enough to look for the first occurrence because the IoUs to ground truth should be different.
                                                            hv_MaxIdx.Dispose();
                                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                            {
                                                                hv_MaxIdx = hv_IoUsWithGT.TupleFindFirst(
                                                                    hv_MaxIoU);
                                                            }
                                                            hv_GTClassIDMaxIoU.Dispose();
                                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                            {
                                                                hv_GTClassIDMaxIoU = hv_GtClassIDs.TupleSelect(
                                                                    hv_GTIdxsNotToIgnore.TupleSelect(hv_MaxIdx));
                                                            }
                                                        }
                                                        if ((int)(hv_EvaluateOrientation.TupleAnd(new HTuple(hv_MaxIoU.TupleGreater(
                                                            0.0)))) != 0)
                                                        {
                                                            //Calculate the absolute orientation difference to the GT instance with maximal IoU.
                                                            hv_AbsOrientationDiff.Dispose();
                                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                            {
                                                                hv_AbsOrientationDiff = (((hv_ResPhis.TupleSelect(
                                                                    hv_FPResIdxsAllResults.TupleSelect(hv_ResIdx))) - (hv_GtPhis.TupleSelect(
                                                                    hv_GTIdxsNotToIgnore.TupleSelect(hv_MaxIdx))))).TupleAbs()
                                                                    ;
                                                            }
                                                            if ((int)(new HTuple(hv_AbsOrientationDiff.TupleGreater(
                                                                (new HTuple(180)).TupleRad()))) != 0)
                                                            {
                                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                                {
                                                                    {
                                                                        HTuple
                                                                          ExpTmpLocalVar_AbsOrientationDiff = ((new HTuple(360)).TupleRad()
                                                                            ) - hv_AbsOrientationDiff;
                                                                        hv_AbsOrientationDiff.Dispose();
                                                                        hv_AbsOrientationDiff = ExpTmpLocalVar_AbsOrientationDiff;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        //Determine false positive type.
                                                        if ((int)(new HTuple(hv_MaxIoU.TupleEqual(0.0))) != 0)
                                                        {
                                                            //Background detection. This detection does not overlap to any ground truth (that is not ignored).
                                                            if (hv_ResIsFPBackground == null)
                                                                hv_ResIsFPBackground = new HTuple();
                                                            hv_ResIsFPBackground[hv_FPResIdxsThisClass.TupleSelect(
                                                                hv_ResIdx)] = 1;
                                                        }
                                                        else if ((int)((new HTuple(hv_MaxIoU.TupleGreaterEqual(
                                                            hv_IoUThresholds.TupleSelect(hv_ITIdx)))).TupleAnd(
                                                            new HTuple(hv_CurrentClassID.TupleNotEqual(hv_GTClassIDMaxIoU)))) != 0)
                                                        {
                                                            //False class.
                                                            //Note that this does not necessarily mean that this detection
                                                            //would be a true positive if the class was changed. It could still be a duplicate.
                                                            if (hv_ResIsFPClass == null)
                                                                hv_ResIsFPClass = new HTuple();
                                                            hv_ResIsFPClass[hv_FPResIdxsThisClass.TupleSelect(hv_ResIdx)] = hv_ClassIDToClassIdx.TupleSelect(
                                                                hv_GTClassIDMaxIoU);
                                                            //Store the absolute orientation difference.
                                                            if ((int)(hv_EvaluateOrientation) != 0)
                                                            {
                                                                if (hv_ResAbsOrientationDiffClass == null)
                                                                    hv_ResAbsOrientationDiffClass = new HTuple();
                                                                hv_ResAbsOrientationDiffClass[hv_FPResIdxsThisClass.TupleSelect(
                                                                    hv_ResIdx)] = hv_AbsOrientationDiff;
                                                            }
                                                        }
                                                        else if ((int)((new HTuple(hv_MaxIoU.TupleGreaterEqual(
                                                            hv_IoUThresholds.TupleSelect(hv_ITIdx)))).TupleAnd(
                                                            new HTuple(hv_CurrentClassID.TupleEqual(hv_GTClassIDMaxIoU)))) != 0)
                                                        {
                                                            //Duplicate detection. There must exist another detection with a higher confidence with the same ground truth.
                                                            if (hv_ResIsFPDuplicate == null)
                                                                hv_ResIsFPDuplicate = new HTuple();
                                                            hv_ResIsFPDuplicate[hv_FPResIdxsThisClass.TupleSelect(
                                                                hv_ResIdx)] = 1;
                                                            //Store the absolute orientation difference.
                                                            if ((int)(hv_EvaluateOrientation) != 0)
                                                            {
                                                                if (hv_ResAbsOrientationDiffDuplicate == null)
                                                                    hv_ResAbsOrientationDiffDuplicate = new HTuple();
                                                                hv_ResAbsOrientationDiffDuplicate[hv_FPResIdxsThisClass.TupleSelect(
                                                                    hv_ResIdx)] = hv_AbsOrientationDiff;
                                                            }
                                                        }
                                                        else if ((int)((new HTuple(hv_MaxIoU.TupleLess(
                                                            hv_IoUThresholds.TupleSelect(hv_ITIdx)))).TupleAnd(
                                                            new HTuple(hv_CurrentClassID.TupleEqual(hv_GTClassIDMaxIoU)))) != 0)
                                                        {
                                                            //Bad localization. Class is correct, but the IoU is too low.
                                                            if (hv_ResIsFPLocalization == null)
                                                                hv_ResIsFPLocalization = new HTuple();
                                                            hv_ResIsFPLocalization[hv_FPResIdxsThisClass.TupleSelect(
                                                                hv_ResIdx)] = 1;
                                                            //Store the absolute orientation difference.
                                                            if ((int)(hv_EvaluateOrientation) != 0)
                                                            {
                                                                if (hv_ResAbsOrientationDiffLocalization == null)
                                                                    hv_ResAbsOrientationDiffLocalization = new HTuple();
                                                                hv_ResAbsOrientationDiffLocalization[hv_FPResIdxsThisClass.TupleSelect(
                                                                    hv_ResIdx)] = hv_AbsOrientationDiff;
                                                            }
                                                        }
                                                        else if ((int)((new HTuple(hv_MaxIoU.TupleLess(
                                                            hv_IoUThresholds.TupleSelect(hv_ITIdx)))).TupleAnd(
                                                            new HTuple(hv_CurrentClassID.TupleNotEqual(hv_GTClassIDMaxIoU)))) != 0)
                                                        {
                                                            //Wrong class and bad localization.
                                                            if (hv_ResIsFPMultiple == null)
                                                                hv_ResIsFPMultiple = new HTuple();
                                                            hv_ResIsFPMultiple[hv_FPResIdxsThisClass.TupleSelect(
                                                                hv_ResIdx)] = 1;
                                                            //Store the absolute orientation difference.
                                                            if ((int)(hv_EvaluateOrientation) != 0)
                                                            {
                                                                if (hv_ResAbsOrientationDiffMultiple == null)
                                                                    hv_ResAbsOrientationDiffMultiple = new HTuple();
                                                                hv_ResAbsOrientationDiffMultiple[hv_FPResIdxsThisClass.TupleSelect(
                                                                    hv_ResIdx)] = hv_AbsOrientationDiff;
                                                            }
                                                        }
                                                        else
                                                        {
                                                            //This case should never occur.
                                                            throw new HalconException("Fatal error during detailed evaluation.");
                                                        }
                                                    }
                                                }
                                            }
                                            //
                                            //Overwrite the detailed running measures.
                                            hv_IsFPClass.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_fp_class",
                                                out hv_IsFPClass);
                                            hv_IsFPBackground.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_fp_background",
                                                out hv_IsFPBackground);
                                            hv_IsFPLocalization.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_fp_localization",
                                                out hv_IsFPLocalization);
                                            hv_IsFPDuplicate.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_fp_duplicate",
                                                out hv_IsFPDuplicate);
                                            hv_IsFPMultiple.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_fp_multiple",
                                                out hv_IsFPMultiple);
                                            if ((int)(hv_EvaluateOrientation) != 0)
                                            {
                                                hv_AbsOrientationDiffMultiple.Dispose();
                                                HOperatorSet.GetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_multiple",
                                                    out hv_AbsOrientationDiffMultiple);
                                                hv_AbsOrientationDiffDuplicate.Dispose();
                                                HOperatorSet.GetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_duplicate",
                                                    out hv_AbsOrientationDiffDuplicate);
                                                hv_AbsOrientationDiffLocalization.Dispose();
                                                HOperatorSet.GetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_localization",
                                                    out hv_AbsOrientationDiffLocalization);
                                                hv_AbsOrientationDiffClass.Dispose();
                                                HOperatorSet.GetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_class",
                                                    out hv_AbsOrientationDiffClass);
                                            }
                                            //Allocate new blocks if necessary (all have the same length).
                                            if ((int)(new HTuple(((hv_PerClassNumPred.TupleSelect(hv_ClsIdx))).TupleGreater(
                                                new HTuple(hv_IsFPClass.TupleLength())))) != 0)
                                            {
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_IsFPClass = hv_IsFPClass.TupleConcat(
                                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                        hv_IsFPClass.Dispose();
                                                        hv_IsFPClass = ExpTmpLocalVar_IsFPClass;
                                                    }
                                                }
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_IsFPBackground = hv_IsFPBackground.TupleConcat(
                                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                        hv_IsFPBackground.Dispose();
                                                        hv_IsFPBackground = ExpTmpLocalVar_IsFPBackground;
                                                    }
                                                }
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_IsFPLocalization = hv_IsFPLocalization.TupleConcat(
                                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                        hv_IsFPLocalization.Dispose();
                                                        hv_IsFPLocalization = ExpTmpLocalVar_IsFPLocalization;
                                                    }
                                                }
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_IsFPDuplicate = hv_IsFPDuplicate.TupleConcat(
                                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                        hv_IsFPDuplicate.Dispose();
                                                        hv_IsFPDuplicate = ExpTmpLocalVar_IsFPDuplicate;
                                                    }
                                                }
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_IsFPMultiple = hv_IsFPMultiple.TupleConcat(
                                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                        hv_IsFPMultiple.Dispose();
                                                        hv_IsFPMultiple = ExpTmpLocalVar_IsFPMultiple;
                                                    }
                                                }
                                                if ((int)(hv_EvaluateOrientation) != 0)
                                                {
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        {
                                                            HTuple
                                                              ExpTmpLocalVar_AbsOrientationDiffMultiple = hv_AbsOrientationDiffMultiple.TupleConcat(
                                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                            hv_AbsOrientationDiffMultiple.Dispose();
                                                            hv_AbsOrientationDiffMultiple = ExpTmpLocalVar_AbsOrientationDiffMultiple;
                                                        }
                                                    }
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        {
                                                            HTuple
                                                              ExpTmpLocalVar_AbsOrientationDiffDuplicate = hv_AbsOrientationDiffDuplicate.TupleConcat(
                                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                            hv_AbsOrientationDiffDuplicate.Dispose();
                                                            hv_AbsOrientationDiffDuplicate = ExpTmpLocalVar_AbsOrientationDiffDuplicate;
                                                        }
                                                    }
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        {
                                                            HTuple
                                                              ExpTmpLocalVar_AbsOrientationDiffLocalization = hv_AbsOrientationDiffLocalization.TupleConcat(
                                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                            hv_AbsOrientationDiffLocalization.Dispose();
                                                            hv_AbsOrientationDiffLocalization = ExpTmpLocalVar_AbsOrientationDiffLocalization;
                                                        }
                                                    }
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        {
                                                            HTuple
                                                              ExpTmpLocalVar_AbsOrientationDiffClass = hv_AbsOrientationDiffClass.TupleConcat(
                                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                            hv_AbsOrientationDiffClass.Dispose();
                                                            hv_AbsOrientationDiffClass = ExpTmpLocalVar_AbsOrientationDiffClass;
                                                        }
                                                    }
                                                }
                                            }
                                            if (hv_IsFPClass == null)
                                                hv_IsFPClass = new HTuple();
                                            hv_IsFPClass[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                                hv_ClsIdx)) - 1, 1)] = hv_ResIsFPClass;
                                            if (hv_IsFPBackground == null)
                                                hv_IsFPBackground = new HTuple();
                                            hv_IsFPBackground[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                                hv_ClsIdx)) - 1, 1)] = hv_ResIsFPBackground;
                                            if (hv_IsFPLocalization == null)
                                                hv_IsFPLocalization = new HTuple();
                                            hv_IsFPLocalization[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                                hv_ClsIdx)) - 1, 1)] = hv_ResIsFPLocalization;
                                            if (hv_IsFPDuplicate == null)
                                                hv_IsFPDuplicate = new HTuple();
                                            hv_IsFPDuplicate[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                                hv_ClsIdx)) - 1, 1)] = hv_ResIsFPDuplicate;
                                            if (hv_IsFPMultiple == null)
                                                hv_IsFPMultiple = new HTuple();
                                            hv_IsFPMultiple[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                                hv_ClsIdx)) - 1, 1)] = hv_ResIsFPMultiple;
                                            if ((int)(hv_EvaluateOrientation) != 0)
                                            {
                                                if (hv_AbsOrientationDiffMultiple == null)
                                                    hv_AbsOrientationDiffMultiple = new HTuple();
                                                hv_AbsOrientationDiffMultiple[HTuple.TupleGenSequence(hv_OldNumPred,
                                                    (hv_PerClassNumPred.TupleSelect(hv_ClsIdx)) - 1, 1)] = hv_ResAbsOrientationDiffMultiple;
                                                if (hv_AbsOrientationDiffDuplicate == null)
                                                    hv_AbsOrientationDiffDuplicate = new HTuple();
                                                hv_AbsOrientationDiffDuplicate[HTuple.TupleGenSequence(hv_OldNumPred,
                                                    (hv_PerClassNumPred.TupleSelect(hv_ClsIdx)) - 1, 1)] = hv_ResAbsOrientationDiffDuplicate;
                                                if (hv_AbsOrientationDiffLocalization == null)
                                                    hv_AbsOrientationDiffLocalization = new HTuple();
                                                hv_AbsOrientationDiffLocalization[HTuple.TupleGenSequence(hv_OldNumPred,
                                                    (hv_PerClassNumPred.TupleSelect(hv_ClsIdx)) - 1, 1)] = hv_ResAbsOrientationDiffLocalization;
                                                if (hv_AbsOrientationDiffClass == null)
                                                    hv_AbsOrientationDiffClass = new HTuple();
                                                hv_AbsOrientationDiffClass[HTuple.TupleGenSequence(hv_OldNumPred,
                                                    (hv_PerClassNumPred.TupleSelect(hv_ClsIdx)) - 1, 1)] = hv_ResAbsOrientationDiffClass;
                                            }
                                            HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_fp_class",
                                                hv_IsFPClass);
                                            HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_fp_background",
                                                hv_IsFPBackground);
                                            HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_fp_localization",
                                                hv_IsFPLocalization);
                                            HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_fp_duplicate",
                                                hv_IsFPDuplicate);
                                            HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_fp_multiple",
                                                hv_IsFPMultiple);
                                            if ((int)(hv_EvaluateOrientation) != 0)
                                            {
                                                HOperatorSet.SetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_multiple",
                                                    hv_AbsOrientationDiffMultiple);
                                                HOperatorSet.SetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_duplicate",
                                                    hv_AbsOrientationDiffDuplicate);
                                                HOperatorSet.SetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_localization",
                                                    hv_AbsOrientationDiffLocalization);
                                                HOperatorSet.SetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_class",
                                                    hv_AbsOrientationDiffClass);
                                            }
                                        }
                                        //
                                        //End of detailed evaluation processing.
                                        //
                                    }
                                }
                                else
                                {
                                    if ((int)(hv_DetailedEvaluation.TupleAnd(new HTuple(hv_CurrentNumGtNoIgnore.TupleGreater(
                                        0)))) != 0)
                                    {
                                        //There are false negatives for this class.
                                        //Loop over IoU thresholds.
                                        for (hv_ITIdx = 0; (int)hv_ITIdx <= (int)((new HTuple(hv_IoUThresholds.TupleLength()
                                            )) - 1); hv_ITIdx = (int)hv_ITIdx + 1)
                                        {
                                            if (hv_SampleHasFN == null)
                                                hv_SampleHasFN = new HTuple();
                                            hv_SampleHasFN[hv_ITIdx] = 1;
                                        }
                                    }
                                }
                            }
                            //Update the confidences, num_gt and num_pred.
                            HOperatorSet.SetDictTuple(hv_AreaRunningMeasures, "num_gt", hv_PerClassNumGt);
                            HOperatorSet.SetDictTuple(hv_AreaRunningMeasures, "num_pred", hv_PerClassNumPred);
                            HOperatorSet.SetDictTuple(hv_AreaRunningMeasures, "confidence", hv_PerClassConfidences);
                            HOperatorSet.SetDictTuple(hv_AreaRunningMeasures, "num_gt_ignore", hv_PerClassNumGtIgnore);
                            //
                            if ((int)(hv_DetailedEvaluation) != 0)
                            {
                                //Set values that are calculated over all classes (for each IoU threshold).
                                for (hv_ITIdx = 0; (int)hv_ITIdx <= (int)((new HTuple(hv_IoUThresholds.TupleLength()
                                    )) - 1); hv_ITIdx = (int)hv_ITIdx + 1)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUMeasure.Dispose();
                                        HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                            hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUMeasure);
                                    }
                                    //Set image IDs with false negatives
                                    if ((int)(hv_SampleHasFN.TupleSelect(hv_ITIdx)) != 0)
                                    {
                                        hv_CurrentImageID.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentSample, "image_id", out hv_CurrentImageID);
                                        hv_ImageIDsWithFN.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_negatives",
                                            out hv_ImageIDsWithFN);
                                        hv_NumImageIDsWithFN.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_negatives",
                                            out hv_NumImageIDsWithFN);
                                        //Allocate a new block if necessary.
                                        if ((int)(new HTuple(((hv_NumImageIDsWithFN + 1)).TupleGreater(new HTuple(hv_ImageIDsWithFN.TupleLength()
                                            )))) != 0)
                                        {
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                {
                                                    HTuple
                                                      ExpTmpLocalVar_ImageIDsWithFN = hv_ImageIDsWithFN.TupleConcat(
                                                        HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                    hv_ImageIDsWithFN.Dispose();
                                                    hv_ImageIDsWithFN = ExpTmpLocalVar_ImageIDsWithFN;
                                                }
                                            }
                                        }
                                        if (hv_ImageIDsWithFN == null)
                                            hv_ImageIDsWithFN = new HTuple();
                                        hv_ImageIDsWithFN[hv_NumImageIDsWithFN] = hv_CurrentImageID;
                                        HOperatorSet.SetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_negatives",
                                            hv_ImageIDsWithFN);
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_negatives",
                                                hv_NumImageIDsWithFN + 1);
                                        }
                                    }
                                    if ((int)(hv_SampleHasFP.TupleSelect(hv_ITIdx)) != 0)
                                    {
                                        hv_CurrentImageID.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentSample, "image_id", out hv_CurrentImageID);
                                        hv_ImageIDsWithFP.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_positives",
                                            out hv_ImageIDsWithFP);
                                        hv_NumImageIDsWithFP.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_positives",
                                            out hv_NumImageIDsWithFP);
                                        //Allocate a new block if necessary.
                                        if ((int)(new HTuple(((hv_NumImageIDsWithFP + 1)).TupleGreater(new HTuple(hv_ImageIDsWithFP.TupleLength()
                                            )))) != 0)
                                        {
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                {
                                                    HTuple
                                                      ExpTmpLocalVar_ImageIDsWithFP = hv_ImageIDsWithFP.TupleConcat(
                                                        HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                    hv_ImageIDsWithFP.Dispose();
                                                    hv_ImageIDsWithFP = ExpTmpLocalVar_ImageIDsWithFP;
                                                }
                                            }
                                        }
                                        if (hv_ImageIDsWithFP == null)
                                            hv_ImageIDsWithFP = new HTuple();
                                        hv_ImageIDsWithFP[hv_NumImageIDsWithFP] = hv_CurrentImageID;
                                        HOperatorSet.SetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_positives",
                                            hv_ImageIDsWithFP);
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_positives",
                                                hv_NumImageIDsWithFP + 1);
                                        }
                                    }
                                }
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_CurrentRunningMeasures, "area_" + hv_AreaName,
                                hv_AreaRunningMeasures);
                        }
                    }
                }
                //

                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_IoUThresholds.Dispose();
                hv_InstanceType.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClasses.Dispose();
                hv_Measures.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_NumAreaRanges.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_KeyExists.Dispose();
                hv_ClassIDToClassIdx.Dispose();
                hv_EvaluateOrientation.Dispose();
                hv_SIdx.Dispose();
                hv_CurrentSample.Dispose();
                hv_CurrentResult.Dispose();
                hv_GtClassIDs.Dispose();
                hv_ResClassIDs.Dispose();
                hv_NumGT.Dispose();
                hv_NumRes.Dispose();
                hv_Confidences.Dispose();
                hv_ResSortIndices.Dispose();
                hv_GtAreas.Dispose();
                hv_ResAreas.Dispose();
                hv_IoUs.Dispose();
                hv_GtPhis.Dispose();
                hv_ResPhis.Dispose();
                hv_MDIdx.Dispose();
                hv_MaxNum.Dispose();
                hv_MaxNumStr.Dispose();
                hv_CurrentRunningMeasures.Dispose();
                hv_AreaIdx.Dispose();
                hv_MinArea.Dispose();
                hv_MaxArea.Dispose();
                hv_AreaName.Dispose();
                hv_AreaRunningMeasures.Dispose();
                hv_GtIgnore.Dispose();
                hv_GtIgnoreInds.Dispose();
                hv_PerClassNumGt.Dispose();
                hv_PerClassNumPred.Dispose();
                hv_PerClassConfidences.Dispose();
                hv_PerClassNumGtIgnore.Dispose();
                hv_SampleHasFP.Dispose();
                hv_SampleHasFN.Dispose();
                hv_ClsIdx.Dispose();
                hv_CurrentClassID.Dispose();
                hv_CurrentGtIdxs.Dispose();
                hv_CurrentNumGt.Dispose();
                hv_CurrentGtIgnore.Dispose();
                hv_CurrentNumGtIgnore.Dispose();
                hv_CurrentNumGtNoIgnore.Dispose();
                hv_CurrentResIdxs.Dispose();
                hv_CurrentNumRes.Dispose();
                hv_CurrentResAreas.Dispose();
                hv_OldNumPred.Dispose();
                hv_CurrentClassConfidences.Dispose();
                hv_GtSortIdx.Dispose();
                hv_CurrentResPhis.Dispose();
                hv_CurrentGtPhis.Dispose();
                hv_ITIdx.Dispose();
                hv_GtMatched.Dispose();
                hv_ResMatched.Dispose();
                hv_ResAbsOrientationDiff.Dispose();
                hv_ResIgnore.Dispose();
                hv_ResIdx.Dispose();
                hv_CurrentIoU.Dispose();
                hv_MatchIdx.Dispose();
                hv_GtIdx.Dispose();
                hv_AreaIgnore.Dispose();
                hv_PerIoUMeasure.Dispose();
                hv_PerClassMeasures.Dispose();
                hv_CurrentIsTP.Dispose();
                hv_CurrentIgnore.Dispose();
                hv_CurrentAbsOrientationDiff.Dispose();
                hv_GtMatchedNoIgnore.Dispose();
                hv_ResIsFPClass.Dispose();
                hv_ResIsFPBackground.Dispose();
                hv_ResIsFPLocalization.Dispose();
                hv_ResIsFPDuplicate.Dispose();
                hv_ResIsFPMultiple.Dispose();
                hv_ResAbsOrientationDiffClass.Dispose();
                hv_ResAbsOrientationDiffLocalization.Dispose();
                hv_ResAbsOrientationDiffDuplicate.Dispose();
                hv_ResAbsOrientationDiffMultiple.Dispose();
                hv_FPResIdxsThisClass.Dispose();
                hv_FPResIdxsAllResults.Dispose();
                hv_GTIdxsNotToIgnore.Dispose();
                hv_MaxIoU.Dispose();
                hv_IoUsWithGT.Dispose();
                hv_MaxIdx.Dispose();
                hv_GTClassIDMaxIoU.Dispose();
                hv_AbsOrientationDiff.Dispose();
                hv_IsFPClass.Dispose();
                hv_IsFPBackground.Dispose();
                hv_IsFPLocalization.Dispose();
                hv_IsFPDuplicate.Dispose();
                hv_IsFPMultiple.Dispose();
                hv_AbsOrientationDiffMultiple.Dispose();
                hv_AbsOrientationDiffDuplicate.Dispose();
                hv_AbsOrientationDiffLocalization.Dispose();
                hv_AbsOrientationDiffClass.Dispose();
                hv_CurrentImageID.Dispose();
                hv_ImageIDsWithFN.Dispose();
                hv_NumImageIDsWithFN.Dispose();
                hv_ImageIDsWithFP.Dispose();
                hv_NumImageIDsWithFP.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_IoUThresholds.Dispose();
                hv_InstanceType.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClasses.Dispose();
                hv_Measures.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_NumAreaRanges.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_KeyExists.Dispose();
                hv_ClassIDToClassIdx.Dispose();
                hv_EvaluateOrientation.Dispose();
                hv_SIdx.Dispose();
                hv_CurrentSample.Dispose();
                hv_CurrentResult.Dispose();
                hv_GtClassIDs.Dispose();
                hv_ResClassIDs.Dispose();
                hv_NumGT.Dispose();
                hv_NumRes.Dispose();
                hv_Confidences.Dispose();
                hv_ResSortIndices.Dispose();
                hv_GtAreas.Dispose();
                hv_ResAreas.Dispose();
                hv_IoUs.Dispose();
                hv_GtPhis.Dispose();
                hv_ResPhis.Dispose();
                hv_MDIdx.Dispose();
                hv_MaxNum.Dispose();
                hv_MaxNumStr.Dispose();
                hv_CurrentRunningMeasures.Dispose();
                hv_AreaIdx.Dispose();
                hv_MinArea.Dispose();
                hv_MaxArea.Dispose();
                hv_AreaName.Dispose();
                hv_AreaRunningMeasures.Dispose();
                hv_GtIgnore.Dispose();
                hv_GtIgnoreInds.Dispose();
                hv_PerClassNumGt.Dispose();
                hv_PerClassNumPred.Dispose();
                hv_PerClassConfidences.Dispose();
                hv_PerClassNumGtIgnore.Dispose();
                hv_SampleHasFP.Dispose();
                hv_SampleHasFN.Dispose();
                hv_ClsIdx.Dispose();
                hv_CurrentClassID.Dispose();
                hv_CurrentGtIdxs.Dispose();
                hv_CurrentNumGt.Dispose();
                hv_CurrentGtIgnore.Dispose();
                hv_CurrentNumGtIgnore.Dispose();
                hv_CurrentNumGtNoIgnore.Dispose();
                hv_CurrentResIdxs.Dispose();
                hv_CurrentNumRes.Dispose();
                hv_CurrentResAreas.Dispose();
                hv_OldNumPred.Dispose();
                hv_CurrentClassConfidences.Dispose();
                hv_GtSortIdx.Dispose();
                hv_CurrentResPhis.Dispose();
                hv_CurrentGtPhis.Dispose();
                hv_ITIdx.Dispose();
                hv_GtMatched.Dispose();
                hv_ResMatched.Dispose();
                hv_ResAbsOrientationDiff.Dispose();
                hv_ResIgnore.Dispose();
                hv_ResIdx.Dispose();
                hv_CurrentIoU.Dispose();
                hv_MatchIdx.Dispose();
                hv_GtIdx.Dispose();
                hv_AreaIgnore.Dispose();
                hv_PerIoUMeasure.Dispose();
                hv_PerClassMeasures.Dispose();
                hv_CurrentIsTP.Dispose();
                hv_CurrentIgnore.Dispose();
                hv_CurrentAbsOrientationDiff.Dispose();
                hv_GtMatchedNoIgnore.Dispose();
                hv_ResIsFPClass.Dispose();
                hv_ResIsFPBackground.Dispose();
                hv_ResIsFPLocalization.Dispose();
                hv_ResIsFPDuplicate.Dispose();
                hv_ResIsFPMultiple.Dispose();
                hv_ResAbsOrientationDiffClass.Dispose();
                hv_ResAbsOrientationDiffLocalization.Dispose();
                hv_ResAbsOrientationDiffDuplicate.Dispose();
                hv_ResAbsOrientationDiffMultiple.Dispose();
                hv_FPResIdxsThisClass.Dispose();
                hv_FPResIdxsAllResults.Dispose();
                hv_GTIdxsNotToIgnore.Dispose();
                hv_MaxIoU.Dispose();
                hv_IoUsWithGT.Dispose();
                hv_MaxIdx.Dispose();
                hv_GTClassIDMaxIoU.Dispose();
                hv_AbsOrientationDiff.Dispose();
                hv_IsFPClass.Dispose();
                hv_IsFPBackground.Dispose();
                hv_IsFPLocalization.Dispose();
                hv_IsFPDuplicate.Dispose();
                hv_IsFPMultiple.Dispose();
                hv_AbsOrientationDiffMultiple.Dispose();
                hv_AbsOrientationDiffDuplicate.Dispose();
                hv_AbsOrientationDiffLocalization.Dispose();
                hv_AbsOrientationDiffClass.Dispose();
                hv_CurrentImageID.Dispose();
                hv_ImageIDsWithFN.Dispose();
                hv_NumImageIDsWithFN.Dispose();
                hv_ImageIDsWithFP.Dispose();
                hv_NumImageIDsWithFP.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Update running measures for a pixel-based evaluation. 
        public void update_running_pixel_measures(HTuple hv_Samples, HTuple hv_Results,
            HTuple hv_EvalParams, HTuple hv_RunningMeasures)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Annot = null, ho_Result = null, ho_ClsIgnore = null;
            HObject ho_ClsIgnoreTmp = null, ho_ClsAnnot = null, ho_ClsResult = null;
            HObject ho_TPReg = null, ho_FPReg = null, ho_FNReg = null;

            // Local control variables 

            HTuple hv_ClassIDs = new HTuple(), hv_IgnoreClassIDs = new HTuple();
            HTuple hv_Measures = new HTuple(), hv_CalcConfMatrix = new HTuple();
            HTuple hv_NumClasses = new HTuple(), hv_MaxId = new HTuple();
            HTuple hv_ConfMatrix = new HTuple(), hv_MapClassIDs = new HTuple();
            HTuple hv_ClsIdToClsIdx = new HTuple(), hv_TP = new HTuple();
            HTuple hv_FP = new HTuple(), hv_FN = new HTuple(), hv_SampleIndex = new HTuple();
            HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
            HTuple hv_AnnotVals = new HTuple(), hv_ResultVals = new HTuple();
            HTuple hv_ConfTuple = new HTuple(), hv_ConfHist = new HTuple();
            HTuple hv_BinSize = new HTuple(), hv_ConfMatrixTmp = new HTuple();
            HTuple hv_IgnoreIndex = new HTuple(), hv_ClsIndex = new HTuple();
            HTuple hv_ClsId = new HTuple(), hv_ClsTP = new HTuple();
            HTuple hv_ClsFP = new HTuple(), hv_ClsFN = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Annot);
            HOperatorSet.GenEmptyObj(out ho_Result);
            HOperatorSet.GenEmptyObj(out ho_ClsIgnore);
            HOperatorSet.GenEmptyObj(out ho_ClsIgnoreTmp);
            HOperatorSet.GenEmptyObj(out ho_ClsAnnot);
            HOperatorSet.GenEmptyObj(out ho_ClsResult);
            HOperatorSet.GenEmptyObj(out ho_TPReg);
            HOperatorSet.GenEmptyObj(out ho_FPReg);
            HOperatorSet.GenEmptyObj(out ho_FNReg);
            try
            {
                //
                //This procedure updates the RunningMeasures
                //for a pixel-based evaluation for segmentation.
                //These measures are stored in the dictionary RunningMeasures and
                //updated by incorporating the Results the model obtained for the Samples.
                //
                //Get the class IDs.
                hv_ClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                //Get the ignore class IDs.
                hv_IgnoreClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "ignore_class_ids", out hv_IgnoreClassIDs);
                //Check if we need to compute/update the confusion matrix.
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                hv_CalcConfMatrix.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_CalcConfMatrix = (new HTuple(((hv_Measures.TupleFind(
                        "pixel_confusion_matrix"))).TupleGreater(-1))).TupleOr(new HTuple(((hv_Measures.TupleFind(
                        "all"))).TupleGreater(-1)));
                }
                //Get the number of classes.
                hv_NumClasses.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
                //Get the maximum class ID plus a possible ignore-class.
                hv_MaxId.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_MaxId = (hv_ClassIDs.TupleMax()
                        ) + (new HTuple((new HTuple(hv_IgnoreClassIDs.TupleLength())).TupleGreater(
                        0)));
                }
                //
                if ((int)(hv_CalcConfMatrix) != 0)
                {
                    //Get the current confusion matrix.
                    hv_ConfMatrix.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "pixel_confusion_matrix", out hv_ConfMatrix);
                    //Check if we need to map the class IDs.
                    hv_MapClassIDs.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "class_id_mapping",
                        out hv_MapClassIDs);
                    if ((int)(hv_MapClassIDs) != 0)
                    {
                        hv_ClsIdToClsIdx.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "class_id_mapping", out hv_ClsIdToClsIdx);
                        hv_NumClasses.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_NumClasses = (hv_ClsIdToClsIdx.TupleMax()
                                ) + 1;
                        }
                    }
                }
                else
                {
                    //Get the tuples for TP/FP/FN
                    hv_TP.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "tp", out hv_TP);
                    hv_FP.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "fp", out hv_FP);
                    hv_FN.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "fn", out hv_FN);
                }
                //
                //Loop over images, i.e. sample dicts.
                for (hv_SampleIndex = 0; (int)hv_SampleIndex <= (int)((new HTuple(hv_Samples.TupleLength()
                    )) - 1); hv_SampleIndex = (int)hv_SampleIndex + 1)
                {
                    //Get annotation.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_Annot.Dispose();
                        HOperatorSet.GetDictObject(out ho_Annot, hv_Samples.TupleSelect(hv_SampleIndex),
                            "segmentation_image");
                    }
                    //Get result.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_Result.Dispose();
                        HOperatorSet.GetDictObject(out ho_Result, hv_Results.TupleSelect(hv_SampleIndex),
                            "segmentation_image");
                    }
                    //
                    //Update the measures.
                    if ((int)(hv_CalcConfMatrix) != 0)
                    {
                        //Get the ground truth and predicted class IDs of all pixels.
                        hv_Rows.Dispose(); hv_Columns.Dispose();
                        HOperatorSet.GetRegionPoints(ho_Annot, out hv_Rows, out hv_Columns);
                        hv_AnnotVals.Dispose();
                        HOperatorSet.GetGrayval(ho_Annot, hv_Rows, hv_Columns, out hv_AnnotVals);
                        hv_ResultVals.Dispose();
                        HOperatorSet.GetGrayval(ho_Result, hv_Rows, hv_Columns, out hv_ResultVals);
                        //Map the class IDs to class indices.
                        if ((int)(hv_MapClassIDs) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_AnnotVals = hv_ClsIdToClsIdx.TupleSelect(
                                        hv_AnnotVals);
                                    hv_AnnotVals.Dispose();
                                    hv_AnnotVals = ExpTmpLocalVar_AnnotVals;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ResultVals = hv_ClsIdToClsIdx.TupleSelect(
                                        hv_ResultVals);
                                    hv_ResultVals.Dispose();
                                    hv_ResultVals = ExpTmpLocalVar_ResultVals;
                                }
                            }
                        }
                        //The ground truth and predicted IDs are accumulated
                        //such that each confusion pair (class_i <-> class_j) gets a unique value.
                        hv_ConfTuple.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ConfTuple = (hv_NumClasses * hv_AnnotVals) + hv_ResultVals;
                        }
                        //Compute the histogram of this confusion tuple.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ConfHist.Dispose(); hv_BinSize.Dispose();
                            HOperatorSet.TupleHistoRange(hv_ConfTuple, 0, (hv_NumClasses * hv_NumClasses) - 1,
                                hv_NumClasses * hv_NumClasses, out hv_ConfHist, out hv_BinSize);
                        }
                        hv_ConfMatrixTmp.Dispose();
                        HOperatorSet.CreateMatrix(hv_NumClasses, hv_NumClasses, hv_ConfHist, out hv_ConfMatrixTmp);
                        {
                            HTuple ExpTmpOutVar_0;
                            HOperatorSet.TransposeMatrix(hv_ConfMatrixTmp, out ExpTmpOutVar_0);
                            hv_ConfMatrixTmp.Dispose();
                            hv_ConfMatrixTmp = ExpTmpOutVar_0;
                        }
                        {
                            HTuple ExpTmpOutVar_0;
                            HOperatorSet.AddMatrix(hv_ConfMatrix, hv_ConfMatrixTmp, out ExpTmpOutVar_0);
                            hv_ConfMatrix.Dispose();
                            hv_ConfMatrix = ExpTmpOutVar_0;
                        }
                    }
                    else
                    {
                        //Get the ignore region.
                        ho_ClsIgnore.Dispose();
                        HOperatorSet.GenEmptyRegion(out ho_ClsIgnore);
                        for (hv_IgnoreIndex = 0; (int)hv_IgnoreIndex <= (int)((new HTuple(hv_IgnoreClassIDs.TupleLength()
                            )) - 1); hv_IgnoreIndex = (int)hv_IgnoreIndex + 1)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_ClsIgnoreTmp.Dispose();
                                HOperatorSet.Threshold(ho_Annot, out ho_ClsIgnoreTmp, hv_IgnoreClassIDs.TupleSelect(
                                    hv_IgnoreIndex), hv_IgnoreClassIDs.TupleSelect(hv_IgnoreIndex));
                            }
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.Union2(ho_ClsIgnore, ho_ClsIgnoreTmp, out ExpTmpOutVar_0
                                    );
                                ho_ClsIgnore.Dispose();
                                ho_ClsIgnore = ExpTmpOutVar_0;
                            }
                        }
                        //
                        //Go through model classes.
                        for (hv_ClsIndex = 0; (int)hv_ClsIndex <= (int)((new HTuple(hv_ClassIDs.TupleLength()
                            )) - 1); hv_ClsIndex = (int)hv_ClsIndex + 1)
                        {
                            hv_ClsId.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClsId = hv_ClassIDs.TupleSelect(
                                    hv_ClsIndex);
                            }
                            //Get the annotated region for this class.
                            ho_ClsAnnot.Dispose();
                            HOperatorSet.Threshold(ho_Annot, out ho_ClsAnnot, hv_ClsId, hv_ClsId);
                            //Get the result region for this class.
                            ho_ClsResult.Dispose();
                            HOperatorSet.Threshold(ho_Result, out ho_ClsResult, hv_ClsId, hv_ClsId);
                            //The pixels in the ignore region should not be considered.
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.Difference(ho_ClsResult, ho_ClsIgnore, out ExpTmpOutVar_0
                                    );
                                ho_ClsResult.Dispose();
                                ho_ClsResult = ExpTmpOutVar_0;
                            }
                            //Get TP/FP/FN.
                            ho_TPReg.Dispose();
                            HOperatorSet.Intersection(ho_ClsAnnot, ho_ClsResult, out ho_TPReg);
                            ho_FPReg.Dispose();
                            HOperatorSet.Difference(ho_ClsResult, ho_ClsAnnot, out ho_FPReg);
                            //We define false negatives as pixels that have been labeled as this class,
                            //but not been correctly predicted.
                            ho_FNReg.Dispose();
                            HOperatorSet.Difference(ho_ClsAnnot, ho_ClsResult, out ho_FNReg);
                            //Get corresponding pixel numbers and update.
                            hv_ClsTP.Dispose();
                            HOperatorSet.RegionFeatures(ho_TPReg, "area", out hv_ClsTP);
                            hv_ClsFP.Dispose();
                            HOperatorSet.RegionFeatures(ho_FPReg, "area", out hv_ClsFP);
                            hv_ClsFN.Dispose();
                            HOperatorSet.RegionFeatures(ho_FNReg, "area", out hv_ClsFN);
                            if (hv_TP == null)
                                hv_TP = new HTuple();
                            hv_TP[hv_ClsIndex] = (hv_TP.TupleSelect(hv_ClsIndex)) + hv_ClsTP;
                            if (hv_FP == null)
                                hv_FP = new HTuple();
                            hv_FP[hv_ClsIndex] = (hv_FP.TupleSelect(hv_ClsIndex)) + hv_ClsFP;
                            if (hv_FN == null)
                                hv_FN = new HTuple();
                            hv_FN[hv_ClsIndex] = (hv_FN.TupleSelect(hv_ClsIndex)) + hv_ClsFN;
                        }
                    }
                }
                //
                //Update running measures.
                if ((int)(hv_CalcConfMatrix) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "pixel_confusion_matrix", hv_ConfMatrix);
                }
                else
                {
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "tp", hv_TP);
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "fp", hv_FP);
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "fn", hv_FN);
                }
                //
                ho_Annot.Dispose();
                ho_Result.Dispose();
                ho_ClsIgnore.Dispose();
                ho_ClsIgnoreTmp.Dispose();
                ho_ClsAnnot.Dispose();
                ho_ClsResult.Dispose();
                ho_TPReg.Dispose();
                ho_FPReg.Dispose();
                ho_FNReg.Dispose();

                hv_ClassIDs.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_Measures.Dispose();
                hv_CalcConfMatrix.Dispose();
                hv_NumClasses.Dispose();
                hv_MaxId.Dispose();
                hv_ConfMatrix.Dispose();
                hv_MapClassIDs.Dispose();
                hv_ClsIdToClsIdx.Dispose();
                hv_TP.Dispose();
                hv_FP.Dispose();
                hv_FN.Dispose();
                hv_SampleIndex.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_AnnotVals.Dispose();
                hv_ResultVals.Dispose();
                hv_ConfTuple.Dispose();
                hv_ConfHist.Dispose();
                hv_BinSize.Dispose();
                hv_ConfMatrixTmp.Dispose();
                hv_IgnoreIndex.Dispose();
                hv_ClsIndex.Dispose();
                hv_ClsId.Dispose();
                hv_ClsTP.Dispose();
                hv_ClsFP.Dispose();
                hv_ClsFN.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Annot.Dispose();
                ho_Result.Dispose();
                ho_ClsIgnore.Dispose();
                ho_ClsIgnoreTmp.Dispose();
                ho_ClsAnnot.Dispose();
                ho_ClsResult.Dispose();
                ho_TPReg.Dispose();
                ho_FPReg.Dispose();
                ho_FNReg.Dispose();

                hv_ClassIDs.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_Measures.Dispose();
                hv_CalcConfMatrix.Dispose();
                hv_NumClasses.Dispose();
                hv_MaxId.Dispose();
                hv_ConfMatrix.Dispose();
                hv_MapClassIDs.Dispose();
                hv_ClsIdToClsIdx.Dispose();
                hv_TP.Dispose();
                hv_FP.Dispose();
                hv_FN.Dispose();
                hv_SampleIndex.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_AnnotVals.Dispose();
                hv_ResultVals.Dispose();
                hv_ConfTuple.Dispose();
                hv_ConfHist.Dispose();
                hv_BinSize.Dispose();
                hv_ConfMatrixTmp.Dispose();
                hv_IgnoreIndex.Dispose();
                hv_ClsIndex.Dispose();
                hv_ClsId.Dispose();
                hv_ClsTP.Dispose();
                hv_ClsFP.Dispose();
                hv_ClsFN.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Window
        // Short Description: This procedure sets and returns meta information to display images correctly. 
        public void update_window_meta_information(HTuple hv_WindowHandle, HTuple hv_WidthImage,
            HTuple hv_HeightImage, HTuple hv_WindowRow1, HTuple hv_WindowColumn1, HTuple hv_MapColorBarWidth,
            HTuple hv_MarginBottom, out HTuple hv_WindowImageRatioHeight, out HTuple hv_WindowImageRatioWidth,
            out HTuple hv_SetPartRow2, out HTuple hv_SetPartColumn2, out HTuple hv_PrevWindowCoordinatesOut)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv__ = new HTuple(), hv_WindowWidth = new HTuple();
            HTuple hv_WindowHeight = new HTuple(), hv_WindowRow2 = new HTuple();
            HTuple hv_WindowColumn2 = new HTuple(), hv_WindowRatio = new HTuple();
            HTuple hv_ImageRow2 = new HTuple(), hv_ImageColumn2 = new HTuple();
            HTuple hv_ImageRatio = new HTuple(), hv_ImageWindowRatioHeight = new HTuple();
            HTuple hv_ImageRow2InWindow = new HTuple(), hv_ImageCol2InWindow = new HTuple();
            // Initialize local and output iconic variables 
            hv_WindowImageRatioHeight = new HTuple();
            hv_WindowImageRatioWidth = new HTuple();
            hv_SetPartRow2 = new HTuple();
            hv_SetPartColumn2 = new HTuple();
            hv_PrevWindowCoordinatesOut = new HTuple();
            try
            {
                //
                //This procedure sets and returns meta information to display images correctly.
                //
                //Set part for the image to be displayed later and adapt window size (+ MarginBottom + MapColorBarWidth).
                hv__.Dispose(); hv__.Dispose(); hv_WindowWidth.Dispose(); hv_WindowHeight.Dispose();
                HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv__, out hv__, out hv_WindowWidth,
                    out hv_WindowHeight);
                hv_WindowImageRatioHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowImageRatioHeight = hv_WindowHeight / (hv_HeightImage * 1.0);
                }
                hv_WindowImageRatioWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowImageRatioWidth = hv_WindowWidth / (hv_WidthImage * 1.0);
                }
                //
                //Set window part such that image is displayed undistorted.
                hv_WindowRow2.Dispose();
                hv_WindowRow2 = new HTuple(hv_WindowHeight);
                hv_WindowColumn2.Dispose();
                hv_WindowColumn2 = new HTuple(hv_WindowWidth);
                hv_WindowRatio.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowRatio = hv_WindowColumn2 / (hv_WindowRow2 * 1.0);
                }
                //
                hv_ImageRow2.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ImageRow2 = hv_HeightImage + (hv_MarginBottom / hv_WindowImageRatioHeight);
                }
                hv_ImageColumn2.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ImageColumn2 = hv_WidthImage + (hv_MapColorBarWidth / hv_WindowImageRatioWidth);
                }
                hv_ImageRatio.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ImageRatio = hv_ImageColumn2 / (hv_ImageRow2 * 1.0);
                }
                if ((int)(new HTuple(hv_ImageRatio.TupleGreater(hv_WindowRatio))) != 0)
                {
                    //
                    //Extend image until right window border.
                    hv_SetPartColumn2.Dispose();
                    hv_SetPartColumn2 = new HTuple(hv_ImageColumn2);
                    hv_ImageWindowRatioHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageWindowRatioHeight = hv_ImageColumn2 / (hv_WindowColumn2 * 1.0);
                    }
                    hv_ImageRow2InWindow.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageRow2InWindow = hv_ImageRow2 / hv_ImageWindowRatioHeight;
                    }
                    hv_SetPartRow2.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SetPartRow2 = hv_ImageRow2 + ((hv_WindowRow2 - hv_ImageRow2InWindow) / hv_WindowImageRatioWidth);
                    }
                }
                else
                {
                    //
                    //Extend image until bottom of window.
                    hv_SetPartRow2.Dispose();
                    hv_SetPartRow2 = new HTuple(hv_ImageRow2);
                    hv_ImageWindowRatioHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageWindowRatioHeight = hv_ImageRow2 / (hv_WindowRow2 * 1.0);
                    }
                    hv_ImageCol2InWindow.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageCol2InWindow = hv_ImageColumn2 / hv_ImageWindowRatioHeight;
                    }
                    hv_SetPartColumn2.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SetPartColumn2 = hv_ImageColumn2 + ((hv_WindowColumn2 - hv_ImageCol2InWindow) / hv_WindowImageRatioHeight);
                    }
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_SetPartRow2, hv_SetPartColumn2);
                }
                //
                //Return the coordinates of the new window.
                hv_PrevWindowCoordinatesOut.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PrevWindowCoordinatesOut = new HTuple();
                    hv_PrevWindowCoordinatesOut = hv_PrevWindowCoordinatesOut.TupleConcat(hv_WindowRow1, hv_WindowColumn1, hv_WindowWidth, hv_WindowHeight);
                }
                //

                hv__.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_WindowRow2.Dispose();
                hv_WindowColumn2.Dispose();
                hv_WindowRatio.Dispose();
                hv_ImageRow2.Dispose();
                hv_ImageColumn2.Dispose();
                hv_ImageRatio.Dispose();
                hv_ImageWindowRatioHeight.Dispose();
                hv_ImageRow2InWindow.Dispose();
                hv_ImageCol2InWindow.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv__.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_WindowRow2.Dispose();
                hv_WindowColumn2.Dispose();
                hv_WindowRatio.Dispose();
                hv_ImageRow2.Dispose();
                hv_ImageColumn2.Dispose();
                hv_ImageRatio.Dispose();
                hv_ImageWindowRatioHeight.Dispose();
                hv_ImageRow2InWindow.Dispose();
                hv_ImageCol2InWindow.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Check that all given entries in EvalParams are valid. 
        public void validate_evaluation_param(HTuple hv_EvalParams, out HTuple hv_Valid,
            out HTuple hv_Exception)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ClassIDsExist = new HTuple(), hv_ClassIDs = new HTuple();
            HTuple hv_NumClassesExist = new HTuple(), hv_NumClasses = new HTuple();
            HTuple hv_EvalInstancesExists = new HTuple(), hv_EvaluationTypeExists = new HTuple();
            HTuple hv_EvaluationType = new HTuple(), hv_Indices = new HTuple();
            HTuple hv_MeasuresExists = new HTuple(), hv_Measures = new HTuple();
            HTuple hv_ValidMeasures = new HTuple(), hv_Ks = new HTuple();
            HTuple hv_KeysExist = new HTuple(), hv_ClassNames = new HTuple();
            HTuple hv_ClassesToEvaluate = new HTuple(), hv_ClassIDsToEvaluate = new HTuple();
            HTuple hv_IouThreshExists = new HTuple(), hv_IouThresholds = new HTuple();
            HTuple hv_MaxNumDetectionsExists = new HTuple(), hv_MaxNumDetections = new HTuple();
            HTuple hv_AreaRangesExist = new HTuple(), hv_AreaRanges = new HTuple();
            HTuple hv_AreaKeysExist = new HTuple(), hv_AreaNames = new HTuple();
            HTuple hv_MinAreas = new HTuple(), hv_MaxAreas = new HTuple();
            HTuple hv_InstanceTypeExists = new HTuple(), hv_InstanceType = new HTuple();
            HTuple hv_ValidInstanceTypes = new HTuple(), hv_AllocationBlockLengthExists = new HTuple();
            HTuple hv_AllocationBlockLength = new HTuple(), hv_DetailedEvaluationExists = new HTuple();
            HTuple hv_DetailedEvaluation = new HTuple(), hv_IgnoreClassIDsExist = new HTuple();
            HTuple hv_ValidMeasuresString = new HTuple(), hv_Idx = new HTuple();
            HTuple hv_ValidMeasure = new HTuple();
            // Initialize local and output iconic variables 
            hv_Valid = new HTuple();
            hv_Exception = new HTuple();
            try
            {
                //
                //This procedure checks if the dictionary EvalParams
                //contains all necessary parameters and if they are valid (type, range, ...).
                //
                hv_Valid.Dispose();
                hv_Valid = 0;
                hv_Exception.Dispose();
                hv_Exception = "";
                //Check class IDs.
                hv_ClassIDsExist.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "class_ids", out hv_ClassIDsExist);
                if ((int)(hv_ClassIDsExist.TupleNot()) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "The evaluation parameters need a key-value pair for 'class_ids'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();

                    return;
                }
                else
                {
                    hv_ClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                    if ((int)(new HTuple((new HTuple(hv_ClassIDs.TupleLength())).TupleLess(1))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'class_ids' should have at least length 1";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    if ((int)(new HTuple(((hv_ClassIDs.TupleIsIntElem())).TupleNotEqual(HTuple.TupleGenConst(
                        new HTuple(hv_ClassIDs.TupleLength()), 1)))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'class_ids' should be of type int";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    if ((int)(new HTuple(((((hv_ClassIDs.TupleLessElem(0))).TupleFind(1))).TupleGreater(
                        -1))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'class_ids' should be positive or zero";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                }
                //Check the entry num_classes.
                hv_NumClassesExist.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "num_classes", out hv_NumClassesExist);
                if ((int)(hv_NumClassesExist.TupleNot()) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "The evaluation parameters need a key-value pair for 'num_classes'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();

                    return;
                }
                else
                {
                    hv_NumClasses.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
                    if ((int)(new HTuple((new HTuple(hv_NumClasses.TupleLength())).TupleNotEqual(
                        1))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'num_classes' should have length 1";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    if ((int)(new HTuple(((hv_NumClasses.TupleType())).TupleNotEqual((new HTuple((new HTuple(1)).TupleInt()
                        )).TupleType()))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'num_classes' should be of type int";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    if ((int)(new HTuple(hv_NumClasses.TupleLess(1))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'num_classes' should be at least 1";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                }
                //Check that num_classes is equal to |class_ids|.
                if ((int)(new HTuple(hv_NumClasses.TupleNotEqual(new HTuple(hv_ClassIDs.TupleLength()
                    )))) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "'num_classes' has to be set to the number of 'class_ids'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();

                    return;
                }
                //Check the entry 'evaluate_instances'.
                hv_EvalInstancesExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "evaluate_instances",
                    out hv_EvalInstancesExists);
                if ((int)(hv_EvalInstancesExists.TupleNot()) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "The evaluation parameters need a key-value pair for 'evaluate_instances'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();

                    return;
                }
                //Check the entry 'evaluation_type'.
                hv_EvaluationTypeExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "evaluation_type", out hv_EvaluationTypeExists);
                if ((int)(hv_EvaluationTypeExists.TupleNot()) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "The evaluation parameters need a key-value pair for 'evaluation_type'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();

                    return;
                }
                else
                {
                    hv_EvaluationType.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "evaluation_type", out hv_EvaluationType);
                    hv_Indices.Dispose();
                    HOperatorSet.TupleFind((((new HTuple("anomaly_detection")).TupleConcat("classification")).TupleConcat(
                        "segmentation")).TupleConcat("detection"), hv_EvaluationType, out hv_Indices);
                    if ((int)((new HTuple(hv_Indices.TupleEqual(-1))).TupleOr(new HTuple(hv_Indices.TupleEqual(
                        new HTuple())))) != 0)
                    {
                        hv_Exception.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Exception = "Invalid entry for 'evaluation_type': " + hv_EvaluationType;
                        }

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                }
                //Check the entry 'measures'.
                hv_MeasuresExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "measures", out hv_MeasuresExists);
                if ((int)(hv_MeasuresExists.TupleNot()) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "The evaluation parameters need a key-value pair for 'measures'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();

                    return;
                }
                else
                {
                    hv_Measures.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                    if ((int)(new HTuple((new HTuple(hv_Measures.TupleLength())).TupleEqual(0))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'measures' should contain at least one entry";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                }
                //Check evaluation type specific entries of EvalParams.
                hv_EvaluationType.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "evaluation_type", out hv_EvaluationType);
                if ((int)(new HTuple(hv_EvaluationType.TupleEqual("anomaly_detection"))) != 0)
                {
                    //
                    //Check for correct number of classes.
                    if ((int)(new HTuple((new HTuple(hv_ClassIDs.TupleLength())).TupleNotEqual(
                        2))) != 0)
                    {
                        throw new HalconException("The number of classes must be 2 for model type anomaly detection.");
                    }
                    //
                    //Currently only the anomaly score histogram is evaluated
                    hv_ValidMeasures.Dispose();
                    hv_ValidMeasures = "anomaly_score_histogram";
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("classification"))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Ks.Dispose();
                        HOperatorSet.TupleGenSequence(1, new HTuple(hv_ClassIDs.TupleLength()), 1,
                            out hv_Ks);
                    }
                    hv_ValidMeasures.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ValidMeasures = ("top" + hv_Ks) + "_error";
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ValidMeasures = hv_ValidMeasures.TupleConcat(
                                ((((new HTuple("precision")).TupleConcat("recall")).TupleConcat("f_score")).TupleConcat(
                                "absolute_confusion_matrix")).TupleConcat("relative_confusion_matrix"));
                            hv_ValidMeasures.Dispose();
                            hv_ValidMeasures = ExpTmpLocalVar_ValidMeasures;
                        }
                    }
                    //
                    //Check if not both of the two options to specify the evaluated classes are chosen.
                    hv_KeysExist.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", (new HTuple("class_names_to_evaluate")).TupleConcat(
                        "class_ids_to_evaluate"), out hv_KeysExist);
                    if ((int)(new HTuple(((hv_KeysExist.TupleSum())).TupleEqual(2))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "No more than one option of 'class_names_to_evaluate' and 'class_ids_to_evaluate' is allowed";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    if ((int)(hv_KeysExist.TupleSelect(0)) != 0)
                    {
                        hv_ClassNames.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "class_names", out hv_ClassNames);
                        hv_ClassesToEvaluate.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "class_names_to_evaluate", out hv_ClassesToEvaluate);
                        if ((int)(new HTuple(((hv_ClassesToEvaluate.TupleDifference(hv_ClassNames.TupleConcat(
                            "global")))).TupleNotEqual(new HTuple()))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "Invalid entry in 'class_names_to_evaluate'";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                    if ((int)(hv_KeysExist.TupleSelect(1)) != 0)
                    {
                        hv_ClassIDs.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                        hv_ClassIDsToEvaluate.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids_to_evaluate", out hv_ClassIDsToEvaluate);
                        if ((int)(new HTuple(((hv_ClassIDsToEvaluate.TupleDifference(hv_ClassIDs.TupleConcat(
                            "global")))).TupleNotEqual(new HTuple()))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "Invalid entry in 'class_ids_to_evaluate'";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("detection"))) != 0)
                {
                    //Instance-based evaluation.
                    //Add instance measures.
                    hv_ValidMeasures.Dispose();
                    hv_ValidMeasures = new HTuple();
                    hv_ValidMeasures[0] = "all";
                    hv_ValidMeasures[1] = "mean_ap";
                    //
                    //Check if the entry 'iou_threshold' is present.
                    hv_IouThreshExists.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "iou_threshold", out hv_IouThreshExists);
                    if ((int)(hv_IouThreshExists.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "The evaluation parameters need a key-value pair for 'iou_threshold'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    else
                    {
                        hv_IouThresholds.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "iou_threshold", out hv_IouThresholds);
                        //Check the length of 'iou_threshold'.
                        if ((int)(new HTuple((new HTuple(hv_IouThresholds.TupleLength())).TupleLess(
                            1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'iou_threshold' is empty";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        if ((int)(new HTuple(((hv_IouThresholds.TupleIsRealElem())).TupleNotEqual(
                            HTuple.TupleGenConst(new HTuple(hv_IouThresholds.TupleLength()), 1)))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'iou_threshold' should be of type real";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check if the IoU thresholds are within (0.0, 1.0).
                        if ((int)((new HTuple(((hv_IouThresholds.TupleMin())).TupleLessEqual(0.0))).TupleOr(
                            new HTuple(((hv_IouThresholds.TupleMax())).TupleGreaterEqual(1.0)))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = new HTuple("Invalid 'iou_threshold', not in range (0.0, 1.0)");

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                    //
                    //Check if the entry 'max_num_detections' is present.
                    hv_MaxNumDetectionsExists.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "max_num_detections",
                        out hv_MaxNumDetectionsExists);
                    if ((int)(hv_MaxNumDetectionsExists.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "The evaluation parameters need a key-value pair for 'max_num_detections'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    else
                    {
                        hv_MaxNumDetections.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "max_num_detections", out hv_MaxNumDetections);
                        //Check the length of 'max_num_detections'.
                        if ((int)(new HTuple((new HTuple(hv_MaxNumDetections.TupleLength())).TupleLess(
                            1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'max_num_detections' is empty";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        if ((int)(new HTuple(((hv_MaxNumDetections.TupleIsIntElem())).TupleNotEqual(
                            HTuple.TupleGenConst(new HTuple(hv_MaxNumDetections.TupleLength()),
                            1)))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'max_num_detections' should be of type int";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check if 'max_num_detections' is -1 (to use all detections) or positive.
                        if ((int)((new HTuple(((hv_MaxNumDetections.TupleMin())).TupleLess(-1))).TupleOr(
                            new HTuple(((hv_MaxNumDetections.TupleFind(0))).TupleGreater(-1)))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'max_num_detections' should be -1 or positive";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                    //
                    //Check if the entry 'area_ranges' is present.
                    hv_AreaRangesExist.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "area_ranges", out hv_AreaRangesExist);
                    if ((int)(hv_AreaRangesExist.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "The evaluation parameters need a key-value pair for 'area_ranges'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    else
                    {
                        //Check if the entry 'area_ranges' is a dict.
                        hv_AreaRanges.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "area_ranges", out hv_AreaRanges);
                        if ((int)(new HTuple(((hv_AreaRanges.TupleSemType())).TupleNotEqual("dict"))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges' must be a dict";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check that the necessary keys exist.
                        hv_AreaKeysExist.Dispose();
                        HOperatorSet.GetDictParam(hv_AreaRanges, "key_exists", ((new HTuple("name")).TupleConcat(
                            "min")).TupleConcat("max"), out hv_AreaKeysExist);
                        if ((int)(((hv_AreaKeysExist.TupleSelect(0))).TupleNot()) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges' need a key-value pair for 'name'";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        if ((int)(((hv_AreaKeysExist.TupleSelect(1))).TupleNot()) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges' need a key-value pair for 'min'";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        if ((int)(((hv_AreaKeysExist.TupleSelect(2))).TupleNot()) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges' need a key-value pair for 'max'";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check the lengths of the area keys.
                        hv_AreaNames.Dispose();
                        HOperatorSet.GetDictTuple(hv_AreaRanges, "name", out hv_AreaNames);
                        if ((int)(new HTuple((new HTuple(hv_AreaNames.TupleLength())).TupleLess(
                            1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges': 'name' is empty";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        hv_MinAreas.Dispose();
                        HOperatorSet.GetDictTuple(hv_AreaRanges, "min", out hv_MinAreas);
                        if ((int)(new HTuple((new HTuple(hv_MinAreas.TupleLength())).TupleLess(
                            1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges': 'min' is empty";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        hv_MaxAreas.Dispose();
                        HOperatorSet.GetDictTuple(hv_AreaRanges, "max", out hv_MaxAreas);
                        if ((int)(new HTuple((new HTuple(hv_MaxAreas.TupleLength())).TupleLess(
                            1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges': 'max' is empty";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        if ((int)((new HTuple((new HTuple(hv_AreaNames.TupleLength())).TupleNotEqual(
                            new HTuple(hv_MinAreas.TupleLength())))).TupleOr(new HTuple((new HTuple(hv_AreaNames.TupleLength()
                            )).TupleNotEqual(new HTuple(hv_MaxAreas.TupleLength()))))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = new HTuple("'area_ranges': 'name', 'min' and 'max' must have the same length");

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check values of min, max.
                        if ((int)(new HTuple(((((hv_MinAreas.TupleGreaterEqualElem(hv_MaxAreas))).TupleFind(
                            1))).TupleGreater(-1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges': 'min' must be elementwise smaller than 'max'";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                    //
                    //Check if instance-type is valid.
                    hv_InstanceTypeExists.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "instance_type", out hv_InstanceTypeExists);
                    if ((int)(hv_InstanceTypeExists.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "The evaluation parameters need a key-value pair for 'instance_type'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    else
                    {
                        hv_InstanceType.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "instance_type", out hv_InstanceType);
                        hv_ValidInstanceTypes.Dispose();
                        hv_ValidInstanceTypes = new HTuple();
                        hv_ValidInstanceTypes[0] = "rectangle1";
                        hv_ValidInstanceTypes[1] = "rectangle2";
                        if ((int)(new HTuple(((hv_ValidInstanceTypes.TupleFind(hv_InstanceType))).TupleEqual(
                            -1))) != 0)
                        {
                            hv_Exception.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Exception = ("Invalid instance type '" + hv_InstanceType) + "'";
                            }

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                    //
                    //Check if the entry 'allocation_block_length' is present and valid.
                    hv_AllocationBlockLengthExists.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "allocation_block_length",
                        out hv_AllocationBlockLengthExists);
                    if ((int)(hv_AllocationBlockLengthExists.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "The evaluation parameters need a key-value pair for 'allocation_block_length'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    else
                    {
                        hv_AllocationBlockLength.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "allocation_block_length", out hv_AllocationBlockLength);
                        //Check the length of 'allocation_block_length'.
                        if ((int)(new HTuple((new HTuple(hv_AllocationBlockLength.TupleLength()
                            )).TupleNotEqual(1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'allocation_block_length' should have length 1";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check the type of 'allocation_block_length'.
                        if ((int)(new HTuple(((hv_AllocationBlockLength.TupleType())).TupleNotEqual(
                            (new HTuple((new HTuple(0)).TupleInt())).TupleType()))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'allocation_block_length' should be of type int";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check if 'allocation_block_length' is larger than zero.
                        if ((int)(new HTuple(hv_AllocationBlockLength.TupleLess(1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'allocation_block_length' should be positive";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                    //
                    //Check if the entry 'detailed_evaluation' is valid if present.
                    hv_DetailedEvaluationExists.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "detailed_evaluation",
                        out hv_DetailedEvaluationExists);
                    if ((int)(hv_DetailedEvaluationExists.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "The evaluation parameters need a key-value pair for 'detailed_evaluation'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    else
                    {
                        hv_DetailedEvaluation.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "detailed_evaluation", out hv_DetailedEvaluation);
                        //Check the length of 'detailed_evaluation'.
                        if ((int)(new HTuple((new HTuple(hv_DetailedEvaluation.TupleLength())).TupleNotEqual(
                            1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'detailed_evaluation' should have length 1";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check the type of 'detailed_evaluation'.
                        if ((int)(new HTuple(((hv_DetailedEvaluation.TupleType())).TupleNotEqual(
                            (new HTuple(1)).TupleType()))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'detailed_evaluation' should be of type int";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check if 'detailed_evaluation' is larger than zero.
                        if ((int)((new HTuple(hv_DetailedEvaluation.TupleNotEqual(0))).TupleAnd(
                            new HTuple(hv_DetailedEvaluation.TupleNotEqual(1)))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'detailed_evaluation' should be zero or one";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                    //
                    //Add valid measure 'soap' if instance_type is 'rectangle2'.
                    if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_ValidMeasures = hv_ValidMeasures.TupleConcat(
                                    "soap");
                                hv_ValidMeasures.Dispose();
                                hv_ValidMeasures = ExpTmpLocalVar_ValidMeasures;
                            }
                        }
                    }
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("segmentation"))) != 0)
                {
                    //Pixel-based evaluation.
                    hv_ValidMeasures.Dispose();
                    hv_ValidMeasures = new HTuple();
                    hv_ValidMeasures[0] = "all";
                    hv_ValidMeasures[1] = "pixel_accuracy";
                    hv_ValidMeasures[2] = "mean_accuracy";
                    hv_ValidMeasures[3] = "mean_iou";
                    hv_ValidMeasures[4] = "class_iou";
                    hv_ValidMeasures[5] = "class_pixel_accuracy";
                    hv_ValidMeasures[6] = "pixel_confusion_matrix";
                    hv_ValidMeasures[7] = "frequency_weighted_iou";
                    //
                    //Check if the entry 'ignore_class_ids' exists.
                    hv_IgnoreClassIDsExist.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "ignore_class_ids",
                        out hv_IgnoreClassIDsExist);
                    if ((int)(hv_IgnoreClassIDsExist.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "The evaluation parameters need a key-value pair for 'ignore_class_ids'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                }
                else
                {
                    hv_Exception.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Exception = "Unknown evaluation_type: " + hv_EvaluationType;
                    }

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();

                    return;
                }
                //Check measures.
                hv_ValidMeasuresString.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ValidMeasuresString = HTuple.TupleGenConst(
                        ((new HTuple(hv_ValidMeasures.TupleLength())) * 2) - 1, new HTuple("','"));
                }
                if (hv_ValidMeasuresString == null)
                    hv_ValidMeasuresString = new HTuple();
                hv_ValidMeasuresString[HTuple.TupleGenSequence(0, (new HTuple(hv_ValidMeasuresString.TupleLength()
                    )) - 1, 2)] = hv_ValidMeasures;
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_ValidMeasuresString = hv_ValidMeasuresString.TupleSum()
                            ;
                        hv_ValidMeasuresString.Dispose();
                        hv_ValidMeasuresString = ExpTmpLocalVar_ValidMeasuresString;
                    }
                }
                for (hv_Idx = 0; (int)hv_Idx <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_Idx = (int)hv_Idx + 1)
                {
                    hv_ValidMeasure.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ValidMeasure = ((hv_ValidMeasures.TupleFind(
                            hv_Measures.TupleSelect(hv_Idx)))).TupleGreaterElem(-1);
                    }
                    if ((int)(hv_ValidMeasure.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Exception = ((("Invalid measure '" + (hv_Measures.TupleSelect(
                                hv_Idx))) + new HTuple("', choose one of ['")) + hv_ValidMeasuresString) + "']";
                        }

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                }
                //
                //Done with checks.
                hv_Valid.Dispose();
                hv_Valid = 1;

                hv_ClassIDsExist.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClassesExist.Dispose();
                hv_NumClasses.Dispose();
                hv_EvalInstancesExists.Dispose();
                hv_EvaluationTypeExists.Dispose();
                hv_EvaluationType.Dispose();
                hv_Indices.Dispose();
                hv_MeasuresExists.Dispose();
                hv_Measures.Dispose();
                hv_ValidMeasures.Dispose();
                hv_Ks.Dispose();
                hv_KeysExist.Dispose();
                hv_ClassNames.Dispose();
                hv_ClassesToEvaluate.Dispose();
                hv_ClassIDsToEvaluate.Dispose();
                hv_IouThreshExists.Dispose();
                hv_IouThresholds.Dispose();
                hv_MaxNumDetectionsExists.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRangesExist.Dispose();
                hv_AreaRanges.Dispose();
                hv_AreaKeysExist.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_InstanceTypeExists.Dispose();
                hv_InstanceType.Dispose();
                hv_ValidInstanceTypes.Dispose();
                hv_AllocationBlockLengthExists.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_DetailedEvaluationExists.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_IgnoreClassIDsExist.Dispose();
                hv_ValidMeasuresString.Dispose();
                hv_Idx.Dispose();
                hv_ValidMeasure.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ClassIDsExist.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClassesExist.Dispose();
                hv_NumClasses.Dispose();
                hv_EvalInstancesExists.Dispose();
                hv_EvaluationTypeExists.Dispose();
                hv_EvaluationType.Dispose();
                hv_Indices.Dispose();
                hv_MeasuresExists.Dispose();
                hv_Measures.Dispose();
                hv_ValidMeasures.Dispose();
                hv_Ks.Dispose();
                hv_KeysExist.Dispose();
                hv_ClassNames.Dispose();
                hv_ClassesToEvaluate.Dispose();
                hv_ClassIDsToEvaluate.Dispose();
                hv_IouThreshExists.Dispose();
                hv_IouThresholds.Dispose();
                hv_MaxNumDetectionsExists.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRangesExist.Dispose();
                hv_AreaRanges.Dispose();
                hv_AreaKeysExist.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_InstanceTypeExists.Dispose();
                hv_InstanceType.Dispose();
                hv_ValidInstanceTypes.Dispose();
                hv_AllocationBlockLengthExists.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_DetailedEvaluationExists.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_IgnoreClassIDsExist.Dispose();
                hv_ValidMeasuresString.Dispose();
                hv_Idx.Dispose();
                hv_ValidMeasure.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Local procedures 
        public void check_data_availability(HTuple hv_ExampleDataDir, HTuple hv_DLDatasetFileName,
            HTuple hv_TrainedModelFileName, HTuple hv_UsePretrainedModel)
        {



            // Local control variables 

            HTuple hv_FileExists = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure checks the availability of all files required to run the
                //evaluation example.
                //
                hv_FileExists.Dispose();
                HOperatorSet.FileExists(hv_ExampleDataDir, out hv_FileExists);
                if ((int)(hv_FileExists.TupleNot()) != 0)
                {
                    throw new HalconException(hv_ExampleDataDir + " does not exist. Please run part 1 of example series.");
                }
                //
                hv_FileExists.Dispose();
                HOperatorSet.FileExists(hv_DLDatasetFileName, out hv_FileExists);
                if ((int)(hv_FileExists.TupleNot()) != 0)
                {
                    throw new HalconException(hv_DLDatasetFileName + " does not exist. Please run part 1 of example series.");
                }
                //
                hv_FileExists.Dispose();
                HOperatorSet.FileExists(hv_TrainedModelFileName, out hv_FileExists);
                if ((int)(hv_FileExists.TupleNot()) != 0)
                {
                    if ((int)(hv_UsePretrainedModel) != 0)
                    {
                        throw new HalconException(hv_TrainedModelFileName + " does not exist. Please run the HALCON Deep Learning installer.");
                    }
                    else
                    {
                        throw new HalconException(hv_TrainedModelFileName + " does not exist. Please run part 2 of example series.");
                    }
                }
                //

                hv_FileExists.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_FileExists.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void check_data_availability_COPY_1(HTuple hv_ExampleDataDir, HTuple hv_DLDatasetFileName,
            HTuple hv_TrainedModelFileName, HTuple hv_UsePretrainedModel)
        {



            // Local control variables 

            HTuple hv_FileExists = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure checks the availability of all files required to run the
                //evaluation example.

                hv_FileExists.Dispose();
                HOperatorSet.FileExists(hv_ExampleDataDir, out hv_FileExists);
                if ((int)(hv_FileExists.TupleNot()) != 0)
                {
                    throw new HalconException(hv_ExampleDataDir + " does not exist. Please run part 1 of example series.");
                }

                hv_FileExists.Dispose();
                HOperatorSet.FileExists(hv_DLDatasetFileName, out hv_FileExists);
                if ((int)(hv_FileExists.TupleNot()) != 0)
                {
                    throw new HalconException(hv_DLDatasetFileName + " does not exist. Please run part 1 of example series.");
                }

                hv_FileExists.Dispose();
                HOperatorSet.FileExists(hv_TrainedModelFileName, out hv_FileExists);
                if ((int)(hv_FileExists.TupleNot()) != 0)
                {
                    if ((int)(hv_UsePretrainedModel) != 0)
                    {
                        throw new HalconException(hv_TrainedModelFileName + " does not exist. Please run the HALCON Deep Learning installer.");
                    }
                    else
                    {
                        throw new HalconException(hv_TrainedModelFileName + " does not exist. Please run part 2 of example series.");
                    }
                }


                hv_FileExists.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_FileExists.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_close_example_image_window(HTuple hv_ExampleInternals)
        {



            // Local control variables 

            HTuple hv_WindowHandleImages = new HTuple();
            HTuple hv_Exception = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure closes the image window.

                try
                {
                    hv_WindowHandleImages.Dispose();
                    HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images", out hv_WindowHandleImages);
                    HDevWindowStack.SetActive(hv_WindowHandleImages);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                    }
                    //Delete key.
                    HOperatorSet.RemoveDictKey(hv_ExampleInternals, "window_images");
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                }


                hv_WindowHandleImages.Dispose();
                hv_Exception.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_WindowHandleImages.Dispose();
                hv_Exception.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_close_example_legend_window(HTuple hv_ExampleInternals)
        {



            // Local control variables 

            HTuple hv_WindowHandleLegend = new HTuple();
            HTuple hv_Exception = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure closes the legend window.

                try
                {
                    hv_WindowHandleLegend.Dispose();
                    HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_legend", out hv_WindowHandleLegend);
                    HDevWindowStack.SetActive(hv_WindowHandleLegend);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                    }
                    //Delete key.
                    HOperatorSet.RemoveDictKey(hv_ExampleInternals, "window_legend");
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                }


                hv_WindowHandleLegend.Dispose();
                hv_Exception.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_WindowHandleLegend.Dispose();
                hv_Exception.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_close_example_windows(HTuple hv_ExampleInternals)
        {



            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_Keys = new HTuple(), hv_Index = new HTuple();
            HTuple hv_WindowHandle = new HTuple(), hv_Exception = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure closes all example windows.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_Keys.Dispose();
                    hv_Index.Dispose();
                    hv_WindowHandle.Dispose();
                    hv_Exception.Dispose();

                    return;
                }
                //
                hv_Keys.Dispose();
                HOperatorSet.GetDictParam(hv_ExampleInternals, "keys", new HTuple(), out hv_Keys);
                for (hv_Index = 0; (int)hv_Index <= (int)(new HTuple(hv_Keys.TupleLength())); hv_Index = (int)hv_Index + 1)
                {
                    try
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_WindowHandle.Dispose();
                            HOperatorSet.GetDictTuple(hv_ExampleInternals, hv_Keys.TupleSelect(hv_Index),
                                out hv_WindowHandle);
                        }
                        HDevWindowStack.SetActive(hv_WindowHandle);
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                        }
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException1)
                    {
                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    }
                }
                //

                hv_ShowExampleScreens.Dispose();
                hv_Keys.Dispose();
                hv_Index.Dispose();
                hv_WindowHandle.Dispose();
                hv_Exception.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_Keys.Dispose();
                hv_Index.Dispose();
                hv_WindowHandle.Dispose();
                hv_Exception.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_example_reset_windows(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_WindowHandlesToClose = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_I = new HTuple();
            HTuple hv_WindowHandleKeys = new HTuple(), hv_Index = new HTuple();
            HTuple hv_WindowImagesNeeded = new HTuple(), hv_WindowLegendNeeded = new HTuple();
            HTuple hv_WindowHandleImages = new HTuple(), hv_WindowHandleLegend = new HTuple();
            HTuple hv_WindowHandleText = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure resets the graphics windows.

                //Close any windows that are listed in key 'window_handles_to_close'.
                try
                {
                    hv_WindowHandlesToClose.Dispose();
                    HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_handles_to_close",
                        out hv_WindowHandlesToClose);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    hv_WindowHandlesToClose.Dispose();
                    hv_WindowHandlesToClose = new HTuple();
                }
                for (hv_I = 0; (int)hv_I <= (int)((new HTuple(hv_WindowHandlesToClose.TupleLength()
                    )) - 1); hv_I = (int)hv_I + 1)
                {
                    HDevWindowStack.SetActive(hv_WindowHandlesToClose.TupleSelect(
                        hv_I));
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                    }
                }
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_handles_to_close", new HTuple());

                //Open image window if needed
                hv_WindowHandleKeys.Dispose();
                HOperatorSet.GetDictParam(hv_ExampleInternals, "keys", new HTuple(), out hv_WindowHandleKeys);
                hv_Index.Dispose();
                HOperatorSet.TupleFind(hv_WindowHandleKeys, "window_images", out hv_Index);
                hv_WindowImagesNeeded.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_needed", out hv_WindowImagesNeeded);
                if ((int)(hv_WindowImagesNeeded.TupleAnd(new HTuple(hv_Index.TupleEqual(-1)))) != 0)
                {
                    //Open new window for images
                    dev_open_example_image_window(hv_ExampleInternals);
                }
                else if ((int)((new HTuple(hv_WindowImagesNeeded.TupleNot())).TupleAnd(
                    new HTuple(hv_Index.TupleNotEqual(-1)))) != 0)
                {
                    //Window for images exists but is not needed -> close it
                    dev_close_example_image_window(hv_ExampleInternals);
                }

                //Open legend window if needed
                hv_WindowHandleKeys.Dispose();
                HOperatorSet.GetDictParam(hv_ExampleInternals, "keys", new HTuple(), out hv_WindowHandleKeys);
                hv_Index.Dispose();
                HOperatorSet.TupleFind(hv_WindowHandleKeys, "window_legend", out hv_Index);
                hv_WindowLegendNeeded.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_legend_needed", out hv_WindowLegendNeeded);
                if ((int)(hv_WindowLegendNeeded.TupleAnd(new HTuple(hv_Index.TupleEqual(-1)))) != 0)
                {
                    //Open new window for legend
                    dev_open_example_legend_window(hv_ExampleInternals, 280);
                }
                else if ((int)((new HTuple(hv_WindowLegendNeeded.TupleNot())).TupleAnd(
                    new HTuple(hv_Index.TupleNotEqual(-1)))) != 0)
                {
                    //Window for legend exists but is not needed -> close it
                    dev_close_example_legend_window(hv_ExampleInternals);
                }

                //Set the correct area (part) of the image window.
                try
                {
                    hv_WindowHandleImages.Dispose();
                    HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images", out hv_WindowHandleImages);
                    HDevWindowStack.SetActive(hv_WindowHandleImages);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                    }
                    //Set default window extends
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), 360, 0, 800,
                            500);
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetPart(HDevWindowStack.GetActive(), 1, 1, -1, -1);
                    }
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                }

                //Set the correct area (part) of the legend window.
                try
                {
                    hv_WindowHandleLegend.Dispose();
                    HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_legend", out hv_WindowHandleLegend);
                    HDevWindowStack.SetActive(hv_WindowHandleLegend);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetPart(HDevWindowStack.GetActive(), 1, 1, -1, -1);
                    }
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                }
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                }

                hv_WindowHandlesToClose.Dispose();
                hv_Exception.Dispose();
                hv_I.Dispose();
                hv_WindowHandleKeys.Dispose();
                hv_Index.Dispose();
                hv_WindowImagesNeeded.Dispose();
                hv_WindowLegendNeeded.Dispose();
                hv_WindowHandleImages.Dispose();
                hv_WindowHandleLegend.Dispose();
                hv_WindowHandleText.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_WindowHandlesToClose.Dispose();
                hv_Exception.Dispose();
                hv_I.Dispose();
                hv_WindowHandleKeys.Dispose();
                hv_Index.Dispose();
                hv_WindowImagesNeeded.Dispose();
                hv_WindowLegendNeeded.Dispose();
                hv_WindowHandleImages.Dispose();
                hv_WindowHandleLegend.Dispose();
                hv_WindowHandleText.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_confusion_matrix(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure explains the pixel accuracy.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_Text.Dispose();

                    return;
                }
                //
                //Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                dev_display_example_reset_windows(hv_ExampleInternals);
                //
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                //
                //Display introductional text.
                hv_Text.Dispose();
                hv_Text = "Evaluation measures: Confusion matrix";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("Knowing the ground truth class, we can compare the class affiliations:");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "the predicted one and the correct one.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "A confusion matrix is a table with such comparisons.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "This table makes it easy to see how well the network performs for each";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "class. For every class it lists how many instances have been predicted";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "into which class.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("In HALCON, we represent for each class the instances");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "with this ground truth label in a column and";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "the instances predicted to belong to this class in a row. ";
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", "box", "true");
                }
                //

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_evaluation_measures(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure shows an overview of evaluation measures.

                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_Text.Dispose();

                    return;
                }

                //* Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                dev_display_example_reset_windows(hv_ExampleInternals);

                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);

                //Display introductional text.
                hv_Text.Dispose();
                hv_Text = "The evaluation of a classification model is performed by ";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "the procedure 'evaluate_dl_model'.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "In classification the whole image is assigned to a class.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("In the following, the measures and possible visualizations are introduced.");
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }

                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", "box", "true");
                }


                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_final(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure shows the final screen for the example.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_Text.Dispose();

                    return;
                }
                //
                dev_open_example_text_window(hv_ExampleInternals);
                //
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                //
                //Display introductional text.
                hv_Text.Dispose();
                hv_Text = "In this example we have seen:";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = " - which evaluation measures can be computed for a classification model";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = " - how the model is evaluated by means of measures and visual inspection";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("If the performance of the model satisfies the requirements,");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "it can now be applied to new images.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("How this is done, is explained in the next example");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "'classify_pill_defects_deep_learning_4_infer.hdev'.";
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Please open the next example.",
                        "window", "bottom", "right", "black", "box", "true");
                }
                //
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_handles_to_close", hv_WindowHandleText);
                //

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_introduction(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure shows an overview on all example parts.

                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_Text.Dispose();

                    return;
                }

                //Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
                dev_display_example_reset_windows(hv_ExampleInternals);

                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);

                //Display introductional text.
                hv_Text.Dispose();
                hv_Text = new HTuple("This example is part of a series of examples, which summarize ");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "the workflow for DL classification.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "The four parts are: ";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "1. Dataset preprocessing.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "2. Training of the model.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "3. Evaluation of the trained model.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "4. Inference on new images.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "This example covers part 3: 'Evaluation of the trained model'.";

                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", "box", "true");
                }


                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_precision_recall_f1score(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure explains the entities precision, recall and F1-score..
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_Text.Dispose();

                    return;
                }
                //
                //Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                dev_display_example_reset_windows(hv_ExampleInternals);
                //
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                //
                //Display introductional text.
                hv_Text.Dispose();
                hv_Text = new HTuple("Evaluation measures: Precision, Recall, and F1-score");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "The precision is the proportion of";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "all correctly predicted positives (TP) to";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "all predicted positives (TP and FP).";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("The recall, also called the \"true positive rate\", is the proportion of");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "all correctly predicted positives (TP) to";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "all real positives (TP and FN).";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("To represent precision and recall with a single number, we compute");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "the harmonic mean (F1-score) of precision and recall.";
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", "box", "true");
                }
                //

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_run_program(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_UsePretrainedModel = new HTuple();
            HTuple hv_Text = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure informs about the code that will be executed.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_UsePretrainedModel.Dispose();
                    hv_Text.Dispose();

                    return;
                }
                //
                //Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                dev_display_example_reset_windows(hv_ExampleInternals);
                //
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                //
                //Display introductional text.
                hv_UsePretrainedModel.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "use_pretrained_model", out hv_UsePretrainedModel);
                if ((int)(hv_UsePretrainedModel) != 0)
                {
                    hv_Text.Dispose();
                    hv_Text = "We will now evaluate the pretrained model shipped with HALCON.";
                }
                else
                {
                    hv_Text.Dispose();
                    hv_Text = "We will now evaluate the retrained model from example part 2";
                    if (hv_Text == null)
                        hv_Text = new HTuple();
                    hv_Text[new HTuple(hv_Text.TupleLength())] = "'classify_pills_deep_learning_2_train.hdev'.";
                }
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("First, we calculate the evaluation measure on the 'test'-split.");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "We display the resulting measures and a confusion matrix.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("Then, we display an interactive confusion matrix.");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("Clicking on an entry, the corresponding images are shown.");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("Finally, a heatmap is shown for a set of images. Here, ");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "we will do this for images labeled and classified as 'contamination'.";
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", "box", "true");
                }
                //
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_handles_to_close", hv_WindowHandleText);
                //

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_UsePretrainedModel.Dispose();
                hv_Text.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_UsePretrainedModel.Dispose();
                hv_Text.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_topK(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure explains the Mean IoU.

                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_Text.Dispose();

                    return;
                }

                //Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                dev_display_example_reset_windows(hv_ExampleInternals);

                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);

                //Display introductional text.
                hv_Text.Dispose();
                hv_Text = "Evaluation measures: top-k error";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("For a given image, the classifier infers class confidences of");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "how likely the image belongs to every distinguished class.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "The top-k error tells the ratio of predictions where the ground truth class";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "is not within the k predicted classes with the highest confidences.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("E.g., in the case of top-1 error, we check if the target label matches");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "the prediction with the highest probability.";

                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }

                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", "box", "true");
                }


                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                return;

            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_visual_inspection_intro(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure explains the visual inspection tools.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_Text.Dispose();

                    return;
                }

                //Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                dev_display_example_reset_windows(hv_ExampleInternals);
                //
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                //
                //Display text.
                hv_Text.Dispose();
                hv_Text = "Visual inspection:";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "Use the procedure 'dev_display_dl_interactive_confusion_matrix'";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "to show a confusion matrix and interactively display the images";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "by clicking on the matrix entries.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "For a quick generation of a heatmap of an image to analyze its";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "classification result use the operator 'gen_dl_model_heatmap'.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "The procedure 'gen_dl_model_classification_heatmap' can be";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "used as an alternative.";
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", "box", "true");
                }
                //

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_example_init(HTuple hv_ShowExampleScreens, HTuple hv_UsePretrainedModel,
            out HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_WindowWidthText = new HTuple(), hv_WindowHeightText = new HTuple();
            HTuple hv_WindowBGColor = new HTuple(), hv_WindowHandleText = new HTuple();
            // Initialize local and output iconic variables 
            hv_ExampleInternals = new HTuple();
            try
            {
                //This procedure initializes the graphic windows that are used for explanations during the example.

                //A dictionary that will be used/adapted by other example procedures.
                hv_ExampleInternals.Dispose();
                HOperatorSet.CreateDict(out hv_ExampleInternals);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "show_example_screens", hv_ShowExampleScreens);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "use_pretrained_model", hv_UsePretrainedModel);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_WindowWidthText.Dispose();
                    hv_WindowHeightText.Dispose();
                    hv_WindowBGColor.Dispose();
                    hv_WindowHandleText.Dispose();

                    return;
                }

                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                }
                hv_WindowWidthText.Dispose();
                hv_WindowWidthText = 800;
                hv_WindowHeightText.Dispose();
                hv_WindowHeightText = 300;
                hv_WindowBGColor.Dispose();
                hv_WindowBGColor = "gray";
                HOperatorSet.SetWindowAttr("background_color", hv_WindowBGColor);
                HOperatorSet.OpenWindow(0, 0, hv_WindowWidthText, hv_WindowHeightText, 0, "visible", "", out hv_WindowHandleText);
                HDevWindowStack.Push(hv_WindowHandleText);
                set_display_font(hv_WindowHandleText, 16, "mono", "true", "false");
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_text", hv_WindowHandleText);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_text_width", hv_WindowWidthText);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_text_height", hv_WindowHeightText);

                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);


                hv_WindowWidthText.Dispose();
                hv_WindowHeightText.Dispose();
                hv_WindowBGColor.Dispose();
                hv_WindowHandleText.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_WindowWidthText.Dispose();
                hv_WindowHeightText.Dispose();
                hv_WindowBGColor.Dispose();
                hv_WindowHandleText.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_open_example_image_window(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_WindowHeightText = new HTuple();
            HTuple hv_WindowWidthImage = new HTuple(), hv_WindowHeightImages = new HTuple();
            HTuple hv_WindowBGColor = new HTuple(), hv_WindowYImages = new HTuple();
            HTuple hv_WindowXImages = new HTuple(), hv_WindowHandleImages = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure initializes the graphic windows that are used to display example images.

                hv_WindowHeightText.Dispose();
                hv_WindowHeightText = 300;
                hv_WindowWidthImage.Dispose();
                hv_WindowWidthImage = 500;
                hv_WindowHeightImages.Dispose();
                hv_WindowHeightImages = 500;
                hv_WindowBGColor.Dispose();
                hv_WindowBGColor = "gray";

                hv_WindowYImages.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowYImages = hv_WindowHeightText + 60;
                }
                hv_WindowXImages.Dispose();
                hv_WindowXImages = 0;
                HOperatorSet.SetWindowAttr("background_color", hv_WindowBGColor);
                HOperatorSet.OpenWindow(hv_WindowYImages, hv_WindowXImages, hv_WindowWidthImage, hv_WindowHeightImages, 0, "visible", "", out hv_WindowHandleImages);
                HDevWindowStack.Push(hv_WindowHandleImages);
                set_display_font(hv_WindowHandleImages, 16, "mono", "true", "false");
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images", hv_WindowHandleImages);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_width", hv_WindowWidthImage);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_height", hv_WindowHeightImages);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_x", hv_WindowXImages);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_y", hv_WindowYImages);

                hv_WindowHeightText.Dispose();
                hv_WindowWidthImage.Dispose();
                hv_WindowHeightImages.Dispose();
                hv_WindowBGColor.Dispose();
                hv_WindowYImages.Dispose();
                hv_WindowXImages.Dispose();
                hv_WindowHandleImages.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_WindowHeightText.Dispose();
                hv_WindowWidthImage.Dispose();
                hv_WindowHeightImages.Dispose();
                hv_WindowBGColor.Dispose();
                hv_WindowYImages.Dispose();
                hv_WindowXImages.Dispose();
                hv_WindowHandleImages.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_open_example_legend_window(HTuple hv_ExampleInternals, HTuple hv_WindowWidth)
        {



            // Local control variables 

            HTuple hv_WindowImagesHeight = new HTuple();
            HTuple hv_WindowImagesWidth = new HTuple(), hv_WindowImagesX = new HTuple();
            HTuple hv_WindowImagesY = new HTuple(), hv_WindowHandleLegend = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure initializes the graphic windows that are used to display a legend.

                hv_WindowImagesHeight.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_height", out hv_WindowImagesHeight);
                hv_WindowImagesWidth.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_width", out hv_WindowImagesWidth);
                hv_WindowImagesX.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_x", out hv_WindowImagesX);
                hv_WindowImagesY.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_y", out hv_WindowImagesY);
                HOperatorSet.SetWindowAttr("background_color", "black");
                HOperatorSet.OpenWindow(hv_WindowImagesY, (hv_WindowImagesX + hv_WindowImagesWidth) + 5, hv_WindowWidth, hv_WindowImagesHeight, 0, "visible", "", out hv_WindowHandleLegend);
                HDevWindowStack.Push(hv_WindowHandleLegend);
                set_display_font(hv_WindowHandleLegend, 14, "mono", "true", "false");
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend", hv_WindowHandleLegend);

                hv_WindowImagesHeight.Dispose();
                hv_WindowImagesWidth.Dispose();
                hv_WindowImagesX.Dispose();
                hv_WindowImagesY.Dispose();
                hv_WindowHandleLegend.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_WindowImagesHeight.Dispose();
                hv_WindowImagesWidth.Dispose();
                hv_WindowImagesX.Dispose();
                hv_WindowImagesY.Dispose();
                hv_WindowHandleLegend.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_open_example_text_window(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_WindowWidthText = new HTuple(), hv_WindowHeightText = new HTuple();
            HTuple hv_WindowBGColor = new HTuple(), hv_WindowHandleText = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                hv_WindowWidthText.Dispose();
                hv_WindowWidthText = 800;
                hv_WindowHeightText.Dispose();
                hv_WindowHeightText = 300;
                hv_WindowBGColor.Dispose();
                hv_WindowBGColor = "gray";
                HOperatorSet.SetWindowAttr("background_color", hv_WindowBGColor);
                HOperatorSet.OpenWindow(0, 0, hv_WindowWidthText, hv_WindowHeightText, 0, "visible", "", out hv_WindowHandleText);
                HDevWindowStack.Push(hv_WindowHandleText);
                set_display_font(hv_WindowHandleText, 16, "mono", "true", "false");
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_text", hv_WindowHandleText);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_text_width", hv_WindowWidthText);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_text_height", hv_WindowHeightText);

                hv_WindowWidthText.Dispose();
                hv_WindowHeightText.Dispose();
                hv_WindowBGColor.Dispose();
                hv_WindowHandleText.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_WindowWidthText.Dispose();
                hv_WindowHeightText.Dispose();
                hv_WindowBGColor.Dispose();
                hv_WindowHandleText.Dispose();

                throw HDevExpDefaultException;
            }
        }

    }
}
