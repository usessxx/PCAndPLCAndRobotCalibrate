using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using HalconDotNet;
using System.Windows.Forms;

namespace HalconMVTec
{
   public class DeepLearningObjectDetectionRectangle2Training
    {
        // Local control variables 
        HTuple hv_PreprocessResultDirectoryPath = new HTuple();//存储预处理结果-sample文件夹 及 hdict文件的上一级文件夹路径(包含文件夹名)
        HTuple hv_PreprocessResultFileName = new HTuple();//预处理结果文件名(以".hdict"为后缀,例如:dl_preprocess_dataset.hdict)
        //HTuple hv_PreprocessResultParameterFileName = new HTuple();//预处理结果-参数的文件名(以".hdict"为后缀,例如:dl_preprocess_param.hdict)

        HTuple hv_PreprocessModelFileName = new HTuple();//读取预处理后的网络模型文件的路径(例如:preprocess_dl_model_detection.hdl)

        HTuple hv_BestModelBaseName = new HTuple();//已训练好的Best模型文件的存放路径(包含文件名,不需要后缀)(例如:best_dl_model_classification.hdl;best_dl_model_classification_info.hdict)
        HTuple hv_FinalModelBaseName = new HTuple();//已训练好的Final模型文件的存放路径(包含文件名,不需要后缀)(例如:final_dl_model_classification.hdl;final_dl_model_classification_info.hdict)

        HTuple hv_BatchSize = new HTuple();//批次大小:每个周期训练的图片数量
        HTuple hv_TotalEpochs = new HTuple();//Number of epochs to train the model.训练周期
        HTuple hv_EvaluationIntervalEpochs = new HTuple();//Evaluation interval (in epochs) to calculate evaluation measures on the validation split.每隔多少个训练周期验证一次(推荐设定为1)
        HTuple hv_InitialLearningRate = new HTuple();//Initial learning rate.初始化学习率
        HTuple hv_ChangeLearningRateEpochs = new HTuple();//Change the learning rate in the following epochs, e.g. [4, 8, 12].Set it to [] if the learning rate should not be changed.
        HTuple hv_ChangeLearningRateValues = new HTuple();//Change the learning rate to the following values, e.g. InitialLearningRate * [0.1, 0.01, 0.001].The tuple has to be of the same length as ChangeLearningRateEpochs.
        HTuple hv_Momentum = new HTuple();//Momentum should be high if batch size is small.        
        HTuple hv_WeightPrior = new HTuple();//权重过大会导致初始LOSS变大,训练时间增加----但是模型性能会提升
        HTuple hv_RandomSeed = new HTuple();//Set a random seed for training.
        HTuple hv_DisplayEvaluation = new HTuple();//Control whether training progress is displayed (true/false).是否显示评估过程

        HTuple hv_GenParamName = new HTuple();
        HTuple hv_GenParamValue = new HTuple();
        HTuple hv_AugmentationParam = new HTuple();
        HTuple hv_ChangeStrategy = new HTuple();
        HTuple hv_SerializationStrategy = new HTuple();
        HTuple hv_SelectedPercentageTrainSamples = new HTuple();
        HTuple hv_DisplayParam = new HTuple();
        HTuple hv_DLModelHandle = new HTuple();
        HTuple hv_DLDataset = new HTuple();
        HTuple hv_ClassNames = new HTuple();
        HTuple hv_DLPreprocessParam = new HTuple();
        HTuple hv_ImageWidth = new HTuple();
        HTuple hv_ImageHeight = new HTuple();
        HTuple hv_ImageNumChannels = new HTuple();
        HTuple hv_TrainParam = new HTuple();
        HTuple hv_TrainResults = new HTuple();
        HTuple hv_TrainInfos = new HTuple();
        HTuple hv_EvaluationInfos = new HTuple();

        #region DeepLearningObjectDetectionRectangle2Training(构造函数里对训练参数初始化)
        //构造函数里对预处理参数初始化
        public DeepLearningObjectDetectionRectangle2Training()
        {
            hv_BatchSize = 16;
            hv_InitialLearningRate = 0.001;

            hv_Momentum = 0.9;
            hv_TotalEpochs = 100;
            hv_EvaluationIntervalEpochs = 1;

            hv_WeightPrior = 0.001;
            hv_RandomSeed = 42;
            hv_DisplayEvaluation = 1;

            //MODIFY
            //ADD FOR DISPLAY
            //非常重要!如果没有以下4行代码,则开启的两个窗口不显示内容,且这两个窗口是死机的状态!!!
            HOperatorSet.SetSystem("width", 512);
            HOperatorSet.SetSystem("height", 512);
            if (HalconAPI.isWindows)
                HOperatorSet.SetSystem("use_window_thread", "true");
        }
        #endregion

        #region TrainingAction(训练开始)
        public void TrainingAction(string preprocessResultDirectoryPath, string preprocessModelFileName, string preprocessResultFileName,
             string bestModelBaseName, string finalModelBaseName, int batchSize,
            int totalEpochs, int evaluationIntervalEpochs, float initialLearningRate, int learningRateStepEveryNthEpoch, float learningRateStepRatio, float momentum, float weightPrior, int RandomSeed)
        {
            // Initialize local and output iconic variables 
            try
            {
                dev_update_off();

                //学习率计算
                hv_ChangeLearningRateValues[0] = hv_InitialLearningRate;
                int k = 0;
                for (int i = 0; i < hv_TotalEpochs; i++)
                {
                    if (i % learningRateStepEveryNthEpoch == 0 && i > 0)
                    {
                        hv_ChangeLearningRateEpochs[k] = i;
                        if (k == 0)
                            hv_ChangeLearningRateValues[k] = hv_ChangeLearningRateValues[k] * learningRateStepRatio;
                        if (k > 0)
                            hv_ChangeLearningRateValues[k] = hv_ChangeLearningRateValues[k - 1] * learningRateStepRatio;
                        k++;
                    }
                }

                hv_PreprocessResultDirectoryPath = preprocessResultDirectoryPath;
                hv_PreprocessModelFileName = preprocessModelFileName;
                hv_PreprocessResultFileName = preprocessResultFileName;
                hv_BestModelBaseName = bestModelBaseName;
                hv_FinalModelBaseName = finalModelBaseName;
                hv_BatchSize = batchSize;
                hv_TotalEpochs = totalEpochs;
                hv_EvaluationIntervalEpochs = evaluationIntervalEpochs;
                hv_InitialLearningRate = initialLearningRate;

                hv_Momentum = momentum;
                hv_WeightPrior = weightPrior;
                hv_RandomSeed = RandomSeed;


                hv_GenParamName = new HTuple();
                hv_GenParamValue = new HTuple();


                //halcon自带的数据增强（4/8/12）
                hv_AugmentationParam.Dispose();
                HOperatorSet.CreateDict(out hv_AugmentationParam);
                //Percentage of samples to be augmented.
                HOperatorSet.SetDictTuple(hv_AugmentationParam, "augmentation_percentage", 10);
                //Mirror images along row and column.
                HOperatorSet.SetDictTuple(hv_AugmentationParam, "mirror", "rc");
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_GenParamName = hv_GenParamName.TupleConcat(
                            "augment");
                        hv_GenParamName.Dispose();
                        hv_GenParamName = ExpTmpLocalVar_GenParamName;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_GenParamValue = hv_GenParamValue.TupleConcat(
                            hv_AugmentationParam);
                        hv_GenParamValue.Dispose();
                        hv_GenParamValue = ExpTmpLocalVar_GenParamValue;
                    }
                }

                //改变学习率过程
                if ((int)(new HTuple((new HTuple(hv_ChangeLearningRateEpochs.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    hv_ChangeStrategy.Dispose();
                    HOperatorSet.CreateDict(out hv_ChangeStrategy);
                    //Specify the model parameter to be changed, here the learning rate.
                    HOperatorSet.SetDictTuple(hv_ChangeStrategy, "model_param", "learning_rate");
                    //Start the parameter value at 'initial_value'.
                    HOperatorSet.SetDictTuple(hv_ChangeStrategy, "initial_value", hv_InitialLearningRate);
                    //Reduce the learning rate in the following epochs.
                    HOperatorSet.SetDictTuple(hv_ChangeStrategy, "epochs", hv_ChangeLearningRateEpochs);
                    //Reduce the learning rate to the following value at epoch 30.
                    HOperatorSet.SetDictTuple(hv_ChangeStrategy, "values", hv_ChangeLearningRateValues);
                    //Collect all change strategies as input.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_GenParamName = hv_GenParamName.TupleConcat(
                                "change");
                            hv_GenParamName.Dispose();
                            hv_GenParamName = ExpTmpLocalVar_GenParamName;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_GenParamValue = hv_GenParamValue.TupleConcat(
                                hv_ChangeStrategy);
                            hv_GenParamValue.Dispose();
                            hv_GenParamValue = ExpTmpLocalVar_GenParamValue;
                        }
                    }
                }
                //'best'
                hv_SerializationStrategy.Dispose();
                HOperatorSet.CreateDict(out hv_SerializationStrategy);
                HOperatorSet.SetDictTuple(hv_SerializationStrategy, "type", "best");
                HOperatorSet.SetDictTuple(hv_SerializationStrategy, "basename", hv_BestModelBaseName);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_GenParamName = hv_GenParamName.TupleConcat(
                            "serialize");
                        hv_GenParamName.Dispose();
                        hv_GenParamName = ExpTmpLocalVar_GenParamName;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_GenParamValue = hv_GenParamValue.TupleConcat(
                            hv_SerializationStrategy);
                        hv_GenParamValue.Dispose();
                        hv_GenParamValue = ExpTmpLocalVar_GenParamValue;
                    }
                }
                //'final'
                hv_SerializationStrategy.Dispose();
                HOperatorSet.CreateDict(out hv_SerializationStrategy);
                HOperatorSet.SetDictTuple(hv_SerializationStrategy, "type", "final");
                HOperatorSet.SetDictTuple(hv_SerializationStrategy, "basename", hv_FinalModelBaseName);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_GenParamName = hv_GenParamName.TupleConcat(
                            "serialize");
                        hv_GenParamName.Dispose();
                        hv_GenParamName = ExpTmpLocalVar_GenParamName;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_GenParamValue = hv_GenParamValue.TupleConcat(
                            hv_SerializationStrategy);
                        hv_GenParamValue.Dispose();
                        hv_GenParamValue = ExpTmpLocalVar_GenParamValue;
                    }
                }

                //在训练集中验证准确率
                hv_SelectedPercentageTrainSamples.Dispose();
                hv_SelectedPercentageTrainSamples = 20;
                hv_DisplayParam.Dispose();
                HOperatorSet.CreateDict(out hv_DisplayParam);
                HOperatorSet.SetDictTuple(hv_DisplayParam, "selected_percentage_train_samples",
                    hv_SelectedPercentageTrainSamples);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_GenParamName = hv_GenParamName.TupleConcat(
                            "display");
                        hv_GenParamName.Dispose();
                        hv_GenParamName = ExpTmpLocalVar_GenParamName;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple ExpTmpLocalVar_GenParamValue = hv_GenParamValue.TupleConcat(hv_DisplayParam);
                        hv_GenParamValue.Dispose();
                        hv_GenParamValue = ExpTmpLocalVar_GenParamValue;
                    }
                }

                //Check if all necessary files exist.
                //检查预处理网络模型及预处理结果文件是否存在
                try
                {
                    check_data_availability(hv_PreprocessResultDirectoryPath, hv_PreprocessModelFileName, hv_PreprocessResultDirectoryPath + "\\" + hv_PreprocessResultFileName);
                }
                catch (Exception ex)
                {
                    MessageBox.Show("数据文件检查错误!" + "\r" + ex.ToString());
                    return;
                }

                //Read in the model that was initialized during preprocessing.
                hv_DLModelHandle.Dispose();
                if (System.IO.File.Exists(bestModelBaseName + ".hdl"))//自动在上次的训练结果上继续训练
                    HOperatorSet.ReadDlModel(bestModelBaseName + ".hdl", out hv_DLModelHandle);
                else
                    HOperatorSet.ReadDlModel(hv_PreprocessModelFileName, out hv_DLModelHandle);
                
                //Read in the preprocessed DLDataset file.
                hv_DLDataset.Dispose();
                HOperatorSet.ReadDict(hv_PreprocessResultDirectoryPath + "\\" + hv_PreprocessResultFileName, new HTuple(), new HTuple(), out hv_DLDataset);

                //设置模型参数
                //Set model hyper-parameters as specified in the settings above.
                HOperatorSet.SetDlModelParam(hv_DLModelHandle, "learning_rate", hv_InitialLearningRate);
                HOperatorSet.SetDlModelParam(hv_DLModelHandle, "momentum", hv_Momentum);

                if ((int)(new HTuple(hv_BatchSize.TupleEqual("maximum"))) != 0)
                {
                    set_dl_model_param_max_gpu_batch_size(hv_DLModelHandle, 100);
                }
                else
                {
                    HOperatorSet.SetDlModelParam(hv_DLModelHandle, "batch_size", hv_BatchSize);
                }
                if ((int)(new HTuple((new HTuple(hv_WeightPrior.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    HOperatorSet.SetDlModelParam(hv_DLModelHandle, "weight_prior", hv_WeightPrior);
                }

                //MODIFY
                //设置GPU运行,如果显存不足则报错
                try
                {
                    HOperatorSet.SetDlModelParam(hv_DLModelHandle, "runtime_init", "immediately");
                }
                catch (Exception ex)
                {
                    MessageBox.Show(ex.ToString());
                    return;
                }


                //Create training parameters.
                hv_TrainParam.Dispose();
                create_dl_train_param(hv_DLModelHandle, hv_TotalEpochs, hv_EvaluationIntervalEpochs, hv_DisplayEvaluation, hv_RandomSeed, hv_GenParamName, hv_GenParamValue, out hv_TrainParam);

                //Start the training by calling the training operator
                //train_dl_model_batch () within the following procedure.
                hv_TrainResults.Dispose(); hv_TrainInfos.Dispose(); hv_EvaluationInfos.Dispose();
                train_dl_model(hv_DLDataset, hv_DLModelHandle, hv_TrainParam, 0.0, out hv_TrainResults, out hv_TrainInfos, out hv_EvaluationInfos);

                //Stop after the training has finished, before closing the windows.
                if (HDevWindowStack.IsOpen())
                {
                    //HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue", "window", "bottom", "right", "black", new HTuple(), new HTuple());

                }
                //Close training windows.
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                }

            }
            catch (HalconException HDevExpDefaultException)
            {
                hv_BestModelBaseName.Dispose();
                hv_FinalModelBaseName.Dispose();
                hv_BatchSize.Dispose();
                hv_InitialLearningRate.Dispose();
                hv_Momentum.Dispose();
                hv_EvaluationIntervalEpochs.Dispose();
                hv_ChangeLearningRateEpochs.Dispose();
                hv_ChangeLearningRateValues.Dispose();
                hv_WeightPrior.Dispose();
                hv_DisplayEvaluation.Dispose();
                hv_GenParamName.Dispose();
                hv_GenParamValue.Dispose();
                hv_AugmentationParam.Dispose();
                hv_ChangeStrategy.Dispose();
                hv_SerializationStrategy.Dispose();
                hv_SelectedPercentageTrainSamples.Dispose();
                hv_DisplayParam.Dispose();
                hv_DLModelHandle.Dispose();
                hv_DLDataset.Dispose();
                hv_TrainParam.Dispose();
                hv_TrainResults.Dispose();
                hv_TrainInfos.Dispose();
                hv_EvaluationInfos.Dispose();

                //throw HDevExpDefaultException;
                MessageBox.Show(HDevExpDefaultException.ToString());
            }

            hv_BestModelBaseName.Dispose();
            hv_FinalModelBaseName.Dispose();
            hv_BatchSize.Dispose();
            hv_InitialLearningRate.Dispose();
            hv_Momentum.Dispose();
            hv_EvaluationIntervalEpochs.Dispose();
            hv_ChangeLearningRateEpochs.Dispose();
            hv_ChangeLearningRateValues.Dispose();
            hv_WeightPrior.Dispose();
            hv_DisplayEvaluation.Dispose();
            hv_GenParamName.Dispose();
            hv_GenParamValue.Dispose();
            hv_AugmentationParam.Dispose();
            hv_ChangeStrategy.Dispose();
            hv_SerializationStrategy.Dispose();
            hv_SelectedPercentageTrainSamples.Dispose();
            hv_DisplayParam.Dispose();
            hv_DLModelHandle.Dispose();
            hv_DLDataset.Dispose();
            hv_TrainParam.Dispose();
            hv_TrainResults.Dispose();
            hv_TrainInfos.Dispose();
            hv_EvaluationInfos.Dispose();
        }
        #endregion

        // Procedures 
        // External procedures 
        // Chapter: Deep Learning / Evaluation
        private void add_colormap_to_image(HObject ho_GrayValueImage, HObject ho_Image,
            out HObject ho_ColoredImage, HTuple hv_HeatmapColorScheme)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_RGBValueImage, ho_Channels, ho_ChannelsScaled;
            HObject ho_Channel = null, ho_ChannelScaled = null, ho_ChannelScaledByte = null;
            HObject ho_ImageByte, ho_ImageByteR = null, ho_ImageByteG = null;
            HObject ho_ImageByteB = null;

            // Local copy input parameter variables 
            HObject ho_GrayValueImage_COPY_INP_TMP;
            ho_GrayValueImage_COPY_INP_TMP = new HObject(ho_GrayValueImage);



            // Local control variables 

            HTuple hv_Type = new HTuple(), hv_NumChannels = new HTuple();
            HTuple hv_ChannelIndex = new HTuple(), hv_ChannelMin = new HTuple();
            HTuple hv_ChannelMax = new HTuple(), hv__ = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ColoredImage);
            HOperatorSet.GenEmptyObj(out ho_RGBValueImage);
            HOperatorSet.GenEmptyObj(out ho_Channels);
            HOperatorSet.GenEmptyObj(out ho_ChannelsScaled);
            HOperatorSet.GenEmptyObj(out ho_Channel);
            HOperatorSet.GenEmptyObj(out ho_ChannelScaled);
            HOperatorSet.GenEmptyObj(out ho_ChannelScaledByte);
            HOperatorSet.GenEmptyObj(out ho_ImageByte);
            HOperatorSet.GenEmptyObj(out ho_ImageByteR);
            HOperatorSet.GenEmptyObj(out ho_ImageByteG);
            HOperatorSet.GenEmptyObj(out ho_ImageByteB);
            try
            {
                //
                //This procedure adds a gray-value image to a RGB image with a chosen colormap.
                //
                hv_Type.Dispose();
                HOperatorSet.GetImageType(ho_GrayValueImage_COPY_INP_TMP, out hv_Type);
                //The image LUT needs a byte image. Rescale real images.
                if ((int)(new HTuple(hv_Type.TupleEqual("real"))) != 0)
                {
                    {
                        HObject ExpTmpOutVar_0;
                        scale_image_range(ho_GrayValueImage_COPY_INP_TMP, out ExpTmpOutVar_0, 0,
                            1);
                        ho_GrayValueImage_COPY_INP_TMP.Dispose();
                        ho_GrayValueImage_COPY_INP_TMP = ExpTmpOutVar_0;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConvertImageType(ho_GrayValueImage_COPY_INP_TMP, out ExpTmpOutVar_0,
                            "byte");
                        ho_GrayValueImage_COPY_INP_TMP.Dispose();
                        ho_GrayValueImage_COPY_INP_TMP = ExpTmpOutVar_0;
                    }
                }
                else if ((int)(new HTuple(hv_Type.TupleNotEqual("byte"))) != 0)
                {
                    throw new HalconException(new HTuple("For this transformation, a byte or real image is needed!"));
                }
                //
                //Apply the chosen color scheme on the gray value.
                ho_RGBValueImage.Dispose();
                apply_colorscheme_on_gray_value_image(ho_GrayValueImage_COPY_INP_TMP, out ho_RGBValueImage,
                    hv_HeatmapColorScheme);
                //
                //Convert input image to byte image for visualization.
                ho_Channels.Dispose();
                HOperatorSet.ImageToChannels(ho_Image, out ho_Channels);
                hv_NumChannels.Dispose();
                HOperatorSet.CountChannels(ho_Image, out hv_NumChannels);
                ho_ChannelsScaled.Dispose();
                HOperatorSet.GenEmptyObj(out ho_ChannelsScaled);
                HTuple end_val19 = hv_NumChannels;
                HTuple step_val19 = 1;
                for (hv_ChannelIndex = 1; hv_ChannelIndex.Continue(end_val19, step_val19); hv_ChannelIndex = hv_ChannelIndex.TupleAdd(step_val19))
                {
                    ho_Channel.Dispose();
                    HOperatorSet.SelectObj(ho_Channels, out ho_Channel, hv_ChannelIndex);
                    hv_ChannelMin.Dispose(); hv_ChannelMax.Dispose(); hv__.Dispose();
                    HOperatorSet.MinMaxGray(ho_Channel, ho_Channel, 0, out hv_ChannelMin, out hv_ChannelMax,
                        out hv__);
                    ho_ChannelScaled.Dispose();
                    scale_image_range(ho_Channel, out ho_ChannelScaled, hv_ChannelMin, hv_ChannelMax);
                    ho_ChannelScaledByte.Dispose();
                    HOperatorSet.ConvertImageType(ho_ChannelScaled, out ho_ChannelScaledByte,
                        "byte");
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_ChannelsScaled, ho_ChannelScaledByte, out ExpTmpOutVar_0
                            );
                        ho_ChannelsScaled.Dispose();
                        ho_ChannelsScaled = ExpTmpOutVar_0;
                    }
                }
                ho_ImageByte.Dispose();
                HOperatorSet.ChannelsToImage(ho_ChannelsScaled, out ho_ImageByte);
                //
                //Note that ImageByte needs to have the same number of channels as
                //RGBValueImage to display colormap image correctly.
                hv_NumChannels.Dispose();
                HOperatorSet.CountChannels(ho_ImageByte, out hv_NumChannels);
                if ((int)(new HTuple(hv_NumChannels.TupleNotEqual(3))) != 0)
                {
                    //Just take the first channel and use this to generate
                    //an image with 3 channels for visualization.
                    ho_ImageByteR.Dispose();
                    HOperatorSet.AccessChannel(ho_ImageByte, out ho_ImageByteR, 1);
                    ho_ImageByteG.Dispose();
                    HOperatorSet.CopyImage(ho_ImageByteR, out ho_ImageByteG);
                    ho_ImageByteB.Dispose();
                    HOperatorSet.CopyImage(ho_ImageByteR, out ho_ImageByteB);
                    ho_ImageByte.Dispose();
                    HOperatorSet.Compose3(ho_ImageByteR, ho_ImageByteG, ho_ImageByteB, out ho_ImageByte
                        );
                }
                //
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.AddImage(ho_ImageByte, ho_RGBValueImage, out ExpTmpOutVar_0, 0.5,
                        0);
                    ho_RGBValueImage.Dispose();
                    ho_RGBValueImage = ExpTmpOutVar_0;
                }
                ho_ColoredImage.Dispose();
                ho_ColoredImage = new HObject(ho_RGBValueImage);
                //
                ho_GrayValueImage_COPY_INP_TMP.Dispose();
                ho_RGBValueImage.Dispose();
                ho_Channels.Dispose();
                ho_ChannelsScaled.Dispose();
                ho_Channel.Dispose();
                ho_ChannelScaled.Dispose();
                ho_ChannelScaledByte.Dispose();
                ho_ImageByte.Dispose();
                ho_ImageByteR.Dispose();
                ho_ImageByteG.Dispose();
                ho_ImageByteB.Dispose();

                hv_Type.Dispose();
                hv_NumChannels.Dispose();
                hv_ChannelIndex.Dispose();
                hv_ChannelMin.Dispose();
                hv_ChannelMax.Dispose();
                hv__.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_GrayValueImage_COPY_INP_TMP.Dispose();
                ho_RGBValueImage.Dispose();
                ho_Channels.Dispose();
                ho_ChannelsScaled.Dispose();
                ho_Channel.Dispose();
                ho_ChannelScaled.Dispose();
                ho_ChannelScaledByte.Dispose();
                ho_ImageByte.Dispose();
                ho_ImageByteR.Dispose();
                ho_ImageByteG.Dispose();
                ho_ImageByteB.Dispose();

                hv_Type.Dispose();
                hv_NumChannels.Dispose();
                hv_ChannelIndex.Dispose();
                hv_ChannelMin.Dispose();
                hv_ChannelMax.Dispose();
                hv__.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Create a lookup table and convert a grey scale image. 
        public void apply_colorscheme_on_gray_value_image(HObject ho_InputImage, out HObject ho_ResultImage,
            HTuple hv_Schema)
        {




            // Local iconic variables 

            HObject ho_ImageR, ho_ImageG, ho_ImageB;

            // Local control variables 

            HTuple hv_X = new HTuple(), hv_Low = new HTuple();
            HTuple hv_High = new HTuple(), hv_OffR = new HTuple();
            HTuple hv_OffG = new HTuple(), hv_OffB = new HTuple();
            HTuple hv_A1 = new HTuple(), hv_A0 = new HTuple(), hv_R = new HTuple();
            HTuple hv_G = new HTuple(), hv_B = new HTuple(), hv_A0R = new HTuple();
            HTuple hv_A0G = new HTuple(), hv_A0B = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ResultImage);
            HOperatorSet.GenEmptyObj(out ho_ImageR);
            HOperatorSet.GenEmptyObj(out ho_ImageG);
            HOperatorSet.GenEmptyObj(out ho_ImageB);
            try
            {
                //
                //This procedure generates an RGB ResultImage for a grey-value InputImage.
                //In order to do so, create a color distribution as look up table
                //according to the Schema.
                //
                hv_X.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_X = HTuple.TupleGenSequence(
                        0, 255, 1);
                }
                hv_Low.Dispose();
                HOperatorSet.TupleGenConst(256, 0, out hv_Low);
                hv_High.Dispose();
                HOperatorSet.TupleGenConst(256, 255, out hv_High);
                //
                if ((int)(new HTuple(hv_Schema.TupleEqual("jet"))) != 0)
                {
                    //Scheme Jet: from blue to red
                    hv_OffR.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_OffR = 3.0 * 64.0;
                    }
                    hv_OffG.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_OffG = 2.0 * 64.0;
                    }
                    hv_OffB.Dispose();
                    hv_OffB = 64.0;
                    hv_A1.Dispose();
                    hv_A1 = -4.0;
                    hv_A0.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_A0 = 255.0 + 128.0;
                    }
                    hv_R.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_R = ((((((((hv_X - hv_OffR)).TupleAbs()
                            ) * hv_A1) + hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
                    }
                    hv_G.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_G = ((((((((hv_X - hv_OffG)).TupleAbs()
                            ) * hv_A1) + hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
                    }
                    hv_B.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_B = ((((((((hv_X - hv_OffB)).TupleAbs()
                            ) * hv_A1) + hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
                    }
                    //
                }
                else if ((int)(new HTuple(hv_Schema.TupleEqual("inverse_jet"))) != 0)
                {
                    //Scheme InvJet: from red to blue.
                    hv_OffR.Dispose();
                    hv_OffR = 64;
                    hv_OffG.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_OffG = 2 * 64;
                    }
                    hv_OffB.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_OffB = 3 * 64;
                    }
                    hv_A1.Dispose();
                    hv_A1 = -4.0;
                    hv_A0.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_A0 = 255.0 + 128.0;
                    }
                    hv_R.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_R = ((((((((hv_X - hv_OffR)).TupleAbs()
                            ) * hv_A1) + hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
                    }
                    hv_G.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_G = ((((((((hv_X - hv_OffG)).TupleAbs()
                            ) * hv_A1) + hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
                    }
                    hv_B.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_B = ((((((((hv_X - hv_OffB)).TupleAbs()
                            ) * hv_A1) + hv_A0)).TupleMax2(hv_Low))).TupleMin2(hv_High);
                    }
                    //
                }
                else if ((int)(new HTuple(hv_Schema.TupleEqual("hot"))) != 0)
                {
                    //Scheme Hot.
                    hv_A1.Dispose();
                    hv_A1 = 3.0;
                    hv_A0R.Dispose();
                    hv_A0R = 0.0;
                    hv_A0G.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_A0G = ((1.0 / 3.0) * hv_A1) * 255.0;
                    }
                    hv_A0B.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_A0B = ((2.0 / 3.0) * hv_A1) * 255.0;
                    }
                    hv_R.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_R = (((((hv_X * hv_A1) - hv_A0R)).TupleMax2(
                            hv_Low))).TupleMin2(hv_High);
                    }
                    hv_G.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_G = (((((hv_X * hv_A1) - hv_A0G)).TupleMax2(
                            hv_Low))).TupleMin2(hv_High);
                    }
                    hv_B.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_B = (((((hv_X * hv_A1) - hv_A0B)).TupleMax2(
                            hv_Low))).TupleMin2(hv_High);
                    }
                    //
                }
                else if ((int)(new HTuple(hv_Schema.TupleEqual("inverse_hot"))) != 0)
                {
                    //Scheme Inverse Hot.
                    hv_A1.Dispose();
                    hv_A1 = -3.0;
                    hv_A0R.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_A0R = hv_A1 * 255.0;
                    }
                    hv_A0G.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_A0G = ((2.0 / 3.0) * hv_A1) * 255.0;
                    }
                    hv_A0B.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_A0B = ((1.0 / 3.0) * hv_A1) * 255.0;
                    }
                    hv_R.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_R = (((((hv_X * hv_A1) - hv_A0R)).TupleMax2(
                            hv_Low))).TupleMin2(hv_High);
                    }
                    hv_G.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_G = (((((hv_X * hv_A1) - hv_A0G)).TupleMax2(
                            hv_Low))).TupleMin2(hv_High);
                    }
                    hv_B.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_B = (((((hv_X * hv_A1) - hv_A0B)).TupleMax2(
                            hv_Low))).TupleMin2(hv_High);
                    }
                    //
                }
                else
                {
                    //
                    throw new HalconException(("Unknown color schema: " + hv_Schema) + ".");
                    //
                }
                //
                ho_ImageR.Dispose();
                HOperatorSet.LutTrans(ho_InputImage, out ho_ImageR, hv_R);
                ho_ImageG.Dispose();
                HOperatorSet.LutTrans(ho_InputImage, out ho_ImageG, hv_G);
                ho_ImageB.Dispose();
                HOperatorSet.LutTrans(ho_InputImage, out ho_ImageB, hv_B);
                ho_ResultImage.Dispose();
                HOperatorSet.Compose3(ho_ImageR, ho_ImageG, ho_ImageB, out ho_ResultImage);
                //
                ho_ImageR.Dispose();
                ho_ImageG.Dispose();
                ho_ImageB.Dispose();

                hv_X.Dispose();
                hv_Low.Dispose();
                hv_High.Dispose();
                hv_OffR.Dispose();
                hv_OffG.Dispose();
                hv_OffB.Dispose();
                hv_A1.Dispose();
                hv_A0.Dispose();
                hv_R.Dispose();
                hv_G.Dispose();
                hv_B.Dispose();
                hv_A0R.Dispose();
                hv_A0G.Dispose();
                hv_A0B.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_ImageR.Dispose();
                ho_ImageG.Dispose();
                ho_ImageB.Dispose();

                hv_X.Dispose();
                hv_Low.Dispose();
                hv_High.Dispose();
                hv_OffR.Dispose();
                hv_OffG.Dispose();
                hv_OffB.Dispose();
                hv_A1.Dispose();
                hv_A0.Dispose();
                hv_R.Dispose();
                hv_G.Dispose();
                hv_B.Dispose();
                hv_A0R.Dispose();
                hv_A0G.Dispose();
                hv_A0B.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        private void area_iou(HTuple hv_Sample, HTuple hv_Result, HTuple hv_InstanceType,
            HTuple hv_ResultSortIndices, out HTuple hv_SampleArea, out HTuple hv_ResultArea,
            out HTuple hv_IoU)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_GtRow1 = new HTuple(), hv_GtCol1 = new HTuple();
            HTuple hv_GtRow2 = new HTuple(), hv_GtCol2 = new HTuple();
            HTuple hv_ResRow1 = new HTuple(), hv_ResCol1 = new HTuple();
            HTuple hv_ResRow2 = new HTuple(), hv_ResCol2 = new HTuple();
            HTuple hv_GtIdx = new HTuple(), hv_Height = new HTuple();
            HTuple hv_Width = new HTuple(), hv_ValidIdxs = new HTuple();
            HTuple hv_Intersection = new HTuple(), hv_Union = new HTuple();
            HTuple hv_GtRow = new HTuple(), hv_GtCol = new HTuple();
            HTuple hv_GtLength1 = new HTuple(), hv_GtLength2 = new HTuple();
            HTuple hv_GtPhi = new HTuple(), hv_ResRow = new HTuple();
            HTuple hv_ResCol = new HTuple(), hv_ResLength1 = new HTuple();
            HTuple hv_ResLength2 = new HTuple(), hv_ResPhi = new HTuple();
            // Initialize local and output iconic variables 
            hv_SampleArea = new HTuple();
            hv_ResultArea = new HTuple();
            hv_IoU = new HTuple();
            try
            {
                //
                //Compute the intersection over union (IoU) between
                //the ground truth and the inferred bounding box of the object instances.
                //The bounding box type is determined over the InstanceType.
                //
                if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
                {
                    //Get bounding box coordinates.
                    hv_GtRow1.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_row1", out hv_GtRow1);
                    hv_GtCol1.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_col1", out hv_GtCol1);
                    hv_GtRow2.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_row2", out hv_GtRow2);
                    hv_GtCol2.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_col2", out hv_GtCol2);
                    hv_ResRow1.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_row1", out hv_ResRow1);
                    hv_ResCol1.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_col1", out hv_ResCol1);
                    hv_ResRow2.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_row2", out hv_ResRow2);
                    hv_ResCol2.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_col2", out hv_ResCol2);
                    //
                    //Sort the results.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResRow1 = hv_ResRow1.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResRow1.Dispose();
                            hv_ResRow1 = ExpTmpLocalVar_ResRow1;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResCol1 = hv_ResCol1.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResCol1.Dispose();
                            hv_ResCol1 = ExpTmpLocalVar_ResCol1;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResRow2 = hv_ResRow2.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResRow2.Dispose();
                            hv_ResRow2 = ExpTmpLocalVar_ResRow2;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResCol2 = hv_ResCol2.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResCol2.Dispose();
                            hv_ResCol2 = ExpTmpLocalVar_ResCol2;
                        }
                    }
                    //
                    //Compute areas.
                    hv_SampleArea.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SampleArea = (hv_GtRow2 - hv_GtRow1) * (hv_GtCol2 - hv_GtCol1);
                    }
                    hv_ResultArea.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ResultArea = (hv_ResRow2 - hv_ResRow1) * (hv_ResCol2 - hv_ResCol1);
                    }
                    //
                    //Compute IoUs.
                    hv_IoU.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_IoU = HTuple.TupleGenConst(
                            (new HTuple(hv_GtRow1.TupleLength())) * (new HTuple(hv_ResRow1.TupleLength()
                            )), 0);
                    }
                    if ((int)(new HTuple((new HTuple(hv_IoU.TupleLength())).TupleGreater(0))) != 0)
                    {
                        for (hv_GtIdx = 0; (int)hv_GtIdx <= (int)((new HTuple(hv_GtRow1.TupleLength()
                            )) - 1); hv_GtIdx = (int)hv_GtIdx + 1)
                        {
                            hv_Height.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Height = (((hv_GtRow2.TupleSelect(
                                    hv_GtIdx))).TupleMin2(hv_ResRow2)) - (((hv_GtRow1.TupleSelect(hv_GtIdx))).TupleMax2(
                                    hv_ResRow1));
                            }
                            hv_Width.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Width = (((hv_GtCol2.TupleSelect(
                                    hv_GtIdx))).TupleMin2(hv_ResCol2)) - (((hv_GtCol1.TupleSelect(hv_GtIdx))).TupleMax2(
                                    hv_ResCol1));
                            }
                            hv_ValidIdxs.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ValidIdxs = (new HTuple(((hv_Height.TupleGreaterElem(
                                    0))).TupleAnd(hv_Width.TupleGreaterElem(0)))).TupleFind(1);
                            }
                            if ((int)(new HTuple(hv_ValidIdxs.TupleGreater(-1))) != 0)
                            {
                                hv_Intersection.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Intersection = (hv_Height.TupleSelect(
                                        hv_ValidIdxs)) * (hv_Width.TupleSelect(hv_ValidIdxs));
                                }
                                hv_Union.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Union = ((hv_SampleArea.TupleSelect(
                                        hv_GtIdx)) + (hv_ResultArea.TupleSelect(hv_ValidIdxs))) - hv_Intersection;
                                }
                                if (hv_IoU == null)
                                    hv_IoU = new HTuple();
                                hv_IoU[(hv_GtIdx * (new HTuple(hv_ResRow1.TupleLength()))) + hv_ValidIdxs] = (hv_Intersection.TupleReal()
                                    ) / hv_Union;
                            }
                        }
                    }
                }
                else if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
                {
                    //Get bounding box coordinates.
                    hv_GtRow.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_row", out hv_GtRow);
                    hv_GtCol.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_col", out hv_GtCol);
                    hv_GtLength1.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_length1", out hv_GtLength1);
                    hv_GtLength2.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_length2", out hv_GtLength2);
                    hv_GtPhi.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "bbox_phi", out hv_GtPhi);
                    hv_ResRow.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_row", out hv_ResRow);
                    hv_ResCol.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_col", out hv_ResCol);
                    hv_ResLength1.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_length1", out hv_ResLength1);
                    hv_ResLength2.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_length2", out hv_ResLength2);
                    hv_ResPhi.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "bbox_phi", out hv_ResPhi);
                    //
                    //Sort results.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResRow = hv_ResRow.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResRow.Dispose();
                            hv_ResRow = ExpTmpLocalVar_ResRow;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResCol = hv_ResCol.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResCol.Dispose();
                            hv_ResCol = ExpTmpLocalVar_ResCol;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResLength1 = hv_ResLength1.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResLength1.Dispose();
                            hv_ResLength1 = ExpTmpLocalVar_ResLength1;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResLength2 = hv_ResLength2.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResLength2.Dispose();
                            hv_ResLength2 = ExpTmpLocalVar_ResLength2;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResPhi = hv_ResPhi.TupleSelect(
                                hv_ResultSortIndices);
                            hv_ResPhi.Dispose();
                            hv_ResPhi = ExpTmpLocalVar_ResPhi;
                        }
                    }
                    //
                    //Compute Areas.
                    hv_SampleArea.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SampleArea = (4.0 * hv_GtLength1) * hv_GtLength2;
                    }
                    hv_ResultArea.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ResultArea = (4.0 * hv_ResLength1) * hv_ResLength2;
                    }
                    //
                    //Compute IoUs.
                    hv_IoU.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_IoU = HTuple.TupleGenConst(
                            (new HTuple(hv_GtRow.TupleLength())) * (new HTuple(hv_ResRow.TupleLength()
                            )), 0);
                    }
                    if ((int)(new HTuple((new HTuple(hv_IoU.TupleLength())).TupleGreater(0))) != 0)
                    {
                        for (hv_GtIdx = 0; (int)hv_GtIdx <= (int)((new HTuple(hv_GtRow.TupleLength()
                            )) - 1); hv_GtIdx = (int)hv_GtIdx + 1)
                        {
                            hv_ValidIdxs.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ValidIdxs = (new HTuple(((((hv_SampleArea.TupleSelect(
                                    hv_GtIdx))).TupleGreaterElem(0))).TupleAnd(hv_ResultArea.TupleGreaterElem(
                                    0)))).TupleFind(1);
                            }
                            if ((int)(new HTuple(hv_ValidIdxs.TupleGreater(-1))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Intersection.Dispose();
                                    HOperatorSet.AreaIntersectionRectangle2(hv_GtRow.TupleSelect(hv_GtIdx),
                                        hv_GtCol.TupleSelect(hv_GtIdx), hv_GtPhi.TupleSelect(hv_GtIdx),
                                        hv_GtLength1.TupleSelect(hv_GtIdx), hv_GtLength2.TupleSelect(hv_GtIdx),
                                        hv_ResRow.TupleSelect(hv_ValidIdxs), hv_ResCol.TupleSelect(hv_ValidIdxs),
                                        hv_ResPhi.TupleSelect(hv_ValidIdxs), hv_ResLength1.TupleSelect(
                                        hv_ValidIdxs), hv_ResLength2.TupleSelect(hv_ValidIdxs), out hv_Intersection);
                                }
                                hv_Union.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Union = ((hv_SampleArea.TupleSelect(
                                        hv_GtIdx)) + (hv_ResultArea.TupleSelect(hv_ValidIdxs))) - hv_Intersection;
                                }
                                if (hv_IoU == null)
                                    hv_IoU = new HTuple();
                                hv_IoU[(hv_GtIdx * (new HTuple(hv_ResRow.TupleLength()))) + hv_ValidIdxs] = (hv_Intersection.TupleReal()
                                    ) / hv_Union;
                            }
                        }
                    }
                }
                else
                {
                    throw new HalconException(("Instance type '" + hv_InstanceType) + "' is not supported");
                }

                hv_GtRow1.Dispose();
                hv_GtCol1.Dispose();
                hv_GtRow2.Dispose();
                hv_GtCol2.Dispose();
                hv_ResRow1.Dispose();
                hv_ResCol1.Dispose();
                hv_ResRow2.Dispose();
                hv_ResCol2.Dispose();
                hv_GtIdx.Dispose();
                hv_Height.Dispose();
                hv_Width.Dispose();
                hv_ValidIdxs.Dispose();
                hv_Intersection.Dispose();
                hv_Union.Dispose();
                hv_GtRow.Dispose();
                hv_GtCol.Dispose();
                hv_GtLength1.Dispose();
                hv_GtLength2.Dispose();
                hv_GtPhi.Dispose();
                hv_ResRow.Dispose();
                hv_ResCol.Dispose();
                hv_ResLength1.Dispose();
                hv_ResLength2.Dispose();
                hv_ResPhi.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_GtRow1.Dispose();
                hv_GtCol1.Dispose();
                hv_GtRow2.Dispose();
                hv_GtCol2.Dispose();
                hv_ResRow1.Dispose();
                hv_ResCol1.Dispose();
                hv_ResRow2.Dispose();
                hv_ResCol2.Dispose();
                hv_GtIdx.Dispose();
                hv_Height.Dispose();
                hv_Width.Dispose();
                hv_ValidIdxs.Dispose();
                hv_Intersection.Dispose();
                hv_Union.Dispose();
                hv_GtRow.Dispose();
                hv_GtCol.Dispose();
                hv_GtLength1.Dispose();
                hv_GtLength2.Dispose();
                hv_GtPhi.Dispose();
                hv_ResRow.Dispose();
                hv_ResCol.Dispose();
                hv_ResLength1.Dispose();
                hv_ResLength2.Dispose();
                hv_ResPhi.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Distort the given samples to augment the dataset. 
        public void augment_dl_samples(HTuple hv_DLSampleBatch, HTuple hv_GenParam)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Image = null, ho_SegmentationImage = null;
            HObject ho_WeightImage = null, ho_ImageRotate = null, ho_ImageScaled = null;
            HObject ho_Filter = null, ho_GaussImage = null, ho_GaussFilter = null;
            HObject ho_Gauss = null, ho_GaussTargetType = null, ho_AddImage = null;
            HObject ho_ImageSpot = null, ho_ImagePart = null, ho_ImageRotated = null;
            HObject ho_DomainRotated = null;

            // Local control variables 

            HTuple hv_AugmentationPercentage = new HTuple();
            HTuple hv_Rotation = new HTuple(), hv_Mirror = new HTuple();
            HTuple hv_BrightnessVariation = new HTuple(), hv_BrightnessVariationSpot = new HTuple();
            HTuple hv_CropPercentage = new HTuple(), hv_CropPixel = new HTuple();
            HTuple hv_RotationRange = new HTuple(), hv_IgnoreDirection = new HTuple();
            HTuple hv_ClassIDsNoOrientationExist = new HTuple(), hv_ClassIDsNoOrientation = new HTuple();
            HTuple hv_AugmentationPercentageExists = new HTuple();
            HTuple hv_RotationExists = new HTuple(), hv_MirrorExists = new HTuple();
            HTuple hv_BrightnessVariationExists = new HTuple(), hv_BrightnessVariationSpotExists = new HTuple();
            HTuple hv_CropPercentageExists = new HTuple(), hv_CropPixelExists = new HTuple();
            HTuple hv_RotationRangeExists = new HTuple(), hv_IgnoreDirectionExists = new HTuple();
            HTuple hv_ClassIDsNoOrientationExists = new HTuple(), hv_CurrentParamValue = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_NumSamples = new HTuple();
            HTuple hv_NumAvailableDistortions = new HTuple(), hv_SampleIndex = new HTuple();
            HTuple hv_SelectedDistortion = new HTuple(), hv_CurrentDistortion = new HTuple();
            HTuple hv_DLSample = new HTuple(), hv_ClassificationImageExists = new HTuple();
            HTuple hv_Rectangle1ParamExist = new HTuple(), hv_Rectangle2ParamExist = new HTuple();
            HTuple hv_SegmentationImageExists = new HTuple(), hv_WeightImageExists = new HTuple();
            HTuple hv_BBoxRow1 = new HTuple(), hv_BBoxCol1 = new HTuple();
            HTuple hv_BBoxRow2 = new HTuple(), hv_BBoxCol2 = new HTuple();
            HTuple hv_BBoxRow = new HTuple(), hv_BBoxCol = new HTuple();
            HTuple hv_BBoxLength1 = new HTuple(), hv_BBoxLength2 = new HTuple();
            HTuple hv_BBoxPhi = new HTuple(), hv_BBoxLabelID = new HTuple();
            HTuple hv_RotationStep = new HTuple(), hv_NumPossibleRotations = new HTuple();
            HTuple hv_CurrentRotation = new HTuple(), hv_ImageWidth = new HTuple();
            HTuple hv_ImageHeight = new HTuple(), hv_HomMat2DIdentity = new HTuple();
            HTuple hv_HomMat2DTmp = new HTuple(), hv_HomMat2DAdapted = new HTuple();
            HTuple hv_Offset = new HTuple(), hv_HomMat2DRotate = new HTuple();
            HTuple hv_RowTrans1 = new HTuple(), hv_ColTrans1 = new HTuple();
            HTuple hv_RowTrans2 = new HTuple(), hv_ColTrans2 = new HTuple();
            HTuple hv_RowTrans = new HTuple(), hv_ColTrans = new HTuple();
            HTuple hv_MaxAngle = new HTuple(), hv_DiffAngle = new HTuple();
            HTuple hv_IndicesLarge = new HTuple(), hv_ObjIdx = new HTuple();
            HTuple hv_BBoxLengthTmp = new HTuple(), hv_NumMirrorMethods = new HTuple();
            HTuple hv_ProbabilityMethods = new HTuple(), hv_StrMirror = new HTuple();
            HTuple hv_StrIdx = new HTuple(), hv_SelectedChar = new HTuple();
            HTuple hv_BBoxCol1Mirror = new HTuple(), hv_BBoxCol2Mirror = new HTuple();
            HTuple hv_BBoxRow1Mirror = new HTuple(), hv_BBoxRow2Mirror = new HTuple();
            HTuple hv_BrightnessVariationValue = new HTuple(), hv_SpotSize = new HTuple();
            HTuple hv_SpotRow = new HTuple(), hv_SpotColumn = new HTuple();
            HTuple hv_Direction = new HTuple(), hv_ShiftRow = new HTuple();
            HTuple hv_ShiftCol = new HTuple(), hv_Type = new HTuple();
            HTuple hv_NChannels = new HTuple(), hv_Index1 = new HTuple();
            HTuple hv_CropRate = new HTuple(), hv_Row1 = new HTuple();
            HTuple hv_Row2 = new HTuple(), hv_Column1 = new HTuple();
            HTuple hv_Column2 = new HTuple(), hv_Length = new HTuple();

            HTupleVector hvec_AvailableDistortions = new HTupleVector(1);
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Image);
            HOperatorSet.GenEmptyObj(out ho_SegmentationImage);
            HOperatorSet.GenEmptyObj(out ho_WeightImage);
            HOperatorSet.GenEmptyObj(out ho_ImageRotate);
            HOperatorSet.GenEmptyObj(out ho_ImageScaled);
            HOperatorSet.GenEmptyObj(out ho_Filter);
            HOperatorSet.GenEmptyObj(out ho_GaussImage);
            HOperatorSet.GenEmptyObj(out ho_GaussFilter);
            HOperatorSet.GenEmptyObj(out ho_Gauss);
            HOperatorSet.GenEmptyObj(out ho_GaussTargetType);
            HOperatorSet.GenEmptyObj(out ho_AddImage);
            HOperatorSet.GenEmptyObj(out ho_ImageSpot);
            HOperatorSet.GenEmptyObj(out ho_ImagePart);
            HOperatorSet.GenEmptyObj(out ho_ImageRotated);
            HOperatorSet.GenEmptyObj(out ho_DomainRotated);
            try
            {
                //
                //This procedure chooses random samples in the DLSampleBatch
                //and modifies them in order to augment the dataset.
                //The augmentation method has to be specified
                //using the dictionary GenParam.
                //
                //If no augmentation parameter is given we return directly and the samples stay unchanged.
                if ((int)(new HTuple((new HTuple(hv_GenParam.TupleLength())).TupleEqual(0))) != 0)
                {
                    ho_Image.Dispose();
                    ho_SegmentationImage.Dispose();
                    ho_WeightImage.Dispose();
                    ho_ImageRotate.Dispose();
                    ho_ImageScaled.Dispose();
                    ho_Filter.Dispose();
                    ho_GaussImage.Dispose();
                    ho_GaussFilter.Dispose();
                    ho_Gauss.Dispose();
                    ho_GaussTargetType.Dispose();
                    ho_AddImage.Dispose();
                    ho_ImageSpot.Dispose();
                    ho_ImagePart.Dispose();
                    ho_ImageRotated.Dispose();
                    ho_DomainRotated.Dispose();

                    hv_AugmentationPercentage.Dispose();
                    hv_Rotation.Dispose();
                    hv_Mirror.Dispose();
                    hv_BrightnessVariation.Dispose();
                    hv_BrightnessVariationSpot.Dispose();
                    hv_CropPercentage.Dispose();
                    hv_CropPixel.Dispose();
                    hv_RotationRange.Dispose();
                    hv_IgnoreDirection.Dispose();
                    hv_ClassIDsNoOrientationExist.Dispose();
                    hv_ClassIDsNoOrientation.Dispose();
                    hv_AugmentationPercentageExists.Dispose();
                    hv_RotationExists.Dispose();
                    hv_MirrorExists.Dispose();
                    hv_BrightnessVariationExists.Dispose();
                    hv_BrightnessVariationSpotExists.Dispose();
                    hv_CropPercentageExists.Dispose();
                    hv_CropPixelExists.Dispose();
                    hv_RotationRangeExists.Dispose();
                    hv_IgnoreDirectionExists.Dispose();
                    hv_ClassIDsNoOrientationExists.Dispose();
                    hv_CurrentParamValue.Dispose();
                    hv_Exception.Dispose();
                    hv_NumSamples.Dispose();
                    hv_NumAvailableDistortions.Dispose();
                    hv_SampleIndex.Dispose();
                    hv_SelectedDistortion.Dispose();
                    hv_CurrentDistortion.Dispose();
                    hv_DLSample.Dispose();
                    hv_ClassificationImageExists.Dispose();
                    hv_Rectangle1ParamExist.Dispose();
                    hv_Rectangle2ParamExist.Dispose();
                    hv_SegmentationImageExists.Dispose();
                    hv_WeightImageExists.Dispose();
                    hv_BBoxRow1.Dispose();
                    hv_BBoxCol1.Dispose();
                    hv_BBoxRow2.Dispose();
                    hv_BBoxCol2.Dispose();
                    hv_BBoxRow.Dispose();
                    hv_BBoxCol.Dispose();
                    hv_BBoxLength1.Dispose();
                    hv_BBoxLength2.Dispose();
                    hv_BBoxPhi.Dispose();
                    hv_BBoxLabelID.Dispose();
                    hv_RotationStep.Dispose();
                    hv_NumPossibleRotations.Dispose();
                    hv_CurrentRotation.Dispose();
                    hv_ImageWidth.Dispose();
                    hv_ImageHeight.Dispose();
                    hv_HomMat2DIdentity.Dispose();
                    hv_HomMat2DTmp.Dispose();
                    hv_HomMat2DAdapted.Dispose();
                    hv_Offset.Dispose();
                    hv_HomMat2DRotate.Dispose();
                    hv_RowTrans1.Dispose();
                    hv_ColTrans1.Dispose();
                    hv_RowTrans2.Dispose();
                    hv_ColTrans2.Dispose();
                    hv_RowTrans.Dispose();
                    hv_ColTrans.Dispose();
                    hv_MaxAngle.Dispose();
                    hv_DiffAngle.Dispose();
                    hv_IndicesLarge.Dispose();
                    hv_ObjIdx.Dispose();
                    hv_BBoxLengthTmp.Dispose();
                    hv_NumMirrorMethods.Dispose();
                    hv_ProbabilityMethods.Dispose();
                    hv_StrMirror.Dispose();
                    hv_StrIdx.Dispose();
                    hv_SelectedChar.Dispose();
                    hv_BBoxCol1Mirror.Dispose();
                    hv_BBoxCol2Mirror.Dispose();
                    hv_BBoxRow1Mirror.Dispose();
                    hv_BBoxRow2Mirror.Dispose();
                    hv_BrightnessVariationValue.Dispose();
                    hv_SpotSize.Dispose();
                    hv_SpotRow.Dispose();
                    hv_SpotColumn.Dispose();
                    hv_Direction.Dispose();
                    hv_ShiftRow.Dispose();
                    hv_ShiftCol.Dispose();
                    hv_Type.Dispose();
                    hv_NChannels.Dispose();
                    hv_Index1.Dispose();
                    hv_CropRate.Dispose();
                    hv_Row1.Dispose();
                    hv_Row2.Dispose();
                    hv_Column1.Dispose();
                    hv_Column2.Dispose();
                    hv_Length.Dispose();
                    hvec_AvailableDistortions.Dispose();

                    return;
                }
                //
                //** Set the default values: ***
                //
                //The percentage of the images that are to be augmented.
                hv_AugmentationPercentage.Dispose();
                hv_AugmentationPercentage = new HTuple();
                hv_AugmentationPercentage[0] = "augmentation_percentage";
                hv_AugmentationPercentage[1] = 50;
                //Step size for possible rotations.
                hv_Rotation.Dispose();
                hv_Rotation = new HTuple();
                hv_Rotation[0] = "rotate";
                hv_Rotation[1] = 0;
                //Allowed mirroring types are coded by 'r' (row), 'c' (column).
                hv_Mirror.Dispose();
                hv_Mirror = new HTuple();
                hv_Mirror[0] = "mirror";
                hv_Mirror[1] = "off";
                //The absolute brightness change can vary in the range [-value, +value].
                hv_BrightnessVariation.Dispose();
                hv_BrightnessVariation = new HTuple();
                hv_BrightnessVariation[0] = "brightness_variation";
                hv_BrightnessVariation[1] = 0;
                //The absolute brightness peak of a randomly positioned spot can vary in the range [-value, +value].
                hv_BrightnessVariationSpot.Dispose();
                hv_BrightnessVariationSpot = new HTuple();
                hv_BrightnessVariationSpot[0] = "brightness_variation_spot";
                hv_BrightnessVariationSpot[1] = 0;
                //
                //In case of a classification model there are more augmentation types.
                //Fraction of image length and width that remains after cropping (in %).
                hv_CropPercentage.Dispose();
                hv_CropPercentage = new HTuple();
                hv_CropPercentage[0] = "crop_percentage";
                hv_CropPercentage[1] = "off";
                //Image length and width that remains after cropping (in pixel).
                hv_CropPixel.Dispose();
                hv_CropPixel = new HTuple();
                hv_CropPixel[0] = "crop_pixel";
                hv_CropPixel[1] = "off";
                //Step range for rotations with step size 1.
                hv_RotationRange.Dispose();
                hv_RotationRange = new HTuple();
                hv_RotationRange[0] = "rotate_range";
                hv_RotationRange[1] = 0;
                //
                //In case of a detection model of instance_type 'rectangle2': Use directions of instances within bounding boxes.
                hv_IgnoreDirection.Dispose();
                hv_IgnoreDirection = new HTuple();
                hv_IgnoreDirection[0] = "ignore_direction";
                hv_IgnoreDirection[1] = 0;
                //In case of a detection model of instance_type 'rectangle2': Class IDs without orientation.
                hv_ClassIDsNoOrientationExist.Dispose();
                hv_ClassIDsNoOrientationExist = new HTuple();
                hv_ClassIDsNoOrientationExist[0] = "class_ids_no_orientation";
                hv_ClassIDsNoOrientationExist[1] = 0;
                hv_ClassIDsNoOrientation.Dispose();
                hv_ClassIDsNoOrientation = new HTuple();
                //** Set user-defined parameters: ***
                //
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_AugmentationPercentageExists.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "key_exists", hv_AugmentationPercentage.TupleSelect(
                        0), out hv_AugmentationPercentageExists);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RotationExists.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "key_exists", hv_Rotation.TupleSelect(
                        0), out hv_RotationExists);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_MirrorExists.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "key_exists", hv_Mirror.TupleSelect(
                        0), out hv_MirrorExists);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_BrightnessVariationExists.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "key_exists", hv_BrightnessVariation.TupleSelect(
                        0), out hv_BrightnessVariationExists);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_BrightnessVariationSpotExists.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "key_exists", hv_BrightnessVariationSpot.TupleSelect(
                        0), out hv_BrightnessVariationSpotExists);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_CropPercentageExists.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "key_exists", hv_CropPercentage.TupleSelect(
                        0), out hv_CropPercentageExists);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_CropPixelExists.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "key_exists", hv_CropPixel.TupleSelect(
                        0), out hv_CropPixelExists);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RotationRangeExists.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "key_exists", hv_RotationRange.TupleSelect(
                        0), out hv_RotationRangeExists);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_IgnoreDirectionExists.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "key_exists", hv_IgnoreDirection.TupleSelect(
                        0), out hv_IgnoreDirectionExists);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ClassIDsNoOrientationExists.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "key_exists", hv_ClassIDsNoOrientationExist.TupleSelect(
                        0), out hv_ClassIDsNoOrientationExists);
                }
                //
                if ((int)(hv_AugmentationPercentageExists) != 0)
                {
                    //Set augmentation percentage.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentParamValue.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, hv_AugmentationPercentage.TupleSelect(
                            0), out hv_CurrentParamValue);
                    }
                    if (hv_AugmentationPercentage == null)
                        hv_AugmentationPercentage = new HTuple();
                    hv_AugmentationPercentage[1] = hv_CurrentParamValue;
                    //Check if input value is in range of 0-100 %.
                    hv_Exception.Dispose();
                    hv_Exception = "The given value for augmentation_percentage has to be in the range 0-100.";
                    if ((int)(hv_CurrentParamValue.TupleIsNumber()) != 0)
                    {
                        if ((int)((new HTuple(hv_CurrentParamValue.TupleLess(0))).TupleOr(new HTuple(hv_CurrentParamValue.TupleGreater(
                            100)))) != 0)
                        {
                            throw new HalconException(hv_Exception);
                        }
                    }
                    else
                    {
                        throw new HalconException(hv_Exception);
                    }
                }
                //If nothing should be augmented we return immediately.
                if ((int)(new HTuple(((hv_AugmentationPercentage.TupleSelect(1))).TupleEqual(
                    0))) != 0)
                {
                    ho_Image.Dispose();
                    ho_SegmentationImage.Dispose();
                    ho_WeightImage.Dispose();
                    ho_ImageRotate.Dispose();
                    ho_ImageScaled.Dispose();
                    ho_Filter.Dispose();
                    ho_GaussImage.Dispose();
                    ho_GaussFilter.Dispose();
                    ho_Gauss.Dispose();
                    ho_GaussTargetType.Dispose();
                    ho_AddImage.Dispose();
                    ho_ImageSpot.Dispose();
                    ho_ImagePart.Dispose();
                    ho_ImageRotated.Dispose();
                    ho_DomainRotated.Dispose();

                    hv_AugmentationPercentage.Dispose();
                    hv_Rotation.Dispose();
                    hv_Mirror.Dispose();
                    hv_BrightnessVariation.Dispose();
                    hv_BrightnessVariationSpot.Dispose();
                    hv_CropPercentage.Dispose();
                    hv_CropPixel.Dispose();
                    hv_RotationRange.Dispose();
                    hv_IgnoreDirection.Dispose();
                    hv_ClassIDsNoOrientationExist.Dispose();
                    hv_ClassIDsNoOrientation.Dispose();
                    hv_AugmentationPercentageExists.Dispose();
                    hv_RotationExists.Dispose();
                    hv_MirrorExists.Dispose();
                    hv_BrightnessVariationExists.Dispose();
                    hv_BrightnessVariationSpotExists.Dispose();
                    hv_CropPercentageExists.Dispose();
                    hv_CropPixelExists.Dispose();
                    hv_RotationRangeExists.Dispose();
                    hv_IgnoreDirectionExists.Dispose();
                    hv_ClassIDsNoOrientationExists.Dispose();
                    hv_CurrentParamValue.Dispose();
                    hv_Exception.Dispose();
                    hv_NumSamples.Dispose();
                    hv_NumAvailableDistortions.Dispose();
                    hv_SampleIndex.Dispose();
                    hv_SelectedDistortion.Dispose();
                    hv_CurrentDistortion.Dispose();
                    hv_DLSample.Dispose();
                    hv_ClassificationImageExists.Dispose();
                    hv_Rectangle1ParamExist.Dispose();
                    hv_Rectangle2ParamExist.Dispose();
                    hv_SegmentationImageExists.Dispose();
                    hv_WeightImageExists.Dispose();
                    hv_BBoxRow1.Dispose();
                    hv_BBoxCol1.Dispose();
                    hv_BBoxRow2.Dispose();
                    hv_BBoxCol2.Dispose();
                    hv_BBoxRow.Dispose();
                    hv_BBoxCol.Dispose();
                    hv_BBoxLength1.Dispose();
                    hv_BBoxLength2.Dispose();
                    hv_BBoxPhi.Dispose();
                    hv_BBoxLabelID.Dispose();
                    hv_RotationStep.Dispose();
                    hv_NumPossibleRotations.Dispose();
                    hv_CurrentRotation.Dispose();
                    hv_ImageWidth.Dispose();
                    hv_ImageHeight.Dispose();
                    hv_HomMat2DIdentity.Dispose();
                    hv_HomMat2DTmp.Dispose();
                    hv_HomMat2DAdapted.Dispose();
                    hv_Offset.Dispose();
                    hv_HomMat2DRotate.Dispose();
                    hv_RowTrans1.Dispose();
                    hv_ColTrans1.Dispose();
                    hv_RowTrans2.Dispose();
                    hv_ColTrans2.Dispose();
                    hv_RowTrans.Dispose();
                    hv_ColTrans.Dispose();
                    hv_MaxAngle.Dispose();
                    hv_DiffAngle.Dispose();
                    hv_IndicesLarge.Dispose();
                    hv_ObjIdx.Dispose();
                    hv_BBoxLengthTmp.Dispose();
                    hv_NumMirrorMethods.Dispose();
                    hv_ProbabilityMethods.Dispose();
                    hv_StrMirror.Dispose();
                    hv_StrIdx.Dispose();
                    hv_SelectedChar.Dispose();
                    hv_BBoxCol1Mirror.Dispose();
                    hv_BBoxCol2Mirror.Dispose();
                    hv_BBoxRow1Mirror.Dispose();
                    hv_BBoxRow2Mirror.Dispose();
                    hv_BrightnessVariationValue.Dispose();
                    hv_SpotSize.Dispose();
                    hv_SpotRow.Dispose();
                    hv_SpotColumn.Dispose();
                    hv_Direction.Dispose();
                    hv_ShiftRow.Dispose();
                    hv_ShiftCol.Dispose();
                    hv_Type.Dispose();
                    hv_NChannels.Dispose();
                    hv_Index1.Dispose();
                    hv_CropRate.Dispose();
                    hv_Row1.Dispose();
                    hv_Row2.Dispose();
                    hv_Column1.Dispose();
                    hv_Column2.Dispose();
                    hv_Length.Dispose();
                    hvec_AvailableDistortions.Dispose();

                    return;
                }
                if ((int)(hv_RotationExists) != 0)
                {
                    //Set rotation.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentParamValue.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, hv_Rotation.TupleSelect(0), out hv_CurrentParamValue);
                    }
                    if (hv_Rotation == null)
                        hv_Rotation = new HTuple();
                    hv_Rotation[1] = hv_CurrentParamValue;
                    //Check if the input value is either 0, 90, or 180.
                    hv_Exception.Dispose();
                    hv_Exception = new HTuple("The value given for rotation has to be either 0, 90, or 180.");
                    if ((int)(hv_CurrentParamValue.TupleIsNumber()) != 0)
                    {
                        if ((int)(new HTuple((new HTuple((((new HTuple(0)).TupleConcat(90)).TupleConcat(
                            180)).TupleFind(hv_CurrentParamValue))).TupleEqual(-1))) != 0)
                        {
                            throw new HalconException(hv_Exception);
                        }
                    }
                    else
                    {
                        throw new HalconException(hv_Exception);
                    }
                }
                if ((int)(hv_MirrorExists) != 0)
                {
                    //Set mirroring.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentParamValue.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, hv_Mirror.TupleSelect(0), out hv_CurrentParamValue);
                    }
                    if (hv_Mirror == null)
                        hv_Mirror = new HTuple();
                    hv_Mirror[1] = hv_CurrentParamValue;
                    //Check if the input is a string and contains either 'off' or the mirroring code.
                    if ((int)(((hv_CurrentParamValue.TupleIsNumber())).TupleOr((new HTuple((new HTuple((new HTuple((new HTuple((new HTuple(hv_CurrentParamValue.TupleEqual(
                        "off"))).TupleOr(new HTuple(hv_CurrentParamValue.TupleEqual("c"))))).TupleOr(
                        new HTuple(hv_CurrentParamValue.TupleEqual("r"))))).TupleOr(new HTuple(hv_CurrentParamValue.TupleEqual(
                        "cr"))))).TupleOr(new HTuple(hv_CurrentParamValue.TupleEqual("rc"))))).TupleNot()
                        )) != 0)
                    {
                        throw new HalconException("Unknown type for mirroring.");
                    }
                }
                if ((int)(hv_BrightnessVariationExists) != 0)
                {
                    //Set brightness variation.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentParamValue.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, hv_BrightnessVariation.TupleSelect(
                            0), out hv_CurrentParamValue);
                    }
                    if (hv_BrightnessVariation == null)
                        hv_BrightnessVariation = new HTuple();
                    hv_BrightnessVariation[1] = hv_CurrentParamValue;
                    //Check if the input value is in range of 0-255.
                    hv_Exception.Dispose();
                    hv_Exception = "The given value for brightness_variation has to be in the range 0-255.";
                    if ((int)(hv_CurrentParamValue.TupleIsNumber()) != 0)
                    {
                        if ((int)((new HTuple(hv_CurrentParamValue.TupleLess(0))).TupleOr(new HTuple(hv_CurrentParamValue.TupleGreater(
                            255)))) != 0)
                        {
                            throw new HalconException(hv_Exception);
                        }
                    }
                    else
                    {
                        throw new HalconException(hv_Exception);
                    }
                }
                if ((int)(hv_BrightnessVariationSpotExists) != 0)
                {
                    //Set brightness variation spot.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentParamValue.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, hv_BrightnessVariationSpot.TupleSelect(
                            0), out hv_CurrentParamValue);
                    }
                    if (hv_BrightnessVariationSpot == null)
                        hv_BrightnessVariationSpot = new HTuple();
                    hv_BrightnessVariationSpot[1] = hv_CurrentParamValue;
                    //Check if the input value is in range of 0-255.
                    hv_Exception.Dispose();
                    hv_Exception = "The given value for brightness_variation_spot has to be in the range 0-255.";
                    if ((int)(hv_CurrentParamValue.TupleIsNumber()) != 0)
                    {
                        if ((int)((new HTuple(hv_CurrentParamValue.TupleLess(0))).TupleOr(new HTuple(hv_CurrentParamValue.TupleGreater(
                            255)))) != 0)
                        {
                            throw new HalconException(hv_Exception);
                        }
                    }
                    else
                    {
                        throw new HalconException(hv_Exception);
                    }
                }
                if ((int)(hv_CropPercentageExists) != 0)
                {
                    //Set cropping with percentage.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentParamValue.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, hv_CropPercentage.TupleSelect(0),
                            out hv_CurrentParamValue);
                    }
                    if (hv_CropPercentage == null)
                        hv_CropPercentage = new HTuple();
                    hv_CropPercentage[1] = hv_CurrentParamValue;
                    //Check if the input value is in range of 1-100%.
                    hv_Exception.Dispose();
                    hv_Exception = "The given value for crop_percentage has to be in the range 1-100.";
                    if ((int)(hv_CurrentParamValue.TupleIsNumber()) != 0)
                    {
                        if ((int)((new HTuple(hv_CurrentParamValue.TupleLess(1))).TupleOr(new HTuple(hv_CurrentParamValue.TupleGreater(
                            100)))) != 0)
                        {
                            throw new HalconException(hv_Exception);
                        }
                    }
                    else
                    {
                        throw new HalconException(hv_Exception);
                    }
                }
                if ((int)(hv_CropPixelExists) != 0)
                {
                    //Set cropping with pixels.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentParamValue.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, hv_CropPixel.TupleSelect(0), out hv_CurrentParamValue);
                    }
                    if (hv_CropPixel == null)
                        hv_CropPixel = new HTuple();
                    hv_CropPixel[1] = hv_CurrentParamValue;
                    //Check if the input value is greater 0.
                    hv_Exception.Dispose();
                    hv_Exception = "The given value for crop_pixel has to be greater or equal to 1.";
                    if ((int)(hv_CurrentParamValue.TupleIsNumber()) != 0)
                    {
                        if ((int)(new HTuple(hv_CurrentParamValue.TupleLess(1))) != 0)
                        {
                            throw new HalconException(hv_Exception);
                        }
                    }
                    else
                    {
                        throw new HalconException(hv_Exception);
                    }
                }
                if ((int)(hv_RotationRangeExists) != 0)
                {
                    //Set rotation range.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentParamValue.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, hv_RotationRange.TupleSelect(0), out hv_CurrentParamValue);
                    }
                    if (hv_RotationRange == null)
                        hv_RotationRange = new HTuple();
                    hv_RotationRange[1] = hv_CurrentParamValue;
                    //Check if the input value is in range of 0-180.
                    hv_Exception.Dispose();
                    hv_Exception = "The given value for rotate_range has to be in the range 0-180.";
                    if ((int)(hv_CurrentParamValue.TupleIsNumber()) != 0)
                    {
                        if ((int)((new HTuple(hv_CurrentParamValue.TupleLess(0))).TupleOr(new HTuple(hv_CurrentParamValue.TupleGreater(
                            180)))) != 0)
                        {
                            throw new HalconException(hv_Exception);
                        }
                    }
                    else
                    {
                        throw new HalconException(hv_Exception);
                    }
                }
                if ((int)(hv_IgnoreDirectionExists) != 0)
                {
                    //Set if the direction is to be ignored or not.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentParamValue.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, hv_IgnoreDirection.TupleSelect(0),
                            out hv_CurrentParamValue);
                    }
                    if (hv_IgnoreDirection == null)
                        hv_IgnoreDirection = new HTuple();
                    hv_IgnoreDirection[1] = hv_CurrentParamValue;
                    hv_Exception.Dispose();
                    hv_Exception = new HTuple("The value given for ignore_direction has to be either 'true','false', true or false.");
                    if ((int)(new HTuple((new HTuple(((((new HTuple("true")).TupleConcat("false")).TupleConcat(
                        1)).TupleConcat(0)).TupleFind(hv_IgnoreDirection.TupleSelect(1)))).TupleEqual(
                        -1))) != 0)
                    {
                        throw new HalconException(hv_Exception);
                    }
                    if ((int)(new HTuple(hv_CurrentParamValue.TupleEqual("false"))) != 0)
                    {
                        if (hv_IgnoreDirection == null)
                            hv_IgnoreDirection = new HTuple();
                        hv_IgnoreDirection[1] = 0;
                    }
                    else if ((int)(new HTuple(hv_CurrentParamValue.TupleEqual("true"))) != 0)
                    {
                        if (hv_IgnoreDirection == null)
                            hv_IgnoreDirection = new HTuple();
                        hv_IgnoreDirection[1] = 1;
                    }
                }
                if ((int)(hv_ClassIDsNoOrientationExists) != 0)
                {
                    //Set the IDs of the classes, for whose instances the orientation is not to be considered.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentParamValue.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, hv_ClassIDsNoOrientationExist.TupleSelect(
                            0), out hv_CurrentParamValue);
                    }
                    if (hv_ClassIDsNoOrientationExist == null)
                        hv_ClassIDsNoOrientationExist = new HTuple();
                    hv_ClassIDsNoOrientationExist[1] = new HTuple(hv_CurrentParamValue.TupleNotEqual(
                        new HTuple()));
                    if ((int)(new HTuple(hv_CurrentParamValue.TupleNotEqual(new HTuple()))) != 0)
                    {
                        hv_ClassIDsNoOrientation.Dispose();
                        hv_ClassIDsNoOrientation = new HTuple(hv_CurrentParamValue);
                    }
                }
                //
                //Aggregate all possible distortions and parameter values into a vector.
                //
                hvec_AvailableDistortions.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_AvailableDistortions = dh.Take(dh.Add(new HTupleVector(1)));
                }
                //Rotation with a given angular step size.
                if ((int)(new HTuple(((hv_Rotation.TupleSelect(1))).TupleGreater(0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hvec_AvailableDistortions[new HTuple(hvec_AvailableDistortions.Length)] = dh.Add(new HTupleVector(hv_Rotation));
                    }
                }
                //Mirroring is allowed in row and column direction.
                if ((int)((new HTuple(((hv_Mirror.TupleSelect(1))).TupleRegexpTest("r"))).TupleOr(
                    ((hv_Mirror.TupleSelect(1))).TupleRegexpTest("c"))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hvec_AvailableDistortions[new HTuple(hvec_AvailableDistortions.Length)] = dh.Add(new HTupleVector(hv_Mirror));
                    }
                }
                //Brightness variation.
                if ((int)(new HTuple(((hv_BrightnessVariation.TupleSelect(1))).TupleGreater(
                    0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hvec_AvailableDistortions[new HTuple(hvec_AvailableDistortions.Length)] = dh.Add(new HTupleVector(hv_BrightnessVariation));
                    }
                }
                //Brightness variation spot.
                if ((int)(new HTuple(((hv_BrightnessVariationSpot.TupleSelect(1))).TupleGreater(
                    0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hvec_AvailableDistortions[new HTuple(hvec_AvailableDistortions.Length)] = dh.Add(new HTupleVector(hv_BrightnessVariationSpot));
                    }
                }
                //Cropping percentage.
                if ((int)(((hv_CropPercentage.TupleSelect(1))).TupleIsNumber()) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hvec_AvailableDistortions[new HTuple(hvec_AvailableDistortions.Length)] = dh.Add(new HTupleVector(hv_CropPercentage));
                    }
                }
                //Cropping pixels.
                if ((int)(((hv_CropPixel.TupleSelect(1))).TupleIsNumber()) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hvec_AvailableDistortions[new HTuple(hvec_AvailableDistortions.Length)] = dh.Add(new HTupleVector(hv_CropPixel));
                    }
                }
                //Rotation within a given range (step size 1).
                if ((int)(new HTuple(((hv_RotationRange.TupleSelect(1))).TupleGreater(0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hvec_AvailableDistortions[new HTuple(hvec_AvailableDistortions.Length)] = dh.Add(new HTupleVector(hv_RotationRange));
                    }
                }
                //
                //** Choose random samples and augmentation methods: ***
                //
                //Number of samples to be augmented.
                hv_NumSamples.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumSamples = new HTuple(hv_DLSampleBatch.TupleLength()
                        );
                }
                if ((int)(new HTuple(hv_NumSamples.TupleEqual(0))) != 0)
                {
                    throw new HalconException("There are no DLSamples to be processed.");
                }
                //Check number of selected distortions.
                hv_NumAvailableDistortions.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumAvailableDistortions = new HTuple(hvec_AvailableDistortions.Length);
                }
                if ((int)(new HTuple(hv_NumAvailableDistortions.TupleEqual(0))) != 0)
                {
                    ho_Image.Dispose();
                    ho_SegmentationImage.Dispose();
                    ho_WeightImage.Dispose();
                    ho_ImageRotate.Dispose();
                    ho_ImageScaled.Dispose();
                    ho_Filter.Dispose();
                    ho_GaussImage.Dispose();
                    ho_GaussFilter.Dispose();
                    ho_Gauss.Dispose();
                    ho_GaussTargetType.Dispose();
                    ho_AddImage.Dispose();
                    ho_ImageSpot.Dispose();
                    ho_ImagePart.Dispose();
                    ho_ImageRotated.Dispose();
                    ho_DomainRotated.Dispose();

                    hv_AugmentationPercentage.Dispose();
                    hv_Rotation.Dispose();
                    hv_Mirror.Dispose();
                    hv_BrightnessVariation.Dispose();
                    hv_BrightnessVariationSpot.Dispose();
                    hv_CropPercentage.Dispose();
                    hv_CropPixel.Dispose();
                    hv_RotationRange.Dispose();
                    hv_IgnoreDirection.Dispose();
                    hv_ClassIDsNoOrientationExist.Dispose();
                    hv_ClassIDsNoOrientation.Dispose();
                    hv_AugmentationPercentageExists.Dispose();
                    hv_RotationExists.Dispose();
                    hv_MirrorExists.Dispose();
                    hv_BrightnessVariationExists.Dispose();
                    hv_BrightnessVariationSpotExists.Dispose();
                    hv_CropPercentageExists.Dispose();
                    hv_CropPixelExists.Dispose();
                    hv_RotationRangeExists.Dispose();
                    hv_IgnoreDirectionExists.Dispose();
                    hv_ClassIDsNoOrientationExists.Dispose();
                    hv_CurrentParamValue.Dispose();
                    hv_Exception.Dispose();
                    hv_NumSamples.Dispose();
                    hv_NumAvailableDistortions.Dispose();
                    hv_SampleIndex.Dispose();
                    hv_SelectedDistortion.Dispose();
                    hv_CurrentDistortion.Dispose();
                    hv_DLSample.Dispose();
                    hv_ClassificationImageExists.Dispose();
                    hv_Rectangle1ParamExist.Dispose();
                    hv_Rectangle2ParamExist.Dispose();
                    hv_SegmentationImageExists.Dispose();
                    hv_WeightImageExists.Dispose();
                    hv_BBoxRow1.Dispose();
                    hv_BBoxCol1.Dispose();
                    hv_BBoxRow2.Dispose();
                    hv_BBoxCol2.Dispose();
                    hv_BBoxRow.Dispose();
                    hv_BBoxCol.Dispose();
                    hv_BBoxLength1.Dispose();
                    hv_BBoxLength2.Dispose();
                    hv_BBoxPhi.Dispose();
                    hv_BBoxLabelID.Dispose();
                    hv_RotationStep.Dispose();
                    hv_NumPossibleRotations.Dispose();
                    hv_CurrentRotation.Dispose();
                    hv_ImageWidth.Dispose();
                    hv_ImageHeight.Dispose();
                    hv_HomMat2DIdentity.Dispose();
                    hv_HomMat2DTmp.Dispose();
                    hv_HomMat2DAdapted.Dispose();
                    hv_Offset.Dispose();
                    hv_HomMat2DRotate.Dispose();
                    hv_RowTrans1.Dispose();
                    hv_ColTrans1.Dispose();
                    hv_RowTrans2.Dispose();
                    hv_ColTrans2.Dispose();
                    hv_RowTrans.Dispose();
                    hv_ColTrans.Dispose();
                    hv_MaxAngle.Dispose();
                    hv_DiffAngle.Dispose();
                    hv_IndicesLarge.Dispose();
                    hv_ObjIdx.Dispose();
                    hv_BBoxLengthTmp.Dispose();
                    hv_NumMirrorMethods.Dispose();
                    hv_ProbabilityMethods.Dispose();
                    hv_StrMirror.Dispose();
                    hv_StrIdx.Dispose();
                    hv_SelectedChar.Dispose();
                    hv_BBoxCol1Mirror.Dispose();
                    hv_BBoxCol2Mirror.Dispose();
                    hv_BBoxRow1Mirror.Dispose();
                    hv_BBoxRow2Mirror.Dispose();
                    hv_BrightnessVariationValue.Dispose();
                    hv_SpotSize.Dispose();
                    hv_SpotRow.Dispose();
                    hv_SpotColumn.Dispose();
                    hv_Direction.Dispose();
                    hv_ShiftRow.Dispose();
                    hv_ShiftCol.Dispose();
                    hv_Type.Dispose();
                    hv_NChannels.Dispose();
                    hv_Index1.Dispose();
                    hv_CropRate.Dispose();
                    hv_Row1.Dispose();
                    hv_Row2.Dispose();
                    hv_Column1.Dispose();
                    hv_Column2.Dispose();
                    hv_Length.Dispose();
                    hvec_AvailableDistortions.Dispose();

                    return;
                }
                //
                //Select randomly a distortion type for each sample.
                //
                //Augment (distort) the samples.
                //
                HTuple end_val233 = hv_NumSamples - 1;
                HTuple step_val233 = 1;
                for (hv_SampleIndex = 0; hv_SampleIndex.Continue(end_val233, step_val233); hv_SampleIndex = hv_SampleIndex.TupleAdd(step_val233))
                {
                    if ((int)(new HTuple((new HTuple(HTuple.TupleRand(1) * 100)).TupleGreater(hv_AugmentationPercentage.TupleSelect(
                        1)))) != 0)
                    {
                        //Only augment the given percentage of samples.
                        continue;
                    }
                    //Select the distortion type.
                    hv_SelectedDistortion.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SelectedDistortion = ((HTuple.TupleRand(
                            1) * hv_NumAvailableDistortions)).TupleInt();
                    }
                    hv_CurrentDistortion.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentDistortion = new HTuple(hvec_AvailableDistortions[hv_SelectedDistortion].T);
                    }
                    //
                    //Select the image to be augmented.
                    hv_DLSample.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DLSample = hv_DLSampleBatch.TupleSelect(
                            hv_SampleIndex);
                    }
                    ho_Image.Dispose();
                    HOperatorSet.GetDictObject(out ho_Image, hv_DLSample, "image");
                    hv_ClassificationImageExists.Dispose();
                    HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "image_label_id", out hv_ClassificationImageExists);
                    hv_Rectangle1ParamExist.Dispose();
                    HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "bbox_row1", out hv_Rectangle1ParamExist);
                    hv_Rectangle2ParamExist.Dispose();
                    HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "bbox_phi", out hv_Rectangle2ParamExist);
                    hv_SegmentationImageExists.Dispose();
                    HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "segmentation_image",
                        out hv_SegmentationImageExists);
                    hv_WeightImageExists.Dispose();
                    HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "weight_image", out hv_WeightImageExists);
                    //Check which keys have to be modified as well.
                    if ((int)(hv_Rectangle1ParamExist) != 0)
                    {
                        hv_BBoxRow1.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row1", out hv_BBoxRow1);
                        hv_BBoxCol1.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col1", out hv_BBoxCol1);
                        hv_BBoxRow2.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row2", out hv_BBoxRow2);
                        hv_BBoxCol2.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col2", out hv_BBoxCol2);
                    }
                    else if ((int)(hv_Rectangle2ParamExist) != 0)
                    {
                        hv_BBoxRow.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row", out hv_BBoxRow);
                        hv_BBoxCol.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col", out hv_BBoxCol);
                        hv_BBoxLength1.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_length1", out hv_BBoxLength1);
                        hv_BBoxLength2.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_length2", out hv_BBoxLength2);
                        hv_BBoxPhi.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLSample, "bbox_phi", out hv_BBoxPhi);
                        if ((int)(hv_ClassIDsNoOrientationExist.TupleSelect(1)) != 0)
                        {
                            hv_BBoxLabelID.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLSample, "bbox_label_id", out hv_BBoxLabelID);
                        }
                    }
                    if ((int)(hv_SegmentationImageExists) != 0)
                    {
                        ho_SegmentationImage.Dispose();
                        HOperatorSet.GetDictObject(out ho_SegmentationImage, hv_DLSample, "segmentation_image");
                    }
                    if ((int)(hv_WeightImageExists) != 0)
                    {
                        ho_WeightImage.Dispose();
                        HOperatorSet.GetDictObject(out ho_WeightImage, hv_DLSample, "weight_image");
                    }
                    //Some augmentation methods are only allowed for model type classification.
                    if ((int)(hv_ClassificationImageExists.TupleNot()) != 0)
                    {
                        if ((int)(new HTuple(((hv_CurrentDistortion.TupleSelect(0))).TupleEqual(
                            hv_CropPercentage.TupleSelect(0)))) != 0)
                        {
                            throw new HalconException("The augmentation method crop_percentage is only allowed for model type classification.");
                        }
                        else if ((int)(new HTuple(((hv_CurrentDistortion.TupleSelect(
                            0))).TupleEqual(hv_CropPixel.TupleSelect(0)))) != 0)
                        {
                            throw new HalconException("The augmentation method crop_pixel is only allowed for model type classification.");
                        }
                        else if ((int)(new HTuple(((hv_CurrentDistortion.TupleSelect(
                            0))).TupleEqual(hv_RotationRange.TupleSelect(0)))) != 0)
                        {
                            throw new HalconException("The augmentation method rotate_range is only allowed for model type classification.");
                        }
                    }
                    //
                    if ((int)(new HTuple(((hv_CurrentDistortion.TupleSelect(0))).TupleEqual(hv_Rotation.TupleSelect(
                        0)))) != 0)
                    {
                        //
                        //Rotation
                        //
                        //Determine rotation angle for distortion type 'rotate' (angle in range (0:CurrentDistortion[1]:360)).
                        hv_RotationStep.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_RotationStep = hv_CurrentDistortion.TupleSelect(
                                1);
                        }
                        hv_NumPossibleRotations.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_NumPossibleRotations = (360.0 / hv_RotationStep) - 1;
                        }
                        hv_CurrentRotation.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentRotation = hv_RotationStep * ((((hv_NumPossibleRotations * HTuple.TupleRand(
                                1))).TupleInt()) + 1);
                        }
                        //
                        if ((int)(new HTuple(hv_CurrentRotation.TupleNotEqual(0))) != 0)
                        {
                            hv_ImageWidth.Dispose(); hv_ImageHeight.Dispose();
                            HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
                            if ((int)((new HTuple(hv_ImageWidth.TupleNotEqual(hv_ImageHeight))).TupleAnd(
                                new HTuple(hv_CurrentRotation.TupleNotEqual(180.0)))) != 0)
                            {
                                //If an image is not quadratic, a rotation by 90 or 270 degrees is ignored.
                                continue;
                            }
                            //
                            ho_ImageRotate.Dispose();
                            HOperatorSet.RotateImage(ho_Image, out ho_ImageRotate, hv_CurrentRotation,
                                "constant");
                            HOperatorSet.SetDictObject(ho_ImageRotate, hv_DLSample, "image");
                            //
                            if ((int)(hv_Rectangle1ParamExist.TupleOr(hv_Rectangle2ParamExist)) != 0)
                            {
                                //Create a transformation matrix for the rotation of the bounding boxes.
                                hv_ImageWidth.Dispose(); hv_ImageHeight.Dispose();
                                HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
                                hv_HomMat2DIdentity.Dispose();
                                HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
                                hv_HomMat2DTmp.Dispose();
                                HOperatorSet.HomMat2dTranslate(hv_HomMat2DIdentity, 0.5, 0.5, out hv_HomMat2DTmp);
                                hv_HomMat2DAdapted.Dispose();
                                HOperatorSet.HomMat2dTranslateLocal(hv_HomMat2DTmp, -0.5, -0.5, out hv_HomMat2DAdapted);
                                hv_Offset.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Offset = ((hv_ImageHeight - hv_ImageWidth) * 0.5) * (((hv_CurrentRotation.TupleRad()
                                        )).TupleSin());
                                }
                                {
                                    HTuple ExpTmpOutVar_0;
                                    HOperatorSet.HomMat2dTranslate(hv_HomMat2DAdapted, hv_Offset, hv_Offset,
                                        out ExpTmpOutVar_0);
                                    hv_HomMat2DAdapted.Dispose();
                                    hv_HomMat2DAdapted = ExpTmpOutVar_0;
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_HomMat2DRotate.Dispose();
                                    HOperatorSet.HomMat2dRotate(hv_HomMat2DAdapted, hv_CurrentRotation.TupleRad()
                                        , hv_ImageHeight * 0.5, hv_ImageWidth * 0.5, out hv_HomMat2DRotate);
                                }
                            }
                            if ((int)(hv_Rectangle1ParamExist) != 0)
                            {
                                hv_RowTrans1.Dispose(); hv_ColTrans1.Dispose();
                                HOperatorSet.AffineTransPixel(hv_HomMat2DRotate, hv_BBoxRow1, hv_BBoxCol1,
                                    out hv_RowTrans1, out hv_ColTrans1);
                                hv_RowTrans2.Dispose(); hv_ColTrans2.Dispose();
                                HOperatorSet.AffineTransPixel(hv_HomMat2DRotate, hv_BBoxRow2, hv_BBoxCol2,
                                    out hv_RowTrans2, out hv_ColTrans2);
                                if ((int)(new HTuple(hv_CurrentRotation.TupleEqual(90))) != 0)
                                {
                                    hv_BBoxRow1.Dispose();
                                    hv_BBoxRow1 = new HTuple(hv_RowTrans2);
                                    hv_BBoxCol1.Dispose();
                                    hv_BBoxCol1 = new HTuple(hv_ColTrans1);
                                    hv_BBoxRow2.Dispose();
                                    hv_BBoxRow2 = new HTuple(hv_RowTrans1);
                                    hv_BBoxCol2.Dispose();
                                    hv_BBoxCol2 = new HTuple(hv_ColTrans2);
                                }
                                else if ((int)(new HTuple(hv_CurrentRotation.TupleEqual(
                                    180))) != 0)
                                {
                                    hv_BBoxRow1.Dispose();
                                    hv_BBoxRow1 = new HTuple(hv_RowTrans2);
                                    hv_BBoxCol1.Dispose();
                                    hv_BBoxCol1 = new HTuple(hv_ColTrans2);
                                    hv_BBoxRow2.Dispose();
                                    hv_BBoxRow2 = new HTuple(hv_RowTrans1);
                                    hv_BBoxCol2.Dispose();
                                    hv_BBoxCol2 = new HTuple(hv_ColTrans1);
                                }
                                else if ((int)(new HTuple(hv_CurrentRotation.TupleEqual(
                                    270))) != 0)
                                {
                                    hv_BBoxRow1.Dispose();
                                    hv_BBoxRow1 = new HTuple(hv_RowTrans1);
                                    hv_BBoxCol1.Dispose();
                                    hv_BBoxCol1 = new HTuple(hv_ColTrans2);
                                    hv_BBoxRow2.Dispose();
                                    hv_BBoxRow2 = new HTuple(hv_RowTrans2);
                                    hv_BBoxCol2.Dispose();
                                    hv_BBoxCol2 = new HTuple(hv_ColTrans1);
                                }
                                //
                                HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row1", hv_BBoxRow1);
                                HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col1", hv_BBoxCol1);
                                HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row2", hv_BBoxRow2);
                                HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col2", hv_BBoxCol2);
                            }
                            else if ((int)(hv_Rectangle2ParamExist) != 0)
                            {
                                hv_RowTrans.Dispose(); hv_ColTrans.Dispose();
                                HOperatorSet.AffineTransPixel(hv_HomMat2DRotate, hv_BBoxRow, hv_BBoxCol,
                                    out hv_RowTrans, out hv_ColTrans);
                                //Write the bounding box angles phi in the expected interval:
                                //-180° < phi <= 180° or if IgnoreDirection set to true -90° < phi <= 90°.
                                if ((int)(((hv_IgnoreDirection.TupleSelect(1))).TupleNot()) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_BBoxPhi = hv_BBoxPhi + (hv_CurrentRotation.TupleRad()
                                                );
                                            hv_BBoxPhi.Dispose();
                                            hv_BBoxPhi = ExpTmpLocalVar_BBoxPhi;
                                        }
                                    }
                                    hv_MaxAngle.Dispose();
                                    hv_MaxAngle = 180;
                                    hv_DiffAngle.Dispose();
                                    hv_DiffAngle = 360;
                                }
                                else
                                {
                                    if ((int)((new HTuple(hv_CurrentRotation.TupleEqual(90))).TupleOr(
                                        new HTuple(hv_CurrentRotation.TupleEqual(270)))) != 0)
                                    {
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_BBoxPhi = hv_BBoxPhi + ((new HTuple(90)).TupleRad()
                                                    );
                                                hv_BBoxPhi.Dispose();
                                                hv_BBoxPhi = ExpTmpLocalVar_BBoxPhi;
                                            }
                                        }
                                    }
                                    hv_MaxAngle.Dispose();
                                    hv_MaxAngle = 90;
                                    hv_DiffAngle.Dispose();
                                    hv_DiffAngle = 180;
                                }
                                hv_IndicesLarge.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_IndicesLarge = ((hv_BBoxPhi.TupleGreaterElem(
                                        hv_MaxAngle.TupleRad()))).TupleFind(1);
                                }
                                if ((int)(new HTuple(hv_IndicesLarge.TupleNotEqual(-1))) != 0)
                                {
                                    if (hv_BBoxPhi == null)
                                        hv_BBoxPhi = new HTuple();
                                    hv_BBoxPhi[hv_IndicesLarge] = (hv_BBoxPhi.TupleSelect(hv_IndicesLarge)) - (hv_DiffAngle.TupleRad()
                                        );
                                }
                                //Check that the angle BBoxPhi for objects without orientation is always set to 0.0.
                                if ((int)(hv_ClassIDsNoOrientationExist.TupleSelect(1)) != 0)
                                {
                                    for (hv_ObjIdx = 0; (int)hv_ObjIdx <= (int)((new HTuple(hv_BBoxLabelID.TupleLength()
                                        )) - 1); hv_ObjIdx = (int)hv_ObjIdx + 1)
                                    {
                                        if ((int)(new HTuple(((hv_ClassIDsNoOrientation.TupleFind(hv_BBoxLabelID.TupleSelect(
                                            hv_ObjIdx)))).TupleNotEqual(-1))) != 0)
                                        {
                                            if (hv_BBoxPhi == null)
                                                hv_BBoxPhi = new HTuple();
                                            hv_BBoxPhi[hv_ObjIdx] = 0.0;
                                            //These classes require Length1 <= Length2: exchange them for 90° or 270° rotations.
                                            if ((int)((new HTuple(hv_CurrentRotation.TupleEqual(90))).TupleOr(
                                                new HTuple(hv_CurrentRotation.TupleEqual(270)))) != 0)
                                            {
                                                hv_BBoxLengthTmp.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_BBoxLengthTmp = hv_BBoxLength1.TupleSelect(
                                                        hv_ObjIdx);
                                                }
                                                if (hv_BBoxLength1 == null)
                                                    hv_BBoxLength1 = new HTuple();
                                                hv_BBoxLength1[hv_ObjIdx] = hv_BBoxLength2.TupleSelect(hv_ObjIdx);
                                                if (hv_BBoxLength2 == null)
                                                    hv_BBoxLength2 = new HTuple();
                                                hv_BBoxLength2[hv_ObjIdx] = hv_BBoxLengthTmp;
                                            }
                                        }
                                    }
                                }
                                HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row", hv_RowTrans);
                                HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col", hv_ColTrans);
                                HOperatorSet.SetDictTuple(hv_DLSample, "bbox_phi", hv_BBoxPhi);
                                HOperatorSet.SetDictTuple(hv_DLSample, "bbox_length1", hv_BBoxLength1);
                                HOperatorSet.SetDictTuple(hv_DLSample, "bbox_length2", hv_BBoxLength2);
                            }
                            if ((int)(hv_SegmentationImageExists) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.RotateImage(ho_SegmentationImage, out ExpTmpOutVar_0,
                                        hv_CurrentRotation.TupleInt(), "constant");
                                    ho_SegmentationImage.Dispose();
                                    ho_SegmentationImage = ExpTmpOutVar_0;
                                }
                                HOperatorSet.SetDictObject(ho_SegmentationImage, hv_DLSample, "segmentation_image");
                            }
                            if ((int)(hv_WeightImageExists) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.RotateImage(ho_WeightImage, out ExpTmpOutVar_0, hv_CurrentRotation.TupleInt()
                                        , "constant");
                                    ho_WeightImage.Dispose();
                                    ho_WeightImage = ExpTmpOutVar_0;
                                }
                                HOperatorSet.SetDictObject(ho_WeightImage, hv_DLSample, "weight_image");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_CurrentDistortion.TupleSelect(0))).TupleEqual(
                        hv_Mirror.TupleSelect(0)))) != 0)
                    {
                        //
                        //Mirroring
                        //
                        //If more than one axis is allowed,
                        //choose mirror axis/axes to be applied.
                        hv_NumMirrorMethods.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_NumMirrorMethods = ((hv_CurrentDistortion.TupleSelect(
                                1))).TupleStrlen();
                        }
                        hv_ProbabilityMethods.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ProbabilityMethods = 1.0 / hv_NumMirrorMethods;
                        }
                        hv_StrMirror.Dispose();
                        hv_StrMirror = "";
                        while ((int)(new HTuple(hv_StrMirror.TupleEqual(""))) != 0)
                        {
                            HTuple end_val394 = hv_NumMirrorMethods - 1;
                            HTuple step_val394 = 1;
                            for (hv_StrIdx = 0; hv_StrIdx.Continue(end_val394, step_val394); hv_StrIdx = hv_StrIdx.TupleAdd(step_val394))
                            {
                                hv_SelectedChar.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_SelectedChar = ((hv_CurrentDistortion.TupleSelect(
                                        1))).TupleStrBitSelect(hv_StrIdx);
                                }
                                if ((int)(new HTuple((HTuple.TupleRand(1)).TupleLess(hv_ProbabilityMethods))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_StrMirror = hv_StrMirror + hv_SelectedChar;
                                            hv_StrMirror.Dispose();
                                            hv_StrMirror = ExpTmpLocalVar_StrMirror;
                                        }
                                    }
                                }
                            }
                        }
                        //Apply the chosen mirror axis/axes to the given sample data.
                        hv_ImageWidth.Dispose(); hv_ImageHeight.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
                        if ((int)(hv_StrMirror.TupleRegexpTest("c")) != 0)
                        {
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.MirrorImage(ho_Image, out ExpTmpOutVar_0, "column");
                                ho_Image.Dispose();
                                ho_Image = ExpTmpOutVar_0;
                            }
                            if ((int)(hv_Rectangle1ParamExist) != 0)
                            {
                                hv_BBoxCol1Mirror.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_BBoxCol1Mirror = (hv_ImageWidth - hv_BBoxCol2) - 1;
                                }
                                hv_BBoxCol2Mirror.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_BBoxCol2Mirror = (hv_ImageWidth - hv_BBoxCol1) - 1;
                                }
                                hv_BBoxCol1.Dispose();
                                hv_BBoxCol1 = new HTuple(hv_BBoxCol1Mirror);
                                hv_BBoxCol2.Dispose();
                                hv_BBoxCol2 = new HTuple(hv_BBoxCol2Mirror);
                            }
                            else if ((int)(hv_Rectangle2ParamExist) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_BBoxCol = (hv_ImageWidth - hv_BBoxCol) - 1;
                                        hv_BBoxCol.Dispose();
                                        hv_BBoxCol = ExpTmpLocalVar_BBoxCol;
                                    }
                                }
                                //Check that BBoxPhi is only mirrored for classes with orientation.
                                if ((int)(hv_ClassIDsNoOrientationExist.TupleSelect(1)) != 0)
                                {
                                    for (hv_ObjIdx = 0; (int)hv_ObjIdx <= (int)((new HTuple(hv_BBoxLabelID.TupleLength()
                                        )) - 1); hv_ObjIdx = (int)hv_ObjIdx + 1)
                                    {
                                        if ((int)(new HTuple(((hv_ClassIDsNoOrientation.TupleFind(hv_BBoxLabelID.TupleSelect(
                                            hv_ObjIdx)))).TupleEqual(-1))) != 0)
                                        {
                                            if ((int)(hv_IgnoreDirection.TupleSelect(1)) != 0)
                                            {
                                                if (hv_BBoxPhi == null)
                                                    hv_BBoxPhi = new HTuple();
                                                hv_BBoxPhi[hv_ObjIdx] = -(hv_BBoxPhi.TupleSelect(hv_ObjIdx));
                                            }
                                            else
                                            {
                                                if (hv_BBoxPhi == null)
                                                    hv_BBoxPhi = new HTuple();
                                                hv_BBoxPhi[hv_ObjIdx] = (((-(((hv_BBoxPhi.TupleSelect(hv_ObjIdx))).TupleLessElem(
                                                    0.0))) + (((hv_BBoxPhi.TupleSelect(hv_ObjIdx))).TupleGreaterEqualElem(
                                                    0.0))) * ((new HTuple(180)).TupleRad())) - (hv_BBoxPhi.TupleSelect(
                                                    hv_ObjIdx));
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    if ((int)(hv_IgnoreDirection.TupleSelect(1)) != 0)
                                    {
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_BBoxPhi = -hv_BBoxPhi;
                                                hv_BBoxPhi.Dispose();
                                                hv_BBoxPhi = ExpTmpLocalVar_BBoxPhi;
                                            }
                                        }
                                    }
                                    else
                                    {
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_BBoxPhi = (((-(hv_BBoxPhi.TupleLessElem(
                                                    0.0))) + (hv_BBoxPhi.TupleGreaterEqualElem(0.0))) * ((new HTuple(180)).TupleRad()
                                                    )) - hv_BBoxPhi;
                                                hv_BBoxPhi.Dispose();
                                                hv_BBoxPhi = ExpTmpLocalVar_BBoxPhi;
                                            }
                                        }
                                    }
                                }
                            }
                            if ((int)(hv_SegmentationImageExists) != 0)
                            {
                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.MirrorImage(ho_SegmentationImage, out ExpTmpOutVar_0,
                                        "column");
                                    ho_SegmentationImage.Dispose();
                                    ho_SegmentationImage = ExpTmpOutVar_0;
                                }
                            }
                            if ((int)(hv_WeightImageExists) != 0)
                            {
                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.MirrorImage(ho_WeightImage, out ExpTmpOutVar_0, "column");
                                    ho_WeightImage.Dispose();
                                    ho_WeightImage = ExpTmpOutVar_0;
                                }
                            }
                        }
                        //
                        if ((int)(hv_StrMirror.TupleRegexpTest("r")) != 0)
                        {
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.MirrorImage(ho_Image, out ExpTmpOutVar_0, "row");
                                ho_Image.Dispose();
                                ho_Image = ExpTmpOutVar_0;
                            }
                            if ((int)(hv_Rectangle1ParamExist) != 0)
                            {
                                hv_BBoxRow1Mirror.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_BBoxRow1Mirror = (hv_ImageHeight - hv_BBoxRow2) - 1;
                                }
                                hv_BBoxRow2Mirror.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_BBoxRow2Mirror = (hv_ImageHeight - hv_BBoxRow1) - 1;
                                }
                                hv_BBoxRow1.Dispose();
                                hv_BBoxRow1 = new HTuple(hv_BBoxRow1Mirror);
                                hv_BBoxRow2.Dispose();
                                hv_BBoxRow2 = new HTuple(hv_BBoxRow2Mirror);
                            }
                            else if ((int)(hv_Rectangle2ParamExist) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_BBoxRow = (hv_ImageHeight - hv_BBoxRow) - 1;
                                        hv_BBoxRow.Dispose();
                                        hv_BBoxRow = ExpTmpLocalVar_BBoxRow;
                                    }
                                }
                                if ((int)(hv_ClassIDsNoOrientationExist.TupleSelect(1)) != 0)
                                {
                                    for (hv_ObjIdx = 0; (int)hv_ObjIdx <= (int)((new HTuple(hv_BBoxLabelID.TupleLength()
                                        )) - 1); hv_ObjIdx = (int)hv_ObjIdx + 1)
                                    {
                                        if ((int)(new HTuple(((hv_ClassIDsNoOrientation.TupleFind(hv_BBoxLabelID.TupleSelect(
                                            hv_ObjIdx)))).TupleEqual(-1))) != 0)
                                        {
                                            if (hv_BBoxPhi == null)
                                                hv_BBoxPhi = new HTuple();
                                            hv_BBoxPhi[hv_ObjIdx] = -(hv_BBoxPhi.TupleSelect(hv_ObjIdx));
                                        }
                                    }
                                }
                                else
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_BBoxPhi = -hv_BBoxPhi;
                                            hv_BBoxPhi.Dispose();
                                            hv_BBoxPhi = ExpTmpLocalVar_BBoxPhi;
                                        }
                                    }
                                }
                            }
                            if ((int)(hv_SegmentationImageExists) != 0)
                            {
                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.MirrorImage(ho_SegmentationImage, out ExpTmpOutVar_0,
                                        "row");
                                    ho_SegmentationImage.Dispose();
                                    ho_SegmentationImage = ExpTmpOutVar_0;
                                }
                            }
                            if ((int)(hv_WeightImageExists) != 0)
                            {
                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.MirrorImage(ho_WeightImage, out ExpTmpOutVar_0, "row");
                                    ho_WeightImage.Dispose();
                                    ho_WeightImage = ExpTmpOutVar_0;
                                }
                            }
                        }
                        //
                        //Set the mirrored data to DLSample.
                        HOperatorSet.SetDictObject(ho_Image, hv_DLSample, "image");
                        if ((int)(hv_Rectangle1ParamExist) != 0)
                        {
                            HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col1", hv_BBoxCol1);
                            HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row1", hv_BBoxRow1);
                            HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col2", hv_BBoxCol2);
                            HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row2", hv_BBoxRow2);
                        }
                        else if ((int)(hv_Rectangle2ParamExist) != 0)
                        {
                            HOperatorSet.SetDictTuple(hv_DLSample, "bbox_row", hv_BBoxRow);
                            HOperatorSet.SetDictTuple(hv_DLSample, "bbox_col", hv_BBoxCol);
                            HOperatorSet.SetDictTuple(hv_DLSample, "bbox_phi", hv_BBoxPhi);
                        }
                        if ((int)(hv_SegmentationImageExists) != 0)
                        {
                            HOperatorSet.SetDictObject(ho_SegmentationImage, hv_DLSample, "segmentation_image");
                        }
                        if ((int)(hv_WeightImageExists) != 0)
                        {
                            HOperatorSet.SetDictObject(ho_WeightImage, hv_DLSample, "weight_image");
                        }
                    }
                    else if ((int)(new HTuple(((hv_CurrentDistortion.TupleSelect(0))).TupleEqual(
                        hv_BrightnessVariation.TupleSelect(0)))) != 0)
                    {
                        //Brightness variation:
                        //Add random brightness variation.
                        hv_BrightnessVariationValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BrightnessVariationValue = ((HTuple.TupleRand(
                                1) * 2) - 1) * (hv_CurrentDistortion.TupleSelect(1));
                        }
                        ho_ImageScaled.Dispose();
                        HOperatorSet.ScaleImage(ho_Image, out ho_ImageScaled, 1.0, hv_BrightnessVariationValue);
                        //
                        //Set the augmented image to DLSample.
                        HOperatorSet.SetDictObject(ho_ImageScaled, hv_DLSample, "image");
                    }
                    else if ((int)(new HTuple(((hv_CurrentDistortion.TupleSelect(0))).TupleEqual(
                        hv_BrightnessVariationSpot.TupleSelect(0)))) != 0)
                    {
                        hv_ImageWidth.Dispose(); hv_ImageHeight.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
                        //Determine random brightness variation.
                        hv_BrightnessVariationValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BrightnessVariationValue = ((HTuple.TupleRand(
                                1) * 2) - 1) * (hv_CurrentDistortion.TupleSelect(1));
                        }
                        //Determine random spot size between [0.5*ImageHeight, ImageWidth]
                        hv_SpotSize.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_SpotSize = hv_ImageWidth * ((HTuple.TupleRand(
                                1) / 2) + 0.5);
                        }
                        //Determine random spot position.
                        hv_SpotRow.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_SpotRow = HTuple.TupleRand(
                                1) * hv_ImageHeight;
                        }
                        hv_SpotColumn.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_SpotColumn = HTuple.TupleRand(
                                1) * hv_ImageWidth;
                        }
                        //
                        if ((int)(new HTuple(hv_BrightnessVariationValue.TupleLess(0))) != 0)
                        {
                            hv_Direction.Dispose();
                            hv_Direction = 0;
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_BrightnessVariationValue = -hv_BrightnessVariationValue;
                                    hv_BrightnessVariationValue.Dispose();
                                    hv_BrightnessVariationValue = ExpTmpLocalVar_BrightnessVariationValue;
                                }
                            }
                        }
                        else
                        {
                            hv_Direction.Dispose();
                            hv_Direction = 1;
                        }
                        //Generate Gauss filter that simulates an illumination spot of size 'SpotSize'.
                        ho_Filter.Dispose();
                        HOperatorSet.GenGaussFilter(out ho_Filter, 1, 1, 0, "none", "dc_center",
                            hv_SpotSize, hv_SpotSize);
                        //Shift the filter image to the given position.
                        hv_ShiftRow.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ShiftRow = -((hv_SpotSize / 2) - hv_SpotRow);
                        }
                        hv_ShiftCol.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ShiftCol = -((hv_SpotSize / 2) - hv_SpotColumn);
                        }
                        ho_GaussImage.Dispose();
                        HOperatorSet.TileImagesOffset(ho_Filter, out ho_GaussImage, hv_ShiftRow,
                            hv_ShiftCol, -1, -1, -1, -1, hv_ImageWidth, hv_ImageHeight);
                        ho_GaussFilter.Dispose();
                        HOperatorSet.FullDomain(ho_GaussImage, out ho_GaussFilter);
                        //Convert Gauss filter to target image type and apply brightness variation.
                        hv_Type.Dispose();
                        HOperatorSet.GetImageType(ho_Image, out hv_Type);
                        ho_Gauss.Dispose();
                        HOperatorSet.ScaleImage(ho_GaussFilter, out ho_Gauss, hv_BrightnessVariationValue,
                            0);
                        ho_GaussTargetType.Dispose();
                        HOperatorSet.ConvertImageType(ho_Gauss, out ho_GaussTargetType, hv_Type);
                        //Add channels to fit input image.
                        hv_NChannels.Dispose();
                        HOperatorSet.CountChannels(ho_Image, out hv_NChannels);
                        ho_AddImage.Dispose();
                        HOperatorSet.CopyObj(ho_GaussTargetType, out ho_AddImage, 1, 1);
                        HTuple end_val522 = hv_NChannels - 1;
                        HTuple step_val522 = 1;
                        for (hv_Index1 = 1; hv_Index1.Continue(end_val522, step_val522); hv_Index1 = hv_Index1.TupleAdd(step_val522))
                        {
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.AppendChannel(ho_AddImage, ho_GaussTargetType, out ExpTmpOutVar_0
                                    );
                                ho_AddImage.Dispose();
                                ho_AddImage = ExpTmpOutVar_0;
                            }
                        }
                        //Apply on image.
                        if ((int)(hv_Direction) != 0)
                        {
                            ho_ImageSpot.Dispose();
                            HOperatorSet.AddImage(ho_Image, ho_AddImage, out ho_ImageSpot, 1, 0);
                        }
                        else
                        {
                            ho_ImageSpot.Dispose();
                            HOperatorSet.SubImage(ho_Image, ho_AddImage, out ho_ImageSpot, 1, 0);
                        }
                        //
                        //Set the augmented image to DLSample.
                        HOperatorSet.SetDictObject(ho_ImageSpot, hv_DLSample, "image");
                    }
                    else if ((int)(new HTuple(((hv_CurrentDistortion.TupleSelect(0))).TupleEqual(
                        hv_CropPercentage.TupleSelect(0)))) != 0)
                    {
                        hv_ImageWidth.Dispose(); hv_ImageHeight.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
                        //Define cropping rectangle.
                        hv_CropRate.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CropRate = (hv_CurrentDistortion.TupleSelect(
                                1)) * 0.01;
                        }
                        hv_Row1.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Row1 = ((((1 - hv_CropRate) * hv_ImageHeight) * HTuple.TupleRand(
                                1))).TupleFloor();
                        }
                        hv_Row2.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Row2 = hv_Row1 + (hv_CropRate * hv_ImageHeight);
                        }
                        hv_Column1.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Column1 = ((((1 - hv_CropRate) * hv_ImageWidth) * HTuple.TupleRand(
                                1))).TupleFloor();
                        }
                        hv_Column2.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Column2 = hv_Column1 + (hv_CropRate * hv_ImageWidth);
                        }
                        //Crop the image.
                        ho_ImagePart.Dispose();
                        HOperatorSet.CropRectangle1(ho_Image, out ho_ImagePart, hv_Row1, hv_Column1,
                            hv_Row2, hv_Column2);
                        //Scale image to the input size and set the augmented image to DLSample.
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ZoomImageSize(ho_ImagePart, out ExpTmpOutVar_0, hv_ImageWidth,
                                hv_ImageHeight, "constant");
                            ho_ImagePart.Dispose();
                            ho_ImagePart = ExpTmpOutVar_0;
                        }
                        HOperatorSet.SetDictObject(ho_ImagePart, hv_DLSample, "image");
                    }
                    else if ((int)(new HTuple(((hv_CurrentDistortion.TupleSelect(0))).TupleEqual(
                        hv_CropPixel.TupleSelect(0)))) != 0)
                    {
                        hv_ImageWidth.Dispose(); hv_ImageHeight.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
                        //Define cropping rectangle.
                        hv_Length.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Length = hv_CurrentDistortion.TupleSelect(
                                1);
                        }
                        hv_Row1.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Row1 = HTuple.TupleRand(
                                1) * (hv_ImageHeight - hv_Length);
                        }
                        hv_Row2.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Row2 = (hv_Row1 + hv_Length) - 1;
                        }
                        hv_Column1.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Column1 = HTuple.TupleRand(
                                1) * (hv_ImageWidth - hv_Length);
                        }
                        hv_Column2.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Column2 = (hv_Column1 + hv_Length) - 1;
                        }
                        //Crop the image.
                        ho_ImagePart.Dispose();
                        HOperatorSet.CropRectangle1(ho_Image, out ho_ImagePart, hv_Row1, hv_Column1,
                            hv_Row2, hv_Column2);
                        //Scale the image to the input size and set the augmented image to DLSample.
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ZoomImageSize(ho_ImagePart, out ExpTmpOutVar_0, hv_ImageWidth,
                                hv_ImageHeight, "constant");
                            ho_ImagePart.Dispose();
                            ho_ImagePart = ExpTmpOutVar_0;
                        }
                        HOperatorSet.SetDictObject(ho_ImagePart, hv_DLSample, "image");
                    }
                    else if ((int)(new HTuple(((hv_CurrentDistortion.TupleSelect(0))).TupleEqual(
                        hv_RotationRange.TupleSelect(0)))) != 0)
                    {
                        hv_ImageWidth.Dispose(); hv_ImageHeight.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
                        //Determine rotation angle for method 'rotate_range' (angle in range [0:1:CurrentDistortion[1])).
                        hv_RotationStep.Dispose();
                        hv_RotationStep = 1;
                        hv_NumPossibleRotations.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_NumPossibleRotations = hv_CurrentDistortion.TupleSelect(
                                1);
                        }
                        hv_CurrentRotation.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentRotation = hv_RotationStep * ((((hv_NumPossibleRotations * HTuple.TupleRand(
                                1))).TupleInt()) + 1);
                        }
                        //Select direction of rotation randomly.
                        if ((int)(new HTuple((new HTuple((HTuple.TupleRand(1)).TupleRound())).TupleGreater(
                            0.5))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_CurrentRotation = 360.0 - hv_CurrentRotation;
                                    hv_CurrentRotation.Dispose();
                                    hv_CurrentRotation = ExpTmpLocalVar_CurrentRotation;
                                }
                            }
                        }
                        if ((int)((new HTuple(((hv_CurrentRotation.TupleInt())).TupleEqual(hv_CurrentRotation))).TupleAnd(
                            new HTuple((((hv_CurrentRotation.TupleInt()) % 90)).TupleEqual(0)))) != 0)
                        {
                            //Rotations around 90 degrees are faster with rotate_image.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_ImagePart.Dispose();
                                HOperatorSet.RotateImage(ho_Image, out ho_ImagePart, hv_CurrentRotation.TupleInt()
                                    , "constant");
                            }
                        }
                        else
                        {
                            //Create rotation matrix.
                            hv_HomMat2DIdentity.Dispose();
                            HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_HomMat2DRotate.Dispose();
                                HOperatorSet.HomMat2dRotate(hv_HomMat2DIdentity, hv_CurrentRotation.TupleRad()
                                    , hv_ImageHeight / 2.0, hv_ImageWidth / 2.0, out hv_HomMat2DRotate);
                            }
                            //Apply rotation.
                            ho_ImageRotated.Dispose();
                            HOperatorSet.AffineTransImage(ho_Image, out ho_ImageRotated, hv_HomMat2DRotate,
                                "constant", "false");
                            //Remove potential undefined domain.
                            ho_DomainRotated.Dispose();
                            HOperatorSet.GetDomain(ho_ImageRotated, out ho_DomainRotated);
                            hv_Row1.Dispose(); hv_Column1.Dispose(); hv_Row2.Dispose(); hv_Column2.Dispose();
                            HOperatorSet.InnerRectangle1(ho_DomainRotated, out hv_Row1, out hv_Column1,
                                out hv_Row2, out hv_Column2);
                            ho_ImagePart.Dispose();
                            HOperatorSet.CropRectangle1(ho_ImageRotated, out ho_ImagePart, hv_Row1,
                                hv_Column1, hv_Row2, hv_Column2);
                            //Scale image to the input size.
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.ZoomImageSize(ho_ImagePart, out ExpTmpOutVar_0, hv_ImageWidth,
                                    hv_ImageHeight, "constant");
                                ho_ImagePart.Dispose();
                                ho_ImagePart = ExpTmpOutVar_0;
                            }
                        }
                        //
                        //Set the augmented image to DLSample.
                        HOperatorSet.SetDictObject(ho_ImagePart, hv_DLSample, "image");
                    }
                }
                ho_Image.Dispose();
                ho_SegmentationImage.Dispose();
                ho_WeightImage.Dispose();
                ho_ImageRotate.Dispose();
                ho_ImageScaled.Dispose();
                ho_Filter.Dispose();
                ho_GaussImage.Dispose();
                ho_GaussFilter.Dispose();
                ho_Gauss.Dispose();
                ho_GaussTargetType.Dispose();
                ho_AddImage.Dispose();
                ho_ImageSpot.Dispose();
                ho_ImagePart.Dispose();
                ho_ImageRotated.Dispose();
                ho_DomainRotated.Dispose();

                hv_AugmentationPercentage.Dispose();
                hv_Rotation.Dispose();
                hv_Mirror.Dispose();
                hv_BrightnessVariation.Dispose();
                hv_BrightnessVariationSpot.Dispose();
                hv_CropPercentage.Dispose();
                hv_CropPixel.Dispose();
                hv_RotationRange.Dispose();
                hv_IgnoreDirection.Dispose();
                hv_ClassIDsNoOrientationExist.Dispose();
                hv_ClassIDsNoOrientation.Dispose();
                hv_AugmentationPercentageExists.Dispose();
                hv_RotationExists.Dispose();
                hv_MirrorExists.Dispose();
                hv_BrightnessVariationExists.Dispose();
                hv_BrightnessVariationSpotExists.Dispose();
                hv_CropPercentageExists.Dispose();
                hv_CropPixelExists.Dispose();
                hv_RotationRangeExists.Dispose();
                hv_IgnoreDirectionExists.Dispose();
                hv_ClassIDsNoOrientationExists.Dispose();
                hv_CurrentParamValue.Dispose();
                hv_Exception.Dispose();
                hv_NumSamples.Dispose();
                hv_NumAvailableDistortions.Dispose();
                hv_SampleIndex.Dispose();
                hv_SelectedDistortion.Dispose();
                hv_CurrentDistortion.Dispose();
                hv_DLSample.Dispose();
                hv_ClassificationImageExists.Dispose();
                hv_Rectangle1ParamExist.Dispose();
                hv_Rectangle2ParamExist.Dispose();
                hv_SegmentationImageExists.Dispose();
                hv_WeightImageExists.Dispose();
                hv_BBoxRow1.Dispose();
                hv_BBoxCol1.Dispose();
                hv_BBoxRow2.Dispose();
                hv_BBoxCol2.Dispose();
                hv_BBoxRow.Dispose();
                hv_BBoxCol.Dispose();
                hv_BBoxLength1.Dispose();
                hv_BBoxLength2.Dispose();
                hv_BBoxPhi.Dispose();
                hv_BBoxLabelID.Dispose();
                hv_RotationStep.Dispose();
                hv_NumPossibleRotations.Dispose();
                hv_CurrentRotation.Dispose();
                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_HomMat2DIdentity.Dispose();
                hv_HomMat2DTmp.Dispose();
                hv_HomMat2DAdapted.Dispose();
                hv_Offset.Dispose();
                hv_HomMat2DRotate.Dispose();
                hv_RowTrans1.Dispose();
                hv_ColTrans1.Dispose();
                hv_RowTrans2.Dispose();
                hv_ColTrans2.Dispose();
                hv_RowTrans.Dispose();
                hv_ColTrans.Dispose();
                hv_MaxAngle.Dispose();
                hv_DiffAngle.Dispose();
                hv_IndicesLarge.Dispose();
                hv_ObjIdx.Dispose();
                hv_BBoxLengthTmp.Dispose();
                hv_NumMirrorMethods.Dispose();
                hv_ProbabilityMethods.Dispose();
                hv_StrMirror.Dispose();
                hv_StrIdx.Dispose();
                hv_SelectedChar.Dispose();
                hv_BBoxCol1Mirror.Dispose();
                hv_BBoxCol2Mirror.Dispose();
                hv_BBoxRow1Mirror.Dispose();
                hv_BBoxRow2Mirror.Dispose();
                hv_BrightnessVariationValue.Dispose();
                hv_SpotSize.Dispose();
                hv_SpotRow.Dispose();
                hv_SpotColumn.Dispose();
                hv_Direction.Dispose();
                hv_ShiftRow.Dispose();
                hv_ShiftCol.Dispose();
                hv_Type.Dispose();
                hv_NChannels.Dispose();
                hv_Index1.Dispose();
                hv_CropRate.Dispose();
                hv_Row1.Dispose();
                hv_Row2.Dispose();
                hv_Column1.Dispose();
                hv_Column2.Dispose();
                hv_Length.Dispose();
                hvec_AvailableDistortions.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Image.Dispose();
                ho_SegmentationImage.Dispose();
                ho_WeightImage.Dispose();
                ho_ImageRotate.Dispose();
                ho_ImageScaled.Dispose();
                ho_Filter.Dispose();
                ho_GaussImage.Dispose();
                ho_GaussFilter.Dispose();
                ho_Gauss.Dispose();
                ho_GaussTargetType.Dispose();
                ho_AddImage.Dispose();
                ho_ImageSpot.Dispose();
                ho_ImagePart.Dispose();
                ho_ImageRotated.Dispose();
                ho_DomainRotated.Dispose();

                hv_AugmentationPercentage.Dispose();
                hv_Rotation.Dispose();
                hv_Mirror.Dispose();
                hv_BrightnessVariation.Dispose();
                hv_BrightnessVariationSpot.Dispose();
                hv_CropPercentage.Dispose();
                hv_CropPixel.Dispose();
                hv_RotationRange.Dispose();
                hv_IgnoreDirection.Dispose();
                hv_ClassIDsNoOrientationExist.Dispose();
                hv_ClassIDsNoOrientation.Dispose();
                hv_AugmentationPercentageExists.Dispose();
                hv_RotationExists.Dispose();
                hv_MirrorExists.Dispose();
                hv_BrightnessVariationExists.Dispose();
                hv_BrightnessVariationSpotExists.Dispose();
                hv_CropPercentageExists.Dispose();
                hv_CropPixelExists.Dispose();
                hv_RotationRangeExists.Dispose();
                hv_IgnoreDirectionExists.Dispose();
                hv_ClassIDsNoOrientationExists.Dispose();
                hv_CurrentParamValue.Dispose();
                hv_Exception.Dispose();
                hv_NumSamples.Dispose();
                hv_NumAvailableDistortions.Dispose();
                hv_SampleIndex.Dispose();
                hv_SelectedDistortion.Dispose();
                hv_CurrentDistortion.Dispose();
                hv_DLSample.Dispose();
                hv_ClassificationImageExists.Dispose();
                hv_Rectangle1ParamExist.Dispose();
                hv_Rectangle2ParamExist.Dispose();
                hv_SegmentationImageExists.Dispose();
                hv_WeightImageExists.Dispose();
                hv_BBoxRow1.Dispose();
                hv_BBoxCol1.Dispose();
                hv_BBoxRow2.Dispose();
                hv_BBoxCol2.Dispose();
                hv_BBoxRow.Dispose();
                hv_BBoxCol.Dispose();
                hv_BBoxLength1.Dispose();
                hv_BBoxLength2.Dispose();
                hv_BBoxPhi.Dispose();
                hv_BBoxLabelID.Dispose();
                hv_RotationStep.Dispose();
                hv_NumPossibleRotations.Dispose();
                hv_CurrentRotation.Dispose();
                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_HomMat2DIdentity.Dispose();
                hv_HomMat2DTmp.Dispose();
                hv_HomMat2DAdapted.Dispose();
                hv_Offset.Dispose();
                hv_HomMat2DRotate.Dispose();
                hv_RowTrans1.Dispose();
                hv_ColTrans1.Dispose();
                hv_RowTrans2.Dispose();
                hv_ColTrans2.Dispose();
                hv_RowTrans.Dispose();
                hv_ColTrans.Dispose();
                hv_MaxAngle.Dispose();
                hv_DiffAngle.Dispose();
                hv_IndicesLarge.Dispose();
                hv_ObjIdx.Dispose();
                hv_BBoxLengthTmp.Dispose();
                hv_NumMirrorMethods.Dispose();
                hv_ProbabilityMethods.Dispose();
                hv_StrMirror.Dispose();
                hv_StrIdx.Dispose();
                hv_SelectedChar.Dispose();
                hv_BBoxCol1Mirror.Dispose();
                hv_BBoxCol2Mirror.Dispose();
                hv_BBoxRow1Mirror.Dispose();
                hv_BBoxRow2Mirror.Dispose();
                hv_BrightnessVariationValue.Dispose();
                hv_SpotSize.Dispose();
                hv_SpotRow.Dispose();
                hv_SpotColumn.Dispose();
                hv_Direction.Dispose();
                hv_ShiftRow.Dispose();
                hv_ShiftCol.Dispose();
                hv_Type.Dispose();
                hv_NChannels.Dispose();
                hv_Index1.Dispose();
                hv_CropRate.Dispose();
                hv_Row1.Dispose();
                hv_Row2.Dispose();
                hv_Column1.Dispose();
                hv_Column2.Dispose();
                hv_Length.Dispose();
                hvec_AvailableDistortions.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Calculate evaluation measures based on the values of RunningMeasures and the settings in EvalParams. 
        public void calculate_evaluation_measures(HTuple hv_RunningMeasures, HTuple hv_EvalParams,
            out HTuple hv_EvaluationResult)
        {



            // Local control variables 

            HTuple hv_EvaluationType = new HTuple();
            // Initialize local and output iconic variables 
            hv_EvaluationResult = new HTuple();
            try
            {
                //
                //This procedure calculates the final measures depending on the evaluation type.
                //
                hv_EvaluationType.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "evaluation_type", out hv_EvaluationType);
                if ((int)(new HTuple(hv_EvaluationType.TupleEqual("anomaly_detection"))) != 0)
                {
                    hv_EvaluationResult.Dispose();
                    calculate_image_anomaly_measures(hv_RunningMeasures, hv_EvalParams, out hv_EvaluationResult);
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("classification"))) != 0)
                {
                    hv_EvaluationResult.Dispose();
                    calculate_image_classification_measures(hv_RunningMeasures, hv_EvalParams,
                        out hv_EvaluationResult);
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("detection"))) != 0)
                {
                    hv_EvaluationResult.Dispose();
                    calculate_instance_measures(hv_RunningMeasures, hv_EvalParams, out hv_EvaluationResult);
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("segmentation"))) != 0)
                {
                    hv_EvaluationResult.Dispose();
                    calculate_pixel_measures(hv_RunningMeasures, hv_EvalParams, out hv_EvaluationResult);
                }
                //

                hv_EvaluationType.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_EvaluationType.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection
        // Short Description: Calculate anomaly detection measures based on RunningMeasures. 
        private void calculate_image_anomaly_measures(HTuple hv_RunningMeasures, HTuple hv_EvalParams,
            out HTuple hv_EvaluationResult)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_CalcAnomalyHistogram = new HTuple();
            HTuple hv_CalcPrecision = new HTuple(), hv_CalcRecall = new HTuple();
            HTuple hv_CalcAbsoluteConfusionMatrix = new HTuple(), hv_CalcRelativeConfusionMatrix = new HTuple();
            HTuple hv_MeasuresExists = new HTuple(), hv_Measures = new HTuple();
            HTuple hv_M = new HTuple(), hv_AnomalyClassificationThresholdExists = new HTuple();
            HTuple hv_AnomalyClassificationThreshold = new HTuple();
            HTuple hv_ImageIDs = new HTuple(), hv_AnomalyLabelIDs = new HTuple();
            HTuple hv_AnomalyScores = new HTuple(), hv_OKIndices = new HTuple();
            HTuple hv_NOKIndices = new HTuple(), hv_HistoOKXValues = new HTuple();
            HTuple hv_HistoOKYValues = new HTuple(), hv_NumOKEvalData = new HTuple();
            HTuple hv_ImageLevelScoresOK = new HTuple(), hv_HistoNOKXValues = new HTuple();
            HTuple hv_HistoNOKYValues = new HTuple(), hv_NumNOKEvalData = new HTuple();
            HTuple hv_ImageLevelScoresNOK = new HTuple(), hv_ScoreHistogram = new HTuple();
            HTuple hv_NumClasses = new HTuple(), hv_ClassIDs = new HTuple();
            HTuple hv_AllPredictions = new HTuple(), hv_IndThreshold = new HTuple();
            HTuple hv_CurrentThresholdValue = new HTuple(), hv_CurrentThresholdKey = new HTuple();
            HTuple hv_Predictions = new HTuple(), hv_AbsoluteConfustionMatrices = new HTuple();
            HTuple hv_AbsoluteConfusionMatrix = new HTuple(), hv_Rows = new HTuple();
            HTuple hv_Columns = new HTuple(), hv_Value = new HTuple();
            HTuple hv_AbsoluteConfusionMatrixDictionary = new HTuple();
            HTuple hv_RelativeConfustionMatrices = new HTuple(), hv_RelativeConfusionMatrix = new HTuple();
            HTuple hv_RelativeConfusionMatrixDictionary = new HTuple();
            HTuple hv_GlobalEvaluation = new HTuple(), hv_AllClassPrecisions = new HTuple();
            HTuple hv_AllMeanPrecisions = new HTuple(), hv_AbsoluteConfusionMatrices = new HTuple();
            HTuple hv_ClassPrecisions = new HTuple(), hv_MatrixRowSumID = new HTuple();
            HTuple hv_MatrixColumnSumID = new HTuple(), hv_Index = new HTuple();
            HTuple hv_TruePositive = new HTuple(), hv_SumPredictedClass = new HTuple();
            HTuple hv_SumLabel = new HTuple(), hv_ClassPrecision = new HTuple();
            HTuple hv_ValidClassPrecisions = new HTuple(), hv_MeanPrecision = new HTuple();
            HTuple hv_AllClassRecalls = new HTuple(), hv_AllMeanRecalls = new HTuple();
            HTuple hv_ClassRecalls = new HTuple(), hv_ClassRecall = new HTuple();
            HTuple hv_ValidClassRecalls = new HTuple(), hv_MeanRecall = new HTuple();
            // Initialize local and output iconic variables 
            hv_EvaluationResult = new HTuple();
            try
            {
                //
                //This procedure calculates the final summarizing image anomaly detection measures based on the running measures.
                //
                hv_CalcAnomalyHistogram.Dispose();
                hv_CalcAnomalyHistogram = 1;
                hv_CalcPrecision.Dispose();
                hv_CalcPrecision = 0;
                hv_CalcRecall.Dispose();
                hv_CalcRecall = 0;
                hv_CalcAbsoluteConfusionMatrix.Dispose();
                hv_CalcAbsoluteConfusionMatrix = 0;
                hv_CalcRelativeConfusionMatrix.Dispose();
                hv_CalcRelativeConfusionMatrix = 0;
                hv_MeasuresExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "measures", out hv_MeasuresExists);
                if ((int)(hv_MeasuresExists) != 0)
                {
                    hv_Measures.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                    for (hv_M = 0; (int)hv_M <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_M = (int)hv_M + 1)
                    {
                        if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual("anomaly_score_histogram"))) != 0)
                        {
                            //The default, just here for consistency.
                            hv_CalcAnomalyHistogram.Dispose();
                            hv_CalcAnomalyHistogram = 1;
                        }
                        else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                            "precision"))) != 0)
                        {
                            hv_CalcPrecision.Dispose();
                            hv_CalcPrecision = 1;
                            hv_CalcAbsoluteConfusionMatrix.Dispose();
                            hv_CalcAbsoluteConfusionMatrix = 1;
                        }
                        else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                            "recall"))) != 0)
                        {
                            hv_CalcRecall.Dispose();
                            hv_CalcRecall = 1;
                            hv_CalcAbsoluteConfusionMatrix.Dispose();
                            hv_CalcAbsoluteConfusionMatrix = 1;
                        }
                        else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                            "absolute_confusion_matrix"))) != 0)
                        {
                            hv_CalcAbsoluteConfusionMatrix.Dispose();
                            hv_CalcAbsoluteConfusionMatrix = 1;
                        }
                        else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                            "relative_confusion_matrix"))) != 0)
                        {
                            hv_CalcRelativeConfusionMatrix.Dispose();
                            hv_CalcRelativeConfusionMatrix = 1;
                        }
                        else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                            "all"))) != 0)
                        {
                            hv_CalcPrecision.Dispose();
                            hv_CalcPrecision = 1;
                            hv_CalcRecall.Dispose();
                            hv_CalcRecall = 1;
                            hv_CalcAbsoluteConfusionMatrix.Dispose();
                            hv_CalcAbsoluteConfusionMatrix = 1;
                            hv_CalcRelativeConfusionMatrix.Dispose();
                            hv_CalcRelativeConfusionMatrix = 1;
                        }
                        else
                        {
                            throw new HalconException(("Unknown Measure: " + (hv_Measures.TupleSelect(
                                hv_M))) + ".");
                        }
                    }
                }
                //
                hv_AnomalyClassificationThresholdExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "anomaly_classification_thresholds",
                    out hv_AnomalyClassificationThresholdExists);
                if ((int)(hv_AnomalyClassificationThresholdExists) != 0)
                {
                    hv_AnomalyClassificationThreshold.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "anomaly_classification_thresholds",
                        out hv_AnomalyClassificationThreshold);
                }
                else if ((int)(hv_CalcRelativeConfusionMatrix.TupleOr(hv_CalcAbsoluteConfusionMatrix)) != 0)
                {
                    throw new HalconException("A threshold value is needed to calculate a confusion matrix.");
                }
                //
                //Get and check values in RunningMeasures.
                //
                //Get image ids.
                hv_ImageIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "image_ids", out hv_ImageIDs);
                //Get anomaly ids.
                hv_AnomalyLabelIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "anomaly_label_ids", out hv_AnomalyLabelIDs);
                //Get image scores.
                hv_AnomalyScores.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "anomaly_scores", out hv_AnomalyScores);
                //
                //Calculate histograms.
                //
                //Find scores of 'ok' and 'nok' images.
                hv_OKIndices.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_OKIndices = hv_AnomalyLabelIDs.TupleFind(
                        0);
                }
                hv_NOKIndices.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NOKIndices = hv_AnomalyLabelIDs.TupleFind(
                        1);
                }
                if ((int)((new HTuple(hv_OKIndices.TupleEqual(-1))).TupleAnd(new HTuple(hv_NOKIndices.TupleEqual(
                    -1)))) != 0)
                {
                    throw new HalconException("No data available for evaluation");
                }
                //
                //Calculate histogram for 'ok' images.
                hv_HistoOKXValues.Dispose();
                hv_HistoOKXValues = new HTuple();
                hv_HistoOKYValues.Dispose();
                hv_HistoOKYValues = new HTuple();
                hv_NumOKEvalData.Dispose();
                hv_NumOKEvalData = 0;
                if ((int)(new HTuple(hv_OKIndices.TupleNotEqual(-1))) != 0)
                {
                    hv_NumOKEvalData.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumOKEvalData = new HTuple(hv_OKIndices.TupleLength()
                            );
                    }
                    hv_ImageLevelScoresOK.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageLevelScoresOK = hv_AnomalyScores.TupleSelect(
                            hv_OKIndices);
                    }
                    hv_HistoOKXValues.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_HistoOKXValues = hv_ImageLevelScoresOK.TupleSort()
                            ;
                    }
                    hv_HistoOKYValues.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_HistoOKYValues = ((HTuple.TupleGenSequence(
                            new HTuple(hv_ImageLevelScoresOK.TupleLength()), 1, -1)).TupleReal()) / (new HTuple(hv_ImageLevelScoresOK.TupleLength()
                            ));
                    }
                }
                //
                //Calculate histogram for 'nok' images.
                hv_HistoNOKXValues.Dispose();
                hv_HistoNOKXValues = new HTuple();
                hv_HistoNOKYValues.Dispose();
                hv_HistoNOKYValues = new HTuple();
                hv_NumNOKEvalData.Dispose();
                hv_NumNOKEvalData = 0;
                if ((int)(new HTuple(hv_NOKIndices.TupleNotEqual(-1))) != 0)
                {
                    hv_NumNOKEvalData.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumNOKEvalData = new HTuple(hv_NOKIndices.TupleLength()
                            );
                    }
                    hv_ImageLevelScoresNOK.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageLevelScoresNOK = hv_AnomalyScores.TupleSelect(
                            hv_NOKIndices);
                    }
                    hv_HistoNOKXValues.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_HistoNOKXValues = hv_ImageLevelScoresNOK.TupleSort()
                            ;
                    }
                    hv_HistoNOKYValues.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_HistoNOKYValues = ((HTuple.TupleGenSequence(
                            1, new HTuple(hv_ImageLevelScoresNOK.TupleLength()), 1)).TupleReal()) / (new HTuple(hv_ImageLevelScoresNOK.TupleLength()
                            ));
                    }
                }
                //
                //Create dictionary for the score histogram.
                hv_ScoreHistogram.Dispose();
                HOperatorSet.CreateDict(out hv_ScoreHistogram);
                HOperatorSet.SetDictTuple(hv_ScoreHistogram, "ok_x", hv_HistoOKXValues);
                HOperatorSet.SetDictTuple(hv_ScoreHistogram, "ok_y", hv_HistoOKYValues);
                HOperatorSet.SetDictTuple(hv_ScoreHistogram, "nok_x", hv_HistoNOKXValues);
                HOperatorSet.SetDictTuple(hv_ScoreHistogram, "nok_y", hv_HistoNOKYValues);
                //
                //Set the score histogram in the results dictionary.
                hv_EvaluationResult.Dispose();
                HOperatorSet.CreateDict(out hv_EvaluationResult);
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "anomaly_score_histogram", hv_ScoreHistogram);
                //
                //Get Predictions according to given Threshold value(s).
                //Remember, precision and recall base on the absolute confusion matrix.
                if ((int)(hv_CalcAbsoluteConfusionMatrix.TupleOr(hv_CalcRelativeConfusionMatrix)) != 0)
                {
                    hv_NumClasses.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
                    hv_ClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                    hv_AllPredictions.Dispose();
                    HOperatorSet.CreateDict(out hv_AllPredictions);
                    for (hv_IndThreshold = 0; (int)hv_IndThreshold <= (int)((new HTuple(hv_AnomalyClassificationThreshold.TupleLength()
                        )) - 1); hv_IndThreshold = (int)hv_IndThreshold + 1)
                    {
                        hv_CurrentThresholdValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentThresholdValue = hv_AnomalyClassificationThreshold.TupleSelect(
                                hv_IndThreshold);
                        }
                        hv_CurrentThresholdKey.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentThresholdKey = hv_IndThreshold.TupleString(
                                ".3d");
                        }
                        hv_Predictions.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Predictions = hv_AnomalyScores.TupleGreaterEqualElem(
                                hv_CurrentThresholdValue);
                        }
                        HOperatorSet.SetDictTuple(hv_AllPredictions, hv_CurrentThresholdKey, hv_Predictions);
                    }
                }
                //
                //Calculate absolute confusion matrix.
                if ((int)(hv_CalcAbsoluteConfusionMatrix) != 0)
                {
                    hv_AbsoluteConfustionMatrices.Dispose();
                    hv_AbsoluteConfustionMatrices = new HTuple();
                    for (hv_IndThreshold = 0; (int)hv_IndThreshold <= (int)((new HTuple(hv_AnomalyClassificationThreshold.TupleLength()
                        )) - 1); hv_IndThreshold = (int)hv_IndThreshold + 1)
                    {
                        hv_CurrentThresholdValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentThresholdValue = hv_AnomalyClassificationThreshold.TupleSelect(
                                hv_IndThreshold);
                        }
                        hv_CurrentThresholdKey.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentThresholdKey = hv_IndThreshold.TupleString(
                                ".3d");
                        }
                        hv_Predictions.Dispose();
                        HOperatorSet.GetDictTuple(hv_AllPredictions, hv_CurrentThresholdKey, out hv_Predictions);
                        hv_AbsoluteConfusionMatrix.Dispose();
                        gen_confusion_matrix(hv_AnomalyLabelIDs, hv_Predictions, (new HTuple("display_matrix")).TupleConcat(
                            "return_matrix"), (new HTuple("none")).TupleConcat("absolute"), new HTuple(),
                            out hv_AbsoluteConfusionMatrix);
                        hv_Rows.Dispose(); hv_Columns.Dispose();
                        HOperatorSet.GetSizeMatrix(hv_AbsoluteConfusionMatrix, out hv_Rows, out hv_Columns);
                        if ((int)((new HTuple((new HTuple(hv_NumOKEvalData.TupleLessEqual(0))).TupleOr(
                            new HTuple(hv_NumNOKEvalData.TupleLessEqual(0))))).TupleAnd((new HTuple(hv_Rows.TupleLess(
                            2))).TupleOr(new HTuple(hv_Columns.TupleLess(2))))) != 0)
                        {
                            //Patch matrix to 2x2 in case only 'ok' or only 'nok'
                            //data is used for evaluation.
                            hv_Value.Dispose();
                            HOperatorSet.GetValueMatrix(hv_AbsoluteConfusionMatrix, 0, 0, out hv_Value);
                            hv_AbsoluteConfusionMatrix.Dispose();
                            HOperatorSet.CreateMatrix(2, 2, 0, out hv_AbsoluteConfusionMatrix);
                            if ((int)(new HTuple(hv_NumOKEvalData.TupleLessEqual(0))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetValueMatrix(hv_AbsoluteConfusionMatrix, 0, 1, (new HTuple(hv_Predictions.TupleLength()
                                        )) - hv_Value);
                                }
                                HOperatorSet.SetValueMatrix(hv_AbsoluteConfusionMatrix, 1, 1, hv_Value);
                            }
                            if ((int)(new HTuple(hv_NumNOKEvalData.TupleLessEqual(0))) != 0)
                            {
                                HOperatorSet.SetValueMatrix(hv_AbsoluteConfusionMatrix, 0, 0, hv_Value);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetValueMatrix(hv_AbsoluteConfusionMatrix, 1, 0, (new HTuple(hv_Predictions.TupleLength()
                                        )) - hv_Value);
                                }
                            }
                        }
                        hv_AbsoluteConfusionMatrixDictionary.Dispose();
                        HOperatorSet.CreateDict(out hv_AbsoluteConfusionMatrixDictionary);
                        HOperatorSet.SetDictTuple(hv_AbsoluteConfusionMatrixDictionary, "confusion_matrix",
                            hv_AbsoluteConfusionMatrix);
                        HOperatorSet.SetDictTuple(hv_AbsoluteConfusionMatrixDictionary, "threshold",
                            hv_CurrentThresholdValue);
                        if (hv_AbsoluteConfustionMatrices == null)
                            hv_AbsoluteConfustionMatrices = new HTuple();
                        hv_AbsoluteConfustionMatrices[hv_IndThreshold] = hv_AbsoluteConfusionMatrixDictionary;
                    }
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "absolute_confusion_matrix",
                        hv_AbsoluteConfustionMatrices);
                }
                //
                //Calculate relative confusion matrix.
                if ((int)(hv_CalcRelativeConfusionMatrix) != 0)
                {
                    hv_RelativeConfustionMatrices.Dispose();
                    hv_RelativeConfustionMatrices = new HTuple();
                    for (hv_IndThreshold = 0; (int)hv_IndThreshold <= (int)((new HTuple(hv_AnomalyClassificationThreshold.TupleLength()
                        )) - 1); hv_IndThreshold = (int)hv_IndThreshold + 1)
                    {
                        hv_CurrentThresholdValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentThresholdValue = hv_AnomalyClassificationThreshold.TupleSelect(
                                hv_IndThreshold);
                        }
                        hv_CurrentThresholdKey.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentThresholdKey = hv_IndThreshold.TupleString(
                                ".3d");
                        }
                        hv_Predictions.Dispose();
                        HOperatorSet.GetDictTuple(hv_AllPredictions, hv_CurrentThresholdKey, out hv_Predictions);
                        hv_RelativeConfusionMatrix.Dispose();
                        gen_confusion_matrix(hv_AnomalyLabelIDs, hv_Predictions, (new HTuple("display_matrix")).TupleConcat(
                            "return_matrix"), (new HTuple("none")).TupleConcat("relative"), new HTuple(),
                            out hv_RelativeConfusionMatrix);
                        hv_Rows.Dispose(); hv_Columns.Dispose();
                        HOperatorSet.GetSizeMatrix(hv_RelativeConfusionMatrix, out hv_Rows, out hv_Columns);
                        if ((int)((new HTuple((new HTuple(hv_NumOKEvalData.TupleLessEqual(0))).TupleOr(
                            new HTuple(hv_NumNOKEvalData.TupleLessEqual(0))))).TupleAnd((new HTuple(hv_Rows.TupleLess(
                            2))).TupleOr(new HTuple(hv_Columns.TupleLess(2))))) != 0)
                        {
                            //Patch matrix to 2x2 in case only 'ok' or only 'nok'
                            //data is used for evaluation.
                            hv_Value.Dispose();
                            HOperatorSet.GetValueMatrix(hv_RelativeConfusionMatrix, 0, 0, out hv_Value);
                            hv_RelativeConfusionMatrix.Dispose();
                            HOperatorSet.CreateMatrix(2, 2, 0, out hv_RelativeConfusionMatrix);
                            if ((int)(new HTuple(hv_NumOKEvalData.TupleLessEqual(0))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetValueMatrix(hv_RelativeConfusionMatrix, 0, 1, 1.0 - hv_Value);
                                }
                                HOperatorSet.SetValueMatrix(hv_RelativeConfusionMatrix, 1, 1, hv_Value);
                            }
                            if ((int)(new HTuple(hv_NumNOKEvalData.TupleLessEqual(0))) != 0)
                            {
                                HOperatorSet.SetValueMatrix(hv_RelativeConfusionMatrix, 0, 0, hv_Value);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetValueMatrix(hv_RelativeConfusionMatrix, 1, 0, 1.0 - hv_Value);
                                }
                            }
                        }
                        hv_RelativeConfusionMatrixDictionary.Dispose();
                        HOperatorSet.CreateDict(out hv_RelativeConfusionMatrixDictionary);
                        HOperatorSet.SetDictTuple(hv_RelativeConfusionMatrixDictionary, "confusion_matrix",
                            hv_RelativeConfusionMatrix);
                        HOperatorSet.SetDictTuple(hv_RelativeConfusionMatrixDictionary, "threshold",
                            hv_CurrentThresholdValue);
                        if (hv_RelativeConfustionMatrices == null)
                            hv_RelativeConfustionMatrices = new HTuple();
                        hv_RelativeConfustionMatrices[hv_IndThreshold] = hv_RelativeConfusionMatrixDictionary;
                    }
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "relative_confusion_matrix",
                        hv_RelativeConfustionMatrices);
                }
                //
                if ((int)(hv_CalcPrecision.TupleOr(hv_CalcRecall)) != 0)
                {
                    hv_GlobalEvaluation.Dispose();
                    HOperatorSet.CreateDict(out hv_GlobalEvaluation);
                }
                //Calculate precision.
                if ((int)(hv_CalcPrecision) != 0)
                {
                    hv_AllClassPrecisions.Dispose();
                    hv_AllClassPrecisions = new HTuple();
                    hv_AllMeanPrecisions.Dispose();
                    hv_AllMeanPrecisions = new HTuple();
                    hv_AbsoluteConfusionMatrices.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvaluationResult, "absolute_confusion_matrix",
                        out hv_AbsoluteConfusionMatrices);
                    for (hv_IndThreshold = 0; (int)hv_IndThreshold <= (int)((new HTuple(hv_AbsoluteConfusionMatrices.TupleLength()
                        )) - 1); hv_IndThreshold = (int)hv_IndThreshold + 1)
                    {
                        hv_AbsoluteConfusionMatrixDictionary.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_AbsoluteConfusionMatrixDictionary = hv_AbsoluteConfusionMatrices.TupleSelect(
                                hv_IndThreshold);
                        }
                        hv_AbsoluteConfusionMatrix.Dispose();
                        HOperatorSet.GetDictTuple(hv_AbsoluteConfusionMatrixDictionary, "confusion_matrix",
                            out hv_AbsoluteConfusionMatrix);
                        hv_ClassPrecisions.Dispose();
                        hv_ClassPrecisions = new HTuple();
                        hv_MatrixRowSumID.Dispose();
                        HOperatorSet.SumMatrix(hv_AbsoluteConfusionMatrix, "rows", out hv_MatrixRowSumID);
                        hv_MatrixColumnSumID.Dispose();
                        HOperatorSet.SumMatrix(hv_AbsoluteConfusionMatrix, "columns", out hv_MatrixColumnSumID);
                        HTuple end_val184 = hv_NumClasses - 1;
                        HTuple step_val184 = 1;
                        for (hv_Index = 0; hv_Index.Continue(end_val184, step_val184); hv_Index = hv_Index.TupleAdd(step_val184))
                        {
                            //Compute the precision for every selected class.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TruePositive.Dispose();
                                HOperatorSet.GetValueMatrix(hv_AbsoluteConfusionMatrix, hv_ClassIDs.TupleSelect(
                                    hv_Index), hv_ClassIDs.TupleSelect(hv_Index), out hv_TruePositive);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_SumPredictedClass.Dispose();
                                HOperatorSet.GetValueMatrix(hv_MatrixRowSumID, hv_ClassIDs.TupleSelect(
                                    hv_Index), 0, out hv_SumPredictedClass);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_SumLabel.Dispose();
                                HOperatorSet.GetValueMatrix(hv_MatrixColumnSumID, 0, hv_ClassIDs.TupleSelect(
                                    hv_Index), out hv_SumLabel);
                            }
                            if ((int)(new HTuple(hv_SumLabel.TupleLessEqual(0))) != 0)
                            {
                                //Invalid per-class precision.
                                hv_ClassPrecision.Dispose();
                                hv_ClassPrecision = -1.0;
                            }
                            else if ((int)(new HTuple(hv_SumPredictedClass.TupleEqual(
                                0))) != 0)
                            {
                                hv_ClassPrecision.Dispose();
                                hv_ClassPrecision = 0.0;
                            }
                            else
                            {
                                hv_ClassPrecision.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ClassPrecision = hv_TruePositive / hv_SumPredictedClass;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ClassPrecisions = hv_ClassPrecisions.TupleConcat(
                                        hv_ClassPrecision);
                                    hv_ClassPrecisions.Dispose();
                                    hv_ClassPrecisions = ExpTmpLocalVar_ClassPrecisions;
                                }
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ValidClassPrecisions.Dispose();
                            HOperatorSet.TupleSelectMask(hv_ClassPrecisions, hv_ClassPrecisions.TupleGreaterEqualElem(
                                0.0), out hv_ValidClassPrecisions);
                        }
                        hv_MeanPrecision.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MeanPrecision = hv_ValidClassPrecisions.TupleMean()
                                ;
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_AllClassPrecisions = hv_AllClassPrecisions.TupleConcat(
                                    hv_ClassPrecisions);
                                hv_AllClassPrecisions.Dispose();
                                hv_AllClassPrecisions = ExpTmpLocalVar_AllClassPrecisions;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_AllMeanPrecisions = hv_AllMeanPrecisions.TupleConcat(
                                    hv_MeanPrecision);
                                hv_AllMeanPrecisions.Dispose();
                                hv_AllMeanPrecisions = ExpTmpLocalVar_AllMeanPrecisions;
                            }
                        }
                        HOperatorSet.ClearMatrix(hv_MatrixRowSumID);
                    }
                    HOperatorSet.SetDictTuple(hv_GlobalEvaluation, "precision_per_class", hv_AllClassPrecisions);
                    HOperatorSet.SetDictTuple(hv_GlobalEvaluation, "mean_precision", hv_AllMeanPrecisions);
                }
                //
                //Calculate recall.
                if ((int)(hv_CalcRecall) != 0)
                {
                    hv_AllClassRecalls.Dispose();
                    hv_AllClassRecalls = new HTuple();
                    hv_AllMeanRecalls.Dispose();
                    hv_AllMeanRecalls = new HTuple();
                    hv_AbsoluteConfustionMatrices.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvaluationResult, "absolute_confusion_matrix",
                        out hv_AbsoluteConfustionMatrices);
                    for (hv_IndThreshold = 0; (int)hv_IndThreshold <= (int)((new HTuple(hv_AbsoluteConfustionMatrices.TupleLength()
                        )) - 1); hv_IndThreshold = (int)hv_IndThreshold + 1)
                    {
                        hv_AbsoluteConfusionMatrixDictionary.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_AbsoluteConfusionMatrixDictionary = hv_AbsoluteConfustionMatrices.TupleSelect(
                                hv_IndThreshold);
                        }
                        hv_AbsoluteConfusionMatrix.Dispose();
                        HOperatorSet.GetDictTuple(hv_AbsoluteConfusionMatrixDictionary, "confusion_matrix",
                            out hv_AbsoluteConfusionMatrix);
                        hv_ClassRecalls.Dispose();
                        hv_ClassRecalls = new HTuple();
                        hv_MatrixColumnSumID.Dispose();
                        HOperatorSet.SumMatrix(hv_AbsoluteConfusionMatrix, "columns", out hv_MatrixColumnSumID);
                        HTuple end_val219 = hv_NumClasses - 1;
                        HTuple step_val219 = 1;
                        for (hv_Index = 0; hv_Index.Continue(end_val219, step_val219); hv_Index = hv_Index.TupleAdd(step_val219))
                        {
                            //Compute the recall for every selected class.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TruePositive.Dispose();
                                HOperatorSet.GetValueMatrix(hv_AbsoluteConfusionMatrix, hv_ClassIDs.TupleSelect(
                                    hv_Index), hv_ClassIDs.TupleSelect(hv_Index), out hv_TruePositive);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_SumLabel.Dispose();
                                HOperatorSet.GetValueMatrix(hv_MatrixColumnSumID, 0, hv_ClassIDs.TupleSelect(
                                    hv_Index), out hv_SumLabel);
                            }
                            if ((int)(new HTuple(hv_SumLabel.TupleEqual(0))) != 0)
                            {
                                //Invalid per-class recall.
                                hv_ClassRecall.Dispose();
                                hv_ClassRecall = -1.0;
                            }
                            else
                            {
                                hv_ClassRecall.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ClassRecall = hv_TruePositive / hv_SumLabel;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ClassRecalls = hv_ClassRecalls.TupleConcat(
                                        hv_ClassRecall);
                                    hv_ClassRecalls.Dispose();
                                    hv_ClassRecalls = ExpTmpLocalVar_ClassRecalls;
                                }
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ValidClassRecalls.Dispose();
                            HOperatorSet.TupleSelectMask(hv_ClassRecalls, hv_ClassRecalls.TupleGreaterEqualElem(
                                0.0), out hv_ValidClassRecalls);
                        }
                        hv_MeanRecall.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MeanRecall = hv_ValidClassRecalls.TupleMean()
                                ;
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_AllClassRecalls = hv_AllClassRecalls.TupleConcat(
                                    hv_ClassRecalls);
                                hv_AllClassRecalls.Dispose();
                                hv_AllClassRecalls = ExpTmpLocalVar_AllClassRecalls;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_AllMeanRecalls = hv_AllMeanRecalls.TupleConcat(
                                    hv_MeanRecall);
                                hv_AllMeanRecalls.Dispose();
                                hv_AllMeanRecalls = ExpTmpLocalVar_AllMeanRecalls;
                            }
                        }
                        HOperatorSet.ClearMatrix(hv_MatrixColumnSumID);
                        //
                    }
                    HOperatorSet.SetDictTuple(hv_GlobalEvaluation, "recall_per_class", hv_AllClassRecalls);
                    HOperatorSet.SetDictTuple(hv_GlobalEvaluation, "mean_recall", hv_AllMeanRecalls);
                }
                //
                if ((int)(hv_CalcPrecision.TupleOr(hv_CalcRecall)) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "global_evaluation", hv_GlobalEvaluation);
                }
                //

                hv_CalcAnomalyHistogram.Dispose();
                hv_CalcPrecision.Dispose();
                hv_CalcRecall.Dispose();
                hv_CalcAbsoluteConfusionMatrix.Dispose();
                hv_CalcRelativeConfusionMatrix.Dispose();
                hv_MeasuresExists.Dispose();
                hv_Measures.Dispose();
                hv_M.Dispose();
                hv_AnomalyClassificationThresholdExists.Dispose();
                hv_AnomalyClassificationThreshold.Dispose();
                hv_ImageIDs.Dispose();
                hv_AnomalyLabelIDs.Dispose();
                hv_AnomalyScores.Dispose();
                hv_OKIndices.Dispose();
                hv_NOKIndices.Dispose();
                hv_HistoOKXValues.Dispose();
                hv_HistoOKYValues.Dispose();
                hv_NumOKEvalData.Dispose();
                hv_ImageLevelScoresOK.Dispose();
                hv_HistoNOKXValues.Dispose();
                hv_HistoNOKYValues.Dispose();
                hv_NumNOKEvalData.Dispose();
                hv_ImageLevelScoresNOK.Dispose();
                hv_ScoreHistogram.Dispose();
                hv_NumClasses.Dispose();
                hv_ClassIDs.Dispose();
                hv_AllPredictions.Dispose();
                hv_IndThreshold.Dispose();
                hv_CurrentThresholdValue.Dispose();
                hv_CurrentThresholdKey.Dispose();
                hv_Predictions.Dispose();
                hv_AbsoluteConfustionMatrices.Dispose();
                hv_AbsoluteConfusionMatrix.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_Value.Dispose();
                hv_AbsoluteConfusionMatrixDictionary.Dispose();
                hv_RelativeConfustionMatrices.Dispose();
                hv_RelativeConfusionMatrix.Dispose();
                hv_RelativeConfusionMatrixDictionary.Dispose();
                hv_GlobalEvaluation.Dispose();
                hv_AllClassPrecisions.Dispose();
                hv_AllMeanPrecisions.Dispose();
                hv_AbsoluteConfusionMatrices.Dispose();
                hv_ClassPrecisions.Dispose();
                hv_MatrixRowSumID.Dispose();
                hv_MatrixColumnSumID.Dispose();
                hv_Index.Dispose();
                hv_TruePositive.Dispose();
                hv_SumPredictedClass.Dispose();
                hv_SumLabel.Dispose();
                hv_ClassPrecision.Dispose();
                hv_ValidClassPrecisions.Dispose();
                hv_MeanPrecision.Dispose();
                hv_AllClassRecalls.Dispose();
                hv_AllMeanRecalls.Dispose();
                hv_ClassRecalls.Dispose();
                hv_ClassRecall.Dispose();
                hv_ValidClassRecalls.Dispose();
                hv_MeanRecall.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_CalcAnomalyHistogram.Dispose();
                hv_CalcPrecision.Dispose();
                hv_CalcRecall.Dispose();
                hv_CalcAbsoluteConfusionMatrix.Dispose();
                hv_CalcRelativeConfusionMatrix.Dispose();
                hv_MeasuresExists.Dispose();
                hv_Measures.Dispose();
                hv_M.Dispose();
                hv_AnomalyClassificationThresholdExists.Dispose();
                hv_AnomalyClassificationThreshold.Dispose();
                hv_ImageIDs.Dispose();
                hv_AnomalyLabelIDs.Dispose();
                hv_AnomalyScores.Dispose();
                hv_OKIndices.Dispose();
                hv_NOKIndices.Dispose();
                hv_HistoOKXValues.Dispose();
                hv_HistoOKYValues.Dispose();
                hv_NumOKEvalData.Dispose();
                hv_ImageLevelScoresOK.Dispose();
                hv_HistoNOKXValues.Dispose();
                hv_HistoNOKYValues.Dispose();
                hv_NumNOKEvalData.Dispose();
                hv_ImageLevelScoresNOK.Dispose();
                hv_ScoreHistogram.Dispose();
                hv_NumClasses.Dispose();
                hv_ClassIDs.Dispose();
                hv_AllPredictions.Dispose();
                hv_IndThreshold.Dispose();
                hv_CurrentThresholdValue.Dispose();
                hv_CurrentThresholdKey.Dispose();
                hv_Predictions.Dispose();
                hv_AbsoluteConfustionMatrices.Dispose();
                hv_AbsoluteConfusionMatrix.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_Value.Dispose();
                hv_AbsoluteConfusionMatrixDictionary.Dispose();
                hv_RelativeConfustionMatrices.Dispose();
                hv_RelativeConfusionMatrix.Dispose();
                hv_RelativeConfusionMatrixDictionary.Dispose();
                hv_GlobalEvaluation.Dispose();
                hv_AllClassPrecisions.Dispose();
                hv_AllMeanPrecisions.Dispose();
                hv_AbsoluteConfusionMatrices.Dispose();
                hv_ClassPrecisions.Dispose();
                hv_MatrixRowSumID.Dispose();
                hv_MatrixColumnSumID.Dispose();
                hv_Index.Dispose();
                hv_TruePositive.Dispose();
                hv_SumPredictedClass.Dispose();
                hv_SumLabel.Dispose();
                hv_ClassPrecision.Dispose();
                hv_ValidClassPrecisions.Dispose();
                hv_MeanPrecision.Dispose();
                hv_AllClassRecalls.Dispose();
                hv_AllMeanRecalls.Dispose();
                hv_ClassRecalls.Dispose();
                hv_ClassRecall.Dispose();
                hv_ValidClassRecalls.Dispose();
                hv_MeanRecall.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Calculate image classification measures based on RunningMeasures. 
        private void calculate_image_classification_measures(HTuple hv_RunningMeasures,
            HTuple hv_EvalParams, out HTuple hv_EvaluationResult)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_TopKErrorKs = new HTuple(), hv_CalcPrecision = new HTuple();
            HTuple hv_CalcRecall = new HTuple(), hv_CalcFScore = new HTuple();
            HTuple hv_CalcAbsoluteConfusionMatrix = new HTuple(), hv_CalcRelativeConfusionMatrix = new HTuple();
            HTuple hv_Measures = new HTuple(), hv_RegExpTopKError = new HTuple();
            HTuple hv_M = new HTuple(), hv_ComputeTopKError = new HTuple();
            HTuple hv_K = new HTuple(), hv_ClassIDs = new HTuple();
            HTuple hv_KeyExists = new HTuple(), hv_ClassesToEvaluate = new HTuple();
            HTuple hv_ClassIDsToEvaluate = new HTuple(), hv_ClassNames = new HTuple();
            HTuple hv_Index = new HTuple(), hv_Position = new HTuple();
            HTuple hv_ImageIDs = new HTuple(), hv_ImageLabelIDs = new HTuple();
            HTuple hv_Predictions = new HTuple(), hv_TopKPredictions = new HTuple();
            HTuple hv_EvalIndex = new HTuple(), hv_CurrentEvalClass = new HTuple();
            HTuple hv_IndexClass = new HTuple(), hv_EvaluatedSamples = new HTuple();
            HTuple hv_ConfusionMatrix = new HTuple(), hv_RelativeConfusionMatrix = new HTuple();
            HTuple hv_EvalClassID = new HTuple(), hv_KIndex = new HTuple();
            HTuple hv_Indices = new HTuple(), hv_TopKError = new HTuple();
            HTuple hv_NumClasses = new HTuple(), hv_ClassPrecisions = new HTuple();
            HTuple hv_MatrixRowSumID = new HTuple(), hv_TruePositive = new HTuple();
            HTuple hv_SumPredictedClass = new HTuple(), hv_ClassPrecision = new HTuple();
            HTuple hv_Precision = new HTuple(), hv_ClassRecalls = new HTuple();
            HTuple hv_MatrixColumnSumID = new HTuple(), hv_SumLabel = new HTuple();
            HTuple hv_ClassRecall = new HTuple(), hv_Recall = new HTuple();
            HTuple hv_ClassFScores = new HTuple(), hv_SumPrecisionRecall = new HTuple();
            HTuple hv_PositiveIndices = new HTuple(), hv_FScore = new HTuple();
            HTuple hv_KeyName = new HTuple();
            // Initialize local and output iconic variables 
            hv_EvaluationResult = new HTuple();
            try
            {
                //
                //This procedure calculates the final summarizing image classification measures based on the running measures.
                //
                //Set default values.
                hv_TopKErrorKs.Dispose();
                hv_TopKErrorKs = new HTuple();
                hv_CalcPrecision.Dispose();
                hv_CalcPrecision = 0;
                hv_CalcRecall.Dispose();
                hv_CalcRecall = 0;
                hv_CalcFScore.Dispose();
                hv_CalcFScore = 0;
                hv_CalcAbsoluteConfusionMatrix.Dispose();
                hv_CalcAbsoluteConfusionMatrix = 0;
                hv_CalcRelativeConfusionMatrix.Dispose();
                hv_CalcRelativeConfusionMatrix = 0;
                //
                //Check which measures are to be calculated.
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                hv_RegExpTopKError.Dispose();
                hv_RegExpTopKError = "top([0-9]+)_error";
                for (hv_M = 0; (int)hv_M <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_M = (int)hv_M + 1)
                {
                    hv_ComputeTopKError.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ComputeTopKError = ((hv_Measures.TupleSelect(
                            hv_M))).TupleRegexpTest("top([0-9]+)_error");
                    }
                    if ((int)(hv_ComputeTopKError) != 0)
                    {
                        hv_K.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_K = ((((hv_Measures.TupleSelect(
                                hv_M))).TupleRegexpMatch(hv_RegExpTopKError))).TupleNumber();
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_TopKErrorKs = ((hv_TopKErrorKs.TupleConcat(
                                    hv_K))).TupleSort();
                                hv_TopKErrorKs.Dispose();
                                hv_TopKErrorKs = ExpTmpLocalVar_TopKErrorKs;
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "precision"))) != 0)
                    {
                        hv_CalcPrecision.Dispose();
                        hv_CalcPrecision = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "recall"))) != 0)
                    {
                        hv_CalcRecall.Dispose();
                        hv_CalcRecall = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "f_score"))) != 0)
                    {
                        hv_CalcFScore.Dispose();
                        hv_CalcFScore = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "absolute_confusion_matrix"))) != 0)
                    {
                        hv_CalcAbsoluteConfusionMatrix.Dispose();
                        hv_CalcAbsoluteConfusionMatrix = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "relative_confusion_matrix"))) != 0)
                    {
                        hv_CalcRelativeConfusionMatrix.Dispose();
                        hv_CalcRelativeConfusionMatrix = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "all"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_TopKErrorKs = ((hv_TopKErrorKs.TupleConcat(
                                    1))).TupleSort();
                                hv_TopKErrorKs.Dispose();
                                hv_TopKErrorKs = ExpTmpLocalVar_TopKErrorKs;
                            }
                        }
                        hv_CalcPrecision.Dispose();
                        hv_CalcPrecision = 1;
                        hv_CalcRecall.Dispose();
                        hv_CalcRecall = 1;
                        hv_CalcFScore.Dispose();
                        hv_CalcFScore = 1;
                        hv_CalcAbsoluteConfusionMatrix.Dispose();
                        hv_CalcAbsoluteConfusionMatrix = 1;
                        hv_CalcRelativeConfusionMatrix.Dispose();
                        hv_CalcRelativeConfusionMatrix = 1;
                    }
                    else
                    {
                        throw new HalconException("Unknown image classification measure: " + (hv_Measures.TupleSelect(
                            hv_M)));
                    }
                }
                //
                //Initialize output dictionary and get necessary evaluation parameters.
                hv_EvaluationResult.Dispose();
                HOperatorSet.CreateDict(out hv_EvaluationResult);
                hv_ClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                hv_KeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "class_names_to_evaluate",
                    out hv_KeyExists);
                if ((int)(hv_KeyExists) != 0)
                {
                    hv_ClassesToEvaluate.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "class_names_to_evaluate", out hv_ClassesToEvaluate);
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate = new HTuple();
                    hv_ClassNames.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "class_names", out hv_ClassNames);
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_ClassesToEvaluate.TupleLength()
                        )) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        hv_Position.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Position = (((((new HTuple("global")).TupleConcat(
                                hv_ClassNames))).TupleEqualElem(hv_ClassesToEvaluate.TupleSelect(hv_Index)))).TupleFind(
                                1);
                        }
                        if ((int)((new HTuple(hv_Position.TupleEqual(-1))).TupleOr(new HTuple(hv_Position.TupleEqual(
                            new HTuple())))) != 0)
                        {
                            throw new HalconException("Invalid entry in  'class_names_to_evaluate': " + ((((new HTuple("global")).TupleConcat(
                                hv_ClassesToEvaluate))).TupleSelect(hv_Index)));
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_ClassIDsToEvaluate = hv_ClassIDsToEvaluate.TupleConcat(
                                    (((new HTuple("global")).TupleConcat(hv_ClassIDs))).TupleSelect(hv_Position));
                                hv_ClassIDsToEvaluate.Dispose();
                                hv_ClassIDsToEvaluate = ExpTmpLocalVar_ClassIDsToEvaluate;
                            }
                        }
                    }
                    HOperatorSet.SetDictTuple(hv_EvalParams, "class_ids_to_evaluate", hv_ClassIDsToEvaluate);
                }
                hv_ClassIDsToEvaluate.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids_to_evaluate", out hv_ClassIDsToEvaluate);
                //
                //Get and check values in RunningMeasures.
                hv_ImageIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "image_ids", out hv_ImageIDs);
                hv_ImageLabelIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "image_label_ids", out hv_ImageLabelIDs);
                hv_Predictions.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "top1_predictions", out hv_Predictions);
                hv_TopKPredictions.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "topk_predictions", out hv_TopKPredictions);
                //
                //Check if needed classes appear in image label IDs.
                //For the confusion matrices, all classes need to be represented.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_CalcAbsoluteConfusionMatrix = (new HTuple((new HTuple(hv_CalcPrecision.TupleOr(
                            hv_CalcRecall))).TupleOr(hv_CalcFScore))).TupleOr(hv_CalcAbsoluteConfusionMatrix);
                        hv_CalcAbsoluteConfusionMatrix.Dispose();
                        hv_CalcAbsoluteConfusionMatrix = ExpTmpLocalVar_CalcAbsoluteConfusionMatrix;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_CalcRelativeConfusionMatrix = (new HTuple((new HTuple(hv_CalcPrecision.TupleOr(
                            hv_CalcRecall))).TupleOr(hv_CalcFScore))).TupleOr(hv_CalcRelativeConfusionMatrix);
                        hv_CalcRelativeConfusionMatrix.Dispose();
                        hv_CalcRelativeConfusionMatrix = ExpTmpLocalVar_CalcRelativeConfusionMatrix;
                    }
                }
                if ((int)(hv_CalcAbsoluteConfusionMatrix.TupleOr(hv_CalcRelativeConfusionMatrix)) != 0)
                {
                    if ((int)(new HTuple(((((hv_ImageLabelIDs.TupleSort())).TupleUniq())).TupleNotEqual(
                        hv_ClassIDs.TupleSort()))) != 0)
                    {
                        throw new HalconException("Not all classes are represented in the ground truth labels. \nPlease check your data split.");
                    }
                }
                //For top-K errors, the evaluated classes need to be represented.
                if ((int)(new HTuple(hv_TopKErrorKs.TupleNotEqual(new HTuple()))) != 0)
                {
                    for (hv_EvalIndex = 0; (int)hv_EvalIndex <= (int)((new HTuple(hv_ClassIDsToEvaluate.TupleLength()
                        )) - 1); hv_EvalIndex = (int)hv_EvalIndex + 1)
                    {
                        hv_CurrentEvalClass.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentEvalClass = hv_ClassIDsToEvaluate.TupleSelect(
                                hv_EvalIndex);
                        }
                        if ((int)(new HTuple(hv_CurrentEvalClass.TupleNotEqual("global"))) != 0)
                        {
                            hv_IndexClass.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_IndexClass = hv_ImageLabelIDs.TupleFind(
                                    hv_CurrentEvalClass);
                            }
                            if ((int)((new HTuple(hv_IndexClass.TupleEqual(-1))).TupleOr(new HTuple(hv_IndexClass.TupleEqual(
                                new HTuple())))) != 0)
                            {
                                throw new HalconException(("The evaluated class ID " + hv_CurrentEvalClass) + " is not represented in the ground truth labels.");
                            }
                        }
                    }
                }
                //
                //Set image IDs, image label IDs, and top1-predictions to of evaluated samples EvaluationResult.
                hv_EvaluatedSamples.Dispose();
                HOperatorSet.CreateDict(out hv_EvaluatedSamples);
                HOperatorSet.SetDictTuple(hv_EvaluatedSamples, "image_ids", hv_ImageIDs);
                HOperatorSet.SetDictTuple(hv_EvaluatedSamples, "image_label_ids", hv_ImageLabelIDs);
                HOperatorSet.SetDictTuple(hv_EvaluatedSamples, "top1_predictions", hv_Predictions);
                HOperatorSet.SetDictTuple(hv_EvaluationResult, "evaluated_samples", hv_EvaluatedSamples);
                //
                //Calculate absolute confusion matrix if needed and set it to EvaluationResult.
                if ((int)(hv_CalcAbsoluteConfusionMatrix) != 0)
                {
                    hv_ConfusionMatrix.Dispose();
                    gen_confusion_matrix(hv_ImageLabelIDs, hv_Predictions, "display_matrix",
                        "none", new HTuple(), out hv_ConfusionMatrix);
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "absolute_confusion_matrix",
                        hv_ConfusionMatrix);
                }
                //
                //Calculate relative confusion matrix.
                if ((int)(hv_CalcRelativeConfusionMatrix) != 0)
                {
                    hv_RelativeConfusionMatrix.Dispose();
                    gen_confusion_matrix(hv_ImageLabelIDs, hv_Predictions, (new HTuple("display_matrix")).TupleConcat(
                        "return_matrix"), (new HTuple("none")).TupleConcat("relative"), new HTuple(),
                        out hv_RelativeConfusionMatrix);
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "relative_confusion_matrix",
                        hv_RelativeConfusionMatrix);
                }
                //
                // Calcuate measures for every class to be evaluated.
                for (hv_EvalIndex = 0; (int)hv_EvalIndex <= (int)((new HTuple(hv_ClassIDsToEvaluate.TupleLength()
                    )) - 1); hv_EvalIndex = (int)hv_EvalIndex + 1)
                {
                    hv_CurrentEvalClass.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentEvalClass = hv_ClassIDsToEvaluate.TupleSelect(
                            hv_EvalIndex);
                    }
                    hv_EvalClassID.Dispose();
                    HOperatorSet.CreateDict(out hv_EvalClassID);
                    //
                    //Calculate top-K errors.
                    for (hv_KIndex = 0; (int)hv_KIndex <= (int)((new HTuple(hv_TopKErrorKs.TupleLength()
                        )) - 1); hv_KIndex = (int)hv_KIndex + 1)
                    {
                        hv_K.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_K = hv_TopKErrorKs.TupleSelect(
                                hv_KIndex);
                        }
                        if ((int)(new HTuple(hv_CurrentEvalClass.TupleEqual("global"))) != 0)
                        {
                            hv_Indices.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Indices = HTuple.TupleGenSequence(
                                    0, (new HTuple(hv_ImageLabelIDs.TupleLength())) - 1, 1);
                            }
                        }
                        else
                        {
                            hv_Indices.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Indices = hv_ImageLabelIDs.TupleFind(
                                    hv_CurrentEvalClass);
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TopKError.Dispose();
                            compute_top_k_error(hv_ImageLabelIDs.TupleSelect(hv_Indices), hv_TopKPredictions.TupleSelect(
                                hv_Indices), hv_K, out hv_TopKError);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_EvalClassID, ("top" + hv_K) + "_error", hv_TopKError);
                        }
                    }
                    //
                    if ((int)(new HTuple(hv_CurrentEvalClass.TupleEqual("global"))) != 0)
                    {
                        //Compute the mean of the measures for all classes.
                        hv_NumClasses.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_NumClasses = new HTuple(hv_ClassIDs.TupleLength()
                                );
                        }
                        hv_IndexClass.Dispose();
                        hv_IndexClass = new HTuple(hv_ClassIDs);
                    }
                    else
                    {
                        //Compute the measures for a certain class.
                        hv_NumClasses.Dispose();
                        hv_NumClasses = 1;
                        hv_IndexClass.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_IndexClass = hv_ClassIDs.TupleFind(
                                hv_CurrentEvalClass);
                        }
                    }
                    //
                    //Calculate prediction.
                    if ((int)(hv_CalcPrecision.TupleOr(hv_CalcFScore)) != 0)
                    {
                        hv_ClassPrecisions.Dispose();
                        hv_ClassPrecisions = new HTuple();
                        hv_MatrixRowSumID.Dispose();
                        HOperatorSet.SumMatrix(hv_ConfusionMatrix, "rows", out hv_MatrixRowSumID);
                        HTuple end_val138 = hv_NumClasses - 1;
                        HTuple step_val138 = 1;
                        for (hv_Index = 0; hv_Index.Continue(end_val138, step_val138); hv_Index = hv_Index.TupleAdd(step_val138))
                        {
                            //Compute the precision for every selected class.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TruePositive.Dispose();
                                HOperatorSet.GetValueMatrix(hv_ConfusionMatrix, hv_IndexClass.TupleSelect(
                                    hv_Index), hv_IndexClass.TupleSelect(hv_Index), out hv_TruePositive);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_SumPredictedClass.Dispose();
                                HOperatorSet.GetValueMatrix(hv_MatrixRowSumID, hv_IndexClass.TupleSelect(
                                    hv_Index), 0, out hv_SumPredictedClass);
                            }
                            if ((int)(new HTuple(hv_SumPredictedClass.TupleEqual(0))) != 0)
                            {
                                hv_ClassPrecision.Dispose();
                                hv_ClassPrecision = 0;
                            }
                            else
                            {
                                hv_ClassPrecision.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ClassPrecision = hv_TruePositive / hv_SumPredictedClass;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ClassPrecisions = hv_ClassPrecisions.TupleConcat(
                                        hv_ClassPrecision);
                                    hv_ClassPrecisions.Dispose();
                                    hv_ClassPrecisions = ExpTmpLocalVar_ClassPrecisions;
                                }
                            }
                        }
                        hv_Precision.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Precision = hv_ClassPrecisions.TupleMean()
                                ;
                        }
                        HOperatorSet.ClearMatrix(hv_MatrixRowSumID);
                        if ((int)(new HTuple(hv_NumClasses.TupleEqual(1))) != 0)
                        {
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "precision", hv_Precision);
                        }
                        else
                        {
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "mean_precision", hv_Precision);
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "precision_per_class", hv_ClassPrecisions);
                        }
                    }
                    //
                    //Calculate recall.
                    if ((int)(hv_CalcRecall.TupleOr(hv_CalcFScore)) != 0)
                    {
                        hv_ClassRecalls.Dispose();
                        hv_ClassRecalls = new HTuple();
                        hv_MatrixColumnSumID.Dispose();
                        HOperatorSet.SumMatrix(hv_ConfusionMatrix, "columns", out hv_MatrixColumnSumID);
                        HTuple end_val163 = hv_NumClasses - 1;
                        HTuple step_val163 = 1;
                        for (hv_Index = 0; hv_Index.Continue(end_val163, step_val163); hv_Index = hv_Index.TupleAdd(step_val163))
                        {
                            //Compute the recall for every class.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TruePositive.Dispose();
                                HOperatorSet.GetValueMatrix(hv_ConfusionMatrix, hv_IndexClass.TupleSelect(
                                    hv_Index), hv_IndexClass.TupleSelect(hv_Index), out hv_TruePositive);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_SumLabel.Dispose();
                                HOperatorSet.GetValueMatrix(hv_MatrixColumnSumID, 0, hv_IndexClass.TupleSelect(
                                    hv_Index), out hv_SumLabel);
                            }
                            hv_ClassRecall.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClassRecall = hv_TruePositive / hv_SumLabel;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ClassRecalls = hv_ClassRecalls.TupleConcat(
                                        hv_ClassRecall);
                                    hv_ClassRecalls.Dispose();
                                    hv_ClassRecalls = ExpTmpLocalVar_ClassRecalls;
                                }
                            }
                        }
                        hv_Recall.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Recall = hv_ClassRecalls.TupleMean()
                                ;
                        }
                        HOperatorSet.ClearMatrix(hv_MatrixColumnSumID);
                        if ((int)(new HTuple(hv_NumClasses.TupleEqual(1))) != 0)
                        {
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "recall", hv_Recall);
                        }
                        else
                        {
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "mean_recall", hv_Recall);
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "recall_per_class", hv_ClassRecalls);
                        }
                    }
                    //
                    //Calculate F-score.
                    if ((int)(hv_CalcFScore) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClassFScores.Dispose();
                            HOperatorSet.TupleGenConst(new HTuple(hv_ClassPrecisions.TupleLength()),
                                0.0, out hv_ClassFScores);
                        }
                        hv_SumPrecisionRecall.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_SumPrecisionRecall = hv_ClassPrecisions + hv_ClassRecalls;
                        }
                        hv_PositiveIndices.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_PositiveIndices = ((hv_SumPrecisionRecall.TupleNotEqualElem(
                                0.0))).TupleFind(1);
                        }
                        if ((int)((new HTuple(hv_PositiveIndices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_PositiveIndices.TupleNotEqual(
                            new HTuple())))) != 0)
                        {
                            if (hv_ClassFScores == null)
                                hv_ClassFScores = new HTuple();
                            hv_ClassFScores[hv_PositiveIndices] = ((2 * (hv_ClassPrecisions.TupleSelect(
                                hv_PositiveIndices))) * (hv_ClassRecalls.TupleSelect(hv_PositiveIndices))) / (hv_SumPrecisionRecall.TupleSelect(
                                hv_PositiveIndices));
                        }
                        hv_FScore.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FScore = hv_ClassFScores.TupleMean()
                                ;
                        }
                        if ((int)(new HTuple(hv_NumClasses.TupleEqual(1))) != 0)
                        {
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "f_score", hv_FScore);
                        }
                        else
                        {
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "mean_f_score", hv_FScore);
                            HOperatorSet.SetDictTuple(hv_EvalClassID, "f_score_per_class", hv_ClassFScores);
                        }
                    }
                    //
                    //Set evaluation results for current class ID.
                    hv_KeyName.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_KeyName = hv_ClassIDsToEvaluate.TupleSelect(
                            hv_EvalIndex);
                    }
                    if ((int)(new HTuple(((hv_ClassIDsToEvaluate.TupleSelect(hv_EvalIndex))).TupleNotEqual(
                        "global"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_KeyName = "class_id_" + hv_KeyName;
                                hv_KeyName.Dispose();
                                hv_KeyName = ExpTmpLocalVar_KeyName;
                            }
                        }
                    }
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, hv_KeyName, hv_EvalClassID);
                }
                //

                hv_TopKErrorKs.Dispose();
                hv_CalcPrecision.Dispose();
                hv_CalcRecall.Dispose();
                hv_CalcFScore.Dispose();
                hv_CalcAbsoluteConfusionMatrix.Dispose();
                hv_CalcRelativeConfusionMatrix.Dispose();
                hv_Measures.Dispose();
                hv_RegExpTopKError.Dispose();
                hv_M.Dispose();
                hv_ComputeTopKError.Dispose();
                hv_K.Dispose();
                hv_ClassIDs.Dispose();
                hv_KeyExists.Dispose();
                hv_ClassesToEvaluate.Dispose();
                hv_ClassIDsToEvaluate.Dispose();
                hv_ClassNames.Dispose();
                hv_Index.Dispose();
                hv_Position.Dispose();
                hv_ImageIDs.Dispose();
                hv_ImageLabelIDs.Dispose();
                hv_Predictions.Dispose();
                hv_TopKPredictions.Dispose();
                hv_EvalIndex.Dispose();
                hv_CurrentEvalClass.Dispose();
                hv_IndexClass.Dispose();
                hv_EvaluatedSamples.Dispose();
                hv_ConfusionMatrix.Dispose();
                hv_RelativeConfusionMatrix.Dispose();
                hv_EvalClassID.Dispose();
                hv_KIndex.Dispose();
                hv_Indices.Dispose();
                hv_TopKError.Dispose();
                hv_NumClasses.Dispose();
                hv_ClassPrecisions.Dispose();
                hv_MatrixRowSumID.Dispose();
                hv_TruePositive.Dispose();
                hv_SumPredictedClass.Dispose();
                hv_ClassPrecision.Dispose();
                hv_Precision.Dispose();
                hv_ClassRecalls.Dispose();
                hv_MatrixColumnSumID.Dispose();
                hv_SumLabel.Dispose();
                hv_ClassRecall.Dispose();
                hv_Recall.Dispose();
                hv_ClassFScores.Dispose();
                hv_SumPrecisionRecall.Dispose();
                hv_PositiveIndices.Dispose();
                hv_FScore.Dispose();
                hv_KeyName.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_TopKErrorKs.Dispose();
                hv_CalcPrecision.Dispose();
                hv_CalcRecall.Dispose();
                hv_CalcFScore.Dispose();
                hv_CalcAbsoluteConfusionMatrix.Dispose();
                hv_CalcRelativeConfusionMatrix.Dispose();
                hv_Measures.Dispose();
                hv_RegExpTopKError.Dispose();
                hv_M.Dispose();
                hv_ComputeTopKError.Dispose();
                hv_K.Dispose();
                hv_ClassIDs.Dispose();
                hv_KeyExists.Dispose();
                hv_ClassesToEvaluate.Dispose();
                hv_ClassIDsToEvaluate.Dispose();
                hv_ClassNames.Dispose();
                hv_Index.Dispose();
                hv_Position.Dispose();
                hv_ImageIDs.Dispose();
                hv_ImageLabelIDs.Dispose();
                hv_Predictions.Dispose();
                hv_TopKPredictions.Dispose();
                hv_EvalIndex.Dispose();
                hv_CurrentEvalClass.Dispose();
                hv_IndexClass.Dispose();
                hv_EvaluatedSamples.Dispose();
                hv_ConfusionMatrix.Dispose();
                hv_RelativeConfusionMatrix.Dispose();
                hv_EvalClassID.Dispose();
                hv_KIndex.Dispose();
                hv_Indices.Dispose();
                hv_TopKError.Dispose();
                hv_NumClasses.Dispose();
                hv_ClassPrecisions.Dispose();
                hv_MatrixRowSumID.Dispose();
                hv_TruePositive.Dispose();
                hv_SumPredictedClass.Dispose();
                hv_ClassPrecision.Dispose();
                hv_Precision.Dispose();
                hv_ClassRecalls.Dispose();
                hv_MatrixColumnSumID.Dispose();
                hv_SumLabel.Dispose();
                hv_ClassRecall.Dispose();
                hv_Recall.Dispose();
                hv_ClassFScores.Dispose();
                hv_SumPrecisionRecall.Dispose();
                hv_PositiveIndices.Dispose();
                hv_FScore.Dispose();
                hv_KeyName.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Calculate instance measures based on RunningMeasures. 
        private void calculate_instance_measures(HTuple hv_RunningMeasures, HTuple hv_EvalParams,
            out HTuple hv_EvaluationResult)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_CalcClassAP = new HTuple(), hv_CalcMeanAP = new HTuple();
            HTuple hv_CalcSoAP = new HTuple(), hv_InstanceType = new HTuple();
            HTuple hv_Measures = new HTuple(), hv_M = new HTuple();
            HTuple hv_ClassIDs = new HTuple(), hv_NumClasses = new HTuple();
            HTuple hv_MaxNumDetections = new HTuple(), hv_AreaRanges = new HTuple();
            HTuple hv_IoUThresholds = new HTuple(), hv_DetailedEvaluation = new HTuple();
            HTuple hv_InterpolatePRCurves = new HTuple(), hv_KeyExists = new HTuple();
            HTuple hv_AreaNames = new HTuple(), hv_MinAreas = new HTuple();
            HTuple hv_MaxAreas = new HTuple(), hv_RecThreshs = new HTuple();
            HTuple hv_MDIdx = new HTuple(), hv_MaxNum = new HTuple();
            HTuple hv_MaxNumStr = new HTuple(), hv_CurrentRunningMeasures = new HTuple();
            HTuple hv_PerMaxNumEvaluationResult = new HTuple(), hv_AreaIdx = new HTuple();
            HTuple hv_MinArea = new HTuple(), hv_MaxArea = new HTuple();
            HTuple hv_AreaName = new HTuple(), hv_AreaRunningMeasures = new HTuple();
            HTuple hv_PerClassNumGt = new HTuple(), hv_PerClassNumPred = new HTuple();
            HTuple hv_PerClassConfidence = new HTuple(), hv_PerClassNumGtIgnore = new HTuple();
            HTuple hv_CurrentEvaluationResult = new HTuple(), hv_ITIdx = new HTuple();
            HTuple hv_PerIoUAP = new HTuple(), hv_PerIoUSoAP = new HTuple();
            HTuple hv_PerIoUDetailedEvaluation = new HTuple(), hv_ClsIdx = new HTuple();
            HTuple hv_PerClassDetailedEvaluation = new HTuple(), hv_DetectionConfusionMatrix = new HTuple();
            HTuple hv_PerIoUMeasure = new HTuple(), hv_NumImgIDsWithFN = new HTuple();
            HTuple hv_NumImgIDsWithFP = new HTuple(), hv_ImgIDsWithFN = new HTuple();
            HTuple hv_ImgIDsWithFP = new HTuple(), hv_ClassMAPDict = new HTuple();
            HTuple hv_ClassMSoAPDict = new HTuple(), hv_ClassesWithGt = new HTuple();
            HTuple hv_PerClassMAP = new HTuple(), hv_PerIoUMAP = new HTuple();
            HTuple hv_PerClassMSoAP = new HTuple(), hv_PerIoUMSoAP = new HTuple();
            HTuple hv_PerIoUNumClassesWithTP = new HTuple(), hv_PerIoUTP = new HTuple();
            HTuple hv_PerIoUFN = new HTuple(), hv_PerIoUFP = new HTuple();
            HTuple hv_PerIoUFPClass = new HTuple(), hv_PerIoUFPBackground = new HTuple();
            HTuple hv_PerIoUFPLocalization = new HTuple(), hv_PerIoUFPDuplicate = new HTuple();
            HTuple hv_PerIoUFPMultiple = new HTuple(), hv_PerIoUSoAPClass = new HTuple();
            HTuple hv_PerIoUSoAPLocalization = new HTuple(), hv_PerIoUSoAPDuplicate = new HTuple();
            HTuple hv_PerIoUSoAPMultiple = new HTuple(), hv_PerIoUNumClassesWithFPClass = new HTuple();
            HTuple hv_PerIoUNumClassesWithFPLocalization = new HTuple();
            HTuple hv_PerIoUNumClassesWithFPDuplicate = new HTuple();
            HTuple hv_PerIoUNumClassesWithFPMultiple = new HTuple();
            HTuple hv_ClassAPPerIoU = new HTuple(), hv_ClassSoAPPerIoU = new HTuple();
            HTuple hv_NumGt = new HTuple(), hv_NumGtIgnore = new HTuple();
            HTuple hv_NumPred = new HTuple(), hv_Confidences = new HTuple();
            HTuple hv_SortIdxs = new HTuple(), hv_CurrentClassMeasures = new HTuple();
            HTuple hv_IsTP = new HTuple(), hv_Ignore = new HTuple();
            HTuple hv_NoIgnoreIdxs = new HTuple(), hv_IsFP = new HTuple();
            HTuple hv_AccumulatedIsTP = new HTuple(), hv_AccumulatedIsFP = new HTuple();
            HTuple hv_Recall = new HTuple(), hv_Precision = new HTuple();
            HTuple hv_InterpolatedPrecision = new HTuple(), hv_PIdx = new HTuple();
            HTuple hv_PrecisionAtRecThreshs = new HTuple(), hv_RTIdx = new HTuple();
            HTuple hv_RecQuantile = new HTuple(), hv_AOD = new HTuple();
            HTuple hv_IdxsTP = new HTuple(), hv_IsFPClass = new HTuple();
            HTuple hv_IsFPBackground = new HTuple(), hv_IsFPLocalization = new HTuple();
            HTuple hv_IsFPDuplicate = new HTuple(), hv_IsFPMultiple = new HTuple();
            HTuple hv_NumTP = new HTuple(), hv_NumFP = new HTuple();
            HTuple hv_NumFN = new HTuple(), hv_NumFPClass = new HTuple();
            HTuple hv_NumFPBackground = new HTuple(), hv_NumFPLocalization = new HTuple();
            HTuple hv_NumFPDuplicate = new HTuple(), hv_NumFPMultiple = new HTuple();
            HTuple hv_IndicesWithClassConfusion = new HTuple(), hv_IsFPClassIdxs = new HTuple();
            HTuple hv_ClassIdxsConfused = new HTuple(), hv_Idx = new HTuple();
            HTuple hv_NumConfusedThisIdx = new HTuple(), hv_AODClass = new HTuple();
            HTuple hv_IdxsClass = new HTuple(), hv_ResSoAPClass = new HTuple();
            HTuple hv_AODLocalization = new HTuple(), hv_IdxsLocalization = new HTuple();
            HTuple hv_ResSoAPLocalization = new HTuple(), hv_AODDuplicate = new HTuple();
            HTuple hv_IdxsDuplicate = new HTuple(), hv_ResSoAPDuplicate = new HTuple();
            HTuple hv_AODMultiple = new HTuple(), hv_IdxsMultiple = new HTuple();
            HTuple hv_ResSoAPMultiple = new HTuple(), hv_MeanClassAP = new HTuple();
            HTuple hv_MeanClassSoAP = new HTuple(), hv_MAP = new HTuple();
            HTuple hv_MSoAP = new HTuple(), hv_IoUsWithTP = new HTuple();
            HTuple hv_MSoAPAll = new HTuple(), hv_NumSoAPAll = new HTuple();
            HTuple hv_IoUsWithFPClass = new HTuple(), hv_IoUsWithFPLocalization = new HTuple();
            HTuple hv_IoUsWithFPDuplicate = new HTuple(), hv_IoUsWithFPMultiple = new HTuple();
            // Initialize local and output iconic variables 
            hv_EvaluationResult = new HTuple();
            try
            {
                //
                //This procedure calculates the final summarizing instance measures based on the running measures.
                //
                //Set default values.
                hv_CalcClassAP.Dispose();
                hv_CalcClassAP = 0;
                hv_CalcMeanAP.Dispose();
                hv_CalcMeanAP = 0;
                hv_CalcSoAP.Dispose();
                hv_CalcSoAP = 0;
                //Check which measures are to be calculated.
                hv_InstanceType.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "instance_type", out hv_InstanceType);
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                for (hv_M = 0; (int)hv_M <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_M = (int)hv_M + 1)
                {
                    if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual("mean_ap"))) != 0)
                    {
                        hv_CalcMeanAP.Dispose();
                        hv_CalcMeanAP = 1;
                        //As we need to calculate the class APs anyway, we also write them out.
                        hv_CalcClassAP.Dispose();
                        hv_CalcClassAP = 1;
                    }
                    else if ((int)((new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "soap"))).TupleAnd(new HTuple(hv_InstanceType.TupleEqual("rectangle2")))) != 0)
                    {
                        hv_CalcSoAP.Dispose();
                        hv_CalcSoAP = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "all"))) != 0)
                    {
                        hv_CalcClassAP.Dispose();
                        hv_CalcClassAP = 1;
                        hv_CalcMeanAP.Dispose();
                        hv_CalcMeanAP = 1;
                        if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
                        {
                            hv_CalcSoAP.Dispose();
                            hv_CalcSoAP = 1;
                        }
                    }
                    else
                    {
                        throw new HalconException("Unknown Instance Measure: " + (hv_Measures.TupleSelect(
                            hv_M)));
                    }
                }
                //*
                //Dependencies of measures:
                //
                //Recall (per-class)       *                   --> AP per class --> mAP
                //Precision (per-class)  /
                //
                //*
                //Initialize output dictionary and get necessary evaluation parameters.
                hv_EvaluationResult.Dispose();
                HOperatorSet.CreateDict(out hv_EvaluationResult);
                hv_ClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                hv_NumClasses.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
                hv_MaxNumDetections.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "max_num_detections", out hv_MaxNumDetections);
                hv_AreaRanges.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "area_ranges", out hv_AreaRanges);
                hv_IoUThresholds.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "iou_threshold", out hv_IoUThresholds);
                //Check if a detailed evaluation should be done and if PR-curves should be interpolated.
                hv_DetailedEvaluation.Dispose();
                hv_DetailedEvaluation = 0;
                hv_InterpolatePRCurves.Dispose();
                hv_InterpolatePRCurves = 0;
                hv_KeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", (new HTuple("detailed_evaluation")).TupleConcat(
                    "interpolate_pr_curves"), out hv_KeyExists);
                if ((int)(hv_KeyExists.TupleSelect(0)) != 0)
                {
                    hv_DetailedEvaluation.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "detailed_evaluation", out hv_DetailedEvaluation);
                }
                if ((int)(hv_KeyExists.TupleSelect(1)) != 0)
                {
                    hv_InterpolatePRCurves.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "interpolate_pr_curves", out hv_InterpolatePRCurves);
                }
                //
                //Get information about area ranges.
                hv_AreaNames.Dispose();
                HOperatorSet.GetDictTuple(hv_AreaRanges, "name", out hv_AreaNames);
                hv_MinAreas.Dispose();
                HOperatorSet.GetDictTuple(hv_AreaRanges, "min", out hv_MinAreas);
                hv_MaxAreas.Dispose();
                HOperatorSet.GetDictTuple(hv_AreaRanges, "max", out hv_MaxAreas);
                //
                //Equidistant thresholds used to approximate the area under the Precision-Recall curve.
                hv_RecThreshs.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RecThreshs = HTuple.TupleGenSequence(
                        0.0, 1.0, 0.01);
                }
                //Start with calculation.
                if ((int)((new HTuple(hv_CalcClassAP.TupleOr(hv_CalcMeanAP))).TupleOr(hv_CalcSoAP)) != 0)
                {
                    //Loop over maximal number of detections.
                    for (hv_MDIdx = 0; (int)hv_MDIdx <= (int)((new HTuple(hv_MaxNumDetections.TupleLength()
                        )) - 1); hv_MDIdx = (int)hv_MDIdx + 1)
                    {
                        //
                        //Get corresponding running measures.
                        hv_MaxNum.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MaxNum = hv_MaxNumDetections.TupleSelect(
                                hv_MDIdx);
                        }
                        hv_MaxNumStr.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MaxNumStr = "" + hv_MaxNum;
                        }
                        if ((int)(new HTuple(hv_MaxNum.TupleEqual(-1))) != 0)
                        {
                            hv_MaxNumStr.Dispose();
                            hv_MaxNumStr = "all";
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentRunningMeasures.Dispose();
                            HOperatorSet.GetDictTuple(hv_RunningMeasures, "max_num_detections_" + hv_MaxNumStr,
                                out hv_CurrentRunningMeasures);
                        }
                        //
                        //Initialize output dictionary.
                        hv_PerMaxNumEvaluationResult.Dispose();
                        HOperatorSet.CreateDict(out hv_PerMaxNumEvaluationResult);
                        //
                        //Loop over area ranges.
                        for (hv_AreaIdx = 0; (int)hv_AreaIdx <= (int)((new HTuple(hv_AreaNames.TupleLength()
                            )) - 1); hv_AreaIdx = (int)hv_AreaIdx + 1)
                        {
                            //Get area thresholds.
                            hv_MinArea.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_MinArea = hv_MinAreas.TupleSelect(
                                    hv_AreaIdx);
                            }
                            hv_MaxArea.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_MaxArea = hv_MaxAreas.TupleSelect(
                                    hv_AreaIdx);
                            }
                            hv_AreaName.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_AreaName = hv_AreaNames.TupleSelect(
                                    hv_AreaIdx);
                            }
                            //
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_AreaRunningMeasures.Dispose();
                                HOperatorSet.GetDictTuple(hv_CurrentRunningMeasures, "area_" + hv_AreaName,
                                    out hv_AreaRunningMeasures);
                            }
                            //
                            hv_PerClassNumGt.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_gt", out hv_PerClassNumGt);
                            hv_PerClassNumPred.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_pred", out hv_PerClassNumPred);
                            hv_PerClassConfidence.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "confidence", out hv_PerClassConfidence);
                            hv_PerClassNumGtIgnore.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_gt_ignore", out hv_PerClassNumGtIgnore);
                            //
                            //Initialize output dictionary.
                            hv_CurrentEvaluationResult.Dispose();
                            HOperatorSet.CreateDict(out hv_CurrentEvaluationResult);
                            for (hv_ITIdx = 0; (int)hv_ITIdx <= (int)((new HTuple(hv_IoUThresholds.TupleLength()
                                )) - 1); hv_ITIdx = (int)hv_ITIdx + 1)
                            {
                                hv_PerIoUAP.Dispose();
                                HOperatorSet.CreateDict(out hv_PerIoUAP);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "ap_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                        hv_ITIdx)))).TupleRegexpReplace("\\.", "")), hv_PerIoUAP);
                                }
                                if ((int)(hv_CalcSoAP) != 0)
                                {
                                    hv_PerIoUSoAP.Dispose();
                                    HOperatorSet.CreateDict(out hv_PerIoUSoAP);
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "soap_tp_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                            hv_ITIdx)))).TupleRegexpReplace("\\.", "")), hv_PerIoUSoAP);
                                    }
                                }
                                if ((int)(hv_DetailedEvaluation) != 0)
                                {
                                    //Initialize detailed measures.
                                    hv_PerIoUDetailedEvaluation.Dispose();
                                    HOperatorSet.CreateDict(out hv_PerIoUDetailedEvaluation);
                                    HTuple end_val101 = hv_NumClasses - 1;
                                    HTuple step_val101 = 1;
                                    for (hv_ClsIdx = 0; hv_ClsIdx.Continue(end_val101, step_val101); hv_ClsIdx = hv_ClsIdx.TupleAdd(step_val101))
                                    {
                                        hv_PerClassDetailedEvaluation.Dispose();
                                        HOperatorSet.CreateDict(out hv_PerClassDetailedEvaluation);
                                        //Initialize with zeros in case there is no ground truth for this class.
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_tp",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fn",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_class",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_background",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_duplicate",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_localization",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_multiple",
                                            0);
                                        if ((int)(hv_CalcSoAP) != 0)
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "soap_fp_class",
                                                -1);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "soap_fp_duplicate",
                                                -1);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "soap_fp_localization",
                                                -1);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "soap_fp_multiple",
                                                -1);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "class_" + (hv_ClassIDs.TupleSelect(
                                                hv_ClsIdx)), hv_PerClassDetailedEvaluation);
                                        }
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_DetectionConfusionMatrix.Dispose();
                                        HOperatorSet.CreateMatrix(hv_NumClasses + 1, hv_NumClasses + 4, 0, out hv_DetectionConfusionMatrix);
                                    }
                                    HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "detection_confusion_matrix",
                                        hv_DetectionConfusionMatrix);
                                    //
                                    //Get and set image IDs with false negatives and false positives.
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUMeasure.Dispose();
                                        HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                            hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUMeasure);
                                    }
                                    //Get image IDs with false negatives and false positives, respectively.
                                    hv_NumImgIDsWithFN.Dispose();
                                    HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_negatives",
                                        out hv_NumImgIDsWithFN);
                                    hv_NumImgIDsWithFP.Dispose();
                                    HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_positives",
                                        out hv_NumImgIDsWithFP);
                                    hv_ImgIDsWithFN.Dispose();
                                    HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_negatives",
                                        out hv_ImgIDsWithFN);
                                    hv_ImgIDsWithFP.Dispose();
                                    HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_positives",
                                        out hv_ImgIDsWithFP);
                                    //Set in current output.
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "image_ids_with_false_negatives",
                                            hv_ImgIDsWithFN.TupleSelectRange(0, hv_NumImgIDsWithFN - 1));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "image_ids_with_false_positives",
                                            hv_ImgIDsWithFP.TupleSelectRange(0, hv_NumImgIDsWithFP - 1));
                                    }
                                    //
                                    //Set output for this IoU.
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "detailed_evaluation_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                            hv_ITIdx)))).TupleRegexpReplace("\\.", "")), hv_PerIoUDetailedEvaluation);
                                    }
                                }
                            }
                            hv_ClassMAPDict.Dispose();
                            HOperatorSet.CreateDict(out hv_ClassMAPDict);
                            HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_iou_ap",
                                hv_ClassMAPDict);
                            if ((int)(hv_CalcSoAP) != 0)
                            {
                                hv_ClassMSoAPDict.Dispose();
                                HOperatorSet.CreateDict(out hv_ClassMSoAPDict);
                                HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_iou_soap_tp",
                                    hv_ClassMSoAPDict);
                            }
                            //
                            //Check which classes have ground truth annotations.
                            hv_ClassesWithGt.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClassesWithGt = ((((hv_PerClassNumGt - hv_PerClassNumGtIgnore)).TupleGreaterElem(
                                    0))).TupleFind(1);
                            }
                            if ((int)(new HTuple(hv_ClassesWithGt.TupleEqual(-1))) != 0)
                            {
                                hv_ClassesWithGt.Dispose();
                                hv_ClassesWithGt = new HTuple();
                            }
                            //
                            //Initialize PerClassMAP, i.e. mean average precision over IoU-thresholds per class.
                            hv_PerClassMAP.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_PerClassMAP = HTuple.TupleGenConst(
                                    hv_NumClasses, -1.0);
                            }
                            //
                            //Initialize PerIoUMAP, i.e. mean average precision over classes per IoU-threshold.
                            hv_PerIoUMAP.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_PerIoUMAP = HTuple.TupleGenConst(
                                    new HTuple(hv_IoUThresholds.TupleLength()), 0.0);
                            }
                            //
                            if ((int)(hv_CalcSoAP) != 0)
                            {
                                //Initialize PerClassMSoAP, i.e. mean SoAP over IoU-thresholds per class.
                                hv_PerClassMSoAP.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerClassMSoAP = HTuple.TupleGenConst(
                                        hv_NumClasses, -1.0);
                                }
                                //Initialize PerIoUMSoAP, i.e. mean SoAP over classes per IoU-threshold.
                                hv_PerIoUMSoAP.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUMSoAP = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0.0);
                                }
                                //Initialize PerIoUNumClassesWithTP to store the class-indices where true positives occured.
                                hv_PerIoUNumClassesWithTP.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUNumClassesWithTP = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                            }
                            //
                            if ((int)(hv_DetailedEvaluation) != 0)
                            {
                                //Initialize overall num_fn, num_tp, ...
                                hv_PerIoUTP.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUTP = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_PerIoUFN.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUFN = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_PerIoUFP.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUFP = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_PerIoUFPClass.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUFPClass = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_PerIoUFPBackground.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUFPBackground = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_PerIoUFPLocalization.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUFPLocalization = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_PerIoUFPDuplicate.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUFPDuplicate = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_PerIoUFPMultiple.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUFPMultiple = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                if ((int)(hv_CalcSoAP) != 0)
                                {
                                    hv_PerIoUSoAPClass.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUSoAPClass = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), -1);
                                    }
                                    hv_PerIoUSoAPLocalization.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUSoAPLocalization = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), -1);
                                    }
                                    hv_PerIoUSoAPDuplicate.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUSoAPDuplicate = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), -1);
                                    }
                                    hv_PerIoUSoAPMultiple.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUSoAPMultiple = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), -1);
                                    }
                                    hv_PerIoUNumClassesWithFPClass.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUNumClassesWithFPClass = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                    }
                                    hv_PerIoUNumClassesWithFPLocalization.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUNumClassesWithFPLocalization = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                    }
                                    hv_PerIoUNumClassesWithFPDuplicate.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUNumClassesWithFPDuplicate = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                    }
                                    hv_PerIoUNumClassesWithFPMultiple.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUNumClassesWithFPMultiple = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                    }
                                }
                            }
                            //Loop over all classes.
                            HTuple end_val188 = hv_NumClasses - 1;
                            HTuple step_val188 = 1;
                            for (hv_ClsIdx = 0; hv_ClsIdx.Continue(end_val188, step_val188); hv_ClsIdx = hv_ClsIdx.TupleAdd(step_val188))
                            {
                                //
                                //Initialize per-class AP per IoU-threshold (only for one class).
                                hv_ClassAPPerIoU.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_ClassAPPerIoU = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), -1.0);
                                }
                                //
                                if ((int)(hv_CalcSoAP) != 0)
                                {
                                    hv_ClassSoAPPerIoU.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_ClassSoAPPerIoU = HTuple.TupleGenConst(
                                            new HTuple(hv_IoUThresholds.TupleLength()), -1.0);
                                    }
                                }
                                //Get results for this class.
                                hv_NumGt.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_NumGt = hv_PerClassNumGt.TupleSelect(
                                        hv_ClsIdx);
                                }
                                hv_NumGtIgnore.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_NumGtIgnore = hv_PerClassNumGtIgnore.TupleSelect(
                                        hv_ClsIdx);
                                }
                                if ((int)(new HTuple(((hv_NumGt - hv_NumGtIgnore)).TupleGreater(0))) != 0)
                                {
                                    hv_NumPred.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_NumPred = hv_PerClassNumPred.TupleSelect(
                                            hv_ClsIdx);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Confidences.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerClassConfidence, "class_" + (hv_ClassIDs.TupleSelect(
                                            hv_ClsIdx)), out hv_Confidences);
                                    }
                                    //
                                    //Sort the confidences in descending order and
                                    //only take the first NumPred ones due to block allocation.
                                    hv_SortIdxs.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_SortIdxs = ((-(hv_Confidences.TupleSelectRange(
                                            0, hv_NumPred - 1)))).TupleSortIndex();
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_Confidences = hv_Confidences.TupleSelect(
                                                hv_SortIdxs);
                                            hv_Confidences.Dispose();
                                            hv_Confidences = ExpTmpLocalVar_Confidences;
                                        }
                                    }
                                }
                                //
                                //Loop over IoU thresholds.
                                for (hv_ITIdx = 0; (int)hv_ITIdx <= (int)((new HTuple(hv_IoUThresholds.TupleLength()
                                    )) - 1); hv_ITIdx = (int)hv_ITIdx + 1)
                                {
                                    //
                                    //Check if there are ground truth labels for this class.
                                    if ((int)(new HTuple(((hv_NumGt - hv_NumGtIgnore)).TupleGreater(0))) != 0)
                                    {
                                        //
                                        //Get results for this class and IoU-threshold.
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_PerIoUMeasure.Dispose();
                                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                                hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUMeasure);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_CurrentClassMeasures.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "class_" + (hv_ClassIDs.TupleSelect(
                                                hv_ClsIdx)), out hv_CurrentClassMeasures);
                                        }
                                        hv_IsTP.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_tp", out hv_IsTP);
                                        hv_Ignore.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "ignore", out hv_Ignore);
                                        //
                                        //Sort the arrays IsTP and Ignore according to the confidence values.
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_IsTP = hv_IsTP.TupleSelect(
                                                    hv_SortIdxs);
                                                hv_IsTP.Dispose();
                                                hv_IsTP = ExpTmpLocalVar_IsTP;
                                            }
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_Ignore = hv_Ignore.TupleSelect(
                                                    hv_SortIdxs);
                                                hv_Ignore.Dispose();
                                                hv_Ignore = ExpTmpLocalVar_Ignore;
                                            }
                                        }
                                        //
                                        //Sort out the ignored results.
                                        if ((int)(new HTuple((new HTuple(hv_IsTP.TupleLength())).TupleGreater(
                                            0))) != 0)
                                        {
                                            hv_NoIgnoreIdxs.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_NoIgnoreIdxs = hv_Ignore.TupleFind(
                                                    0);
                                            }
                                            if ((int)(new HTuple(hv_NoIgnoreIdxs.TupleNotEqual(-1))) != 0)
                                            {
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_IsTP = hv_IsTP.TupleSelect(
                                                            hv_NoIgnoreIdxs);
                                                        hv_IsTP.Dispose();
                                                        hv_IsTP = ExpTmpLocalVar_IsTP;
                                                    }
                                                }
                                                hv_IsFP.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_IsFP = hv_IsTP.TupleNot()
                                                        ;
                                                }
                                            }
                                            else
                                            {
                                                hv_IsTP.Dispose();
                                                hv_IsTP = new HTuple();
                                                hv_IsFP.Dispose();
                                                hv_IsFP = new HTuple();
                                            }
                                        }
                                        else
                                        {
                                            hv_IsFP.Dispose();
                                            hv_IsFP = new HTuple();
                                        }
                                        //
                                        //Accumulate IsTP and IsFP.
                                        hv_AccumulatedIsTP.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_AccumulatedIsTP = hv_IsTP.TupleCumul()
                                                ;
                                        }
                                        hv_AccumulatedIsFP.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_AccumulatedIsFP = hv_IsFP.TupleCumul()
                                                ;
                                        }
                                        //
                                        //Compute recall.
                                        //The recall is computed with respect to all ground truth instances,
                                        //independent of MaxNum.
                                        hv_Recall.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_Recall = (hv_AccumulatedIsTP.TupleReal()
                                                ) / (hv_NumGt - hv_NumGtIgnore);
                                        }
                                        //
                                        //Compute precision.
                                        hv_Precision.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_Precision = (hv_AccumulatedIsTP.TupleReal()
                                                ) / (hv_AccumulatedIsTP + hv_AccumulatedIsFP);
                                        }
                                        //
                                        //(Optionally) smooth precision-recall curve.
                                        hv_InterpolatedPrecision.Dispose();
                                        hv_InterpolatedPrecision = new HTuple(hv_Precision);
                                        if ((int)(hv_InterpolatePRCurves) != 0)
                                        {
                                            HTuple end_val254 = 0;
                                            HTuple step_val254 = -1;
                                            for (hv_PIdx = hv_NumPred - 2; hv_PIdx.Continue(end_val254, step_val254); hv_PIdx = hv_PIdx.TupleAdd(step_val254))
                                            {
                                                if (hv_InterpolatedPrecision == null)
                                                    hv_InterpolatedPrecision = new HTuple();
                                                hv_InterpolatedPrecision[hv_PIdx] = ((hv_InterpolatedPrecision.TupleSelect(
                                                    hv_PIdx))).TupleMax2(hv_InterpolatedPrecision.TupleSelect(
                                                    hv_PIdx + 1));
                                            }
                                        }
                                        //Compute approximated area under the Precision-Recall curve using Recall-Thresholds.
                                        hv_PrecisionAtRecThreshs.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_PrecisionAtRecThreshs = HTuple.TupleGenConst(
                                                new HTuple(hv_RecThreshs.TupleLength()), 0.0);
                                        }
                                        for (hv_RTIdx = 0; (int)hv_RTIdx <= (int)((new HTuple(hv_RecThreshs.TupleLength()
                                            )) - 1); hv_RTIdx = (int)hv_RTIdx + 1)
                                        {
                                            hv_RecQuantile.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_RecQuantile = ((hv_Recall.TupleGreaterEqualElem(
                                                    hv_RecThreshs.TupleSelect(hv_RTIdx)))).TupleFindFirst(1);
                                            }
                                            if ((int)(new HTuple(hv_RecQuantile.TupleGreater(-1))) != 0)
                                            {
                                                if (hv_PrecisionAtRecThreshs == null)
                                                    hv_PrecisionAtRecThreshs = new HTuple();
                                                hv_PrecisionAtRecThreshs[hv_RTIdx] = hv_InterpolatedPrecision.TupleSelect(
                                                    hv_RecQuantile);
                                            }
                                        }
                                        //
                                        //Calculate AP as mean of precision at equidistant recall values.
                                        if (hv_ClassAPPerIoU == null)
                                            hv_ClassAPPerIoU = new HTuple();
                                        hv_ClassAPPerIoU[hv_ITIdx] = hv_PrecisionAtRecThreshs.TupleMean()
                                            ;
                                        //
                                        //Accumulate AP over classes.
                                        if (hv_PerIoUMAP == null)
                                            hv_PerIoUMAP = new HTuple();
                                        hv_PerIoUMAP[hv_ITIdx] = (hv_PerIoUMAP.TupleSelect(hv_ITIdx)) + (hv_ClassAPPerIoU.TupleSelect(
                                            hv_ITIdx));
                                        //
                                        if ((int)(hv_CalcSoAP) != 0)
                                        {
                                            //Calculate SoAP out of the mean over absolute orientation differences.
                                            hv_AOD.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "abs_orientation_diff",
                                                out hv_AOD);
                                            hv_IdxsTP.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_IdxsTP = hv_IsTP.TupleFind(
                                                    1);
                                            }
                                            if ((int)((new HTuple((new HTuple(hv_IdxsTP.TupleLength())).TupleGreater(
                                                0))).TupleAnd(new HTuple(hv_IdxsTP.TupleNotEqual(-1)))) != 0)
                                            {
                                                if (hv_ClassSoAPPerIoU == null)
                                                    hv_ClassSoAPPerIoU = new HTuple();
                                                hv_ClassSoAPPerIoU[hv_ITIdx] = 1.0 - ((((hv_AOD.TupleSelect(hv_SortIdxs.TupleSelect(
                                                    hv_NoIgnoreIdxs.TupleSelect(hv_IdxsTP))))).TupleMean()) / ((new HTuple(180)).TupleRad()
                                                    ));
                                                //Accumulate SoAP over classes.
                                                if (hv_PerIoUMSoAP == null)
                                                    hv_PerIoUMSoAP = new HTuple();
                                                hv_PerIoUMSoAP[hv_ITIdx] = (hv_PerIoUMSoAP.TupleSelect(hv_ITIdx)) + (hv_ClassSoAPPerIoU.TupleSelect(
                                                    hv_ITIdx));
                                            }
                                            //Update PerIoUNumClassesWithTP.
                                            if ((int)(new HTuple((new HTuple(hv_AccumulatedIsTP.TupleLength()
                                                )).TupleGreater(0))) != 0)
                                            {
                                                if (hv_PerIoUNumClassesWithTP == null)
                                                    hv_PerIoUNumClassesWithTP = new HTuple();
                                                hv_PerIoUNumClassesWithTP[hv_ITIdx] = (hv_PerIoUNumClassesWithTP.TupleSelect(
                                                    hv_ITIdx)) + (((hv_AccumulatedIsTP.TupleSelect((new HTuple(hv_AccumulatedIsTP.TupleLength()
                                                    )) - 1))).TupleGreaterElem(0));
                                            }
                                        }
                                        //
                                        if ((int)(hv_DetailedEvaluation) != 0)
                                        {
                                            //Summarize detailed evaluation running measures, set matrix-values and update overall detailed measures.
                                            //
                                            //Get the necessary running measures.
                                            hv_IsFPClass.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_fp_class",
                                                out hv_IsFPClass);
                                            hv_IsFPBackground.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_fp_background",
                                                out hv_IsFPBackground);
                                            hv_IsFPLocalization.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_fp_localization",
                                                out hv_IsFPLocalization);
                                            hv_IsFPDuplicate.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_fp_duplicate",
                                                out hv_IsFPDuplicate);
                                            hv_IsFPMultiple.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "is_fp_multiple",
                                                out hv_IsFPMultiple);
                                            //
                                            //We use the values with maximal recall,
                                            //in case a higher precision is desired, increase 'min_confidence'.
                                            if ((int)(new HTuple((new HTuple(hv_AccumulatedIsTP.TupleLength()
                                                )).TupleGreater(0))) != 0)
                                            {
                                                hv_NumTP.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_NumTP = hv_AccumulatedIsTP.TupleSelect(
                                                        (new HTuple(hv_AccumulatedIsTP.TupleLength())) - 1);
                                                }
                                            }
                                            else
                                            {
                                                hv_NumTP.Dispose();
                                                hv_NumTP = 0;
                                            }
                                            if ((int)(new HTuple((new HTuple(hv_AccumulatedIsFP.TupleLength()
                                                )).TupleGreater(0))) != 0)
                                            {
                                                hv_NumFP.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_NumFP = hv_AccumulatedIsFP.TupleSelect(
                                                        (new HTuple(hv_AccumulatedIsFP.TupleLength())) - 1);
                                                }
                                            }
                                            else
                                            {
                                                hv_NumFP.Dispose();
                                                hv_NumFP = 0;
                                            }
                                            hv_NumFN.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_NumFN = (hv_NumGt - hv_NumGtIgnore) - hv_NumTP;
                                            }
                                            hv_NumFPClass.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_NumFPClass = ((((hv_IsFPClass.TupleSelect(
                                                    hv_SortIdxs))).TupleGreaterElem(-1))).TupleSum();
                                            }
                                            hv_NumFPBackground.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_NumFPBackground = ((((hv_IsFPBackground.TupleSelect(
                                                    hv_SortIdxs))).TupleGreaterElem(0))).TupleSum();
                                            }
                                            hv_NumFPLocalization.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_NumFPLocalization = ((((hv_IsFPLocalization.TupleSelect(
                                                    hv_SortIdxs))).TupleGreaterElem(0))).TupleSum();
                                            }
                                            hv_NumFPDuplicate.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_NumFPDuplicate = ((((hv_IsFPDuplicate.TupleSelect(
                                                    hv_SortIdxs))).TupleGreaterElem(0))).TupleSum();
                                            }
                                            hv_NumFPMultiple.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_NumFPMultiple = ((((hv_IsFPMultiple.TupleSelect(
                                                    hv_SortIdxs))).TupleGreaterElem(0))).TupleSum();
                                            }
                                            if ((int)(new HTuple((new HTuple(hv_SortIdxs.TupleLength())).TupleEqual(
                                                0))) != 0)
                                            {
                                                hv_NumFPClass.Dispose();
                                                hv_NumFPClass = 0;
                                                hv_NumFPBackground.Dispose();
                                                hv_NumFPBackground = 0;
                                                hv_NumFPLocalization.Dispose();
                                                hv_NumFPLocalization = 0;
                                                hv_NumFPDuplicate.Dispose();
                                                hv_NumFPDuplicate = 0;
                                                hv_NumFPMultiple.Dispose();
                                                hv_NumFPMultiple = 0;
                                            }
                                            //Consistency checks.
                                            if ((int)(new HTuple(((((((((((((((((hv_NumTP.TupleConcat(hv_NumFN))).TupleConcat(
                                                hv_NumFP))).TupleConcat(hv_NumFPClass))).TupleConcat(hv_NumFPBackground))).TupleConcat(
                                                hv_NumFPLocalization))).TupleConcat(hv_NumFPDuplicate))).TupleConcat(
                                                hv_NumFPMultiple))).TupleMin())).TupleLess(0))) != 0)
                                            {
                                                throw new HalconException("Fatal error while calculating instance measures.");
                                            }
                                            if ((int)(new HTuple(hv_NumFP.TupleNotEqual((((hv_NumFPClass + hv_NumFPBackground) + hv_NumFPLocalization) + hv_NumFPDuplicate) + hv_NumFPMultiple))) != 0)
                                            {
                                                throw new HalconException("Fatal error while calculating instance measures.");
                                            }
                                            //
                                            //Set per-class measures.
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_PerIoUDetailedEvaluation.Dispose();
                                                HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "detailed_evaluation_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                                    hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUDetailedEvaluation);
                                            }
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_PerClassDetailedEvaluation.Dispose();
                                                HOperatorSet.GetDictTuple(hv_PerIoUDetailedEvaluation, "class_" + (hv_ClassIDs.TupleSelect(
                                                    hv_ClsIdx)), out hv_PerClassDetailedEvaluation);
                                            }
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_tp",
                                                hv_NumTP);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fn",
                                                hv_NumFN);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp",
                                                hv_NumFP);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_class",
                                                hv_NumFPClass);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_background",
                                                hv_NumFPBackground);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_duplicate",
                                                hv_NumFPDuplicate);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_localization",
                                                hv_NumFPLocalization);
                                            HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation, "num_fp_multiple",
                                                hv_NumFPMultiple);
                                            //
                                            //Set detection confusion matrix values.
                                            hv_DetectionConfusionMatrix.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerIoUDetailedEvaluation, "detection_confusion_matrix",
                                                out hv_DetectionConfusionMatrix);
                                            HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx,
                                                hv_ClsIdx, hv_NumTP);
                                            HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_NumClasses,
                                                hv_ClsIdx, hv_NumFN);
                                            HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx,
                                                hv_NumClasses, hv_NumFPBackground);
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx,
                                                    hv_NumClasses + 1, hv_NumFPLocalization);
                                            }
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx,
                                                    hv_NumClasses + 2, hv_NumFPDuplicate);
                                            }
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx,
                                                    hv_NumClasses + 3, hv_NumFPMultiple);
                                            }
                                            //
                                            //Go over IsFPClass and set confusions in matrix.
                                            hv_IndicesWithClassConfusion.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_IndicesWithClassConfusion = ((((hv_IsFPClass.TupleSelect(
                                                    hv_SortIdxs))).TupleGreaterElem(-1))).TupleFind(1);
                                            }
                                            hv_IsFPClassIdxs.Dispose();
                                            hv_IsFPClassIdxs = new HTuple();
                                            if ((int)(new HTuple(hv_IndicesWithClassConfusion.TupleGreater(
                                                -1))) != 0)
                                            {
                                                hv_IsFPClassIdxs.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_IsFPClassIdxs = hv_IsFPClass.TupleSelect(
                                                        hv_SortIdxs.TupleSelect(hv_IndicesWithClassConfusion));
                                                }
                                            }
                                            hv_ClassIdxsConfused.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ClassIdxsConfused = ((hv_IsFPClassIdxs.TupleSort()
                                                    )).TupleUniq();
                                            }
                                            for (hv_Idx = 0; (int)hv_Idx <= (int)((new HTuple(hv_ClassIdxsConfused.TupleLength()
                                                )) - 1); hv_Idx = (int)hv_Idx + 1)
                                            {
                                                hv_NumConfusedThisIdx.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_NumConfusedThisIdx = ((((hv_IsFPClassIdxs.TupleFind(
                                                        hv_ClassIdxsConfused.TupleSelect(hv_Idx)))).TupleGreaterElem(
                                                        -1))).TupleSum();
                                                }
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    HOperatorSet.SetValueMatrix(hv_DetectionConfusionMatrix, hv_ClsIdx,
                                                        hv_ClassIdxsConfused.TupleSelect(hv_Idx), hv_NumConfusedThisIdx);
                                                }
                                            }
                                            //
                                            //Update overall measures.
                                            if (hv_PerIoUFN == null)
                                                hv_PerIoUFN = new HTuple();
                                            hv_PerIoUFN[hv_ITIdx] = (hv_PerIoUFN.TupleSelect(hv_ITIdx)) + hv_NumFN;
                                            if (hv_PerIoUTP == null)
                                                hv_PerIoUTP = new HTuple();
                                            hv_PerIoUTP[hv_ITIdx] = (hv_PerIoUTP.TupleSelect(hv_ITIdx)) + hv_NumTP;
                                            if (hv_PerIoUFP == null)
                                                hv_PerIoUFP = new HTuple();
                                            hv_PerIoUFP[hv_ITIdx] = (hv_PerIoUFP.TupleSelect(hv_ITIdx)) + hv_NumFP;
                                            if (hv_PerIoUFPClass == null)
                                                hv_PerIoUFPClass = new HTuple();
                                            hv_PerIoUFPClass[hv_ITIdx] = (hv_PerIoUFPClass.TupleSelect(hv_ITIdx)) + hv_NumFPClass;
                                            if (hv_PerIoUFPBackground == null)
                                                hv_PerIoUFPBackground = new HTuple();
                                            hv_PerIoUFPBackground[hv_ITIdx] = (hv_PerIoUFPBackground.TupleSelect(
                                                hv_ITIdx)) + hv_NumFPBackground;
                                            if (hv_PerIoUFPLocalization == null)
                                                hv_PerIoUFPLocalization = new HTuple();
                                            hv_PerIoUFPLocalization[hv_ITIdx] = (hv_PerIoUFPLocalization.TupleSelect(
                                                hv_ITIdx)) + hv_NumFPLocalization;
                                            if (hv_PerIoUFPDuplicate == null)
                                                hv_PerIoUFPDuplicate = new HTuple();
                                            hv_PerIoUFPDuplicate[hv_ITIdx] = (hv_PerIoUFPDuplicate.TupleSelect(
                                                hv_ITIdx)) + hv_NumFPDuplicate;
                                            if (hv_PerIoUFPMultiple == null)
                                                hv_PerIoUFPMultiple = new HTuple();
                                            hv_PerIoUFPMultiple[hv_ITIdx] = (hv_PerIoUFPMultiple.TupleSelect(
                                                hv_ITIdx)) + hv_NumFPMultiple;
                                            if ((int)(hv_CalcSoAP) != 0)
                                            {
                                                //Calculate and update absolute difference of orientation for class false positives.
                                                hv_AODClass.Dispose();
                                                HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "abs_orientation_diff_class",
                                                    out hv_AODClass);
                                                hv_IdxsClass.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_IdxsClass = ((hv_AODClass.TupleGreaterElem(
                                                        -1))).TupleFind(1);
                                                }
                                                if ((int)(new HTuple(hv_IdxsClass.TupleNotEqual(-1))) != 0)
                                                {
                                                    hv_ResSoAPClass.Dispose();
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        hv_ResSoAPClass = 1.0 - ((((hv_AODClass.TupleSelect(
                                                            hv_IdxsClass))).TupleMean()) / ((new HTuple(180)).TupleRad()
                                                            ));
                                                    }
                                                    HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation,
                                                        "soap_fp_class", hv_ResSoAPClass);
                                                    //Update mean over classes.
                                                    if (hv_PerIoUNumClassesWithFPClass == null)
                                                        hv_PerIoUNumClassesWithFPClass = new HTuple();
                                                    hv_PerIoUNumClassesWithFPClass[hv_ITIdx] = (hv_PerIoUNumClassesWithFPClass.TupleSelect(
                                                        hv_ITIdx)) + 1;
                                                    if ((int)(new HTuple(((hv_PerIoUSoAPClass.TupleSelect(hv_ITIdx))).TupleEqual(
                                                        -1))) != 0)
                                                    {
                                                        if (hv_PerIoUSoAPClass == null)
                                                            hv_PerIoUSoAPClass = new HTuple();
                                                        hv_PerIoUSoAPClass[hv_ITIdx] = hv_ResSoAPClass;
                                                    }
                                                    else
                                                    {
                                                        if (hv_PerIoUSoAPClass == null)
                                                            hv_PerIoUSoAPClass = new HTuple();
                                                        hv_PerIoUSoAPClass[hv_ITIdx] = (hv_PerIoUSoAPClass.TupleSelect(
                                                            hv_ITIdx)) + hv_ResSoAPClass;
                                                    }
                                                }
                                                //Calculate and update absolute difference of orientation for localization false positives.
                                                hv_AODLocalization.Dispose();
                                                HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "abs_orientation_diff_localization",
                                                    out hv_AODLocalization);
                                                hv_IdxsLocalization.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_IdxsLocalization = ((hv_AODLocalization.TupleGreaterElem(
                                                        -1))).TupleFind(1);
                                                }
                                                if ((int)(new HTuple(hv_IdxsLocalization.TupleNotEqual(-1))) != 0)
                                                {
                                                    hv_ResSoAPLocalization.Dispose();
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        hv_ResSoAPLocalization = 1.0 - ((((hv_AODLocalization.TupleSelect(
                                                            hv_IdxsLocalization))).TupleMean()) / ((new HTuple(180)).TupleRad()
                                                            ));
                                                    }
                                                    HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation,
                                                        "soap_fp_localization", hv_ResSoAPLocalization);
                                                    //Update mean over classes.
                                                    if (hv_PerIoUNumClassesWithFPLocalization == null)
                                                        hv_PerIoUNumClassesWithFPLocalization = new HTuple();
                                                    hv_PerIoUNumClassesWithFPLocalization[hv_ITIdx] = (hv_PerIoUNumClassesWithFPLocalization.TupleSelect(
                                                        hv_ITIdx)) + 1;
                                                    if ((int)(new HTuple(((hv_PerIoUSoAPLocalization.TupleSelect(
                                                        hv_ITIdx))).TupleEqual(-1))) != 0)
                                                    {
                                                        if (hv_PerIoUSoAPLocalization == null)
                                                            hv_PerIoUSoAPLocalization = new HTuple();
                                                        hv_PerIoUSoAPLocalization[hv_ITIdx] = hv_ResSoAPLocalization;
                                                    }
                                                    else
                                                    {
                                                        if (hv_PerIoUSoAPLocalization == null)
                                                            hv_PerIoUSoAPLocalization = new HTuple();
                                                        hv_PerIoUSoAPLocalization[hv_ITIdx] = (hv_PerIoUSoAPLocalization.TupleSelect(
                                                            hv_ITIdx)) + hv_ResSoAPLocalization;
                                                    }
                                                }
                                                //Calculate and update absolute difference of orientation for class false positives.
                                                hv_AODDuplicate.Dispose();
                                                HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "abs_orientation_diff_duplicate",
                                                    out hv_AODDuplicate);
                                                hv_IdxsDuplicate.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_IdxsDuplicate = ((hv_AODDuplicate.TupleGreaterElem(
                                                        -1))).TupleFind(1);
                                                }
                                                if ((int)(new HTuple(hv_IdxsDuplicate.TupleNotEqual(-1))) != 0)
                                                {
                                                    hv_ResSoAPDuplicate.Dispose();
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        hv_ResSoAPDuplicate = 1.0 - ((((hv_AODDuplicate.TupleSelect(
                                                            hv_IdxsDuplicate))).TupleMean()) / ((new HTuple(180)).TupleRad()
                                                            ));
                                                    }
                                                    HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation,
                                                        "soap_fp_duplicate", hv_ResSoAPDuplicate);
                                                    //Update mean over classes.
                                                    if (hv_PerIoUNumClassesWithFPDuplicate == null)
                                                        hv_PerIoUNumClassesWithFPDuplicate = new HTuple();
                                                    hv_PerIoUNumClassesWithFPDuplicate[hv_ITIdx] = (hv_PerIoUNumClassesWithFPDuplicate.TupleSelect(
                                                        hv_ITIdx)) + 1;
                                                    if ((int)(new HTuple(((hv_PerIoUSoAPDuplicate.TupleSelect(
                                                        hv_ITIdx))).TupleEqual(-1))) != 0)
                                                    {
                                                        if (hv_PerIoUSoAPDuplicate == null)
                                                            hv_PerIoUSoAPDuplicate = new HTuple();
                                                        hv_PerIoUSoAPDuplicate[hv_ITIdx] = hv_ResSoAPDuplicate;
                                                    }
                                                    else
                                                    {
                                                        if (hv_PerIoUSoAPDuplicate == null)
                                                            hv_PerIoUSoAPDuplicate = new HTuple();
                                                        hv_PerIoUSoAPDuplicate[hv_ITIdx] = (hv_PerIoUSoAPDuplicate.TupleSelect(
                                                            hv_ITIdx)) + hv_ResSoAPDuplicate;
                                                    }
                                                }
                                                //Calculate and update absolute difference of orientation for multiple false positives.
                                                hv_AODMultiple.Dispose();
                                                HOperatorSet.GetDictTuple(hv_CurrentClassMeasures, "abs_orientation_diff_multiple",
                                                    out hv_AODMultiple);
                                                hv_IdxsMultiple.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_IdxsMultiple = ((hv_AODMultiple.TupleGreaterElem(
                                                        -1))).TupleFind(1);
                                                }
                                                if ((int)(new HTuple(hv_IdxsMultiple.TupleNotEqual(-1))) != 0)
                                                {
                                                    hv_ResSoAPMultiple.Dispose();
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        hv_ResSoAPMultiple = 1.0 - ((((hv_AODMultiple.TupleSelect(
                                                            hv_IdxsMultiple))).TupleMean()) / ((new HTuple(180)).TupleRad()
                                                            ));
                                                    }
                                                    HOperatorSet.SetDictTuple(hv_PerClassDetailedEvaluation,
                                                        "soap_fp_multiple", hv_ResSoAPMultiple);
                                                    //Update mean over classes.
                                                    if (hv_PerIoUNumClassesWithFPMultiple == null)
                                                        hv_PerIoUNumClassesWithFPMultiple = new HTuple();
                                                    hv_PerIoUNumClassesWithFPMultiple[hv_ITIdx] = (hv_PerIoUNumClassesWithFPMultiple.TupleSelect(
                                                        hv_ITIdx)) + 1;
                                                    if ((int)(new HTuple(((hv_PerIoUSoAPMultiple.TupleSelect(
                                                        hv_ITIdx))).TupleEqual(-1))) != 0)
                                                    {
                                                        if (hv_PerIoUSoAPMultiple == null)
                                                            hv_PerIoUSoAPMultiple = new HTuple();
                                                        hv_PerIoUSoAPMultiple[hv_ITIdx] = hv_ResSoAPMultiple;
                                                    }
                                                    else
                                                    {
                                                        if (hv_PerIoUSoAPMultiple == null)
                                                            hv_PerIoUSoAPMultiple = new HTuple();
                                                        hv_PerIoUSoAPMultiple[hv_ITIdx] = (hv_PerIoUSoAPMultiple.TupleSelect(
                                                            hv_ITIdx)) + hv_ResSoAPMultiple;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    //
                                    //Write to output.
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUAP.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "ap_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                            hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUAP);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUAP, "class_" + (hv_ClassIDs.TupleSelect(
                                            hv_ClsIdx)), hv_ClassAPPerIoU.TupleSelect(hv_ITIdx));
                                    }
                                    if ((int)(hv_CalcSoAP) != 0)
                                    {
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_PerIoUSoAP.Dispose();
                                            HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "soap_tp_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                                hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUSoAP);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUSoAP, "class_" + (hv_ClassIDs.TupleSelect(
                                                hv_ClsIdx)), hv_ClassSoAPPerIoU.TupleSelect(hv_ITIdx));
                                        }
                                    }
                                }
                                //
                                //Class mAP is the mean over IoU-thresholds.
                                if (hv_PerClassMAP == null)
                                    hv_PerClassMAP = new HTuple();
                                hv_PerClassMAP[hv_ClsIdx] = hv_ClassAPPerIoU.TupleMean();
                                hv_ClassMAPDict.Dispose();
                                HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "mean_iou_ap",
                                    out hv_ClassMAPDict);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_ClassMAPDict, "class_" + (hv_ClassIDs.TupleSelect(
                                        hv_ClsIdx)), hv_PerClassMAP.TupleSelect(hv_ClsIdx));
                                }
                                if ((int)(hv_CalcSoAP) != 0)
                                {
                                    //ClassMSoAP is the mean over IoU-thresholds.
                                    if (hv_PerClassMSoAP == null)
                                        hv_PerClassMSoAP = new HTuple();
                                    hv_PerClassMSoAP[hv_ClsIdx] = hv_ClassSoAPPerIoU.TupleMean();
                                    hv_ClassMSoAPDict.Dispose();
                                    HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "mean_iou_soap_tp",
                                        out hv_ClassMSoAPDict);
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_ClassMSoAPDict, "class_" + (hv_ClassIDs.TupleSelect(
                                            hv_ClsIdx)), hv_PerClassMSoAP.TupleSelect(hv_ClsIdx));
                                    }
                                }
                            }
                            //
                            //Calculate the mean AP and optionally mean SoAP (over classes) per IoU-threshold.
                            for (hv_ITIdx = 0; (int)hv_ITIdx <= (int)((new HTuple(hv_IoUThresholds.TupleLength()
                                )) - 1); hv_ITIdx = (int)hv_ITIdx + 1)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_PerIoUAP.Dispose();
                                    HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "ap_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                        hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUAP);
                                }
                                //
                                //Consider only present classes.
                                hv_MeanClassAP.Dispose();
                                hv_MeanClassAP = -1.0;
                                if ((int)(new HTuple((new HTuple(hv_ClassesWithGt.TupleLength())).TupleGreater(
                                    0))) != 0)
                                {
                                    hv_MeanClassAP.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_MeanClassAP = (hv_PerIoUMAP.TupleSelect(
                                            hv_ITIdx)) / (new HTuple(hv_ClassesWithGt.TupleLength()));
                                    }
                                }
                                HOperatorSet.SetDictTuple(hv_PerIoUAP, "mean_class_ap", hv_MeanClassAP);
                                if ((int)(hv_CalcSoAP) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUSoAP.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "soap_tp_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                            hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUSoAP);
                                    }
                                    //
                                    //Consider only present classes.
                                    hv_MeanClassSoAP.Dispose();
                                    hv_MeanClassSoAP = -1.0;
                                    if ((int)(new HTuple(((hv_PerIoUNumClassesWithTP.TupleSelect(hv_ITIdx))).TupleGreater(
                                        0))) != 0)
                                    {
                                        hv_MeanClassSoAP.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_MeanClassSoAP = (hv_PerIoUMSoAP.TupleSelect(
                                                hv_ITIdx)) / (hv_PerIoUNumClassesWithTP.TupleSelect(hv_ITIdx));
                                        }
                                    }
                                    HOperatorSet.SetDictTuple(hv_PerIoUSoAP, "mean_class_soap_tp", hv_MeanClassSoAP);
                                }
                                //
                                if ((int)(hv_DetailedEvaluation) != 0)
                                {
                                    //Add overall measures for TP, FN, FP, ...
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUDetailedEvaluation.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentEvaluationResult, "detailed_evaluation_iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                            hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUDetailedEvaluation);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_tp",
                                            hv_PerIoUTP.TupleSelect(hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fn",
                                            hv_PerIoUFN.TupleSelect(hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp",
                                            hv_PerIoUFP.TupleSelect(hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_class",
                                            hv_PerIoUFPClass.TupleSelect(hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_background",
                                            hv_PerIoUFPBackground.TupleSelect(hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_duplicate",
                                            hv_PerIoUFPDuplicate.TupleSelect(hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_localization",
                                            hv_PerIoUFPLocalization.TupleSelect(hv_ITIdx));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "num_fp_multiple",
                                            hv_PerIoUFPMultiple.TupleSelect(hv_ITIdx));
                                    }
                                    if ((int)(hv_CalcSoAP) != 0)
                                    {
                                        if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPClass.TupleSelect(
                                            hv_ITIdx))).TupleGreater(0))) != 0)
                                        {
                                            if (hv_PerIoUSoAPClass == null)
                                                hv_PerIoUSoAPClass = new HTuple();
                                            hv_PerIoUSoAPClass[hv_ITIdx] = (hv_PerIoUSoAPClass.TupleSelect(
                                                hv_ITIdx)) / (hv_PerIoUNumClassesWithFPClass.TupleSelect(hv_ITIdx));
                                        }
                                        if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPLocalization.TupleSelect(
                                            hv_ITIdx))).TupleGreater(0))) != 0)
                                        {
                                            if (hv_PerIoUSoAPLocalization == null)
                                                hv_PerIoUSoAPLocalization = new HTuple();
                                            hv_PerIoUSoAPLocalization[hv_ITIdx] = (hv_PerIoUSoAPLocalization.TupleSelect(
                                                hv_ITIdx)) / (hv_PerIoUNumClassesWithFPLocalization.TupleSelect(
                                                hv_ITIdx));
                                        }
                                        if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPDuplicate.TupleSelect(
                                            hv_ITIdx))).TupleGreater(0))) != 0)
                                        {
                                            if (hv_PerIoUSoAPDuplicate == null)
                                                hv_PerIoUSoAPDuplicate = new HTuple();
                                            hv_PerIoUSoAPDuplicate[hv_ITIdx] = (hv_PerIoUSoAPDuplicate.TupleSelect(
                                                hv_ITIdx)) / (hv_PerIoUNumClassesWithFPDuplicate.TupleSelect(
                                                hv_ITIdx));
                                        }
                                        if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPMultiple.TupleSelect(
                                            hv_ITIdx))).TupleGreater(0))) != 0)
                                        {
                                            if (hv_PerIoUSoAPMultiple == null)
                                                hv_PerIoUSoAPMultiple = new HTuple();
                                            hv_PerIoUSoAPMultiple[hv_ITIdx] = (hv_PerIoUSoAPMultiple.TupleSelect(
                                                hv_ITIdx)) / (hv_PerIoUNumClassesWithFPMultiple.TupleSelect(
                                                hv_ITIdx));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "soap_fp_class",
                                                hv_PerIoUSoAPClass.TupleSelect(hv_ITIdx));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "soap_fp_localization",
                                                hv_PerIoUSoAPLocalization.TupleSelect(hv_ITIdx));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "soap_fp_duplicate",
                                                hv_PerIoUSoAPDuplicate.TupleSelect(hv_ITIdx));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUDetailedEvaluation, "soap_fp_multiple",
                                                hv_PerIoUSoAPMultiple.TupleSelect(hv_ITIdx));
                                        }
                                    }
                                }
                            }
                            //
                            //Calculate overall mean AP (over classes and IoU-thresholds).
                            //Also here only classes with ground truth annotations are taken into account.
                            hv_MAP.Dispose();
                            hv_MAP = -1.0;
                            if ((int)(new HTuple((new HTuple(hv_ClassesWithGt.TupleLength())).TupleGreater(
                                0))) != 0)
                            {
                                hv_MAP.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_MAP = (((hv_PerClassMAP.TupleSelect(
                                        hv_ClassesWithGt))).TupleSum()) / (new HTuple(hv_ClassesWithGt.TupleLength()
                                        ));
                                }
                            }
                            HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_ap", hv_MAP);
                            if ((int)(hv_CalcSoAP) != 0)
                            {
                                hv_MSoAP.Dispose();
                                hv_MSoAP = -1.0;
                                if ((int)(new HTuple(((hv_PerIoUNumClassesWithTP.TupleSum())).TupleGreater(
                                    0))) != 0)
                                {
                                    hv_IoUsWithTP.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_IoUsWithTP = ((hv_PerIoUNumClassesWithTP.TupleGreaterElem(
                                            0))).TupleFind(1);
                                    }
                                    hv_MSoAP.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_MSoAP = ((((hv_PerIoUMSoAP.TupleSelect(
                                            hv_IoUsWithTP)) / (hv_PerIoUNumClassesWithTP.TupleSelect(hv_IoUsWithTP)))).TupleSum()
                                            ) / (new HTuple(hv_IoUsWithTP.TupleLength()));
                                    }
                                }
                                HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_soap_tp",
                                    hv_MSoAP);
                                if ((int)(hv_DetailedEvaluation) != 0)
                                {
                                    hv_MSoAPAll.Dispose();
                                    hv_MSoAPAll = 0.0;
                                    hv_NumSoAPAll.Dispose();
                                    hv_NumSoAPAll = 0;
                                    if ((int)(new HTuple(((hv_PerIoUNumClassesWithTP.TupleSum())).TupleGreater(
                                        0))) != 0)
                                    {
                                        hv_IoUsWithTP.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_IoUsWithTP = ((hv_PerIoUNumClassesWithTP.TupleGreaterElem(
                                                0))).TupleFind(1);
                                        }
                                        hv_MSoAPAll.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_MSoAPAll = hv_MSoAP * (((hv_PerIoUNumClassesWithTP.TupleSelect(
                                                hv_IoUsWithTP))).TupleSum());
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_NumSoAPAll = hv_NumSoAPAll + (((hv_PerIoUNumClassesWithTP.TupleSelect(
                                                    hv_IoUsWithTP))).TupleSum());
                                                hv_NumSoAPAll.Dispose();
                                                hv_NumSoAPAll = ExpTmpLocalVar_NumSoAPAll;
                                            }
                                        }
                                    }
                                    if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPClass.TupleSum())).TupleGreater(
                                        0))) != 0)
                                    {
                                        hv_IoUsWithFPClass.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_IoUsWithFPClass = ((hv_PerIoUNumClassesWithFPClass.TupleGreaterElem(
                                                0))).TupleFind(1);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_MSoAPAll = hv_MSoAPAll + (((((hv_PerIoUSoAPClass.TupleSelect(
                                                    hv_IoUsWithFPClass))).TupleSum()) / (new HTuple(hv_IoUsWithFPClass.TupleLength()
                                                    ))) * (((hv_PerIoUNumClassesWithFPClass.TupleSelect(hv_IoUsWithFPClass))).TupleSum()
                                                    ));
                                                hv_MSoAPAll.Dispose();
                                                hv_MSoAPAll = ExpTmpLocalVar_MSoAPAll;
                                            }
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_NumSoAPAll = hv_NumSoAPAll + (((hv_PerIoUNumClassesWithFPClass.TupleSelect(
                                                    hv_IoUsWithFPClass))).TupleSum());
                                                hv_NumSoAPAll.Dispose();
                                                hv_NumSoAPAll = ExpTmpLocalVar_NumSoAPAll;
                                            }
                                        }
                                    }
                                    if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPLocalization.TupleSum()
                                        )).TupleGreater(0))) != 0)
                                    {
                                        hv_IoUsWithFPLocalization.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_IoUsWithFPLocalization = ((hv_PerIoUNumClassesWithFPLocalization.TupleGreaterElem(
                                                0))).TupleFind(1);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_MSoAPAll = hv_MSoAPAll + (((((hv_PerIoUSoAPLocalization.TupleSelect(
                                                    hv_IoUsWithFPLocalization))).TupleSum()) / (new HTuple(hv_IoUsWithFPLocalization.TupleLength()
                                                    ))) * (((hv_PerIoUNumClassesWithFPLocalization.TupleSelect(hv_IoUsWithFPLocalization))).TupleSum()
                                                    ));
                                                hv_MSoAPAll.Dispose();
                                                hv_MSoAPAll = ExpTmpLocalVar_MSoAPAll;
                                            }
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_NumSoAPAll = hv_NumSoAPAll + (((hv_PerIoUNumClassesWithFPLocalization.TupleSelect(
                                                    hv_IoUsWithFPLocalization))).TupleSum());
                                                hv_NumSoAPAll.Dispose();
                                                hv_NumSoAPAll = ExpTmpLocalVar_NumSoAPAll;
                                            }
                                        }
                                    }
                                    if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPDuplicate.TupleSum()
                                        )).TupleGreater(0))) != 0)
                                    {
                                        hv_IoUsWithFPDuplicate.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_IoUsWithFPDuplicate = ((hv_PerIoUNumClassesWithFPDuplicate.TupleGreaterElem(
                                                0))).TupleFind(1);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_MSoAPAll = hv_MSoAPAll + (((((hv_PerIoUSoAPDuplicate.TupleSelect(
                                                    hv_IoUsWithFPDuplicate))).TupleSum()) / (new HTuple(hv_IoUsWithFPDuplicate.TupleLength()
                                                    ))) * (((hv_PerIoUNumClassesWithFPDuplicate.TupleSelect(hv_IoUsWithFPDuplicate))).TupleSum()
                                                    ));
                                                hv_MSoAPAll.Dispose();
                                                hv_MSoAPAll = ExpTmpLocalVar_MSoAPAll;
                                            }
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_NumSoAPAll = hv_NumSoAPAll + (((hv_PerIoUNumClassesWithFPDuplicate.TupleSelect(
                                                    hv_IoUsWithFPDuplicate))).TupleSum());
                                                hv_NumSoAPAll.Dispose();
                                                hv_NumSoAPAll = ExpTmpLocalVar_NumSoAPAll;
                                            }
                                        }
                                    }
                                    if ((int)(new HTuple(((hv_PerIoUNumClassesWithFPMultiple.TupleSum()
                                        )).TupleGreater(0))) != 0)
                                    {
                                        hv_IoUsWithFPMultiple.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_IoUsWithFPMultiple = ((hv_PerIoUNumClassesWithFPMultiple.TupleGreaterElem(
                                                0))).TupleFind(1);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_MSoAPAll = hv_MSoAPAll + (((((hv_PerIoUSoAPMultiple.TupleSelect(
                                                    hv_IoUsWithFPMultiple))).TupleSum()) / (new HTuple(hv_IoUsWithFPMultiple.TupleLength()
                                                    ))) * (((hv_PerIoUNumClassesWithFPMultiple.TupleSelect(hv_IoUsWithFPMultiple))).TupleSum()
                                                    ));
                                                hv_MSoAPAll.Dispose();
                                                hv_MSoAPAll = ExpTmpLocalVar_MSoAPAll;
                                            }
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_NumSoAPAll = hv_NumSoAPAll + (((hv_PerIoUNumClassesWithFPMultiple.TupleSelect(
                                                    hv_IoUsWithFPMultiple))).TupleSum());
                                                hv_NumSoAPAll.Dispose();
                                                hv_NumSoAPAll = ExpTmpLocalVar_NumSoAPAll;
                                            }
                                        }
                                    }
                                    if ((int)(new HTuple(hv_NumSoAPAll.TupleGreater(0))) != 0)
                                    {
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_soap_all",
                                                (hv_MSoAPAll.TupleReal()) / hv_NumSoAPAll);
                                        }
                                    }
                                    else
                                    {
                                        HOperatorSet.SetDictTuple(hv_CurrentEvaluationResult, "mean_soap_all",
                                            -1);
                                    }
                                    //
                                }
                            }
                            //
                            //Add CurrentEvaluationResult to output.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_PerMaxNumEvaluationResult, "area_" + hv_AreaName,
                                    hv_CurrentEvaluationResult);
                            }
                        }
                        //Add PerMaxNumEvaluationResult to output.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_EvaluationResult, "max_num_detections_" + hv_MaxNumStr,
                                hv_PerMaxNumEvaluationResult);
                        }
                    }
                }
                //

                hv_CalcClassAP.Dispose();
                hv_CalcMeanAP.Dispose();
                hv_CalcSoAP.Dispose();
                hv_InstanceType.Dispose();
                hv_Measures.Dispose();
                hv_M.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClasses.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_IoUThresholds.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_InterpolatePRCurves.Dispose();
                hv_KeyExists.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_RecThreshs.Dispose();
                hv_MDIdx.Dispose();
                hv_MaxNum.Dispose();
                hv_MaxNumStr.Dispose();
                hv_CurrentRunningMeasures.Dispose();
                hv_PerMaxNumEvaluationResult.Dispose();
                hv_AreaIdx.Dispose();
                hv_MinArea.Dispose();
                hv_MaxArea.Dispose();
                hv_AreaName.Dispose();
                hv_AreaRunningMeasures.Dispose();
                hv_PerClassNumGt.Dispose();
                hv_PerClassNumPred.Dispose();
                hv_PerClassConfidence.Dispose();
                hv_PerClassNumGtIgnore.Dispose();
                hv_CurrentEvaluationResult.Dispose();
                hv_ITIdx.Dispose();
                hv_PerIoUAP.Dispose();
                hv_PerIoUSoAP.Dispose();
                hv_PerIoUDetailedEvaluation.Dispose();
                hv_ClsIdx.Dispose();
                hv_PerClassDetailedEvaluation.Dispose();
                hv_DetectionConfusionMatrix.Dispose();
                hv_PerIoUMeasure.Dispose();
                hv_NumImgIDsWithFN.Dispose();
                hv_NumImgIDsWithFP.Dispose();
                hv_ImgIDsWithFN.Dispose();
                hv_ImgIDsWithFP.Dispose();
                hv_ClassMAPDict.Dispose();
                hv_ClassMSoAPDict.Dispose();
                hv_ClassesWithGt.Dispose();
                hv_PerClassMAP.Dispose();
                hv_PerIoUMAP.Dispose();
                hv_PerClassMSoAP.Dispose();
                hv_PerIoUMSoAP.Dispose();
                hv_PerIoUNumClassesWithTP.Dispose();
                hv_PerIoUTP.Dispose();
                hv_PerIoUFN.Dispose();
                hv_PerIoUFP.Dispose();
                hv_PerIoUFPClass.Dispose();
                hv_PerIoUFPBackground.Dispose();
                hv_PerIoUFPLocalization.Dispose();
                hv_PerIoUFPDuplicate.Dispose();
                hv_PerIoUFPMultiple.Dispose();
                hv_PerIoUSoAPClass.Dispose();
                hv_PerIoUSoAPLocalization.Dispose();
                hv_PerIoUSoAPDuplicate.Dispose();
                hv_PerIoUSoAPMultiple.Dispose();
                hv_PerIoUNumClassesWithFPClass.Dispose();
                hv_PerIoUNumClassesWithFPLocalization.Dispose();
                hv_PerIoUNumClassesWithFPDuplicate.Dispose();
                hv_PerIoUNumClassesWithFPMultiple.Dispose();
                hv_ClassAPPerIoU.Dispose();
                hv_ClassSoAPPerIoU.Dispose();
                hv_NumGt.Dispose();
                hv_NumGtIgnore.Dispose();
                hv_NumPred.Dispose();
                hv_Confidences.Dispose();
                hv_SortIdxs.Dispose();
                hv_CurrentClassMeasures.Dispose();
                hv_IsTP.Dispose();
                hv_Ignore.Dispose();
                hv_NoIgnoreIdxs.Dispose();
                hv_IsFP.Dispose();
                hv_AccumulatedIsTP.Dispose();
                hv_AccumulatedIsFP.Dispose();
                hv_Recall.Dispose();
                hv_Precision.Dispose();
                hv_InterpolatedPrecision.Dispose();
                hv_PIdx.Dispose();
                hv_PrecisionAtRecThreshs.Dispose();
                hv_RTIdx.Dispose();
                hv_RecQuantile.Dispose();
                hv_AOD.Dispose();
                hv_IdxsTP.Dispose();
                hv_IsFPClass.Dispose();
                hv_IsFPBackground.Dispose();
                hv_IsFPLocalization.Dispose();
                hv_IsFPDuplicate.Dispose();
                hv_IsFPMultiple.Dispose();
                hv_NumTP.Dispose();
                hv_NumFP.Dispose();
                hv_NumFN.Dispose();
                hv_NumFPClass.Dispose();
                hv_NumFPBackground.Dispose();
                hv_NumFPLocalization.Dispose();
                hv_NumFPDuplicate.Dispose();
                hv_NumFPMultiple.Dispose();
                hv_IndicesWithClassConfusion.Dispose();
                hv_IsFPClassIdxs.Dispose();
                hv_ClassIdxsConfused.Dispose();
                hv_Idx.Dispose();
                hv_NumConfusedThisIdx.Dispose();
                hv_AODClass.Dispose();
                hv_IdxsClass.Dispose();
                hv_ResSoAPClass.Dispose();
                hv_AODLocalization.Dispose();
                hv_IdxsLocalization.Dispose();
                hv_ResSoAPLocalization.Dispose();
                hv_AODDuplicate.Dispose();
                hv_IdxsDuplicate.Dispose();
                hv_ResSoAPDuplicate.Dispose();
                hv_AODMultiple.Dispose();
                hv_IdxsMultiple.Dispose();
                hv_ResSoAPMultiple.Dispose();
                hv_MeanClassAP.Dispose();
                hv_MeanClassSoAP.Dispose();
                hv_MAP.Dispose();
                hv_MSoAP.Dispose();
                hv_IoUsWithTP.Dispose();
                hv_MSoAPAll.Dispose();
                hv_NumSoAPAll.Dispose();
                hv_IoUsWithFPClass.Dispose();
                hv_IoUsWithFPLocalization.Dispose();
                hv_IoUsWithFPDuplicate.Dispose();
                hv_IoUsWithFPMultiple.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_CalcClassAP.Dispose();
                hv_CalcMeanAP.Dispose();
                hv_CalcSoAP.Dispose();
                hv_InstanceType.Dispose();
                hv_Measures.Dispose();
                hv_M.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClasses.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_IoUThresholds.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_InterpolatePRCurves.Dispose();
                hv_KeyExists.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_RecThreshs.Dispose();
                hv_MDIdx.Dispose();
                hv_MaxNum.Dispose();
                hv_MaxNumStr.Dispose();
                hv_CurrentRunningMeasures.Dispose();
                hv_PerMaxNumEvaluationResult.Dispose();
                hv_AreaIdx.Dispose();
                hv_MinArea.Dispose();
                hv_MaxArea.Dispose();
                hv_AreaName.Dispose();
                hv_AreaRunningMeasures.Dispose();
                hv_PerClassNumGt.Dispose();
                hv_PerClassNumPred.Dispose();
                hv_PerClassConfidence.Dispose();
                hv_PerClassNumGtIgnore.Dispose();
                hv_CurrentEvaluationResult.Dispose();
                hv_ITIdx.Dispose();
                hv_PerIoUAP.Dispose();
                hv_PerIoUSoAP.Dispose();
                hv_PerIoUDetailedEvaluation.Dispose();
                hv_ClsIdx.Dispose();
                hv_PerClassDetailedEvaluation.Dispose();
                hv_DetectionConfusionMatrix.Dispose();
                hv_PerIoUMeasure.Dispose();
                hv_NumImgIDsWithFN.Dispose();
                hv_NumImgIDsWithFP.Dispose();
                hv_ImgIDsWithFN.Dispose();
                hv_ImgIDsWithFP.Dispose();
                hv_ClassMAPDict.Dispose();
                hv_ClassMSoAPDict.Dispose();
                hv_ClassesWithGt.Dispose();
                hv_PerClassMAP.Dispose();
                hv_PerIoUMAP.Dispose();
                hv_PerClassMSoAP.Dispose();
                hv_PerIoUMSoAP.Dispose();
                hv_PerIoUNumClassesWithTP.Dispose();
                hv_PerIoUTP.Dispose();
                hv_PerIoUFN.Dispose();
                hv_PerIoUFP.Dispose();
                hv_PerIoUFPClass.Dispose();
                hv_PerIoUFPBackground.Dispose();
                hv_PerIoUFPLocalization.Dispose();
                hv_PerIoUFPDuplicate.Dispose();
                hv_PerIoUFPMultiple.Dispose();
                hv_PerIoUSoAPClass.Dispose();
                hv_PerIoUSoAPLocalization.Dispose();
                hv_PerIoUSoAPDuplicate.Dispose();
                hv_PerIoUSoAPMultiple.Dispose();
                hv_PerIoUNumClassesWithFPClass.Dispose();
                hv_PerIoUNumClassesWithFPLocalization.Dispose();
                hv_PerIoUNumClassesWithFPDuplicate.Dispose();
                hv_PerIoUNumClassesWithFPMultiple.Dispose();
                hv_ClassAPPerIoU.Dispose();
                hv_ClassSoAPPerIoU.Dispose();
                hv_NumGt.Dispose();
                hv_NumGtIgnore.Dispose();
                hv_NumPred.Dispose();
                hv_Confidences.Dispose();
                hv_SortIdxs.Dispose();
                hv_CurrentClassMeasures.Dispose();
                hv_IsTP.Dispose();
                hv_Ignore.Dispose();
                hv_NoIgnoreIdxs.Dispose();
                hv_IsFP.Dispose();
                hv_AccumulatedIsTP.Dispose();
                hv_AccumulatedIsFP.Dispose();
                hv_Recall.Dispose();
                hv_Precision.Dispose();
                hv_InterpolatedPrecision.Dispose();
                hv_PIdx.Dispose();
                hv_PrecisionAtRecThreshs.Dispose();
                hv_RTIdx.Dispose();
                hv_RecQuantile.Dispose();
                hv_AOD.Dispose();
                hv_IdxsTP.Dispose();
                hv_IsFPClass.Dispose();
                hv_IsFPBackground.Dispose();
                hv_IsFPLocalization.Dispose();
                hv_IsFPDuplicate.Dispose();
                hv_IsFPMultiple.Dispose();
                hv_NumTP.Dispose();
                hv_NumFP.Dispose();
                hv_NumFN.Dispose();
                hv_NumFPClass.Dispose();
                hv_NumFPBackground.Dispose();
                hv_NumFPLocalization.Dispose();
                hv_NumFPDuplicate.Dispose();
                hv_NumFPMultiple.Dispose();
                hv_IndicesWithClassConfusion.Dispose();
                hv_IsFPClassIdxs.Dispose();
                hv_ClassIdxsConfused.Dispose();
                hv_Idx.Dispose();
                hv_NumConfusedThisIdx.Dispose();
                hv_AODClass.Dispose();
                hv_IdxsClass.Dispose();
                hv_ResSoAPClass.Dispose();
                hv_AODLocalization.Dispose();
                hv_IdxsLocalization.Dispose();
                hv_ResSoAPLocalization.Dispose();
                hv_AODDuplicate.Dispose();
                hv_IdxsDuplicate.Dispose();
                hv_ResSoAPDuplicate.Dispose();
                hv_AODMultiple.Dispose();
                hv_IdxsMultiple.Dispose();
                hv_ResSoAPMultiple.Dispose();
                hv_MeanClassAP.Dispose();
                hv_MeanClassSoAP.Dispose();
                hv_MAP.Dispose();
                hv_MSoAP.Dispose();
                hv_IoUsWithTP.Dispose();
                hv_MSoAPAll.Dispose();
                hv_NumSoAPAll.Dispose();
                hv_IoUsWithFPClass.Dispose();
                hv_IoUsWithFPLocalization.Dispose();
                hv_IoUsWithFPDuplicate.Dispose();
                hv_IoUsWithFPMultiple.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Calculate pixel measures based on RunningMeasures. 
        private void calculate_pixel_measures(HTuple hv_RunningMeasures, HTuple hv_EvalParams,
            out HTuple hv_EvaluationResult)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_CalcClassPixelAccuracy = new HTuple();
            HTuple hv_CalcPixelAccuracy = new HTuple(), hv_CalcPixelConfusionMatrix = new HTuple();
            HTuple hv_CalcMeanAccuracy = new HTuple(), hv_CalcMeanIou = new HTuple();
            HTuple hv_CalcClassIou = new HTuple(), hv_CalcFWIou = new HTuple();
            HTuple hv_Measures = new HTuple(), hv_M = new HTuple();
            HTuple hv_ConfMatrix = new HTuple(), hv_TPMat = new HTuple();
            HTuple hv_TP = new HTuple(), hv_SumRowMat = new HTuple();
            HTuple hv_RowSum = new HTuple(), hv_FP = new HTuple();
            HTuple hv_SumColMat = new HTuple(), hv_ColSum = new HTuple();
            HTuple hv_FN = new HTuple(), hv_IgnoreClassIDs = new HTuple();
            HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
            HTuple hv_FPIgnore = new HTuple(), hv_GT = new HTuple();
            HTuple hv_ClsIdxValid = new HTuple(), hv_ClassPixelAccuracy = new HTuple();
            HTuple hv_MeanAccuracy = new HTuple(), hv_PixelAccuracy = new HTuple();
            HTuple hv_ClassIoU = new HTuple(), hv_MeanIoU = new HTuple();
            HTuple hv_FWIoU = new HTuple(), hv_FwWeights = new HTuple();
            // Initialize local and output iconic variables 
            hv_EvaluationResult = new HTuple();
            try
            {
                //
                //This procedure calculates the pixel-wise measures based on the values in running measures.
                //
                //Set default values.
                hv_CalcClassPixelAccuracy.Dispose();
                hv_CalcClassPixelAccuracy = 0;
                hv_CalcPixelAccuracy.Dispose();
                hv_CalcPixelAccuracy = 0;
                hv_CalcPixelConfusionMatrix.Dispose();
                hv_CalcPixelConfusionMatrix = 0;
                hv_CalcMeanAccuracy.Dispose();
                hv_CalcMeanAccuracy = 0;
                hv_CalcMeanIou.Dispose();
                hv_CalcMeanIou = 0;
                hv_CalcClassIou.Dispose();
                hv_CalcClassIou = 0;
                hv_CalcFWIou.Dispose();
                hv_CalcFWIou = 0;
                //Check which measures are to be calculated.
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                hv_EvaluationResult.Dispose();
                HOperatorSet.CreateDict(out hv_EvaluationResult);
                for (hv_M = 0; (int)hv_M <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_M = (int)hv_M + 1)
                {
                    if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual("pixel_accuracy"))) != 0)
                    {
                        hv_CalcPixelAccuracy.Dispose();
                        hv_CalcPixelAccuracy = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "class_pixel_accuracy"))) != 0)
                    {
                        hv_CalcClassPixelAccuracy.Dispose();
                        hv_CalcClassPixelAccuracy = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "pixel_confusion_matrix"))) != 0)
                    {
                        hv_CalcPixelConfusionMatrix.Dispose();
                        hv_CalcPixelConfusionMatrix = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "mean_accuracy"))) != 0)
                    {
                        hv_CalcMeanAccuracy.Dispose();
                        hv_CalcMeanAccuracy = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "mean_iou"))) != 0)
                    {
                        hv_CalcMeanIou.Dispose();
                        hv_CalcMeanIou = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "class_iou"))) != 0)
                    {
                        hv_CalcClassIou.Dispose();
                        hv_CalcClassIou = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "frequency_weighted_iou"))) != 0)
                    {
                        hv_CalcFWIou.Dispose();
                        hv_CalcFWIou = 1;
                    }
                    else if ((int)(new HTuple(((hv_Measures.TupleSelect(hv_M))).TupleEqual(
                        "all"))) != 0)
                    {
                        hv_CalcPixelAccuracy.Dispose();
                        hv_CalcPixelAccuracy = 1;
                        hv_CalcClassPixelAccuracy.Dispose();
                        hv_CalcClassPixelAccuracy = 1;
                        hv_CalcPixelConfusionMatrix.Dispose();
                        hv_CalcPixelConfusionMatrix = 1;
                        hv_CalcMeanAccuracy.Dispose();
                        hv_CalcMeanAccuracy = 1;
                        hv_CalcMeanIou.Dispose();
                        hv_CalcMeanIou = 1;
                        hv_CalcClassIou.Dispose();
                        hv_CalcClassIou = 1;
                        hv_CalcFWIou.Dispose();
                        hv_CalcFWIou = 1;
                    }
                    else
                    {
                        throw new HalconException("Unknown Segmentation Measure: " + (hv_Measures.TupleSelect(
                            hv_M)));
                    }
                }
                //
                //Depending on the running measure values (ConfusionMatrix or TP/FP/FN),
                //we first calculate TP/FP/FN from the ConfusionMatrix.
                if ((int)(hv_CalcPixelConfusionMatrix) != 0)
                {
                    //Get the running measures.
                    hv_ConfMatrix.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "pixel_confusion_matrix", out hv_ConfMatrix);
                    //Get the per-class true positives as the diagonal of the matrix.
                    hv_TPMat.Dispose();
                    HOperatorSet.GetDiagonalMatrix(hv_ConfMatrix, 0, out hv_TPMat);
                    hv_TP.Dispose();
                    HOperatorSet.GetFullMatrix(hv_TPMat, out hv_TP);
                    //For the confusion matrix, the row determines the predicted class-IDs,
                    //the column determines the ground truth class-IDs.
                    //Get the per-class false positives (FP) as the sum over the rows minus the diagonal (TP).
                    hv_SumRowMat.Dispose();
                    HOperatorSet.SumMatrix(hv_ConfMatrix, "rows", out hv_SumRowMat);
                    hv_RowSum.Dispose();
                    HOperatorSet.GetFullMatrix(hv_SumRowMat, out hv_RowSum);
                    hv_FP.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_FP = hv_RowSum - hv_TP;
                    }
                    //Get the per-class false negatives (FN) as the sum over the columns minus the diagonal (TP).
                    hv_SumColMat.Dispose();
                    HOperatorSet.SumMatrix(hv_ConfMatrix, "columns", out hv_SumColMat);
                    hv_ColSum.Dispose();
                    HOperatorSet.GetFullMatrix(hv_SumColMat, out hv_ColSum);
                    hv_FN.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_FN = hv_ColSum - hv_TP;
                    }
                    //We do not want to count the false positives (FP) in the ignore region.
                    //The false negatives (FN) are not affected, since the model does not predict the ignore class.
                    hv_IgnoreClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "ignore_class_ids", out hv_IgnoreClassIDs);
                    if ((int)(new HTuple((new HTuple(hv_IgnoreClassIDs.TupleLength())).TupleGreater(
                        0))) != 0)
                    {
                        //The ignore class corresponds to the last row/column in the confusion matrix.
                        hv_Rows.Dispose(); hv_Columns.Dispose();
                        HOperatorSet.GetSizeMatrix(hv_ConfMatrix, out hv_Rows, out hv_Columns);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FPIgnore.Dispose();
                            HOperatorSet.GetValueMatrix(hv_ConfMatrix, HTuple.TupleGenSequence(0, hv_Rows - 1, 1),
                                HTuple.TupleGenConst(hv_Rows, hv_Columns - 1), out hv_FPIgnore);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_FP = hv_FP - hv_FPIgnore;
                                hv_FP.Dispose();
                                hv_FP = ExpTmpLocalVar_FP;
                            }
                        }
                        //Remove last entries of TP, FP, FN (those related to the ignore class).
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_TP = hv_TP.TupleSelectRange(
                                    0, (new HTuple(hv_TP.TupleLength())) - 2);
                                hv_TP.Dispose();
                                hv_TP = ExpTmpLocalVar_TP;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_FP = hv_FP.TupleSelectRange(
                                    0, (new HTuple(hv_FP.TupleLength())) - 2);
                                hv_FP.Dispose();
                                hv_FP = ExpTmpLocalVar_FP;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_FN = hv_FN.TupleSelectRange(
                                    0, (new HTuple(hv_FN.TupleLength())) - 2);
                                hv_FN.Dispose();
                                hv_FN = ExpTmpLocalVar_FN;
                            }
                        }
                        //Remove last row/column from confusion matrix.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HTuple ExpTmpOutVar_0;
                            HOperatorSet.GetSubMatrix(hv_ConfMatrix, 0, 0, hv_Rows - 1, hv_Columns - 1,
                                out ExpTmpOutVar_0);
                            hv_ConfMatrix.Dispose();
                            hv_ConfMatrix = ExpTmpOutVar_0;
                        }
                    }
                    //Paste the confusion matrix to the output.
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "pixel_confusion_matrix",
                        hv_ConfMatrix);
                }
                else
                {
                    //Get the running measure values.
                    hv_TP.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "tp", out hv_TP);
                    hv_FP.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "fp", out hv_FP);
                    hv_FN.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "fn", out hv_FN);
                }
                //
                //It might be the case, that some of the classes are not present in the set of validation images.
                //--> Exclude these classes (they are indirectly present as they reduce the number of TP for other classes).
                hv_GT.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_GT = hv_TP + hv_FN;
                }
                hv_ClsIdxValid.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ClsIdxValid = ((hv_GT.TupleGreaterElem(
                        0))).TupleFind(1);
                }
                //
                //Mean Accuracy, Class Pixel Accuracy.
                //-> If one of 'mean_accuracy', 'class_pixel_accuracy' is specified, we give back both of them
                //   as they have to be calculated anyway (to the most part).
                if ((int)(hv_CalcClassPixelAccuracy.TupleOr(hv_CalcMeanAccuracy)) != 0)
                {
                    //Compute pixel accuracy per class (although we might only use it for the overall pixel accuracy).
                    hv_ClassPixelAccuracy.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassPixelAccuracy = HTuple.TupleGenConst(
                            new HTuple(hv_GT.TupleLength()), -1);
                    }
                    hv_MeanAccuracy.Dispose();
                    hv_MeanAccuracy = -1;
                    if ((int)(new HTuple(((hv_ClsIdxValid.TupleSelect(0))).TupleGreater(-1))) != 0)
                    {
                        if (hv_ClassPixelAccuracy == null)
                            hv_ClassPixelAccuracy = new HTuple();
                        hv_ClassPixelAccuracy[hv_ClsIdxValid] = (((hv_TP.TupleSelect(hv_ClsIdxValid))).TupleReal()
                            ) / (hv_GT.TupleSelect(hv_ClsIdxValid));
                        hv_MeanAccuracy.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MeanAccuracy = ((hv_ClassPixelAccuracy.TupleSelect(
                                hv_ClsIdxValid))).TupleMean();
                        }
                    }
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "class_pixel_accuracy", hv_ClassPixelAccuracy);
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "mean_accuracy", hv_MeanAccuracy);
                }
                //Pixel Accuracy
                if ((int)(hv_CalcPixelAccuracy) != 0)
                {
                    //Compute pixel accuracy as the total ratio of pixels that have been correctly predicted.
                    hv_PixelAccuracy.Dispose();
                    hv_PixelAccuracy = -1;
                    if ((int)(new HTuple(((hv_ClsIdxValid.TupleSelect(0))).TupleGreater(-1))) != 0)
                    {
                        hv_PixelAccuracy.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_PixelAccuracy = (((((hv_TP.TupleSelect(
                                hv_ClsIdxValid))).TupleSum())).TupleReal()) / (((hv_GT.TupleSelect(hv_ClsIdxValid))).TupleSum()
                                );
                        }
                    }
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "pixel_accuracy", hv_PixelAccuracy);
                }
                //Mean IoU, class IoU, frequency weighted IoU:
                //-> If the measures 'class_iou', 'mean_iou' or 'frequency_weighted_iou' is specified,
                //   we return all three of them as they have to be calculated anyway (to the most part).
                if ((int)((new HTuple(hv_CalcMeanIou.TupleOr(hv_CalcClassIou))).TupleOr(hv_CalcFWIou)) != 0)
                {
                    hv_ClassIoU.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassIoU = HTuple.TupleGenConst(
                            new HTuple(hv_GT.TupleLength()), -1);
                    }
                    hv_MeanIoU.Dispose();
                    hv_MeanIoU = -1;
                    hv_FWIoU.Dispose();
                    hv_FWIoU = -1;
                    if ((int)(new HTuple(((hv_ClsIdxValid.TupleSelect(0))).TupleGreater(-1))) != 0)
                    {
                        if (hv_ClassIoU == null)
                            hv_ClassIoU = new HTuple();
                        hv_ClassIoU[hv_ClsIdxValid] = (((hv_TP.TupleSelect(hv_ClsIdxValid))).TupleReal()
                            ) / ((hv_GT.TupleSelect(hv_ClsIdxValid)) + (hv_FP.TupleSelect(hv_ClsIdxValid)));
                        hv_MeanIoU.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MeanIoU = ((hv_ClassIoU.TupleSelect(
                                hv_ClsIdxValid))).TupleMean();
                        }
                        hv_FwWeights.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FwWeights = (hv_GT.TupleReal()
                                ) / (hv_GT.TupleSum());
                        }
                        hv_FWIoU.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FWIoU = (((hv_FwWeights.TupleSelect(
                                hv_ClsIdxValid)) * (hv_ClassIoU.TupleSelect(hv_ClsIdxValid)))).TupleSum()
                                ;
                        }
                    }
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "class_iou", hv_ClassIoU);
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "mean_iou", hv_MeanIoU);
                    HOperatorSet.SetDictTuple(hv_EvaluationResult, "frequency_weighted_iou",
                        hv_FWIoU);
                }
                //

                hv_CalcClassPixelAccuracy.Dispose();
                hv_CalcPixelAccuracy.Dispose();
                hv_CalcPixelConfusionMatrix.Dispose();
                hv_CalcMeanAccuracy.Dispose();
                hv_CalcMeanIou.Dispose();
                hv_CalcClassIou.Dispose();
                hv_CalcFWIou.Dispose();
                hv_Measures.Dispose();
                hv_M.Dispose();
                hv_ConfMatrix.Dispose();
                hv_TPMat.Dispose();
                hv_TP.Dispose();
                hv_SumRowMat.Dispose();
                hv_RowSum.Dispose();
                hv_FP.Dispose();
                hv_SumColMat.Dispose();
                hv_ColSum.Dispose();
                hv_FN.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_FPIgnore.Dispose();
                hv_GT.Dispose();
                hv_ClsIdxValid.Dispose();
                hv_ClassPixelAccuracy.Dispose();
                hv_MeanAccuracy.Dispose();
                hv_PixelAccuracy.Dispose();
                hv_ClassIoU.Dispose();
                hv_MeanIoU.Dispose();
                hv_FWIoU.Dispose();
                hv_FwWeights.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_CalcClassPixelAccuracy.Dispose();
                hv_CalcPixelAccuracy.Dispose();
                hv_CalcPixelConfusionMatrix.Dispose();
                hv_CalcMeanAccuracy.Dispose();
                hv_CalcMeanIou.Dispose();
                hv_CalcClassIou.Dispose();
                hv_CalcFWIou.Dispose();
                hv_Measures.Dispose();
                hv_M.Dispose();
                hv_ConfMatrix.Dispose();
                hv_TPMat.Dispose();
                hv_TP.Dispose();
                hv_SumRowMat.Dispose();
                hv_RowSum.Dispose();
                hv_FP.Dispose();
                hv_SumColMat.Dispose();
                hv_ColSum.Dispose();
                hv_FN.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_FPIgnore.Dispose();
                hv_GT.Dispose();
                hv_ClsIdxValid.Dispose();
                hv_ClassPixelAccuracy.Dispose();
                hv_MeanAccuracy.Dispose();
                hv_PixelAccuracy.Dispose();
                hv_ClassIoU.Dispose();
                hv_MeanIoU.Dispose();
                hv_FWIoU.Dispose();
                hv_FwWeights.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        private void check_train_dl_model_params(HTuple hv_DLDataset, HTuple hv_DLModelHandle,
            HTuple hv_NumTrainSamples, HTuple hv_StartEpoch, HTuple hv_TrainParam)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ModelType = new HTuple(), hv_PreprocessedDataset = new HTuple();
            HTuple hv_PreprocessParam = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_TrainParamAnomaly = new HTuple(), hv_DomainRatio = new HTuple();
            HTuple hv_ErrorThreshold = new HTuple(), hv_RegularizationNoise = new HTuple();
            HTuple hv_NumEpochs = new HTuple(), hv_BatchSizeDevice = new HTuple();
            HTuple hv_BatchSizeMultiplier = new HTuple(), hv_BatchSize = new HTuple();
            HTuple hv_ClassIDsModel = new HTuple(), hv_ClassIDsDataset = new HTuple();
            HTuple hv_Index = new HTuple(), hv_IndexFind = new HTuple();
            HTuple hv_ClassIDsModelStr = new HTuple(), hv_ClassIDsDatasetStr = new HTuple();
            HTuple hv_DisplayParam = new HTuple(), hv_DisplayKeys = new HTuple();
            HTuple hv_KeyName = new HTuple(), hv_KeyValue = new HTuple();
            HTuple hv_TrainParamCopy = new HTuple(), hv__ = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure checks the parameters used in the procedure train_dl_model for consistency.
                //
                hv_ModelType.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "type", out hv_ModelType);
                //
                //Check the NumEpochs parameter.
                if ((int)(hv_StartEpoch.TupleIsNumber()) != 0)
                {
                    if ((int)(new HTuple(hv_StartEpoch.TupleLess(0.0))) != 0)
                    {
                        throw new HalconException("Error: StartEpoch < 0 is not allowed.");
                    }
                }
                //
                //Check if the dataset is already preprocessed.
                hv_PreprocessedDataset.Dispose();
                hv_PreprocessedDataset = 0;
                try
                {
                    hv_PreprocessParam.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLDataset, "preprocess_param", out hv_PreprocessParam);
                    hv_PreprocessedDataset.Dispose();
                    hv_PreprocessedDataset = 1;
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                }
                if ((int)(hv_PreprocessedDataset.TupleNot()) != 0)
                {
                    throw new HalconException("Error: The supplied dataset needs to be preprocessed already. Use the standard procedure preprocess_dl_dataset.");
                }
                //
                //Check parameters for anomaly detection models.
                if ((int)(new HTuple(hv_ModelType.TupleEqual("anomaly_detection"))) != 0)
                {
                    hv_TrainParamAnomaly.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainParam, "anomaly_param", out hv_TrainParamAnomaly);
                    hv_DomainRatio.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainParamAnomaly, "domain_ratio", out hv_DomainRatio);
                    if ((int)((new HTuple(hv_DomainRatio.TupleLessEqual(0))).TupleOr(new HTuple(hv_DomainRatio.TupleGreater(
                        1.0)))) != 0)
                    {
                        throw new HalconException("Error: The anomaly detection parameter 'domain_ratio' must be between 0 and 1.");
                    }
                    hv_ErrorThreshold.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainParamAnomaly, "error_threshold", out hv_ErrorThreshold);
                    if ((int)((new HTuple(hv_ErrorThreshold.TupleLess(0))).TupleOr(new HTuple(hv_ErrorThreshold.TupleGreater(
                        1)))) != 0)
                    {
                        throw new HalconException("Error: The anomaly detection parameter 'error_threshold' must be between 0 and 1.");
                    }
                    hv_RegularizationNoise.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainParamAnomaly, "regularization_noise", out hv_RegularizationNoise);
                    if ((int)(new HTuple(hv_RegularizationNoise.TupleLess(0))) != 0)
                    {
                        throw new HalconException("Error: The anomaly detection parameter 'regularization_noise' must be greater than or equal to 0.");
                    }

                    hv_ModelType.Dispose();
                    hv_PreprocessedDataset.Dispose();
                    hv_PreprocessParam.Dispose();
                    hv_Exception.Dispose();
                    hv_TrainParamAnomaly.Dispose();
                    hv_DomainRatio.Dispose();
                    hv_ErrorThreshold.Dispose();
                    hv_RegularizationNoise.Dispose();
                    hv_NumEpochs.Dispose();
                    hv_BatchSizeDevice.Dispose();
                    hv_BatchSizeMultiplier.Dispose();
                    hv_BatchSize.Dispose();
                    hv_ClassIDsModel.Dispose();
                    hv_ClassIDsDataset.Dispose();
                    hv_Index.Dispose();
                    hv_IndexFind.Dispose();
                    hv_ClassIDsModelStr.Dispose();
                    hv_ClassIDsDatasetStr.Dispose();
                    hv_DisplayParam.Dispose();
                    hv_DisplayKeys.Dispose();
                    hv_KeyName.Dispose();
                    hv_KeyValue.Dispose();
                    hv_TrainParamCopy.Dispose();
                    hv__.Dispose();

                    return;
                }
                //
                //Check parameters for other models.
                //
                //Check the NumEpochs parameter.
                if ((int)(hv_StartEpoch.TupleIsNumber()) != 0)
                {
                    hv_NumEpochs.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainParam, "num_epochs", out hv_NumEpochs);
                    if ((int)(new HTuple(hv_StartEpoch.TupleGreater(hv_NumEpochs))) != 0)
                    {
                        throw new HalconException("Error: StartEpoch > NumEpochs is not allowed.");
                    }
                }
                else
                {
                    if ((int)(new HTuple(hv_StartEpoch.TupleNotEqual("resume"))) != 0)
                    {
                        throw new HalconException("Error: StartEpoch has to be a number or equal to 'resume'.");
                    }
                }
                //
                //Check that the number of training samples is at least as big as the total batch size.
                hv_BatchSizeDevice.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "batch_size", out hv_BatchSizeDevice);
                hv_BatchSizeMultiplier.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "batch_size_multiplier", out hv_BatchSizeMultiplier);
                hv_BatchSize.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_BatchSize = hv_BatchSizeDevice * hv_BatchSizeMultiplier;
                }
                if ((int)(new HTuple(hv_NumTrainSamples.TupleLess(hv_BatchSize))) != 0)
                {
                    throw new HalconException("Error: Number of training samples is smaller than the batch size.");
                }
                //
                //Check that all model class IDs are a part of the DLDataset class IDs.
                hv_ClassIDsModel.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "class_ids", out hv_ClassIDsModel);
                hv_ClassIDsDataset.Dispose();
                HOperatorSet.GetDictTuple(hv_DLDataset, "class_ids", out hv_ClassIDsDataset);
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_ClassIDsModel.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_IndexFind.Dispose();
                        HOperatorSet.TupleFindFirst(hv_ClassIDsDataset, hv_ClassIDsModel.TupleSelect(
                            hv_Index), out hv_IndexFind);
                    }
                    if ((int)(new HTuple(hv_IndexFind.TupleLess(0))) != 0)
                    {
                        hv_ClassIDsModelStr.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClassIDsModelStr = ((" " + hv_ClassIDsModel)).TupleSum()
                                ;
                        }
                        hv_ClassIDsDatasetStr.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClassIDsDatasetStr = ((" " + hv_ClassIDsDataset)).TupleSum()
                                ;
                        }
                        throw new HalconException((((("Error: A model class ID is not part of the DLDataset class IDs. DLModelHandle class ID: " + hv_ClassIDsModelStr) + ". ") + "DLDataset class IDs: ") + hv_ClassIDsDatasetStr) + ".");
                    }
                }
                //
                //Check display parameters.
                hv_DisplayParam.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainParam, "display_param", out hv_DisplayParam);
                hv_DisplayKeys.Dispose();
                HOperatorSet.GetDictParam(hv_DisplayParam, "keys", new HTuple(), out hv_DisplayKeys);
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_DisplayKeys.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    hv_KeyName.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_KeyName = hv_DisplayKeys.TupleSelect(
                            hv_Index);
                    }
                    if ((int)(new HTuple(hv_KeyName.TupleEqual("enabled"))) != 0)
                    {
                        hv_KeyValue.Dispose();
                        HOperatorSet.GetDictTuple(hv_DisplayParam, hv_KeyName, out hv_KeyValue);
                        if ((int)((new HTuple(hv_KeyValue.TupleNotEqual(1))).TupleAnd(new HTuple(hv_KeyValue.TupleNotEqual(
                            0)))) != 0)
                        {
                            throw new HalconException("The value for 'enabled' is not supported.");
                        }
                    }
                    else if ((int)(new HTuple(hv_KeyName.TupleEqual("change_plot_interval_seconds"))) != 0)
                    {
                        hv_KeyValue.Dispose();
                        HOperatorSet.GetDictTuple(hv_DisplayParam, hv_KeyName, out hv_KeyValue);
                        if ((int)((new HTuple(((hv_KeyValue.TupleIsInt())).TupleOr(hv_KeyValue.TupleIsReal()
                            ))).TupleNot()) != 0)
                        {
                            throw new HalconException("The value of 'change_plot_interval_seconds' has to be of type integer or real");
                        }
                    }
                    else if ((int)(new HTuple(hv_KeyName.TupleEqual("num_images"))) != 0)
                    {
                        hv_KeyValue.Dispose();
                        HOperatorSet.GetDictTuple(hv_DisplayParam, hv_KeyName, out hv_KeyValue);
                        if ((int)((new HTuple(((hv_KeyValue.TupleIsInt())).TupleNot())).TupleOr(
                            new HTuple(hv_KeyValue.TupleLess(1)))) != 0)
                        {
                            throw new HalconException("The value of 'num_images' has to be of type integer and larger or equal to one");
                        }
                    }
                    else if ((int)(new HTuple(hv_KeyName.TupleEqual("selected_percentage_train_samples"))) != 0)
                    {
                        hv_KeyValue.Dispose();
                        HOperatorSet.GetDictTuple(hv_DisplayParam, hv_KeyName, out hv_KeyValue);
                        if ((int)((new HTuple(((hv_KeyValue.TupleIsInt())).TupleOr(hv_KeyValue.TupleIsReal()
                            ))).TupleNot()) != 0)
                        {
                            throw new HalconException("The value of 'selected_percentage_train_samples' has to be of type integer or real");
                        }
                        if ((int)((new HTuple(hv_KeyValue.TupleLess(0))).TupleOr(new HTuple(hv_KeyValue.TupleGreater(
                            100)))) != 0)
                        {
                            throw new HalconException(new HTuple("The value of 'selected_percentage_train_samples' has to be in [0,100]"));
                        }
                    }
                    else if ((int)(new HTuple(hv_KeyName.TupleEqual("update_images_interval_epochs"))) != 0)
                    {
                        hv_KeyValue.Dispose();
                        HOperatorSet.GetDictTuple(hv_DisplayParam, hv_KeyName, out hv_KeyValue);
                        if ((int)((new HTuple(((hv_KeyValue.TupleIsInt())).TupleOr(hv_KeyValue.TupleIsReal()
                            ))).TupleNot()) != 0)
                        {
                            throw new HalconException("The value of 'update_images_interval_epochs' has to be of type integer or real");
                        }
                        if ((int)(new HTuple(hv_KeyValue.TupleLessEqual(0))) != 0)
                        {
                            throw new HalconException("The value of 'update_images_interval_epochs' has to be larger than zero");
                        }
                    }
                    else if ((int)(new HTuple(hv_KeyName.TupleEqual("x_axis_label"))) != 0)
                    {
                        hv_KeyValue.Dispose();
                        HOperatorSet.GetDictTuple(hv_DisplayParam, hv_KeyName, out hv_KeyValue);
                        if ((int)((new HTuple(hv_KeyValue.TupleNotEqual("epochs"))).TupleAnd(new HTuple(hv_KeyValue.TupleNotEqual(
                            "iterations")))) != 0)
                        {
                            throw new HalconException("The value for 'x_axis_label' is not supported.");
                        }
                    }
                    else if ((int)((new HTuple((new HTuple(hv_KeyName.TupleEqual("status_model_params"))).TupleOr(
                        new HTuple(hv_KeyName.TupleEqual("tiled_param"))))).TupleOr(new HTuple(hv_KeyName.TupleEqual(
                        "randomize_images")))) != 0)
                    {
                        //No check for these advanced settings.
                        //No check for randomize_images for backward compatibility.
                        continue;
                    }
                    else
                    {
                        throw new HalconException(("The provided key " + hv_KeyName) + " for 'display' is invalid.");
                    }
                }
                //
                //Initialize change and serialization strategies in order to test for valid values.
                hv_TrainParamCopy.Dispose();
                HOperatorSet.CopyDict(hv_TrainParam, new HTuple(), new HTuple(), out hv_TrainParamCopy);
                hv__.Dispose();
                init_train_dl_model_change_strategies(hv_TrainParamCopy, out hv__);
                hv__.Dispose();
                init_train_dl_model_serialization_strategies(hv_TrainParamCopy, out hv__);
                //

                hv_ModelType.Dispose();
                hv_PreprocessedDataset.Dispose();
                hv_PreprocessParam.Dispose();
                hv_Exception.Dispose();
                hv_TrainParamAnomaly.Dispose();
                hv_DomainRatio.Dispose();
                hv_ErrorThreshold.Dispose();
                hv_RegularizationNoise.Dispose();
                hv_NumEpochs.Dispose();
                hv_BatchSizeDevice.Dispose();
                hv_BatchSizeMultiplier.Dispose();
                hv_BatchSize.Dispose();
                hv_ClassIDsModel.Dispose();
                hv_ClassIDsDataset.Dispose();
                hv_Index.Dispose();
                hv_IndexFind.Dispose();
                hv_ClassIDsModelStr.Dispose();
                hv_ClassIDsDatasetStr.Dispose();
                hv_DisplayParam.Dispose();
                hv_DisplayKeys.Dispose();
                hv_KeyName.Dispose();
                hv_KeyValue.Dispose();
                hv_TrainParamCopy.Dispose();
                hv__.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ModelType.Dispose();
                hv_PreprocessedDataset.Dispose();
                hv_PreprocessParam.Dispose();
                hv_Exception.Dispose();
                hv_TrainParamAnomaly.Dispose();
                hv_DomainRatio.Dispose();
                hv_ErrorThreshold.Dispose();
                hv_RegularizationNoise.Dispose();
                hv_NumEpochs.Dispose();
                hv_BatchSizeDevice.Dispose();
                hv_BatchSizeMultiplier.Dispose();
                hv_BatchSize.Dispose();
                hv_ClassIDsModel.Dispose();
                hv_ClassIDsDataset.Dispose();
                hv_Index.Dispose();
                hv_IndexFind.Dispose();
                hv_ClassIDsModelStr.Dispose();
                hv_ClassIDsDatasetStr.Dispose();
                hv_DisplayParam.Dispose();
                hv_DisplayKeys.Dispose();
                hv_KeyName.Dispose();
                hv_KeyValue.Dispose();
                hv_TrainParamCopy.Dispose();
                hv__.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Collect the information required for displaying the training progress update. 
        private void collect_train_dl_model_info(HTuple hv_DLModelHandle, HTuple hv_TrainResults,
            HTuple hv_EvaluationInfos, HTuple hv_EvaluationComparisonKeys, HTuple hv_Iteration,
            HTuple hv_NumIterations, HTuple hv_NumIterationsPerEpoch, HTuple hv_NumSamplesMeanLoss,
            out HTuple hv_TrainInfo)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_EpochReal = new HTuple(), hv_NumEpochs = new HTuple();
            HTuple hv_TrainResultsStored = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_ModelType = new HTuple(), hv_PossibleParamNames = new HTuple();
            HTuple hv_ModelParams = new HTuple(), hv_Index = new HTuple();
            HTuple hv_ParamName = new HTuple(), hv_DeviceHandles = new HTuple();
            HTuple hv_DeviceLength = new HTuple(), hv_DeviceTypes = new HTuple();
            HTuple hv_DeviceNames = new HTuple(), hv_DeviceIndex = new HTuple();
            HTuple hv_DeviceType = new HTuple(), hv_DeviceName = new HTuple();
            HTuple hv_GenParamValue = new HTuple(), hv_LossSamplesTrainResults = new HTuple();
            HTuple hv_Indices = new HTuple(), hv_TrainResultsUsed = new HTuple();
            HTuple hv_BatchSizeDevice = new HTuple(), hv_BatchSizeMultiplier = new HTuple();
            HTuple hv_BatchSize = new HTuple(), hv_NumIterationsMean = new HTuple();
            HTuple hv_LossParam = new HTuple(), hv_LossValues = new HTuple();
            HTuple hv_TrainResult = new HTuple(), hv_LossValue = new HTuple();
            HTuple hv_LossMean = new HTuple(), hv_BestEvaluationInfo = new HTuple();
            HTuple hv_BestEvaluationInfoTrain = new HTuple(), hv_BestEvaluationValue = new HTuple();
            HTuple hv_BestEvaluationValueTrain = new HTuple(), hv_BestEvaluationKeys = new HTuple();
            HTuple hv_BestEvaluationKeysTrain = new HTuple(), hv_EvaluationInfo = new HTuple();
            HTuple hv_ValidationEvaluationResult = new HTuple(), hv_TrainEvaluationResult = new HTuple();
            HTuple hv_Value = new HTuple(), hv_ValidEvaluationKeys = new HTuple();
            HTuple hv_ValueTrain = new HTuple(), hv_ValidEvaluationKeysTrain = new HTuple();
            HTuple hv_BestEvaluationData = new HTuple();
            // Initialize local and output iconic variables 
            hv_TrainInfo = new HTuple();
            try
            {
                //
                //This procedure computes training information for the given iteration.
                //
                hv_TrainInfo.Dispose();
                HOperatorSet.CreateDict(out hv_TrainInfo);
                //
                //General iteration and epoch status.
                hv_EpochReal.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_EpochReal = (hv_Iteration + 1) / (hv_NumIterationsPerEpoch.TupleReal()
                        );
                }
                //Important note:
                //Inside of this procedure, we compute iterations like that:
                //*  IterationTmp := int(round(EpochReal * (NumIterationsPerEpoch))-1)
                //If a caller of this procedure supplies a value we should use:
                //*  IterationTmp := int(floor(EpochReal * NumIterationsPerEpoch))
                //
                hv_NumEpochs.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumEpochs = hv_NumIterations / (hv_NumIterationsPerEpoch.TupleReal()
                        );
                }
                //
                //Note, iterations depend on a specific batch size,
                //hence only epochs are expressive.
                HOperatorSet.SetDictTuple(hv_TrainInfo, "epoch", hv_EpochReal);
                HOperatorSet.SetDictTuple(hv_TrainInfo, "num_epochs", hv_NumEpochs);
                HOperatorSet.SetDictTuple(hv_TrainInfo, "num_iterations_per_epoch", hv_NumIterationsPerEpoch);
                //
                try
                {
                    hv_TrainResultsStored.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TrainResultsStored = hv_TrainResults.TupleSelect(
                            ((hv_TrainResults.TupleNotEqualElem(-1))).TupleFind(1));
                    }
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    hv_TrainResultsStored.Dispose();
                    hv_TrainResultsStored = new HTuple();
                }
                //
                //Collect all model parameters.
                hv_ModelType.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "type", out hv_ModelType);
                hv_PossibleParamNames.Dispose();
                HOperatorSet.GetParamInfo("get_dl_model_param", "GenParamName", "value_list",
                    out hv_PossibleParamNames);
                hv_ModelParams.Dispose();
                HOperatorSet.CreateDict(out hv_ModelParams);
                HOperatorSet.SetDictTuple(hv_TrainInfo, "model_params", hv_ModelParams);
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_PossibleParamNames.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    hv_ParamName.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ParamName = hv_PossibleParamNames.TupleSelect(
                            hv_Index);
                    }
                    //Do not collect summary as it cannot change during training and consumes much space.
                    if ((int)(new HTuple(hv_ParamName.TupleEqual("summary"))) != 0)
                    {
                        continue;
                    }
                    //
                    try
                    {
                        if ((int)(new HTuple(hv_ParamName.TupleEqual("device"))) != 0)
                        {
                            //The device handle cannot be serialized. Therefore we get the
                            //information via keys and serialize them.
                            hv_DeviceHandles.Dispose();
                            HOperatorSet.GetDlModelParam(hv_DLModelHandle, hv_ParamName, out hv_DeviceHandles);
                            hv_DeviceLength.Dispose();
                            HOperatorSet.TupleLength(hv_DeviceHandles, out hv_DeviceLength);
                            hv_DeviceTypes.Dispose();
                            hv_DeviceTypes = new HTuple();
                            hv_DeviceNames.Dispose();
                            hv_DeviceNames = new HTuple();
                            hv_DeviceTypes.Dispose();
                            HOperatorSet.TupleGenConst(hv_DeviceLength, "", out hv_DeviceTypes);
                            hv_DeviceNames.Dispose();
                            HOperatorSet.TupleGenConst(hv_DeviceLength, "", out hv_DeviceNames);
                            for (hv_DeviceIndex = 0; (int)hv_DeviceIndex <= (int)((new HTuple(hv_DeviceLength.TupleLength()
                                )) - 1); hv_DeviceIndex = (int)hv_DeviceIndex + 1)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_DeviceType.Dispose();
                                    HOperatorSet.GetHandleTuple(hv_DeviceHandles.TupleSelect(hv_DeviceIndex),
                                        "type", out hv_DeviceType);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_DeviceName.Dispose();
                                    HOperatorSet.GetHandleTuple(hv_DeviceHandles.TupleSelect(hv_DeviceIndex),
                                        "name", out hv_DeviceName);
                                }
                                if (hv_DeviceTypes == null)
                                    hv_DeviceTypes = new HTuple();
                                hv_DeviceTypes[hv_DeviceIndex] = hv_DeviceType;
                                if (hv_DeviceNames == null)
                                    hv_DeviceNames = new HTuple();
                                hv_DeviceNames[hv_DeviceIndex] = hv_DeviceName;
                            }
                        }
                        else
                        {
                            hv_GenParamValue.Dispose();
                            HOperatorSet.GetDlModelParam(hv_DLModelHandle, hv_ParamName, out hv_GenParamValue);
                        }
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException1)
                    {
                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        continue;
                    }
                    //
                    if ((int)(new HTuple(hv_ParamName.TupleEqual("device"))) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_ModelParams, "device_type", hv_DeviceTypes);
                        HOperatorSet.SetDictTuple(hv_ModelParams, "device_name", hv_DeviceNames);
                    }
                    else
                    {
                        HOperatorSet.SetDictTuple(hv_ModelParams, hv_ParamName, hv_GenParamValue);
                    }
                }
                //
                //Calculate a mean loss value.
                HOperatorSet.SetDictTuple(hv_TrainInfo, "mean_loss", new HTuple());
                HOperatorSet.SetDictTuple(hv_TrainInfo, "mean_loss_samples", 0);
                //
                hv_LossSamplesTrainResults.Dispose();
                hv_LossSamplesTrainResults = new HTuple();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Indices.Dispose();
                    HOperatorSet.TupleFind(hv_TrainResults.TupleNotEqualElem(-1), 1, out hv_Indices);
                }
                if ((int)(new HTuple(hv_Indices.TupleNotEqual(-1))) != 0)
                {
                    hv_TrainResultsUsed.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TrainResultsUsed = hv_TrainResults.TupleSelect(
                            hv_Indices);
                    }
                }
                else
                {
                    hv_TrainResultsUsed.Dispose();
                    hv_TrainResultsUsed = new HTuple();
                }
                if ((int)(new HTuple((new HTuple(hv_TrainResultsUsed.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    hv_BatchSizeDevice.Dispose();
                    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "batch_size", out hv_BatchSizeDevice);
                    hv_BatchSizeMultiplier.Dispose();
                    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "batch_size_multiplier", out hv_BatchSizeMultiplier);
                    hv_BatchSize.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BatchSize = hv_BatchSizeDevice * hv_BatchSizeMultiplier;
                    }
                    hv_NumIterationsMean.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumIterationsMean = ((((hv_NumSamplesMeanLoss / (hv_BatchSize.TupleReal()
                            ))).TupleCeil())).TupleInt();
                    }
                    //
                    if ((int)(new HTuple(hv_NumIterationsMean.TupleEqual(0))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_TrainResultsUsed = hv_TrainResultsUsed.TupleSelect(
                                    (new HTuple(hv_TrainResultsUsed.TupleLength())) - 1);
                                hv_TrainResultsUsed.Dispose();
                                hv_TrainResultsUsed = ExpTmpLocalVar_TrainResultsUsed;
                            }
                        }
                    }
                    else
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_TrainResultsUsed = hv_TrainResultsUsed.TupleSelectRange(
                                    (((new HTuple(hv_TrainResultsUsed.TupleLength())) - hv_NumIterationsMean)).TupleMax2(
                                    0), (new HTuple(hv_TrainResultsUsed.TupleLength())) - 1);
                                hv_TrainResultsUsed.Dispose();
                                hv_TrainResultsUsed = ExpTmpLocalVar_TrainResultsUsed;
                            }
                        }
                    }
                    //
                    hv_LossParam.Dispose();
                    hv_LossParam = "total_loss";
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_LossValues.Dispose();
                        HOperatorSet.TupleGenConst(new HTuple(hv_TrainResultsUsed.TupleLength()),
                            -1, out hv_LossValues);
                    }
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_TrainResultsUsed.TupleLength()
                        )) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        hv_TrainResult.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TrainResult = hv_TrainResultsUsed.TupleSelect(
                                hv_Index);
                        }
                        hv_LossValue.Dispose();
                        HOperatorSet.GetDictTuple(hv_TrainResult, hv_LossParam, out hv_LossValue);
                        if (hv_LossValues == null)
                            hv_LossValues = new HTuple();
                        hv_LossValues[hv_Index] = hv_LossValue;
                    }
                    hv_LossMean.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_LossMean = hv_LossValues.TupleMean()
                            ;
                    }
                    HOperatorSet.SetDictTuple(hv_TrainInfo, "mean_loss", hv_LossMean);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_TrainInfo, "mean_loss_samples", new HTuple(hv_LossValues.TupleLength()
                            ));
                    }
                }
                //
                //Collect the best evaluation infos.
                hv_BestEvaluationInfo.Dispose();
                hv_BestEvaluationInfo = new HTuple();
                hv_BestEvaluationInfoTrain.Dispose();
                hv_BestEvaluationInfoTrain = new HTuple();
                hv_BestEvaluationValue.Dispose();
                hv_BestEvaluationValue = new HTuple();
                hv_BestEvaluationValueTrain.Dispose();
                hv_BestEvaluationValueTrain = new HTuple();
                hv_BestEvaluationKeys.Dispose();
                hv_BestEvaluationKeys = new HTuple();
                hv_BestEvaluationKeysTrain.Dispose();
                hv_BestEvaluationKeysTrain = new HTuple();
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_EvaluationInfos.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    hv_EvaluationInfo.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_EvaluationInfo = hv_EvaluationInfos.TupleSelect(
                            hv_Index);
                    }
                    //Ignore missing infos
                    if ((int)(new HTuple(hv_EvaluationInfo.TupleEqual(-1))) != 0)
                    {
                        continue;
                    }
                    //
                    hv_ValidationEvaluationResult.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvaluationInfo, "result", out hv_ValidationEvaluationResult);
                    hv_TrainEvaluationResult.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvaluationInfo, "result_train", out hv_TrainEvaluationResult);
                    //
                    //Reduce the result to a single (mean) value.
                    hv_Value.Dispose(); hv_ValidEvaluationKeys.Dispose();
                    reduce_dl_evaluation_result(hv_ValidationEvaluationResult, hv_EvaluationComparisonKeys,
                        out hv_Value, out hv_ValidEvaluationKeys);
                    hv_ValueTrain.Dispose(); hv_ValidEvaluationKeysTrain.Dispose();
                    reduce_dl_evaluation_result(hv_TrainEvaluationResult, hv_EvaluationComparisonKeys,
                        out hv_ValueTrain, out hv_ValidEvaluationKeysTrain);
                    //
                    //Compare current evaluation result with the best one.
                    if ((int)(new HTuple(hv_ModelType.TupleEqual("classification"))) != 0)
                    {
                        //Validation.
                        if ((int)((new HTuple((new HTuple(hv_BestEvaluationInfo.TupleLength())).TupleEqual(
                            0))).TupleOr(new HTuple(hv_Value.TupleLessEqual(hv_BestEvaluationValue)))) != 0)
                        {
                            hv_BestEvaluationInfo.Dispose();
                            hv_BestEvaluationInfo = new HTuple(hv_EvaluationInfo);
                            hv_BestEvaluationValue.Dispose();
                            hv_BestEvaluationValue = new HTuple(hv_Value);
                            hv_BestEvaluationKeys.Dispose();
                            hv_BestEvaluationKeys = new HTuple(hv_ValidEvaluationKeys);
                        }
                        //Training.
                        if ((int)((new HTuple((new HTuple(hv_BestEvaluationInfoTrain.TupleLength()
                            )).TupleEqual(0))).TupleOr(new HTuple(hv_ValueTrain.TupleLessEqual(
                            hv_BestEvaluationValueTrain)))) != 0)
                        {
                            hv_BestEvaluationInfoTrain.Dispose();
                            hv_BestEvaluationInfoTrain = new HTuple(hv_EvaluationInfo);
                            hv_BestEvaluationValueTrain.Dispose();
                            hv_BestEvaluationValueTrain = new HTuple(hv_ValueTrain);
                            hv_BestEvaluationKeysTrain.Dispose();
                            hv_BestEvaluationKeysTrain = new HTuple(hv_ValidEvaluationKeysTrain);
                        }
                    }
                    else
                    {
                        //Validation.
                        if ((int)((new HTuple((new HTuple(hv_BestEvaluationInfo.TupleLength())).TupleEqual(
                            0))).TupleOr(new HTuple(hv_Value.TupleGreaterEqual(hv_BestEvaluationValue)))) != 0)
                        {
                            hv_BestEvaluationInfo.Dispose();
                            hv_BestEvaluationInfo = new HTuple(hv_EvaluationInfo);
                            hv_BestEvaluationValue.Dispose();
                            hv_BestEvaluationValue = new HTuple(hv_Value);
                            hv_BestEvaluationKeys.Dispose();
                            hv_BestEvaluationKeys = new HTuple(hv_ValidEvaluationKeys);
                        }
                        //Training.
                        if ((int)((new HTuple((new HTuple(hv_BestEvaluationInfoTrain.TupleLength()
                            )).TupleEqual(0))).TupleOr(new HTuple(hv_ValueTrain.TupleGreaterEqual(
                            hv_BestEvaluationValueTrain)))) != 0)
                        {
                            hv_BestEvaluationInfoTrain.Dispose();
                            hv_BestEvaluationInfoTrain = new HTuple(hv_EvaluationInfo);
                            hv_BestEvaluationValueTrain.Dispose();
                            hv_BestEvaluationValueTrain = new HTuple(hv_ValueTrain);
                            hv_BestEvaluationKeysTrain.Dispose();
                            hv_BestEvaluationKeysTrain = new HTuple(hv_ValidEvaluationKeysTrain);
                        }
                    }
                }
                //
                //Store best evaluation information.
                if ((int)(new HTuple((new HTuple(hv_BestEvaluationInfo.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    hv_BestEvaluationData.Dispose();
                    HOperatorSet.CreateDict(out hv_BestEvaluationData);
                    HOperatorSet.SetDictTuple(hv_BestEvaluationData, "comparison_keys", hv_BestEvaluationKeys);
                    HOperatorSet.SetDictTuple(hv_BestEvaluationData, "best_info", hv_BestEvaluationInfo);
                    HOperatorSet.SetDictTuple(hv_BestEvaluationData, "best_value", hv_BestEvaluationValue);
                    HOperatorSet.SetDictTuple(hv_BestEvaluationData, "comparison_keys_train",
                        hv_BestEvaluationKeysTrain);
                    HOperatorSet.SetDictTuple(hv_BestEvaluationData, "best_info_train", hv_BestEvaluationInfoTrain);
                    HOperatorSet.SetDictTuple(hv_BestEvaluationData, "best_value_train", hv_BestEvaluationValueTrain);
                    HOperatorSet.SetDictTuple(hv_TrainInfo, "best_evaluation", hv_BestEvaluationData);
                }
                else
                {
                    HOperatorSet.SetDictTuple(hv_TrainInfo, "best_evaluation", new HTuple());
                }
                //

                hv_EpochReal.Dispose();
                hv_NumEpochs.Dispose();
                hv_TrainResultsStored.Dispose();
                hv_Exception.Dispose();
                hv_ModelType.Dispose();
                hv_PossibleParamNames.Dispose();
                hv_ModelParams.Dispose();
                hv_Index.Dispose();
                hv_ParamName.Dispose();
                hv_DeviceHandles.Dispose();
                hv_DeviceLength.Dispose();
                hv_DeviceTypes.Dispose();
                hv_DeviceNames.Dispose();
                hv_DeviceIndex.Dispose();
                hv_DeviceType.Dispose();
                hv_DeviceName.Dispose();
                hv_GenParamValue.Dispose();
                hv_LossSamplesTrainResults.Dispose();
                hv_Indices.Dispose();
                hv_TrainResultsUsed.Dispose();
                hv_BatchSizeDevice.Dispose();
                hv_BatchSizeMultiplier.Dispose();
                hv_BatchSize.Dispose();
                hv_NumIterationsMean.Dispose();
                hv_LossParam.Dispose();
                hv_LossValues.Dispose();
                hv_TrainResult.Dispose();
                hv_LossValue.Dispose();
                hv_LossMean.Dispose();
                hv_BestEvaluationInfo.Dispose();
                hv_BestEvaluationInfoTrain.Dispose();
                hv_BestEvaluationValue.Dispose();
                hv_BestEvaluationValueTrain.Dispose();
                hv_BestEvaluationKeys.Dispose();
                hv_BestEvaluationKeysTrain.Dispose();
                hv_EvaluationInfo.Dispose();
                hv_ValidationEvaluationResult.Dispose();
                hv_TrainEvaluationResult.Dispose();
                hv_Value.Dispose();
                hv_ValidEvaluationKeys.Dispose();
                hv_ValueTrain.Dispose();
                hv_ValidEvaluationKeysTrain.Dispose();
                hv_BestEvaluationData.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_EpochReal.Dispose();
                hv_NumEpochs.Dispose();
                hv_TrainResultsStored.Dispose();
                hv_Exception.Dispose();
                hv_ModelType.Dispose();
                hv_PossibleParamNames.Dispose();
                hv_ModelParams.Dispose();
                hv_Index.Dispose();
                hv_ParamName.Dispose();
                hv_DeviceHandles.Dispose();
                hv_DeviceLength.Dispose();
                hv_DeviceTypes.Dispose();
                hv_DeviceNames.Dispose();
                hv_DeviceIndex.Dispose();
                hv_DeviceType.Dispose();
                hv_DeviceName.Dispose();
                hv_GenParamValue.Dispose();
                hv_LossSamplesTrainResults.Dispose();
                hv_Indices.Dispose();
                hv_TrainResultsUsed.Dispose();
                hv_BatchSizeDevice.Dispose();
                hv_BatchSizeMultiplier.Dispose();
                hv_BatchSize.Dispose();
                hv_NumIterationsMean.Dispose();
                hv_LossParam.Dispose();
                hv_LossValues.Dispose();
                hv_TrainResult.Dispose();
                hv_LossValue.Dispose();
                hv_LossMean.Dispose();
                hv_BestEvaluationInfo.Dispose();
                hv_BestEvaluationInfoTrain.Dispose();
                hv_BestEvaluationValue.Dispose();
                hv_BestEvaluationValueTrain.Dispose();
                hv_BestEvaluationKeys.Dispose();
                hv_BestEvaluationKeysTrain.Dispose();
                hv_EvaluationInfo.Dispose();
                hv_ValidationEvaluationResult.Dispose();
                hv_TrainEvaluationResult.Dispose();
                hv_Value.Dispose();
                hv_ValidEvaluationKeys.Dispose();
                hv_ValueTrain.Dispose();
                hv_ValidEvaluationKeysTrain.Dispose();
                hv_BestEvaluationData.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Classification
        // Short Description: Calculate top-K error. 
        private void compute_top_k_error(HTuple hv_ImageLabelIDs, HTuple hv_TopKPredictions,
            HTuple hv_K, out HTuple hv_TopKError)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_NumMatches = new HTuple(), hv_Index = new HTuple();
            HTuple hv_Predictions = new HTuple(), hv_PredictedClasses = new HTuple();
            // Initialize local and output iconic variables 
            hv_TopKError = new HTuple();
            try
            {
                //
                //This procedure calculates the top-K error out of the given predictions and labels.
                //
                hv_NumMatches.Dispose();
                hv_NumMatches = 0;
                //
                //Loop through all selected ground truth labels.
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_ImageLabelIDs.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    //Get the K best results.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Predictions.Dispose();
                        HOperatorSet.GetDictTuple(hv_TopKPredictions.TupleSelect(hv_Index), "predictions",
                            out hv_Predictions);
                    }
                    hv_PredictedClasses.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_PredictedClasses = hv_Predictions.TupleSelectRange(
                            0, hv_K - 1);
                    }
                    //Count how often the ground truth label
                    //and K predicted classes match.
                    if ((int)(new HTuple(((hv_PredictedClasses.TupleFind(hv_ImageLabelIDs.TupleSelect(
                        hv_Index)))).TupleNotEqual(-1))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_NumMatches = hv_NumMatches + 1;
                                hv_NumMatches.Dispose();
                                hv_NumMatches = ExpTmpLocalVar_NumMatches;
                            }
                        }
                    }
                }
                hv_TopKError.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TopKError = 1.0 - ((hv_NumMatches.TupleReal()
                        ) / (new HTuple(hv_ImageLabelIDs.TupleLength())));
                }
                //

                hv_NumMatches.Dispose();
                hv_Index.Dispose();
                hv_Predictions.Dispose();
                hv_PredictedClasses.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_NumMatches.Dispose();
                hv_Index.Dispose();
                hv_Predictions.Dispose();
                hv_PredictedClasses.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Create a training parameter dictionary which is used in train_dl_model. 
        public void create_dl_train_param(HTuple hv_DLModelHandle, HTuple hv_NumEpochs,
            HTuple hv_EvaluationIntervalEpochs, HTuple hv_EnableDisplay, HTuple hv_RandomSeed,
            HTuple hv_GenParamName, HTuple hv_GenParamValue, out HTuple hv_TrainParam)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ModelType = new HTuple(), hv_AvailableGenParam = new HTuple();
            HTuple hv_IndexGenParam = new HTuple(), hv_IndexFind = new HTuple();
            HTuple hv_IsString = new HTuple(), hv_TrainParamAnomaly = new HTuple();
            HTuple hv_DomainRatioKeyExists = new HTuple(), hv_ErrorThresholdKeyExists = new HTuple();
            HTuple hv_RegularizationNoiseKeyExists = new HTuple();
            HTuple hv_DisplayParam = new HTuple(), hv_EvaluationParam = new HTuple();
            HTuple hv_AugmentationParam = new HTuple(), hv_ClassIDsNoOrientation = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_ChangeStrategies = new HTuple();
            HTuple hv_Indices = new HTuple(), hv_SerializationStrategy = new HTuple();
            HTuple hv_SerializationStrategies = new HTuple(), hv_Seconds = new HTuple();
            HTuple hv_SetDisplayParam = new HTuple(), hv_EvaluationComparisonKeys = new HTuple();
            HTuple hv_BestScoreHighest = new HTuple(), hv_ConvertToMean = new HTuple();
            HTuple hv_Index = new HTuple(), hv_FoundIndices = new HTuple();
            HTuple hv_EnableDisplay_COPY_INP_TMP = new HTuple(hv_EnableDisplay);
            HTuple hv_RandomSeed_COPY_INP_TMP = new HTuple(hv_RandomSeed);

            // Initialize local and output iconic variables 
            hv_TrainParam = new HTuple();
            try
            {
                //
                //This procedure creates a dictionary with all needed training parameters,
                //as required by train_dl_model as input.
                //
                //Check length of input GenParam tuple.
                if ((int)(new HTuple((new HTuple(hv_GenParamName.TupleLength())).TupleNotEqual(
                    new HTuple(hv_GenParamValue.TupleLength())))) != 0)
                {
                    throw new HalconException("GenParamName and GenParamValue have to have the same length.");
                }
                //
                //Some default parameters depend on model type.
                hv_ModelType.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "type", out hv_ModelType);
                if ((int)((new HTuple((new HTuple((new HTuple(hv_ModelType.TupleNotEqual("classification"))).TupleAnd(
                    new HTuple(hv_ModelType.TupleNotEqual("detection"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual(
                    "segmentation"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual("anomaly_detection")))) != 0)
                {
                    throw new HalconException(("Current model type is not supported: \"" + hv_ModelType) + "\"");
                }
                //
                //Check if the given GenParamName strings are available.
                if ((int)(new HTuple(hv_ModelType.TupleNotEqual("anomaly_detection"))) != 0)
                {
                    hv_AvailableGenParam.Dispose();
                    hv_AvailableGenParam = new HTuple();
                    hv_AvailableGenParam[0] = "evaluate";
                    hv_AvailableGenParam[1] = "augment";
                    hv_AvailableGenParam[2] = "change";
                    hv_AvailableGenParam[3] = "serialize";
                    hv_AvailableGenParam[4] = "display";
                }
                else
                {
                    hv_AvailableGenParam.Dispose();
                    hv_AvailableGenParam = "anomaly";
                }
                for (hv_IndexGenParam = 0; (int)hv_IndexGenParam <= (int)((new HTuple(hv_GenParamName.TupleLength()
                    )) - 1); hv_IndexGenParam = (int)hv_IndexGenParam + 1)
                {
                    hv_IndexFind.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_IndexFind = hv_AvailableGenParam.TupleFind(
                            hv_GenParamName.TupleSelect(hv_IndexGenParam));
                    }
                    if ((int)(new HTuple(hv_IndexFind.TupleEqual(-1))) != 0)
                    {
                        throw new HalconException(("The provided GenParamName " + (hv_GenParamName.TupleSelect(
                            hv_IndexGenParam))) + " is invalid.");
                    }
                }
                //
                //Check if display is enabled.
                hv_IsString.Dispose();
                HOperatorSet.TupleIsString(hv_EnableDisplay_COPY_INP_TMP, out hv_IsString);
                if ((int)(hv_IsString) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_EnableDisplay = new HTuple(hv_EnableDisplay_COPY_INP_TMP.TupleEqual(
                                "true"));
                            hv_EnableDisplay_COPY_INP_TMP.Dispose();
                            hv_EnableDisplay_COPY_INP_TMP = ExpTmpLocalVar_EnableDisplay;
                        }
                    }
                }
                else
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_EnableDisplay = new HTuple(hv_EnableDisplay_COPY_INP_TMP.TupleEqual(
                                1));
                            hv_EnableDisplay_COPY_INP_TMP.Dispose();
                            hv_EnableDisplay_COPY_INP_TMP = ExpTmpLocalVar_EnableDisplay;
                        }
                    }
                }
                //
                //Initialize the dictionary holding the training parameters.
                hv_TrainParam.Dispose();
                HOperatorSet.CreateDict(out hv_TrainParam);
                //
                //** User supplied parameters: ***
                //
                //Set training parameters for anomaly detection models.
                if ((int)(new HTuple(hv_ModelType.TupleEqual("anomaly_detection"))) != 0)
                {
                    hv_TrainParamAnomaly.Dispose();
                    get_genparam_single_value(hv_GenParamName, hv_GenParamValue, "anomaly", out hv_TrainParamAnomaly);
                    //Set default values in case no values are provided.
                    if ((int)(new HTuple(hv_TrainParamAnomaly.TupleEqual(new HTuple()))) != 0)
                    {
                        hv_TrainParamAnomaly.Dispose();
                        HOperatorSet.CreateDict(out hv_TrainParamAnomaly);
                    }
                    hv_DomainRatioKeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_TrainParamAnomaly, "key_exists", "domain_ratio",
                        out hv_DomainRatioKeyExists);
                    if ((int)(hv_DomainRatioKeyExists.TupleNot()) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_TrainParamAnomaly, "domain_ratio", 0.1);
                    }
                    hv_ErrorThresholdKeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_TrainParamAnomaly, "key_exists", "error_threshold",
                        out hv_ErrorThresholdKeyExists);
                    if ((int)(hv_ErrorThresholdKeyExists.TupleNot()) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_TrainParamAnomaly, "error_threshold", 0.001);
                    }
                    hv_RegularizationNoiseKeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_TrainParamAnomaly, "key_exists", "regularization_noise",
                        out hv_RegularizationNoiseKeyExists);
                    if ((int)(hv_RegularizationNoiseKeyExists.TupleNot()) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_TrainParamAnomaly, "regularization_noise",
                            0.0001);
                    }
                    //
                    HOperatorSet.SetDictTuple(hv_TrainParamAnomaly, "max_num_epochs", hv_NumEpochs);
                    HOperatorSet.SetDictTuple(hv_TrainParam, "anomaly_param", hv_TrainParamAnomaly);
                    hv_DisplayParam.Dispose();
                    HOperatorSet.CreateDict(out hv_DisplayParam);
                    HOperatorSet.SetDictTuple(hv_DisplayParam, "enabled", hv_EnableDisplay_COPY_INP_TMP);
                    HOperatorSet.SetDictTuple(hv_TrainParam, "display_param", hv_DisplayParam);

                    hv_EnableDisplay_COPY_INP_TMP.Dispose();
                    hv_RandomSeed_COPY_INP_TMP.Dispose();
                    hv_ModelType.Dispose();
                    hv_AvailableGenParam.Dispose();
                    hv_IndexGenParam.Dispose();
                    hv_IndexFind.Dispose();
                    hv_IsString.Dispose();
                    hv_TrainParamAnomaly.Dispose();
                    hv_DomainRatioKeyExists.Dispose();
                    hv_ErrorThresholdKeyExists.Dispose();
                    hv_RegularizationNoiseKeyExists.Dispose();
                    hv_DisplayParam.Dispose();
                    hv_EvaluationParam.Dispose();
                    hv_AugmentationParam.Dispose();
                    hv_ClassIDsNoOrientation.Dispose();
                    hv_Exception.Dispose();
                    hv_ChangeStrategies.Dispose();
                    hv_Indices.Dispose();
                    hv_SerializationStrategy.Dispose();
                    hv_SerializationStrategies.Dispose();
                    hv_Seconds.Dispose();
                    hv_SetDisplayParam.Dispose();
                    hv_EvaluationComparisonKeys.Dispose();
                    hv_BestScoreHighest.Dispose();
                    hv_ConvertToMean.Dispose();
                    hv_Index.Dispose();
                    hv_FoundIndices.Dispose();

                    return;
                }
                //
                //Set training parameters for non-anomaly models.
                //
                //Number of epochs to train the model on the train split of the dataset.
                HOperatorSet.SetDictTuple(hv_TrainParam, "num_epochs", hv_NumEpochs);
                //
                //Interval (in epochs) to evaluate the model on the validation split of the dataset.
                HOperatorSet.SetDictTuple(hv_TrainParam, "evaluation_interval_epochs", hv_EvaluationIntervalEpochs);
                //
                //Transfer evaluation parameters used in further steps.
                hv_EvaluationParam.Dispose();
                get_genparam_single_value(hv_GenParamName, hv_GenParamValue, "evaluate", out hv_EvaluationParam);
                HOperatorSet.SetDictTuple(hv_TrainParam, "evaluation_param", hv_EvaluationParam);
                //
                //Transfer augmentation parameters used in further steps.
                hv_AugmentationParam.Dispose();
                get_genparam_single_value(hv_GenParamName, hv_GenParamValue, "augment", out hv_AugmentationParam);
                if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
                {
                    //In addition, add class IDs without orientation, since these classes require
                    //special treatment during the augmentation.
                    try
                    {
                        hv_ClassIDsNoOrientation.Dispose();
                        HOperatorSet.GetDlModelParam(hv_DLModelHandle, "class_ids_no_orientation",
                            out hv_ClassIDsNoOrientation);
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException1)
                    {
                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        hv_ClassIDsNoOrientation.Dispose();
                        hv_ClassIDsNoOrientation = new HTuple();
                    }
                    if ((int)(new HTuple((new HTuple(hv_ClassIDsNoOrientation.TupleLength())).TupleGreater(
                        0))) != 0)
                    {
                        if ((int)(new HTuple(hv_AugmentationParam.TupleEqual(new HTuple()))) != 0)
                        {
                            hv_AugmentationParam.Dispose();
                            HOperatorSet.CreateDict(out hv_AugmentationParam);
                        }
                        HOperatorSet.SetDictTuple(hv_AugmentationParam, "class_ids_no_orientation",
                            hv_ClassIDsNoOrientation);
                    }
                }
                HOperatorSet.SetDictTuple(hv_TrainParam, "augmentation_param", hv_AugmentationParam);
                //
                //Change strategies for any parameters that need to be changed during training.
                hv_ChangeStrategies.Dispose();
                get_genparam_single_value(hv_GenParamName, hv_GenParamValue, "change", out hv_ChangeStrategies);
                HOperatorSet.SetDictTuple(hv_TrainParam, "change_strategies", hv_ChangeStrategies);
                //
                //Serialization strategies used during training.
                hv_Indices.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Indices = hv_GenParamName.TupleFind(
                        "serialize");
                }
                if ((int)((new HTuple((new HTuple(hv_Indices.TupleLength())).TupleEqual(0))).TupleOr(
                    new HTuple(hv_Indices.TupleEqual(-1)))) != 0)
                {
                    //Set a default in case no value is provided.
                    hv_SerializationStrategy.Dispose();
                    HOperatorSet.CreateDict(out hv_SerializationStrategy);
                    HOperatorSet.SetDictTuple(hv_SerializationStrategy, "type", "best");
                    HOperatorSet.SetDictTuple(hv_SerializationStrategy, "basename", "model_best");
                    hv_SerializationStrategies.Dispose();
                    hv_SerializationStrategies = new HTuple(hv_SerializationStrategy);
                }
                else
                {
                    //Set user provided values.
                    hv_SerializationStrategies.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SerializationStrategies = hv_GenParamValue.TupleSelect(
                            hv_Indices);
                    }
                }
                HOperatorSet.SetDictTuple(hv_TrainParam, "serialization_strategies", hv_SerializationStrategies);
                //
                //Get random seed or set a useful default value.
                if ((int)(new HTuple((new HTuple(hv_RandomSeed_COPY_INP_TMP.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_TrainParam, "seed_rand", hv_RandomSeed_COPY_INP_TMP);
                }
                else
                {
                    //If no random seed is given we will use system time as a default.
                    hv_Seconds.Dispose();
                    HOperatorSet.CountSeconds(out hv_Seconds);
                    hv_RandomSeed_COPY_INP_TMP.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_RandomSeed_COPY_INP_TMP = hv_Seconds.TupleInt()
                            ;
                    }
                    HOperatorSet.SetDictTuple(hv_TrainParam, "seed_rand", hv_RandomSeed_COPY_INP_TMP);
                }
                //
                //** Display parameters: ***
                //
                //Create display parameter dictionary.
                hv_SetDisplayParam.Dispose();
                get_genparam_single_value(hv_GenParamName, hv_GenParamValue, "display", out hv_SetDisplayParam);
                if ((int)(new HTuple(hv_SetDisplayParam.TupleNotEqual(new HTuple()))) != 0)
                {
                    hv_DisplayParam.Dispose();
                    hv_DisplayParam = new HTuple(hv_SetDisplayParam);
                }
                else
                {
                    hv_DisplayParam.Dispose();
                    HOperatorSet.CreateDict(out hv_DisplayParam);
                }
                //
                HOperatorSet.SetDictTuple(hv_DisplayParam, "enabled", hv_EnableDisplay_COPY_INP_TMP);
                HOperatorSet.SetDictTuple(hv_TrainParam, "display_param", hv_DisplayParam);
                //
                //** Generic internal defaults: ***
                //
                //Default update interval (in seconds) of TrainInfo calculation and text/plot updates
                //in case display is enabled.
                HOperatorSet.SetDictTuple(hv_TrainParam, "update_interval_seconds", 2);
                //
                //Evaluation comparison keys. Note, that internally only those keys apply which
                //are really available. No error is thrown as long as a valid key is given.
                //Hence, we use the major defaults here for classification ('top1_error'),
                //for detection ('mean_ap'), and for segmentation ('mean_iou') if no valid key
                //is given.
                //We also set the BestScoreHighest value which describes which value should
                //achieved during the training of the chosen evaluation key.
                //For evaluation keys the score is maximized/minimized.
                hv_EvaluationComparisonKeys.Dispose();
                hv_EvaluationComparisonKeys = new HTuple();
                hv_BestScoreHighest.Dispose();
                hv_BestScoreHighest = new HTuple();
                //
                try
                {
                    hv_EvaluationComparisonKeys.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvaluationParam, "measures", out hv_EvaluationComparisonKeys);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                }
                //
                if ((int)(new HTuple(hv_EvaluationComparisonKeys.TupleEqual(new HTuple()))) != 0)
                {
                    if ((int)(new HTuple(hv_ModelType.TupleEqual("classification"))) != 0)
                    {
                        hv_EvaluationComparisonKeys.Dispose();
                        hv_EvaluationComparisonKeys = "top1_error";
                        hv_BestScoreHighest.Dispose();
                        hv_BestScoreHighest = 0;
                    }
                    else if ((int)(new HTuple(hv_ModelType.TupleEqual("segmentation"))) != 0)
                    {
                        hv_EvaluationComparisonKeys.Dispose();
                        hv_EvaluationComparisonKeys = "mean_iou";
                        hv_BestScoreHighest.Dispose();
                        hv_BestScoreHighest = 1;
                    }
                    else if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
                    {
                        hv_EvaluationComparisonKeys.Dispose();
                        hv_EvaluationComparisonKeys = "mean_ap";
                        hv_BestScoreHighest.Dispose();
                        hv_BestScoreHighest = 1;
                    }
                }
                else
                {
                    hv_BestScoreHighest.Dispose();
                    hv_BestScoreHighest = 1;
                }
                //
                //If the evaluation metric is 'precision', 'recall', 'f_score', or
                //'soap' we always take the mean value.
                hv_ConvertToMean.Dispose();
                hv_ConvertToMean = new HTuple();
                hv_ConvertToMean[0] = "precision";
                hv_ConvertToMean[1] = "recall";
                hv_ConvertToMean[2] = "f_score";
                hv_ConvertToMean[3] = "soap";
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_ConvertToMean.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    hv_FoundIndices.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_FoundIndices = ((hv_EvaluationComparisonKeys.TupleEqualElem(
                            hv_ConvertToMean.TupleSelect(hv_Index)))).TupleFind(1);
                    }
                    if ((int)(new HTuple(hv_FoundIndices.TupleNotEqual(-1))) != 0)
                    {
                        if (hv_EvaluationComparisonKeys == null)
                            hv_EvaluationComparisonKeys = new HTuple();
                        hv_EvaluationComparisonKeys[hv_FoundIndices] = "mean_" + (hv_EvaluationComparisonKeys.TupleSelect(
                            hv_FoundIndices));
                        if ((int)(new HTuple(((hv_ConvertToMean.TupleSelect(hv_Index))).TupleEqual(
                            "soap"))) != 0)
                        {
                            if (hv_EvaluationComparisonKeys == null)
                                hv_EvaluationComparisonKeys = new HTuple();
                            hv_EvaluationComparisonKeys[hv_FoundIndices] = (hv_EvaluationComparisonKeys.TupleSelect(
                                hv_FoundIndices)) + "_tp";
                        }
                    }
                }
                //
                HOperatorSet.SetDictTuple(hv_TrainParam, "evaluation_comparison_keys", hv_EvaluationComparisonKeys);
                HOperatorSet.SetDictTuple(hv_TrainParam, "evaluation_comparison_keys_best_highest",
                    hv_BestScoreHighest);
                //
                //Number of samples used to average the loss during training. Note, this is used for display
                //and information calculation only and does not have an effect on training the model.
                HOperatorSet.SetDictTuple(hv_TrainParam, "num_samples_mean_loss", 1000);
                //

                hv_EnableDisplay_COPY_INP_TMP.Dispose();
                hv_RandomSeed_COPY_INP_TMP.Dispose();
                hv_ModelType.Dispose();
                hv_AvailableGenParam.Dispose();
                hv_IndexGenParam.Dispose();
                hv_IndexFind.Dispose();
                hv_IsString.Dispose();
                hv_TrainParamAnomaly.Dispose();
                hv_DomainRatioKeyExists.Dispose();
                hv_ErrorThresholdKeyExists.Dispose();
                hv_RegularizationNoiseKeyExists.Dispose();
                hv_DisplayParam.Dispose();
                hv_EvaluationParam.Dispose();
                hv_AugmentationParam.Dispose();
                hv_ClassIDsNoOrientation.Dispose();
                hv_Exception.Dispose();
                hv_ChangeStrategies.Dispose();
                hv_Indices.Dispose();
                hv_SerializationStrategy.Dispose();
                hv_SerializationStrategies.Dispose();
                hv_Seconds.Dispose();
                hv_SetDisplayParam.Dispose();
                hv_EvaluationComparisonKeys.Dispose();
                hv_BestScoreHighest.Dispose();
                hv_ConvertToMean.Dispose();
                hv_Index.Dispose();
                hv_FoundIndices.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_EnableDisplay_COPY_INP_TMP.Dispose();
                hv_RandomSeed_COPY_INP_TMP.Dispose();
                hv_ModelType.Dispose();
                hv_AvailableGenParam.Dispose();
                hv_IndexGenParam.Dispose();
                hv_IndexFind.Dispose();
                hv_IsString.Dispose();
                hv_TrainParamAnomaly.Dispose();
                hv_DomainRatioKeyExists.Dispose();
                hv_ErrorThresholdKeyExists.Dispose();
                hv_RegularizationNoiseKeyExists.Dispose();
                hv_DisplayParam.Dispose();
                hv_EvaluationParam.Dispose();
                hv_AugmentationParam.Dispose();
                hv_ClassIDsNoOrientation.Dispose();
                hv_Exception.Dispose();
                hv_ChangeStrategies.Dispose();
                hv_Indices.Dispose();
                hv_SerializationStrategy.Dispose();
                hv_SerializationStrategies.Dispose();
                hv_Seconds.Dispose();
                hv_SetDisplayParam.Dispose();
                hv_EvaluationComparisonKeys.Dispose();
                hv_BestScoreHighest.Dispose();
                hv_ConvertToMean.Dispose();
                hv_Index.Dispose();
                hv_FoundIndices.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Generate a dictionary EvalParams, which contains default values for evaluation parameters. 
        public void create_evaluation_default_param(HTuple hv_EvaluationType, HTuple hv_ClassIDsModel,
            out HTuple hv_EvalParams)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_AvailableEvaluationTypes = new HTuple();
            HTuple hv_EvaluationTypesStr = new HTuple(), hv_Indices = new HTuple();
            HTuple hv_EvaluateInstances = new HTuple(), hv_Measures = new HTuple();
            HTuple hv_AreaRanges = new HTuple(), hv_AllocationBlockLength = new HTuple();
            // Initialize local and output iconic variables 
            hv_EvalParams = new HTuple();
            try
            {
                //
                //This procedure generates a dictionary EvalParams,
                //which contains default values for evaluation parameters.
                //Depending on the evaluation type, the corresponding default parameters and values are set.
                //The class IDs that the model can predict must be given via ClassIDsModel.
                //
                //Check inputs.
                hv_AvailableEvaluationTypes.Dispose();
                hv_AvailableEvaluationTypes = new HTuple();
                hv_AvailableEvaluationTypes[0] = "anomaly_detection";
                hv_AvailableEvaluationTypes[1] = "classification";
                hv_AvailableEvaluationTypes[2] = "detection";
                hv_AvailableEvaluationTypes[3] = "segmentation";
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_EvaluationTypesStr.Dispose();
                    HOperatorSet.TupleGenConst((2 * (new HTuple(hv_AvailableEvaluationTypes.TupleLength()
                        ))) - 1, new HTuple("','"), out hv_EvaluationTypesStr);
                }
                if (hv_EvaluationTypesStr == null)
                    hv_EvaluationTypesStr = new HTuple();
                hv_EvaluationTypesStr[HTuple.TupleGenSequence(0, new HTuple(hv_EvaluationTypesStr.TupleLength()
                    ), 2)] = hv_AvailableEvaluationTypes;
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_EvaluationTypesStr = hv_EvaluationTypesStr.TupleSum()
                            ;
                        hv_EvaluationTypesStr.Dispose();
                        hv_EvaluationTypesStr = ExpTmpLocalVar_EvaluationTypesStr;
                    }
                }
                hv_Indices.Dispose();
                HOperatorSet.TupleFind(hv_AvailableEvaluationTypes, hv_EvaluationType, out hv_Indices);
                if ((int)((new HTuple(hv_Indices.TupleEqual(-1))).TupleOr(new HTuple(hv_Indices.TupleEqual(
                    new HTuple())))) != 0)
                {
                    throw new HalconException(((("Unknown evaluation_type: " + hv_EvaluationType) + ". Choose one of ['") + hv_EvaluationTypesStr) + "']");
                }
                if ((int)(new HTuple((new HTuple(hv_ClassIDsModel.TupleLength())).TupleLess(
                    1))) != 0)
                {
                    throw new HalconException("ClassIDsModel should have at least one entry");
                }
                //
                //Initialize EvalParams.
                hv_EvalParams.Dispose();
                HOperatorSet.CreateDict(out hv_EvalParams);
                HOperatorSet.SetDictTuple(hv_EvalParams, "evaluation_type", hv_EvaluationType);
                //
                //Set the class IDs.
                HOperatorSet.SetDictTuple(hv_EvalParams, "class_ids", hv_ClassIDsModel);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_EvalParams, "num_classes", new HTuple(hv_ClassIDsModel.TupleLength()
                        ));
                }
                //
                //Set specific parameters depending on the evaluation type.
                hv_EvaluateInstances.Dispose();
                hv_EvaluateInstances = 0;
                if ((int)(new HTuple(hv_EvaluationType.TupleEqual("anomaly_detection"))) != 0)
                {
                    //
                    //Set default image level measures.
                    hv_Measures.Dispose();
                    hv_Measures = "anomaly_score_histogram";
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("classification"))) != 0)
                {
                    //
                    //Set default classification measures.
                    hv_Measures.Dispose();
                    hv_Measures = "top1_error";
                    //
                    //Per default all classes are used for evaluation.
                    HOperatorSet.SetDictTuple(hv_EvalParams, "class_ids_to_evaluate", "global");
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("detection"))) != 0)
                {
                    //
                    //Set default detection measures.
                    hv_Measures.Dispose();
                    hv_Measures = "mean_ap";
                    //
                    //Set detection-specific default values.
                    hv_EvaluateInstances.Dispose();
                    hv_EvaluateInstances = 1;
                    HOperatorSet.SetDictTuple(hv_EvalParams, "instance_type", "rectangle1");
                    //Generate ten IoU-thresholds from 0.5 to 0.95 in steps of 0.05.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_EvalParams, "iou_threshold", HTuple.TupleGenSequence(
                            0.5, 0.96, 0.05));
                    }
                    //Set maximal number of detections to -1, i.e. all results per image will be evaluated.
                    HOperatorSet.SetDictTuple(hv_EvalParams, "max_num_detections", -1);
                    //Set default area range named 'all', thus areas from 0 to a value larger than all likely occurring values.
                    hv_AreaRanges.Dispose();
                    HOperatorSet.CreateDict(out hv_AreaRanges);
                    HOperatorSet.SetDictTuple(hv_AreaRanges, "name", "all");
                    HOperatorSet.SetDictTuple(hv_AreaRanges, "min", 0);
                    HOperatorSet.SetDictTuple(hv_AreaRanges, "max", 2e8);
                    HOperatorSet.SetDictTuple(hv_EvalParams, "area_ranges", hv_AreaRanges);
                    //Some tuples are changing their length during the evaluation. As this slows down the
                    //evaluation process they are allocated in blocks of AllocationBlockLength.
                    hv_AllocationBlockLength.Dispose();
                    hv_AllocationBlockLength = 200;
                    HOperatorSet.SetDictTuple(hv_EvalParams, "allocation_block_length", hv_AllocationBlockLength);
                    //Detailed evaluation is not switched on per default, as it slows down the evaluation-process.
                    HOperatorSet.SetDictTuple(hv_EvalParams, "detailed_evaluation", 0);
                    //Interpolate the precision-recall curves per default.
                    HOperatorSet.SetDictTuple(hv_EvalParams, "interpolate_pr_curves", 1);
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("segmentation"))) != 0)
                {
                    //
                    //Set default pixel measures.
                    hv_Measures.Dispose();
                    hv_Measures = new HTuple();
                    hv_Measures[0] = "pixel_accuracy";
                    hv_Measures[1] = "mean_accuracy";
                    hv_Measures[2] = "mean_iou";
                    //
                    //Per default there are no ignored classes.
                    HOperatorSet.SetDictTuple(hv_EvalParams, "ignore_class_ids", new HTuple());
                }
                //
                HOperatorSet.SetDictTuple(hv_EvalParams, "evaluate_instances", hv_EvaluateInstances);
                HOperatorSet.SetDictTuple(hv_EvalParams, "measures", hv_Measures);
                //

                hv_AvailableEvaluationTypes.Dispose();
                hv_EvaluationTypesStr.Dispose();
                hv_Indices.Dispose();
                hv_EvaluateInstances.Dispose();
                hv_Measures.Dispose();
                hv_AreaRanges.Dispose();
                hv_AllocationBlockLength.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_AvailableEvaluationTypes.Dispose();
                hv_EvaluationTypesStr.Dispose();
                hv_Indices.Dispose();
                hv_EvaluateInstances.Dispose();
                hv_Measures.Dispose();
                hv_AreaRanges.Dispose();
                hv_AllocationBlockLength.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: Display a map of the confidences. 
        private void dev_display_confidence_regions(HObject ho_ImageConfidence, HTuple hv_DrawTransparency,
            out HTuple hv_Colors)
        {




            // Local iconic variables 

            HObject ho_Region = null;

            // Local control variables 

            HTuple hv_NumColors = new HTuple(), hv_WeightsColorsAlpha = new HTuple();
            HTuple hv_ColorIndex = new HTuple(), hv_Threshold = new HTuple();
            HTuple hv_MinGray = new HTuple(), hv_MaxGray = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Region);
            hv_Colors = new HTuple();
            try
            {
                //
                //This procedure displays a map of the confidences
                //given in ImageConfidence as regions.
                //DrawTransparency determines the alpha value of the colors.
                //The used colors are returned.
                //
                //Define colors.
                hv_NumColors.Dispose();
                hv_NumColors = 20;
                hv_Colors.Dispose();
                get_distinct_colors(hv_NumColors, 0, 0, 100, out hv_Colors);
                hv_WeightsColorsAlpha.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WeightsColorsAlpha = hv_Colors + hv_DrawTransparency;
                }
                hv_ColorIndex.Dispose();
                hv_ColorIndex = 0;
                //
                //Threshold the image according to
                //the number of colors and
                //display resulting regions.
                HTuple end_val15 = hv_NumColors - 1;
                HTuple step_val15 = 1;
                for (hv_ColorIndex = 0; hv_ColorIndex.Continue(end_val15, step_val15); hv_ColorIndex = hv_ColorIndex.TupleAdd(step_val15))
                {
                    hv_Threshold.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Threshold = hv_ColorIndex * (1.0 / hv_NumColors);
                    }
                    hv_MinGray.Dispose();
                    hv_MinGray = new HTuple(hv_Threshold);
                    hv_MaxGray.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxGray = hv_Threshold + (1 / hv_NumColors);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_Region.Dispose();
                        HOperatorSet.Threshold(ho_ImageConfidence, out ho_Region, hv_Threshold, hv_Threshold + (1.0 / hv_NumColors));
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_WeightsColorsAlpha.TupleSelect(
                                hv_ColorIndex));
                        }
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_Region, HDevWindowStack.GetActive());
                    }
                }
                ho_Region.Dispose();

                hv_NumColors.Dispose();
                hv_WeightsColorsAlpha.Dispose();
                hv_ColorIndex.Dispose();
                hv_Threshold.Dispose();
                hv_MinGray.Dispose();
                hv_MaxGray.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Region.Dispose();

                hv_NumColors.Dispose();
                hv_WeightsColorsAlpha.Dispose();
                hv_ColorIndex.Dispose();
                hv_Threshold.Dispose();
                hv_MinGray.Dispose();
                hv_MaxGray.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Visualize different images, annotations and inference results for a sample. 
        public void dev_display_dl_data(HTuple hv_DLSample, HTuple hv_DLResult, HTuple hv_DLDatasetInfo,
            HTuple hv_KeysForDisplay, HTuple hv_GenParam, HTuple hv_WindowHandleDict)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Image = null, ho_AnomalyImage = null;
            HObject ho_AnomalyRegion = null, ho_PredictionColorFrame = null;
            HObject ho_ImageHeatmap = null, ho_ImageWeight = null, ho_ImageConfidence = null;
            HObject ho_SegmentationImagGroundTruth = null, ho_SegmentationImageResult = null;
            HObject ho_ImageAbsDiff = null, ho_DiffRegion = null;

            // Local control variables 

            HTuple hv_ThresholdWidth = new HTuple(), hv_ScaleWindows = new HTuple();
            HTuple hv_Font = new HTuple(), hv_FontSize = new HTuple();
            HTuple hv_LineWidth = new HTuple(), hv_MapTransparency = new HTuple();
            HTuple hv_MapColorBarWidth = new HTuple(), hv_AnomalyRegionThreshold = new HTuple();
            HTuple hv_AnomalyClassificationThreshold = new HTuple();
            HTuple hv_AnomalyRegionLabelColor = new HTuple(), hv_AnomalyColorTransparency = new HTuple();
            HTuple hv_AnomalyRegionResultColor = new HTuple(), hv_SegMaxWeight = new HTuple();
            HTuple hv_SegDraw = new HTuple(), hv_SegTransparency = new HTuple();
            HTuple hv_SegExcludeClassIDs = new HTuple(), hv_BboxLabelColor = new HTuple();
            HTuple hv_BboxDisplayConfidence = new HTuple(), hv_BboxTextColor = new HTuple();
            HTuple hv_ShowBottomDesc = new HTuple(), hv_ShowLegend = new HTuple();
            HTuple hv_ShowGroundTruthAnomalyRegions = new HTuple();
            HTuple hv_ShowClassificationIDs = new HTuple(), hv_ShowClassificationColorFrame = new HTuple();
            HTuple hv_ShowLabels = new HTuple(), hv_ShowDirection = new HTuple();
            HTuple hv_HeatmapColorScheme = new HTuple(), hv_GenParamNames = new HTuple();
            HTuple hv_ParamIndex = new HTuple(), hv_GenParamName = new HTuple();
            HTuple hv_GenParamValue = new HTuple(), hv_SampleKeys = new HTuple();
            HTuple hv_ResultKeys = new HTuple(), hv_ImageIDExists = new HTuple();
            HTuple hv_ImageID = new HTuple(), hv_ImageIDString = new HTuple();
            HTuple hv_ImageIDStringBraces = new HTuple(), hv_ImageIDStringCapital = new HTuple();
            HTuple hv_NeededKeys = new HTuple(), hv_Index = new HTuple();
            HTuple hv_DLDatasetInfoKeys = new HTuple(), hv_ClassNames = new HTuple();
            HTuple hv_ClassIDs = new HTuple(), hv_Colors = new HTuple();
            HTuple hv_ClassesLegend = new HTuple(), hv_PrevWindowCoordinates = new HTuple();
            HTuple hv_Keys = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_MetaInfoIndex = new HTuple(), hv_MetaInfo = new HTuple();
            HTuple hv_FlushValues = new HTuple(), hv_WindowHandleKeys = new HTuple();
            HTuple hv_KeyIndex = new HTuple(), hv_WindowHandles = new HTuple();
            HTuple hv_WindowIndex = new HTuple(), hv_FlushValue = new HTuple();
            HTuple hv_WidthImage = new HTuple(), hv_HeightImage = new HTuple();
            HTuple hv_CurrentWindowHandle = new HTuple(), hv_WindowImageRatio = new HTuple();
            HTuple hv_AnomalyLabelGroundTruth = new HTuple(), hv_AnomalyLabelIDGroundTruth = new HTuple();
            HTuple hv_AnomalyRegionExists = new HTuple(), hv_Text = new HTuple();
            HTuple hv_AnomalyScore = new HTuple(), hv_AnomalyClassID = new HTuple();
            HTuple hv_AnomalyClassThresholdDisplay = new HTuple();
            HTuple hv_AnomalyRegionThresholdDisplay = new HTuple();
            HTuple hv_AnomalyRegionGroundTruthExists = new HTuple();
            HTuple hv_PredictionColor = new HTuple(), hv_LineColors = new HTuple();
            HTuple hv_ResultColorOffset = new HTuple(), hv_ClassificationLabelIDGroundTruth = new HTuple();
            HTuple hv_ClassificationLabelIDResult = new HTuple(), hv_MarginBottom = new HTuple();
            HTuple hv_WindowCoordinates = new HTuple(), hv_CurrentWindowHeight = new HTuple();
            HTuple hv__ = new HTuple(), hv_MaxHeight = new HTuple();
            HTuple hv_PredictionText = new HTuple(), hv_BoarderOffset = new HTuple();
            HTuple hv_WindowImageRatioHeight = new HTuple(), hv_WindowImageRatioWidth = new HTuple();
            HTuple hv_BoarderOffsetRow = new HTuple(), hv_BoarderOffsetCol = new HTuple();
            HTuple hv_SelectedHeatmapMethod = new HTuple(), hv_DictHeatmap = new HTuple();
            HTuple hv_MethodName = new HTuple(), hv_HeatmapKeys = new HTuple();
            HTuple hv_HeatmapImageName = new HTuple(), hv_TargetClassID = new HTuple();
            HTuple hv_Confidences = new HTuple(), hv_MaxDeviation = new HTuple();
            HTuple hv_ClassificationLabelNameResult = new HTuple();
            HTuple hv_TargetClassConfidence = new HTuple(), hv_ClassificationLabelNamesGroundTruth = new HTuple();
            HTuple hv_BboxIDs = new HTuple(), hv_BboxColors = new HTuple();
            HTuple hv_BboxIDsUniq = new HTuple(), hv_BboxConfidences = new HTuple();
            HTuple hv_TextConf = new HTuple(), hv_BboxClassIndex = new HTuple();
            HTuple hv_BboxColorsResults = new HTuple(), hv_BboxClassIndexUniq = new HTuple();
            HTuple hv_BboxLabelIndex = new HTuple(), hv_BboxColorsBoth = new HTuple();
            HTuple hv_BboxClassLabelIndexUniq = new HTuple(), hv_ColorsSegmentation = new HTuple();
            HTuple hv_DrawMode = new HTuple(), hv_Width = new HTuple();
            HTuple hv_ImageClassIDs = new HTuple(), hv_ImageClassIDsUniq = new HTuple();
            HTuple hv_ImageClassIDsIndices = new HTuple(), hv_ImageClassIDsIndex = new HTuple();
            HTuple hv_ColorsResults = new HTuple(), hv_GroundTruthIDs = new HTuple();
            HTuple hv_ResultIDs = new HTuple(), hv_StringSegExcludeClassIDs = new HTuple();
            HTuple hv_StringIndex = new HTuple(), hv_Min = new HTuple();
            HTuple hv_Max = new HTuple(), hv_Range = new HTuple();
            HTuple hv_MinWeight = new HTuple(), hv_WeightsColors = new HTuple();
            HTuple hv_ConfidenceColors = new HTuple(), hv_Indices = new HTuple();
            HTuple hv_WindowHandleKeysNew = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Image);
            HOperatorSet.GenEmptyObj(out ho_AnomalyImage);
            HOperatorSet.GenEmptyObj(out ho_AnomalyRegion);
            HOperatorSet.GenEmptyObj(out ho_PredictionColorFrame);
            HOperatorSet.GenEmptyObj(out ho_ImageHeatmap);
            HOperatorSet.GenEmptyObj(out ho_ImageWeight);
            HOperatorSet.GenEmptyObj(out ho_ImageConfidence);
            HOperatorSet.GenEmptyObj(out ho_SegmentationImagGroundTruth);
            HOperatorSet.GenEmptyObj(out ho_SegmentationImageResult);
            HOperatorSet.GenEmptyObj(out ho_ImageAbsDiff);
            HOperatorSet.GenEmptyObj(out ho_DiffRegion);
            try
            {
                //
                //This procedure displays the content of the provided DLSample and/or DLResult
                //depending on the input string KeysForDisplay.
                //DLDatasetInfo is a dictionary containing the information about the dataset.
                //The visualization can be adapted with GenParam.
                //
                //** Set the default values: ***
                //
                //Define the screen width when a new window row is started.
                hv_ThresholdWidth.Dispose();
                hv_ThresholdWidth = 1024;
                //Since potentially a lot of windows are opened,
                //scale the windows consistently.
                hv_ScaleWindows.Dispose();
                hv_ScaleWindows = 0.8;
                //Set a font and a font size.
                hv_Font.Dispose();
                hv_Font = "mono";
                hv_FontSize.Dispose();
                hv_FontSize = 14;
                //
                hv_LineWidth.Dispose();
                hv_LineWidth = 2;
                hv_MapTransparency.Dispose();
                hv_MapTransparency = "cc";
                hv_MapColorBarWidth.Dispose();
                hv_MapColorBarWidth = 140;
                //
                //Define anomaly detection-specific parameter values.
                hv_AnomalyRegionThreshold.Dispose();
                hv_AnomalyRegionThreshold = -1;
                hv_AnomalyClassificationThreshold.Dispose();
                hv_AnomalyClassificationThreshold = -1;
                hv_AnomalyRegionLabelColor.Dispose();
                hv_AnomalyRegionLabelColor = "#40e0d0";
                hv_AnomalyColorTransparency.Dispose();
                hv_AnomalyColorTransparency = "40";
                hv_AnomalyRegionResultColor.Dispose();
                hv_AnomalyRegionResultColor = "#ff0000c0";
                //
                //Define segmentation-specific parameter values.
                hv_SegMaxWeight.Dispose();
                hv_SegMaxWeight = 0;
                hv_SegDraw.Dispose();
                hv_SegDraw = "fill";
                hv_SegTransparency.Dispose();
                hv_SegTransparency = "aa";
                hv_SegExcludeClassIDs.Dispose();
                hv_SegExcludeClassIDs = new HTuple();
                //
                //Define bounding box-specific parameter values.
                hv_BboxLabelColor.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_BboxLabelColor = new HTuple("#000000") + "99";
                }
                hv_BboxDisplayConfidence.Dispose();
                hv_BboxDisplayConfidence = 1;
                hv_BboxTextColor.Dispose();
                hv_BboxTextColor = "#eeeeee";
                //
                //By default, display a description on the bottom.
                hv_ShowBottomDesc.Dispose();
                hv_ShowBottomDesc = 1;
                //
                //By default, show a legend with class IDs.
                hv_ShowLegend.Dispose();
                hv_ShowLegend = 1;
                //
                //By default, show the anomaly ground truth regions.
                hv_ShowGroundTruthAnomalyRegions.Dispose();
                hv_ShowGroundTruthAnomalyRegions = 1;
                //
                //By default, show class IDs and color frames for classification ground truth/results.
                hv_ShowClassificationIDs.Dispose();
                hv_ShowClassificationIDs = 1;
                hv_ShowClassificationColorFrame.Dispose();
                hv_ShowClassificationColorFrame = 1;
                //
                //By default, show class labels for detection ground truth/results.
                hv_ShowLabels.Dispose();
                hv_ShowLabels = 1;
                //
                //By default, show direction of the ground truth/results instances for detection with instance_type 'rectangle2'.
                hv_ShowDirection.Dispose();
                hv_ShowDirection = 1;
                //
                //By default, use color scheme 'Jet' for the heatmap display.
                hv_HeatmapColorScheme.Dispose();
                hv_HeatmapColorScheme = "jet";
                //** Set user defined values: ***
                //
                //Overwrite default values by given generic parameters.
                if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
                {
                    hv_GenParamNames.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_GenParamNames);
                    for (hv_ParamIndex = 0; (int)hv_ParamIndex <= (int)((new HTuple(hv_GenParamNames.TupleLength()
                        )) - 1); hv_ParamIndex = (int)hv_ParamIndex + 1)
                    {
                        hv_GenParamName.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_GenParamName = hv_GenParamNames.TupleSelect(
                                hv_ParamIndex);
                        }
                        hv_GenParamValue.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam, hv_GenParamName, out hv_GenParamValue);
                        if ((int)(new HTuple(hv_GenParamName.TupleEqual("threshold_width"))) != 0)
                        {
                            hv_ThresholdWidth.Dispose();
                            hv_ThresholdWidth = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("scale_windows"))) != 0)
                        {
                            hv_ScaleWindows.Dispose();
                            hv_ScaleWindows = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("font"))) != 0)
                        {
                            hv_Font.Dispose();
                            hv_Font = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("font_size"))) != 0)
                        {
                            hv_FontSize.Dispose();
                            hv_FontSize = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("line_width"))) != 0)
                        {
                            hv_LineWidth.Dispose();
                            hv_LineWidth = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("map_transparency"))) != 0)
                        {
                            hv_MapTransparency.Dispose();
                            hv_MapTransparency = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("map_color_bar_width"))) != 0)
                        {
                            hv_MapColorBarWidth.Dispose();
                            hv_MapColorBarWidth = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("segmentation_max_weight"))) != 0)
                        {
                            hv_SegMaxWeight.Dispose();
                            hv_SegMaxWeight = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("segmentation_draw"))) != 0)
                        {
                            hv_SegDraw.Dispose();
                            hv_SegDraw = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("segmentation_transparency"))) != 0)
                        {
                            hv_SegTransparency.Dispose();
                            hv_SegTransparency = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("segmentation_exclude_class_ids"))) != 0)
                        {
                            hv_SegExcludeClassIDs.Dispose();
                            hv_SegExcludeClassIDs = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("bbox_label_color"))) != 0)
                        {
                            hv_BboxLabelColor.Dispose();
                            hv_BboxLabelColor = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("bbox_display_confidence"))) != 0)
                        {
                            hv_BboxDisplayConfidence.Dispose();
                            hv_BboxDisplayConfidence = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("bbox_text_color"))) != 0)
                        {
                            hv_BboxTextColor.Dispose();
                            hv_BboxTextColor = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("display_bottom_desc"))) != 0)
                        {
                            hv_ShowBottomDesc.Dispose();
                            hv_ShowBottomDesc = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("display_legend"))) != 0)
                        {
                            hv_ShowLegend.Dispose();
                            hv_ShowLegend = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("display_classification_ids"))) != 0)
                        {
                            hv_ShowClassificationIDs.Dispose();
                            hv_ShowClassificationIDs = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("display_classification_color_frame"))) != 0)
                        {
                            hv_ShowClassificationColorFrame.Dispose();
                            hv_ShowClassificationColorFrame = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("display_labels"))) != 0)
                        {
                            hv_ShowLabels.Dispose();
                            hv_ShowLabels = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("display_direction"))) != 0)
                        {
                            hv_ShowDirection.Dispose();
                            hv_ShowDirection = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("heatmap_color_scheme"))) != 0)
                        {
                            hv_HeatmapColorScheme.Dispose();
                            hv_HeatmapColorScheme = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("display_ground_truth_anomaly_regions"))) != 0)
                        {
                            hv_ShowGroundTruthAnomalyRegions.Dispose();
                            hv_ShowGroundTruthAnomalyRegions = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("anomaly_region_threshold"))) != 0)
                        {
                            hv_AnomalyRegionThreshold.Dispose();
                            hv_AnomalyRegionThreshold = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("anomaly_classification_threshold"))) != 0)
                        {
                            hv_AnomalyClassificationThreshold.Dispose();
                            hv_AnomalyClassificationThreshold = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("anomaly_region_label_color"))) != 0)
                        {
                            hv_AnomalyRegionLabelColor.Dispose();
                            hv_AnomalyRegionLabelColor = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("anomaly_region_result_color"))) != 0)
                        {
                            hv_AnomalyRegionResultColor.Dispose();
                            hv_AnomalyRegionResultColor = new HTuple(hv_GenParamValue);
                        }
                        else if ((int)(new HTuple(hv_GenParamName.TupleEqual("anomaly_color_transparency"))) != 0)
                        {
                            hv_AnomalyColorTransparency.Dispose();
                            hv_AnomalyColorTransparency = new HTuple(hv_GenParamValue);
                        }
                        else
                        {
                            throw new HalconException(("Unknown generic parameter: " + hv_GenParamName) + ".");
                        }
                    }
                }
                //
                //Get the dictionary keys.
                hv_SampleKeys.Dispose();
                HOperatorSet.GetDictParam(hv_DLSample, "keys", new HTuple(), out hv_SampleKeys);
                if ((int)(new HTuple(hv_DLResult.TupleNotEqual(new HTuple()))) != 0)
                {
                    hv_ResultKeys.Dispose();
                    HOperatorSet.GetDictParam(hv_DLResult, "keys", new HTuple(), out hv_ResultKeys);
                }
                //
                //Get image ID if it is available.
                hv_ImageIDExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLSample, "key_exists", "image_id", out hv_ImageIDExists);
                if ((int)(hv_ImageIDExists) != 0)
                {
                    hv_ImageID.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "image_id", out hv_ImageID);
                    hv_ImageIDString.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageIDString = "image ID " + hv_ImageID;
                    }
                    hv_ImageIDStringBraces.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageIDStringBraces = ("(image ID " + hv_ImageID) + ")";
                    }
                    hv_ImageIDStringCapital.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageIDStringCapital = "Image ID " + hv_ImageID;
                    }
                }
                else
                {
                    hv_ImageIDString.Dispose();
                    hv_ImageIDString = "";
                    hv_ImageIDStringBraces.Dispose();
                    hv_ImageIDStringBraces = new HTuple(hv_ImageIDString);
                    hv_ImageIDStringCapital.Dispose();
                    hv_ImageIDStringCapital = new HTuple(hv_ImageIDString);
                }
                //
                //Check if DLDatasetInfo is valid.
                if ((int)(new HTuple(hv_DLDatasetInfo.TupleEqual(new HTuple()))) != 0)
                {
                    //If DLDatasetInfo is empty, 'image' is the only key allowed in KeysForDisplay.
                    if ((int)((new HTuple((new HTuple(hv_KeysForDisplay.TupleLength())).TupleNotEqual(
                        1))).TupleOr(new HTuple(((hv_KeysForDisplay.TupleSelect(0))).TupleNotEqual(
                        "image")))) != 0)
                    {
                        throw new HalconException("DLDatasetInfo is needed for requested keys in KeysForDisplay.");
                    }
                }
                else
                {
                    //Check if DLDatasetInfo contains necessary keys.
                    hv_NeededKeys.Dispose();
                    hv_NeededKeys = new HTuple();
                    hv_NeededKeys[0] = "class_names";
                    hv_NeededKeys[1] = "class_ids";
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_NeededKeys.TupleLength()
                        )) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        hv_DLDatasetInfoKeys.Dispose();
                        HOperatorSet.GetDictParam(hv_DLDatasetInfo, "keys", new HTuple(), out hv_DLDatasetInfoKeys);
                        if ((int)(new HTuple(((hv_DLDatasetInfoKeys.TupleFindFirst(hv_NeededKeys.TupleSelect(
                            hv_Index)))).TupleEqual(-1))) != 0)
                        {
                            throw new HalconException(("Key " + (hv_NeededKeys.TupleSelect(
                                hv_Index))) + " is missing in DLDatasetInfo.");
                        }
                    }
                    //
                    //Get the general dataset information, if available.
                    hv_ClassNames.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLDatasetInfo, "class_names", out hv_ClassNames);
                    hv_ClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLDatasetInfo, "class_ids", out hv_ClassIDs);
                    //
                    //Define distinct colors for the classes.
                    hv_Colors.Dispose();
                    get_dl_class_colors(hv_ClassNames, out hv_Colors);
                    //
                    hv_ClassesLegend.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassesLegend = (hv_ClassIDs + " : ") + hv_ClassNames;
                    }
                }
                //
                //** Set window parameters: ***
                //
                //Set previous window coordinates.
                hv_PrevWindowCoordinates.Dispose();
                hv_PrevWindowCoordinates = new HTuple();
                hv_PrevWindowCoordinates[0] = 0;
                hv_PrevWindowCoordinates[1] = 0;
                hv_PrevWindowCoordinates[2] = 0;
                hv_PrevWindowCoordinates[3] = 0;
                hv_PrevWindowCoordinates[4] = 1;
                //
                //Check that the WindowHandleDict is of type dictionary.
                try
                {
                    hv_Keys.Dispose();
                    HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_Keys);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    if ((int)(new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(1401))) != 0)
                    {
                        throw new HalconException("WindowHandleDict has to be of type dictionary. Use create_dict to create an empty dictionary.");
                    }
                    else
                    {
                        throw new HalconException(hv_Exception);
                    }
                }
                //For better usage, add meta information about the window handles in WindowHandleDict.
                hv_MetaInfoIndex.Dispose();
                HOperatorSet.TupleFind(hv_Keys, "meta_information", out hv_MetaInfoIndex);
                if ((int)((new HTuple(hv_MetaInfoIndex.TupleEqual(-1))).TupleOr(new HTuple(hv_MetaInfoIndex.TupleEqual(
                    new HTuple())))) != 0)
                {
                    hv_MetaInfo.Dispose();
                    HOperatorSet.CreateDict(out hv_MetaInfo);
                    HOperatorSet.SetDictTuple(hv_WindowHandleDict, "meta_information", hv_MetaInfo);
                }
                //
                //For each window, set 'flush' to 'false' to avoid flickering.
                hv_FlushValues.Dispose();
                hv_FlushValues = new HTuple();
                hv_WindowHandleKeys.Dispose();
                HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_WindowHandleKeys);
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_WindowHandleKeys.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    //Only consider the WindowHandleKeys that are needed for the current visualization.
                    hv_KeyIndex.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_KeyIndex = hv_KeysForDisplay.TupleFind(
                            hv_WindowHandleKeys.TupleSelect(hv_Index));
                    }
                    if ((int)((new HTuple(hv_KeyIndex.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_KeyIndex.TupleNotEqual(
                        new HTuple())))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_WindowHandles.Dispose();
                            HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKeys.TupleSelect(
                                hv_Index), out hv_WindowHandles);
                        }
                        for (hv_WindowIndex = 0; (int)hv_WindowIndex <= (int)((new HTuple(hv_WindowHandles.TupleLength()
                            )) - 1); hv_WindowIndex = (int)hv_WindowIndex + 1)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_FlushValue.Dispose();
                                HOperatorSet.GetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex),
                                    "flush", out hv_FlushValue);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_FlushValues = hv_FlushValues.TupleConcat(
                                        hv_FlushValue);
                                    hv_FlushValues.Dispose();
                                    hv_FlushValues = ExpTmpLocalVar_FlushValues;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex),
                                    "flush", "false");
                            }
                        }
                    }
                }
                //
                //** Display the data: ***
                //
                //Display data dictionaries.
                for (hv_KeyIndex = 0; (int)hv_KeyIndex <= (int)((new HTuple(hv_KeysForDisplay.TupleLength()
                    )) - 1); hv_KeyIndex = (int)hv_KeyIndex + 1)
                {
                    if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "image"))) != 0)
                    {
                        //
                        //Image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ImageIDStringCapital,
                                    "window", "bottom", "left", "white", "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "anomaly_ground_truth"))) != 0)
                    {
                        //Image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        hv_AnomalyLabelGroundTruth.Dispose(); hv_AnomalyLabelIDGroundTruth.Dispose();
                        get_anomaly_ground_truth_label(hv_SampleKeys, hv_DLSample, out hv_AnomalyLabelGroundTruth,
                            out hv_AnomalyLabelIDGroundTruth);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualize image.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        hv_AnomalyRegionExists.Dispose();
                        hv_AnomalyRegionExists = "false";
                        if ((int)(hv_ShowGroundTruthAnomalyRegions) != 0)
                        {
                            //Show the ground truth region.
                            hv_AnomalyRegionExists.Dispose();
                            dev_display_ground_truth_anomaly_regions(hv_SampleKeys, hv_DLSample,
                                hv_CurrentWindowHandle, hv_LineWidth, hv_AnomalyRegionLabelColor,
                                hv_AnomalyColorTransparency, out hv_AnomalyRegionExists);
                        }
                        //
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Ground truth anomalies " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = ((hv_AnomalyLabelIDGroundTruth + " : '") + hv_AnomalyLabelGroundTruth) + "'";
                            if ((int)((new HTuple((new HTuple(hv_AnomalyRegionExists.TupleEqual("false"))).TupleAnd(
                                new HTuple(hv_AnomalyLabelIDGroundTruth.TupleEqual(1))))).TupleAnd(
                                hv_ShowGroundTruthAnomalyRegions)) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "No 'anomaly_ground_truth' exists!";
                            }
                            //
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", "white", "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "anomaly_result"))) != 0)
                    {
                        //
                        //Get image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        //
                        //Get the anomaly results either by applying the specified thresholds or out of DLResult.
                        ho_AnomalyImage.Dispose(); ho_AnomalyRegion.Dispose(); hv_AnomalyScore.Dispose(); hv_AnomalyClassID.Dispose(); hv_AnomalyClassThresholdDisplay.Dispose(); hv_AnomalyRegionThresholdDisplay.Dispose();
                        get_anomaly_result(out ho_AnomalyImage, out ho_AnomalyRegion, hv_DLResult,
                            hv_ResultKeys, hv_AnomalyClassificationThreshold, hv_AnomalyRegionThreshold,
                            out hv_AnomalyScore, out hv_AnomalyClassID, out hv_AnomalyClassThresholdDisplay,
                            out hv_AnomalyRegionThresholdDisplay);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualize image.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        //Display anomaly regions defined by the specified threshold or from DLResult.
                        if ((int)((new HTuple(hv_AnomalyRegionThreshold.TupleNotEqual(-1))).TupleOr(
                            new HTuple(((hv_ResultKeys.TupleFind("anomaly_region"))).TupleNotEqual(
                            -1)))) != 0)
                        {
                            dev_display_result_anomaly_regions(ho_AnomalyRegion, hv_CurrentWindowHandle,
                                hv_LineWidth, hv_AnomalyRegionResultColor);
                        }
                        //
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Detected anomalies " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Results ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            if ((int)(new HTuple(hv_AnomalyClassID.TupleEqual(1))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID + " : 'nok'";
                            }
                            else if ((int)(new HTuple(hv_AnomalyClassID.TupleEqual(
                                0))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID + " : 'ok'";
                            }
                            else
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "No classification result found";
                            }
                            if ((int)((new HTuple(hv_AnomalyRegionThreshold.TupleEqual(-1))).TupleAnd(
                                new HTuple(((hv_ResultKeys.TupleFind("anomaly_region"))).TupleEqual(
                                -1)))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "No segmentation result found";
                            }
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Anomaly score: " + (hv_AnomalyScore.TupleString(
                                ".2f"));
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if ((int)((new HTuple(hv_AnomalyClassThresholdDisplay.TupleNotEqual(-1))).TupleOr(
                                new HTuple(hv_AnomalyRegionThresholdDisplay.TupleNotEqual(-1)))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Thresholds ";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            }
                            //
                            if ((int)(new HTuple(hv_AnomalyClassThresholdDisplay.TupleNotEqual(-1))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Classification: " + (hv_AnomalyClassThresholdDisplay.TupleString(
                                    ".2f"));
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            }
                            if ((int)(new HTuple(hv_AnomalyRegionThresholdDisplay.TupleNotEqual(-1))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Segmentation: " + (hv_AnomalyRegionThresholdDisplay.TupleString(
                                    ".2f"));
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            }
                            //
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", "white", "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "anomaly_both"))) != 0)
                    {
                        //
                        //Get image and ground truth.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        hv_AnomalyLabelGroundTruth.Dispose(); hv_AnomalyLabelIDGroundTruth.Dispose();
                        get_anomaly_ground_truth_label(hv_SampleKeys, hv_DLSample, out hv_AnomalyLabelGroundTruth,
                            out hv_AnomalyLabelIDGroundTruth);
                        //
                        //Get the anomaly results either by applying the specified thresholds or out of DLResult.
                        ho_AnomalyImage.Dispose(); ho_AnomalyRegion.Dispose(); hv_AnomalyScore.Dispose(); hv_AnomalyClassID.Dispose(); hv_AnomalyClassThresholdDisplay.Dispose(); hv_AnomalyRegionThresholdDisplay.Dispose();
                        get_anomaly_result(out ho_AnomalyImage, out ho_AnomalyRegion, hv_DLResult,
                            hv_ResultKeys, hv_AnomalyClassificationThreshold, hv_AnomalyRegionThreshold,
                            out hv_AnomalyScore, out hv_AnomalyClassID, out hv_AnomalyClassThresholdDisplay,
                            out hv_AnomalyRegionThresholdDisplay);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualize image, ground truth (if available), and result regions.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        hv_AnomalyRegionGroundTruthExists.Dispose();
                        hv_AnomalyRegionGroundTruthExists = "false";
                        if ((int)(hv_ShowGroundTruthAnomalyRegions) != 0)
                        {
                            hv_AnomalyRegionGroundTruthExists.Dispose();
                            dev_display_ground_truth_anomaly_regions(hv_SampleKeys, hv_DLSample,
                                hv_CurrentWindowHandle, hv_LineWidth, hv_AnomalyRegionLabelColor,
                                hv_AnomalyColorTransparency, out hv_AnomalyRegionGroundTruthExists);
                        }
                        //
                        //Display anomaly regions defined by the specified threshold or from DLResult.
                        if ((int)((new HTuple(hv_AnomalyRegionThreshold.TupleNotEqual(-1))).TupleOr(
                            new HTuple(((hv_ResultKeys.TupleFind("anomaly_region"))).TupleNotEqual(
                            -1)))) != 0)
                        {
                            dev_display_result_anomaly_regions(ho_AnomalyRegion, hv_CurrentWindowHandle,
                                hv_LineWidth, hv_AnomalyRegionResultColor);
                        }
                        //
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "GT and detected anomalies " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Get prediction color.
                        hv_PredictionColor.Dispose();
                        hv_PredictionColor = "white";
                        if ((int)(new HTuple(hv_AnomalyLabelIDGroundTruth.TupleEqual(hv_AnomalyClassID))) != 0)
                        {
                            hv_PredictionColor.Dispose();
                            hv_PredictionColor = "green";
                        }
                        else if ((int)(new HTuple(hv_AnomalyClassID.TupleNotEqual(-1))) != 0)
                        {
                            hv_PredictionColor.Dispose();
                            hv_PredictionColor = "red";
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Ground truth ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = ((hv_AnomalyLabelIDGroundTruth + " : '") + hv_AnomalyLabelGroundTruth) + "'";
                            if ((int)((new HTuple((new HTuple(hv_AnomalyRegionGroundTruthExists.TupleEqual(
                                "false"))).TupleAnd(new HTuple(hv_AnomalyLabelIDGroundTruth.TupleEqual(
                                1))))).TupleAnd(hv_ShowGroundTruthAnomalyRegions)) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "No segmentation ground truth found";
                            }
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Results ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            if ((int)(new HTuple(hv_AnomalyClassID.TupleEqual(1))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID + " : 'nok'";
                            }
                            else if ((int)(new HTuple(hv_AnomalyClassID.TupleEqual(
                                0))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID + " : 'ok'";
                            }
                            else
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "No classification result found";
                            }
                            if ((int)((new HTuple(hv_AnomalyRegionThreshold.TupleEqual(-1))).TupleAnd(
                                new HTuple(((hv_ResultKeys.TupleFind("anomaly_region"))).TupleEqual(
                                -1)))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "No segmentation result found";
                            }
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Anomaly score: " + (hv_AnomalyScore.TupleString(
                                ".2f"));
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if ((int)((new HTuple(hv_AnomalyClassThresholdDisplay.TupleNotEqual(-1))).TupleOr(
                                new HTuple(hv_AnomalyRegionThresholdDisplay.TupleNotEqual(-1)))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Thresholds ";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "---------------";
                            }
                            //
                            if ((int)(new HTuple(hv_AnomalyClassThresholdDisplay.TupleNotEqual(-1))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Classification: " + (hv_AnomalyClassThresholdDisplay.TupleString(
                                    ".2f"));
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            }
                            if ((int)(new HTuple(hv_AnomalyRegionThresholdDisplay.TupleNotEqual(-1))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Segmentation: " + (hv_AnomalyRegionThresholdDisplay.TupleString(
                                    ".2f"));
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            }
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_LineColors.Dispose();
                                HOperatorSet.TupleGenConst(new HTuple(hv_Text.TupleLength()), "white",
                                    out hv_LineColors);
                            }
                            hv_ResultColorOffset.Dispose();
                            hv_ResultColorOffset = 10;
                            if ((int)((new HTuple((new HTuple(hv_AnomalyRegionGroundTruthExists.TupleEqual(
                                "false"))).TupleAnd(new HTuple(hv_AnomalyLabelIDGroundTruth.TupleEqual(
                                1))))).TupleAnd(hv_ShowGroundTruthAnomalyRegions)) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_ResultColorOffset = hv_ResultColorOffset + 2;
                                        hv_ResultColorOffset.Dispose();
                                        hv_ResultColorOffset = ExpTmpLocalVar_ResultColorOffset;
                                    }
                                }
                            }
                            if (hv_LineColors == null)
                                hv_LineColors = new HTuple();
                            hv_LineColors[hv_ResultColorOffset] = hv_PredictionColor;
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", hv_LineColors, "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "anomaly_image"))) != 0)
                    {
                        //
                        //Image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        //
                        ho_AnomalyImage.Dispose(); ho_AnomalyRegion.Dispose(); hv_AnomalyScore.Dispose(); hv_AnomalyClassID.Dispose(); hv_AnomalyClassThresholdDisplay.Dispose(); hv_AnomalyRegionThresholdDisplay.Dispose();
                        get_anomaly_result(out ho_AnomalyImage, out ho_AnomalyRegion, hv_DLResult,
                            hv_ResultKeys, hv_AnomalyClassificationThreshold, hv_AnomalyRegionThreshold,
                            out hv_AnomalyScore, out hv_AnomalyClassID, out hv_AnomalyClassThresholdDisplay,
                            out hv_AnomalyRegionThresholdDisplay);
                        //
                        //Read in input image.
                        ho_Image.Dispose();
                        HOperatorSet.GetDictObject(out ho_Image, hv_DLSample, "image");
                        //Add the anomaly image to the input image.
                        {
                            HObject ExpTmpOutVar_0;
                            add_colormap_to_image(ho_AnomalyImage, ho_Image, out ExpTmpOutVar_0, hv_HeatmapColorScheme);
                            ho_AnomalyImage.Dispose();
                            ho_AnomalyImage = ExpTmpOutVar_0;
                        }
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_AnomalyImage, HDevWindowStack.GetActive());
                        }
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Anomaly image " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if ((int)(new HTuple(hv_AnomalyClassID.TupleEqual(1))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID + " : 'nok'";
                            }
                            else if ((int)(new HTuple(hv_AnomalyClassID.TupleEqual(
                                0))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_AnomalyClassID + " : 'ok'";
                            }
                            else
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "No classification result found";
                            }
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Anomaly score: " + (hv_AnomalyScore.TupleString(
                                ".2f"));
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", "white", "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "classification_ground_truth"))) != 0)
                    {
                        //
                        //Ground truth classification image and class label.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        //
                        hv_ClassificationLabelIDGroundTruth.Dispose();
                        get_classification_ground_truth(hv_SampleKeys, hv_DLSample, out hv_ClassificationLabelIDGroundTruth);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        if ((int)(hv_ShowClassificationIDs) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "GT label ID: " + hv_ClassificationLabelIDGroundTruth;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", "white", "box", "false");
                            }
                        }
                        //
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Ground truth classification " + hv_ImageIDStringBraces;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Ground truth class ID " + hv_ImageIDStringBraces;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                        hv_ClassesLegend.TupleSelect(hv_ClassificationLabelIDGroundTruth));
                                    hv_Text.Dispose();
                                    hv_Text = ExpTmpLocalVar_Text;
                                }
                            }
                            //
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                        "top", "left", (new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                                        hv_ClassificationLabelIDGroundTruth)), "box", "false");
                                }
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "classification_result"))) != 0)
                    {
                        //
                        //Ground truth classification image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        //
                        hv_ClassificationLabelIDResult.Dispose();
                        get_classification_result(hv_ResultKeys, hv_DLResult, out hv_ClassificationLabelIDResult);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        //Display the class IDs.
                        if ((int)(hv_ShowClassificationIDs) != 0)
                        {
                            hv_MetaInfo.Dispose();
                            HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
                            hv_MarginBottom.Dispose();
                            HOperatorSet.GetDictTuple(hv_MetaInfo, "classification_result_margin_bottom",
                                out hv_MarginBottom);
                            hv_WindowCoordinates.Dispose();
                            HOperatorSet.GetDictTuple(hv_MetaInfo, "classification_result_window_coordinates",
                                out hv_WindowCoordinates);
                            hv_CurrentWindowHeight.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_CurrentWindowHeight = (hv_WindowCoordinates.TupleSelect(
                                    3)) - (hv_WindowCoordinates.TupleSelect(0));
                            }
                            hv__.Dispose(); hv__.Dispose(); hv__.Dispose(); hv_MaxHeight.Dispose();
                            HOperatorSet.GetFontExtents(hv_CurrentWindowHandle, out hv__, out hv__,
                                out hv__, out hv_MaxHeight);
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Result class ID: " + hv_ClassificationLabelIDResult;
                            }
                            if ((int)(hv_ShowBottomDesc) != 0)
                            {
                                if (HDevWindowStack.IsOpen())
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                            hv_CurrentWindowHeight - ((hv_MarginBottom + hv_MaxHeight) + 10), "left",
                                            "white", "box", "false");
                                    }
                                }
                            }
                            else
                            {
                                if (HDevWindowStack.IsOpen())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                        "bottom", "left", "white", "box", "false");
                                }
                            }
                        }
                        //
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Result classification " + hv_ImageIDStringBraces;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Result class ID " + hv_ImageIDStringBraces;
                            }
                            if ((int)(new HTuple(hv_ClassificationLabelIDResult.TupleEqual(new HTuple()))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "No classification result is given!";
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                            hv_ClassesLegend.TupleSelect(hv_ClassificationLabelIDResult));
                                        hv_Text.Dispose();
                                        hv_Text = ExpTmpLocalVar_Text;
                                    }
                                }
                            }
                            //
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                        "top", "left", (new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                                        hv_ClassificationLabelIDResult)), "box", "false");
                                }
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "classification_both"))) != 0)
                    {
                        //
                        //Ground truth and result classification image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        //
                        hv_ClassificationLabelIDGroundTruth.Dispose();
                        get_classification_ground_truth(hv_SampleKeys, hv_DLSample, out hv_ClassificationLabelIDGroundTruth);
                        hv_ClassificationLabelIDResult.Dispose();
                        get_classification_result(hv_ResultKeys, hv_DLResult, out hv_ClassificationLabelIDResult);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        //
                        //Get prediction color.
                        hv_PredictionColor.Dispose();
                        hv_PredictionColor = "white";
                        if ((int)(new HTuple(hv_ClassificationLabelIDGroundTruth.TupleEqual(hv_ClassificationLabelIDResult))) != 0)
                        {
                            hv_PredictionText.Dispose();
                            hv_PredictionText = "Correct";
                            hv_PredictionColor.Dispose();
                            hv_PredictionColor = "green";
                        }
                        else
                        {
                            hv_PredictionText.Dispose();
                            hv_PredictionText = "Wrong";
                            hv_PredictionColor.Dispose();
                            hv_PredictionColor = "red";
                        }
                        //
                        //Generate prediction color frame and show image.
                        if ((int)(hv_ShowClassificationColorFrame) != 0)
                        {
                            //Create a frame with line width 7 that is completely displayed in the window.
                            hv_BoarderOffset.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_BoarderOffset = 7 / 2.0;
                            }
                            hv_MetaInfo.Dispose();
                            HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
                            hv_WindowImageRatioHeight.Dispose();
                            HOperatorSet.GetDictTuple(hv_MetaInfo, "classification_both_window_image_ratio_height",
                                out hv_WindowImageRatioHeight);
                            hv_WindowImageRatioWidth.Dispose();
                            HOperatorSet.GetDictTuple(hv_MetaInfo, "classification_both_window_image_ratio_width",
                                out hv_WindowImageRatioWidth);
                            hv_BoarderOffsetRow.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_BoarderOffsetRow = hv_BoarderOffset / hv_WindowImageRatioHeight;
                            }
                            hv_BoarderOffsetCol.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_BoarderOffsetCol = hv_BoarderOffset / hv_WindowImageRatioWidth;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_PredictionColorFrame.Dispose();
                                HOperatorSet.GenContourPolygonXld(out ho_PredictionColorFrame, ((((((((hv_BoarderOffsetRow - 0.5)).TupleConcat(
                                    hv_BoarderOffsetRow - 0.5))).TupleConcat((hv_HeightImage + 0.5) - hv_BoarderOffsetRow))).TupleConcat(
                                    (hv_HeightImage + 0.5) - hv_BoarderOffsetRow))).TupleConcat(hv_BoarderOffsetRow - 0.5),
                                    ((((((((hv_BoarderOffsetCol - 0.5)).TupleConcat((hv_WidthImage + 0.5) - hv_BoarderOffsetCol))).TupleConcat(
                                    (hv_WidthImage + 0.5) - hv_BoarderOffsetCol))).TupleConcat(hv_BoarderOffsetCol - 0.5))).TupleConcat(
                                    hv_BoarderOffsetCol - 0.5));
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 7);
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_PredictionColor);
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_PredictionColorFrame, HDevWindowStack.GetActive()
                                    );
                            }
                        }
                        else
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                            }
                        }
                        //
                        if ((int)(hv_ShowClassificationIDs) != 0)
                        {
                            hv_MetaInfo.Dispose();
                            HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_MarginBottom.Dispose();
                                HOperatorSet.GetDictTuple(hv_MetaInfo, (hv_KeysForDisplay.TupleSelect(
                                    hv_KeyIndex)) + "_margin_bottom", out hv_MarginBottom);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowCoordinates.Dispose();
                                HOperatorSet.GetDictTuple(hv_MetaInfo, (hv_KeysForDisplay.TupleSelect(
                                    hv_KeyIndex)) + "_window_coordinates", out hv_WindowCoordinates);
                            }
                            hv_CurrentWindowHeight.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_CurrentWindowHeight = (hv_WindowCoordinates.TupleSelect(
                                    3)) - (hv_WindowCoordinates.TupleSelect(0));
                            }
                            hv__.Dispose(); hv__.Dispose(); hv__.Dispose(); hv_MaxHeight.Dispose();
                            HOperatorSet.GetFontExtents(hv_CurrentWindowHandle, out hv__, out hv__,
                                out hv__, out hv_MaxHeight);
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "GT label ID: " + hv_ClassificationLabelIDGroundTruth;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", "white", "box", "false");
                            }
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Result class ID: " + hv_ClassificationLabelIDResult;
                            }
                            if ((int)(hv_ShowBottomDesc) != 0)
                            {
                                if (HDevWindowStack.IsOpen())
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                            hv_CurrentWindowHeight - ((hv_MarginBottom + hv_MaxHeight) + 10), "left",
                                            "white", "box", "false");
                                    }
                                }
                            }
                            else
                            {
                                if (HDevWindowStack.IsOpen())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                        "bottom", "left", "white", "box", "false");
                                }
                            }
                        }
                        //
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Result/Ground truth classification " + hv_ImageIDStringBraces;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Ground truth class ID " + hv_ImageIDStringBraces;
                            }
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = hv_ClassesLegend.TupleSelect(
                                hv_ClassificationLabelIDGroundTruth);
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Result class ID";
                            if ((int)(new HTuple(hv_ClassificationLabelIDResult.TupleEqual(new HTuple()))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "No classification result is given!";
                            }
                            else
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_ClassesLegend.TupleSelect(
                                    hv_ClassificationLabelIDResult);
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Prediction ";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_PredictionText;
                            }
                            //
                            //Get or open next child window.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_LineColors.Dispose();
                                HOperatorSet.TupleGenConst(new HTuple(hv_Text.TupleLength()), "white",
                                    out hv_LineColors);
                            }
                            if (hv_LineColors == null)
                                hv_LineColors = new HTuple();
                            hv_LineColors[1] = hv_Colors.TupleSelect(hv_ClassificationLabelIDGroundTruth);
                            if ((int)(new HTuple(hv_ClassificationLabelIDResult.TupleNotEqual(new HTuple()))) != 0)
                            {
                                if (hv_LineColors == null)
                                    hv_LineColors = new HTuple();
                                hv_LineColors[5] = hv_Colors.TupleSelect(hv_ClassificationLabelIDResult);
                                if (hv_LineColors == null)
                                    hv_LineColors = new HTuple();
                                hv_LineColors[9] = hv_PredictionColor;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", hv_LineColors, "box", "false");
                            }
                        }
                        //
                    }
                    else if ((int)((new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "heatmap_grad_cam"))).TupleOr(new HTuple(((hv_KeysForDisplay.TupleSelect(
                        hv_KeyIndex))).TupleEqual("heatmap_confidence_based")))) != 0)
                    {
                        //
                        //Display the heatmap image (method 'heatmap_grad_cam' or 'heatmap_confidence_based')
                        //in the selected color scheme.
                        //Retrieve heatmap image, inferred image, and inference results.
                        hv_SelectedHeatmapMethod.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_SelectedHeatmapMethod = hv_KeysForDisplay.TupleSelect(
                                hv_KeyIndex);
                        }
                        if ((int)((new HTuple(((hv_ResultKeys.TupleFind("heatmap_grad_cam"))).TupleNotEqual(
                            -1))).TupleOr(new HTuple(((hv_ResultKeys.TupleFind("heatmap_confidence_based"))).TupleNotEqual(
                            -1)))) != 0)
                        {
                            if ((int)(new HTuple(hv_SelectedHeatmapMethod.TupleEqual("heatmap_grad_cam"))) != 0)
                            {
                                hv_DictHeatmap.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLResult, "heatmap_grad_cam", out hv_DictHeatmap);
                                hv_MethodName.Dispose();
                                hv_MethodName = "Grad-CAM";
                            }
                            else
                            {
                                hv_DictHeatmap.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLResult, "heatmap_confidence_based",
                                    out hv_DictHeatmap);
                                hv_MethodName.Dispose();
                                hv_MethodName = "Confidence based";
                            }
                            hv_HeatmapKeys.Dispose();
                            HOperatorSet.GetDictParam(hv_DictHeatmap, "keys", new HTuple(), out hv_HeatmapKeys);
                            hv_HeatmapImageName.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_HeatmapImageName = hv_HeatmapKeys.TupleRegexpSelect(
                                    "heatmap_image_class_[0-9]*");
                            }
                            hv_TargetClassID.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TargetClassID = hv_HeatmapImageName.TupleRegexpMatch(
                                    "heatmap_image_class_([0-9]+)$");
                            }
                            ho_ImageHeatmap.Dispose();
                            HOperatorSet.GetDictObject(out ho_ImageHeatmap, hv_DictHeatmap, hv_HeatmapImageName);
                        }
                        else
                        {
                            throw new HalconException("Heatmap image could not be found in DLResult.");
                        }
                        //
                        if ((int)(new HTuple(hv_SelectedHeatmapMethod.TupleEqual("heatmap_grad_cam"))) != 0)
                        {
                            //Read in input image.
                            ho_Image.Dispose();
                            HOperatorSet.GetDictObject(out ho_Image, hv_DLSample, "image");
                            //Add the heatmap to the input image.
                            {
                                HObject ExpTmpOutVar_0;
                                add_colormap_to_image(ho_ImageHeatmap, ho_Image, out ExpTmpOutVar_0,
                                    hv_HeatmapColorScheme);
                                ho_ImageHeatmap.Dispose();
                                ho_ImageHeatmap = ExpTmpOutVar_0;
                            }
                        }
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_ImageHeatmap, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_ImageHeatmap, HDevWindowStack.GetActive());
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Classification heatmap " + hv_ImageIDStringBraces;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            hv_ClassNames.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLResult, "classification_class_names",
                                out hv_ClassNames);
                            hv_ClassIDs.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLResult, "classification_class_ids", out hv_ClassIDs);
                            hv_Confidences.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLResult, "classification_confidences",
                                out hv_Confidences);
                            if ((int)(new HTuple(hv_SelectedHeatmapMethod.TupleEqual("heatmap_confidence_based"))) != 0)
                            {
                                hv_MaxDeviation.Dispose();
                                HOperatorSet.GetDictTuple(hv_DictHeatmap, "classification_heatmap_maxdeviation",
                                    out hv_MaxDeviation);
                            }
                            hv_ClassificationLabelNameResult.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClassificationLabelNameResult = hv_ClassNames.TupleSelect(
                                    0);
                            }
                            hv_ClassificationLabelIDResult.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClassificationLabelIDResult = hv_ClassIDs.TupleSelect(
                                    0);
                            }
                            hv_TargetClassConfidence.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TargetClassConfidence = hv_Confidences.TupleSelect(
                                    hv_ClassIDs.TupleFind(hv_TargetClassID.TupleNumber()));
                            }
                            hv_Text.Dispose();
                            hv_Text = "--------- ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Image ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "--------- ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("image_label_id"))).TupleNotEqual(
                                -1))) != 0)
                            {
                                hv_ClassificationLabelIDGroundTruth.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLSample, "image_label_id", out hv_ClassificationLabelIDGroundTruth);
                                hv_ClassificationLabelNamesGroundTruth.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLDatasetInfo, "class_names", out hv_ClassificationLabelNamesGroundTruth);
                                //Get prediction color.
                                if ((int)(new HTuple(hv_ClassificationLabelIDGroundTruth.TupleEqual(
                                    hv_ClassificationLabelIDResult))) != 0)
                                {
                                    hv_PredictionColor.Dispose();
                                    hv_PredictionColor = "green";
                                }
                                else
                                {
                                    hv_PredictionColor.Dispose();
                                    hv_PredictionColor = "red";
                                }
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Ground truth class: ";
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = hv_ClassificationLabelNamesGroundTruth.TupleSelect(
                                    hv_ClassificationLabelIDGroundTruth);
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            }
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Predicted class: ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = hv_ClassificationLabelNameResult;
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Confidence: " + (((hv_Confidences.TupleSelect(
                                0))).TupleString(".2f"));
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "--------- ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Heatmap ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "--------- ";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Method: " + hv_MethodName;
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Target class: " + hv_TargetClassID;
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "Target class confidence: " + (hv_TargetClassConfidence.TupleString(
                                ".2f"));
                            if ((int)(new HTuple(hv_SelectedHeatmapMethod.TupleEqual("heatmap_confidence_based"))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = "Maximum deviation: " + (hv_MaxDeviation.TupleString(
                                    ".2f"));
                            }
                            //
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_LineColors.Dispose();
                                HOperatorSet.TupleGenConst(new HTuple(hv_Text.TupleLength()), "white",
                                    out hv_LineColors);
                            }
                            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("image_label_id"))).TupleNotEqual(
                                -1))) != 0)
                            {
                                if (hv_LineColors == null)
                                    hv_LineColors = new HTuple();
                                hv_LineColors[8] = hv_PredictionColor;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", hv_LineColors, "box", "false");
                            }
                        }
                        //
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "segmentation_weight"))) != 0)
                    {
                        //
                        //Weight image.
                        ho_ImageWeight.Dispose();
                        get_weight_image(out ho_ImageWeight, hv_SampleKeys, hv_DLSample);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_ImageWeight, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_ImageWeight, HDevWindowStack.GetActive());
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Weight image " + hv_ImageIDStringBraces,
                                        "window", "bottom", "left", "white", "box", "false");
                                }
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "segmentation_confidence"))) != 0)
                    {
                        //
                        //Segmentation confidences.
                        ho_ImageConfidence.Dispose();
                        get_confidence_image(out ho_ImageConfidence, hv_ResultKeys, hv_DLResult);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_ImageConfidence, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_ImageConfidence, HDevWindowStack.GetActive());
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Confidence image " + hv_ImageIDStringBraces,
                                        "window", "bottom", "left", "white", "box", "false");
                                }
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "bbox_ground_truth"))) != 0)
                    {
                        //
                        //Sample bounding boxes on image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        hv_BboxIDs.Dispose();
                        dev_display_ground_truth_detection(hv_DLSample, hv_SampleKeys, hv_LineWidth,
                            hv_ClassIDs, hv_Colors, hv_BboxLabelColor, hv_WindowImageRatio, hv_BboxTextColor,
                            hv_ShowLabels, hv_ShowDirection, hv_CurrentWindowHandle, out hv_BboxIDs);
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Ground truth " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            hv_BboxColors.Dispose();
                            hv_BboxColors = "white";
                            if ((int)(new HTuple(hv_BboxIDs.TupleLength())) != 0)
                            {
                                hv_BboxIDsUniq.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_BboxIDsUniq = ((hv_BboxIDs.TupleSort()
                                        )).TupleUniq();
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                            hv_ClassesLegend.TupleSelect(hv_BboxIDsUniq));
                                        hv_Text.Dispose();
                                        hv_Text = ExpTmpLocalVar_Text;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_BboxColors = hv_BboxColors.TupleConcat(
                                            hv_Colors.TupleSelect(hv_BboxIDsUniq));
                                        hv_BboxColors.Dispose();
                                        hv_BboxColors = ExpTmpLocalVar_BboxColors;
                                    }
                                }
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                            "No ground truth bounding boxes present.");
                                        hv_Text.Dispose();
                                        hv_Text = ExpTmpLocalVar_Text;
                                    }
                                }
                            }
                            //
                            //Get or open next child window.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", hv_BboxColors, "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "bbox_result"))) != 0)
                    {
                        //
                        //Result bounding boxes on image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        if ((int)(new HTuple(((hv_ResultKeys.TupleFind("bbox_confidence"))).TupleNotEqual(
                            -1))) != 0)
                        {
                            hv_BboxConfidences.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLResult, "bbox_confidence", out hv_BboxConfidences);
                        }
                        else
                        {
                            throw new HalconException("Result bounding box data could not be found in DLResult.");
                        }
                        if ((int)(hv_BboxDisplayConfidence) != 0)
                        {
                            hv_TextConf.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TextConf = (" (" + (hv_BboxConfidences.TupleString(
                                    ".2f"))) + ")";
                            }
                        }
                        else
                        {
                            hv_TextConf.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TextConf = HTuple.TupleGenConst(
                                    new HTuple(hv_BboxConfidences.TupleLength()), "");
                            }
                        }
                        hv_BboxClassIndex.Dispose();
                        dev_display_result_detection(hv_DLResult, hv_ResultKeys, hv_LineWidth,
                            hv_ClassIDs, hv_TextConf, hv_Colors, hv_BboxLabelColor, hv_WindowImageRatio,
                            "top", hv_BboxTextColor, hv_ShowLabels, hv_ShowDirection, hv_CurrentWindowHandle,
                            out hv_BboxClassIndex);
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Result bounding boxes " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            hv_BboxColorsResults.Dispose();
                            hv_BboxColorsResults = "white";
                            if ((int)(new HTuple((new HTuple(hv_BboxClassIndex.TupleLength())).TupleGreater(
                                0))) != 0)
                            {
                                hv_BboxClassIndexUniq.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_BboxClassIndexUniq = ((hv_BboxClassIndex.TupleSort()
                                        )).TupleUniq();
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                            hv_ClassesLegend.TupleSelect(hv_BboxClassIndexUniq));
                                        hv_Text.Dispose();
                                        hv_Text = ExpTmpLocalVar_Text;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_BboxColorsResults = hv_BboxColorsResults.TupleConcat(
                                            hv_Colors.TupleSelect(hv_BboxClassIndexUniq));
                                        hv_BboxColorsResults.Dispose();
                                        hv_BboxColorsResults = ExpTmpLocalVar_BboxColorsResults;
                                    }
                                }
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                            "No result bounding boxes present.");
                                        hv_Text.Dispose();
                                        hv_Text = ExpTmpLocalVar_Text;
                                    }
                                }
                            }
                            //
                            //Get or open next child window.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", hv_BboxColorsResults, "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "bbox_both"))) != 0)
                    {
                        //
                        //Ground truth and result bounding boxes on image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        //Visualization.
                        hv_BboxLabelIndex.Dispose();
                        dev_display_ground_truth_detection(hv_DLSample, hv_SampleKeys, hv_LineWidth,
                            hv_ClassIDs, hv_Colors, hv_BboxLabelColor, hv_WindowImageRatio, hv_BboxTextColor,
                            hv_ShowLabels, hv_ShowDirection, hv_CurrentWindowHandle, out hv_BboxLabelIndex);
                        if ((int)(new HTuple(((hv_ResultKeys.TupleFind("bbox_confidence"))).TupleNotEqual(
                            -1))) != 0)
                        {
                            hv_BboxConfidences.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLResult, "bbox_confidence", out hv_BboxConfidences);
                        }
                        else
                        {
                            throw new HalconException("Result bounding box data could not be found in DLResult.");
                        }
                        if ((int)(hv_BboxDisplayConfidence) != 0)
                        {
                            hv_TextConf.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TextConf = (" (" + (hv_BboxConfidences.TupleString(
                                    ".2f"))) + ")";
                            }
                        }
                        else
                        {
                            hv_TextConf.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TextConf = HTuple.TupleGenConst(
                                    new HTuple(hv_BboxConfidences.TupleLength()), "");
                            }
                        }
                        hv_BboxClassIndex.Dispose();
                        dev_display_result_detection(hv_DLResult, hv_ResultKeys, hv_LineWidth,
                            hv_ClassIDs, hv_TextConf, hv_Colors, hv_BboxLabelColor, hv_WindowImageRatio,
                            "bottom", hv_BboxTextColor, hv_ShowLabels, hv_ShowDirection, hv_CurrentWindowHandle,
                            out hv_BboxClassIndex);
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Ground truth and result bounding boxes " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        hv_Text.Dispose();
                        hv_Text = "Ground truth and";
                        if (hv_Text == null)
                            hv_Text = new HTuple();
                        hv_Text[new HTuple(hv_Text.TupleLength())] = "result bounding boxes " + hv_ImageIDStringBraces;
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            hv_BboxColorsBoth.Dispose();
                            hv_BboxColorsBoth = new HTuple();
                            hv_BboxColorsBoth[0] = "white";
                            hv_BboxColorsBoth[1] = "white";
                            if ((int)(new HTuple((new HTuple((new HTuple(hv_BboxClassIndex.TupleLength()
                                )) + (new HTuple(hv_BboxLabelIndex.TupleLength())))).TupleGreater(0))) != 0)
                            {
                                hv_BboxClassLabelIndexUniq.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_BboxClassLabelIndexUniq = ((((hv_BboxClassIndex.TupleConcat(
                                        hv_BboxLabelIndex))).TupleSort())).TupleUniq();
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                            hv_ClassesLegend.TupleSelect(hv_BboxClassLabelIndexUniq));
                                        hv_Text.Dispose();
                                        hv_Text = ExpTmpLocalVar_Text;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_BboxColorsBoth = hv_BboxColorsBoth.TupleConcat(
                                            hv_Colors.TupleSelect(hv_BboxClassLabelIndexUniq));
                                        hv_BboxColorsBoth.Dispose();
                                        hv_BboxColorsBoth = ExpTmpLocalVar_BboxColorsBoth;
                                    }
                                }
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                            "No ground truth nor result bounding boxes present.");
                                        hv_Text.Dispose();
                                        hv_Text = ExpTmpLocalVar_Text;
                                    }
                                }
                            }
                            //
                            //Get or open next child window.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "top", "left", hv_BboxColorsBoth, "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "segmentation_image_ground_truth"))) != 0)
                    {
                        //
                        //Ground truth segmentation image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        ho_SegmentationImagGroundTruth.Dispose();
                        get_segmentation_image_ground_truth(out ho_SegmentationImagGroundTruth,
                            hv_SampleKeys, hv_DLSample);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        //Display segmentation regions.
                        hv_ColorsSegmentation.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ColorsSegmentation = hv_Colors + hv_SegTransparency;
                        }
                        hv_DrawMode.Dispose();
                        HOperatorSet.GetDraw(hv_CurrentWindowHandle, out hv_DrawMode);
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_SegDraw);
                        }
                        hv_Width.Dispose();
                        HOperatorSet.GetLineWidth(hv_CurrentWindowHandle, out hv_Width);
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidth);
                        }
                        hv_ImageClassIDs.Dispose();
                        dev_display_segmentation_regions(ho_SegmentationImagGroundTruth, hv_ClassIDs,
                            hv_ColorsSegmentation, hv_SegExcludeClassIDs, out hv_ImageClassIDs);
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_Width.TupleInt()
                                    );
                            }
                        }
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Ground truth segmentation " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            hv_ImageClassIDsUniq.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ImageClassIDsUniq = ((hv_ImageClassIDs.TupleSort()
                                    )).TupleUniq();
                            }
                            //Get Indices according to image class IDs.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ImageClassIDsIndices.Dispose();
                                HOperatorSet.TupleGenConst(new HTuple(hv_ImageClassIDsUniq.TupleLength()
                                    ), 0, out hv_ImageClassIDsIndices);
                            }
                            for (hv_ImageClassIDsIndex = 0; (int)hv_ImageClassIDsIndex <= (int)((new HTuple(hv_ImageClassIDsUniq.TupleLength()
                                )) - 1); hv_ImageClassIDsIndex = (int)hv_ImageClassIDsIndex + 1)
                            {
                                if (hv_ImageClassIDsIndices == null)
                                    hv_ImageClassIDsIndices = new HTuple();
                                hv_ImageClassIDsIndices[hv_ImageClassIDsIndex] = hv_ClassIDs.TupleFindFirst(
                                    hv_ImageClassIDsUniq.TupleSelect(hv_ImageClassIDsIndex));
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                        hv_ClassesLegend.TupleSelect(hv_ImageClassIDsIndices));
                                    hv_Text.Dispose();
                                    hv_Text = ExpTmpLocalVar_Text;
                                }
                            }
                            //
                            //Get or open next child window
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                        "top", "left", (new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                                        hv_ImageClassIDsIndices)), "box", "false");
                                }
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "segmentation_image_result"))) != 0)
                    {
                        //
                        //Result segmentation on image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        ho_SegmentationImageResult.Dispose();
                        get_segmentation_image_result(out ho_SegmentationImageResult, hv_ResultKeys,
                            hv_DLResult);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        //Display result segmentation regions.
                        hv_ColorsResults.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ColorsResults = hv_Colors + hv_SegTransparency;
                        }
                        hv_DrawMode.Dispose();
                        HOperatorSet.GetDraw(hv_CurrentWindowHandle, out hv_DrawMode);
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_SegDraw);
                        }
                        hv_Width.Dispose();
                        HOperatorSet.GetLineWidth(hv_CurrentWindowHandle, out hv_Width);
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidth);
                        }
                        hv_ImageClassIDs.Dispose();
                        dev_display_segmentation_regions(ho_SegmentationImageResult, hv_ClassIDs,
                            hv_ColorsResults, hv_SegExcludeClassIDs, out hv_ImageClassIDs);
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_Width.TupleInt()
                                    );
                            }
                        }
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Result segmentation " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            hv_ImageClassIDsUniq.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ImageClassIDsUniq = ((hv_ImageClassIDs.TupleSort()
                                    )).TupleUniq();
                            }
                            //Get Indices according to image class IDs.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ImageClassIDsIndices.Dispose();
                                HOperatorSet.TupleGenConst(new HTuple(hv_ImageClassIDsUniq.TupleLength()
                                    ), 0, out hv_ImageClassIDsIndices);
                            }
                            for (hv_ImageClassIDsIndex = 0; (int)hv_ImageClassIDsIndex <= (int)((new HTuple(hv_ImageClassIDsUniq.TupleLength()
                                )) - 1); hv_ImageClassIDsIndex = (int)hv_ImageClassIDsIndex + 1)
                            {
                                if (hv_ImageClassIDsIndices == null)
                                    hv_ImageClassIDsIndices = new HTuple();
                                hv_ImageClassIDsIndices[hv_ImageClassIDsIndex] = hv_ClassIDs.TupleFindFirst(
                                    hv_ImageClassIDsUniq.TupleSelect(hv_ImageClassIDsIndex));
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                        hv_ClassesLegend.TupleSelect(hv_ImageClassIDsIndices));
                                    hv_Text.Dispose();
                                    hv_Text = ExpTmpLocalVar_Text;
                                }
                            }
                            //
                            //Get or open next child window.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                        "top", "left", (new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                                        hv_ImageClassIDsIndices)), "box", "false");
                                }
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "segmentation_image_both"))) != 0)
                    {
                        //
                        //Ground truth and result segmentation on image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        ho_SegmentationImagGroundTruth.Dispose();
                        get_segmentation_image_ground_truth(out ho_SegmentationImagGroundTruth,
                            hv_SampleKeys, hv_DLSample);
                        ho_SegmentationImageResult.Dispose();
                        get_segmentation_image_result(out ho_SegmentationImageResult, hv_ResultKeys,
                            hv_DLResult);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        //
                        //Display regions.
                        hv_ColorsResults.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ColorsResults = hv_Colors + hv_SegTransparency;
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 2);
                        }
                        hv_GroundTruthIDs.Dispose();
                        dev_display_segmentation_regions(ho_SegmentationImagGroundTruth, hv_ClassIDs,
                            hv_ColorsResults, hv_SegExcludeClassIDs, out hv_GroundTruthIDs);
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), 6);
                        }
                        hv_ResultIDs.Dispose();
                        dev_display_segmentation_regions(ho_SegmentationImageResult, hv_ClassIDs,
                            hv_ColorsResults, hv_SegExcludeClassIDs, out hv_ResultIDs);
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
                        }
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = "Ground truth and result segmentation " + hv_ImageIDStringBraces;
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                        //
                        //Display the legend.
                        if ((int)(hv_ShowLegend) != 0)
                        {
                            hv_ImageClassIDsUniq.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ImageClassIDsUniq = ((((hv_GroundTruthIDs.TupleConcat(
                                    hv_ResultIDs))).TupleSort())).TupleUniq();
                            }
                            //Get Indices according to image class IDs.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ImageClassIDsIndices.Dispose();
                                HOperatorSet.TupleGenConst(new HTuple(hv_ImageClassIDsUniq.TupleLength()
                                    ), 0, out hv_ImageClassIDsIndices);
                            }
                            for (hv_ImageClassIDsIndex = 0; (int)hv_ImageClassIDsIndex <= (int)((new HTuple(hv_ImageClassIDsUniq.TupleLength()
                                )) - 1); hv_ImageClassIDsIndex = (int)hv_ImageClassIDsIndex + 1)
                            {
                                if (hv_ImageClassIDsIndices == null)
                                    hv_ImageClassIDsIndices = new HTuple();
                                hv_ImageClassIDsIndices[hv_ImageClassIDsIndex] = hv_ClassIDs.TupleFindFirst(
                                    hv_ImageClassIDsUniq.TupleSelect(hv_ImageClassIDsIndex));
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_Text = hv_Text.TupleConcat(
                                        hv_ClassesLegend.TupleSelect(hv_ImageClassIDsIndices));
                                    hv_Text.Dispose();
                                    hv_Text = ExpTmpLocalVar_Text;
                                }
                            }
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[(new HTuple(hv_Text.TupleLength())) + 1] = new HTuple("- thicker line: result, thinner lines: ground truth");
                            if (hv_Text == null)
                                hv_Text = new HTuple();
                            hv_Text[new HTuple(hv_Text.TupleLength())] = "  (you may have to zoom in for a more detailed view)";
                            hv_StringSegExcludeClassIDs.Dispose();
                            hv_StringSegExcludeClassIDs = "";
                            for (hv_StringIndex = 0; (int)hv_StringIndex <= (int)((new HTuple(hv_SegExcludeClassIDs.TupleLength()
                                )) - 1); hv_StringIndex = (int)hv_StringIndex + 1)
                            {
                                if ((int)(new HTuple(hv_StringIndex.TupleEqual((new HTuple(hv_SegExcludeClassIDs.TupleLength()
                                    )) - 1))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_StringSegExcludeClassIDs = hv_StringSegExcludeClassIDs + (hv_SegExcludeClassIDs.TupleSelect(
                                                hv_StringIndex));
                                            hv_StringSegExcludeClassIDs.Dispose();
                                            hv_StringSegExcludeClassIDs = ExpTmpLocalVar_StringSegExcludeClassIDs;
                                        }
                                    }
                                }
                                else
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_StringSegExcludeClassIDs = (hv_StringSegExcludeClassIDs + (hv_SegExcludeClassIDs.TupleSelect(
                                                hv_StringIndex))) + new HTuple(", ");
                                            hv_StringSegExcludeClassIDs.Dispose();
                                            hv_StringSegExcludeClassIDs = ExpTmpLocalVar_StringSegExcludeClassIDs;
                                        }
                                    }
                                }
                            }
                            if ((int)(new HTuple(hv_SegExcludeClassIDs.TupleNotEqual(new HTuple()))) != 0)
                            {
                                if (hv_Text == null)
                                    hv_Text = new HTuple();
                                hv_Text[new HTuple(hv_Text.TupleLength())] = ("- (excluded classID(s) " + hv_StringSegExcludeClassIDs) + " from visualization)";
                            }
                            //
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                                get_child_window(hv_HeightImage, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                                    hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex),
                                    out hv_WindowImageRatio, out ExpTmpOutVar_0);
                                hv_PrevWindowCoordinates.Dispose();
                                hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                        "top", "left", (((new HTuple("white")).TupleConcat(hv_Colors.TupleSelect(
                                        hv_ImageClassIDsIndices)))).TupleConcat(((new HTuple("white")).TupleConcat(
                                        "white")).TupleConcat("white")), "box", "false");
                                }
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "segmentation_image_diff"))) != 0)
                    {
                        //
                        //Difference of ground truth and result segmentation on image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        ho_SegmentationImagGroundTruth.Dispose();
                        get_segmentation_image_ground_truth(out ho_SegmentationImagGroundTruth,
                            hv_SampleKeys, hv_DLSample);
                        ho_SegmentationImageResult.Dispose();
                        get_segmentation_image_result(out ho_SegmentationImageResult, hv_ResultKeys,
                            hv_DLResult);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, 0, hv_ScaleWindows, hv_ThresholdWidth, hv_PrevWindowCoordinates,
                                hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(hv_KeyIndex), out hv_CurrentWindowHandle,
                                out hv_WindowImageRatio, out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        ho_ImageAbsDiff.Dispose();
                        HOperatorSet.AbsDiffImage(ho_SegmentationImagGroundTruth, ho_SegmentationImageResult,
                            out ho_ImageAbsDiff, 1);
                        hv_Min.Dispose(); hv_Max.Dispose(); hv_Range.Dispose();
                        HOperatorSet.MinMaxGray(ho_SegmentationImageResult, ho_ImageAbsDiff, 0,
                            out hv_Min, out hv_Max, out hv_Range);
                        if ((int)(new HTuple(hv_Min.TupleNotEqual(hv_Max))) != 0)
                        {
                            ho_DiffRegion.Dispose();
                            HOperatorSet.Threshold(ho_ImageAbsDiff, out ho_DiffRegion, 0.00001, hv_Max);
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetColor(HDevWindowStack.GetActive(), "#ff0000" + hv_SegTransparency);
                                }
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_DiffRegion, HDevWindowStack.GetActive());
                            }
                        }
                        else
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), "No difference found.",
                                    "window", "top", "left", "black", new HTuple(), new HTuple());
                            }
                        }
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            hv_Text.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Text = "Difference of ground truth and result segmentation " + hv_ImageIDStringBraces;
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                    "bottom", "left", "white", "box", "false");
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "segmentation_weight_map"))) != 0)
                    {
                        //
                        //Weight map on image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        ho_ImageWeight.Dispose();
                        get_weight_image(out ho_ImageWeight, hv_SampleKeys, hv_DLSample);
                        //
                        if ((int)(new HTuple(hv_SegMaxWeight.TupleEqual(0))) != 0)
                        {
                            //Calculate SegMaxWeight if not given in GenParam.
                            hv_MinWeight.Dispose(); hv_SegMaxWeight.Dispose(); hv_Range.Dispose();
                            HOperatorSet.MinMaxGray(ho_ImageWeight, ho_ImageWeight, 0, out hv_MinWeight,
                                out hv_SegMaxWeight, out hv_Range);
                        }
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, hv_MapColorBarWidth, hv_ScaleWindows, hv_ThresholdWidth,
                                hv_PrevWindowCoordinates, hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(
                                hv_KeyIndex), out hv_CurrentWindowHandle, out hv_WindowImageRatio,
                                out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        hv_WeightsColors.Dispose();
                        dev_display_weight_regions(ho_ImageWeight, hv_MapTransparency, hv_SegMaxWeight,
                            out hv_WeightsColors);
                        dev_display_map_color_bar(hv_WidthImage, hv_HeightImage, hv_MapColorBarWidth,
                            hv_WeightsColors, hv_SegMaxWeight, hv_WindowImageRatio, hv_CurrentWindowHandle);
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Weight map " + hv_ImageIDStringBraces,
                                        "window", "bottom", "left", "white", "box", "false");
                                }
                            }
                        }
                    }
                    else if ((int)(new HTuple(((hv_KeysForDisplay.TupleSelect(hv_KeyIndex))).TupleEqual(
                        "segmentation_confidence_map"))) != 0)
                    {
                        //
                        //Segmentation confidence map on image.
                        ho_Image.Dispose();
                        get_image(out ho_Image, hv_SampleKeys, hv_DLSample);
                        ho_ImageConfidence.Dispose();
                        get_confidence_image(out ho_ImageConfidence, hv_ResultKeys, hv_DLResult);
                        //
                        //Get or open next window.
                        hv_WidthImage.Dispose(); hv_HeightImage.Dispose();
                        HOperatorSet.GetImageSize(ho_Image, out hv_WidthImage, out hv_HeightImage);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatio.Dispose(); HTuple ExpTmpOutVar_0;
                            get_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                                hv_HeightImage, hv_MapColorBarWidth, hv_ScaleWindows, hv_ThresholdWidth,
                                hv_PrevWindowCoordinates, hv_WindowHandleDict, hv_KeysForDisplay.TupleSelect(
                                hv_KeyIndex), out hv_CurrentWindowHandle, out hv_WindowImageRatio,
                                out ExpTmpOutVar_0);
                            hv_PrevWindowCoordinates.Dispose();
                            hv_PrevWindowCoordinates = ExpTmpOutVar_0;
                        }
                        //
                        //Visualization.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_Image, HDevWindowStack.GetActive());
                        }
                        hv_ConfidenceColors.Dispose();
                        dev_display_confidence_regions(ho_ImageConfidence, hv_MapTransparency,
                            out hv_ConfidenceColors);
                        dev_display_map_color_bar(hv_WidthImage, hv_HeightImage, hv_MapColorBarWidth,
                            hv_ConfidenceColors, 1.0, hv_WindowImageRatio, hv_CurrentWindowHandle);
                        if ((int)(hv_ShowBottomDesc) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Confidence map " + hv_ImageIDStringBraces,
                                        "window", "bottom", "left", "white", "box", "false");
                                }
                            }
                        }
                    }
                    else
                    {
                        //Reset flush buffer of existing windows before throwing an exception.
                        hv_WindowHandleKeys.Dispose();
                        HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_WindowHandleKeys);
                        for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_WindowHandleKeys.TupleLength()
                            )) - 1); hv_Index = (int)hv_Index + 1)
                        {
                            //Only consider the WindowHandleKeys that are needed for the current visualization.
                            hv_Indices.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Indices = hv_KeysForDisplay.TupleFind(
                                    hv_WindowHandleKeys.TupleSelect(hv_Index));
                            }
                            if ((int)((new HTuple(hv_Indices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_Indices.TupleNotEqual(
                                new HTuple())))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_WindowHandles.Dispose();
                                    HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKeys.TupleSelect(
                                        hv_Index), out hv_WindowHandles);
                                }
                                for (hv_WindowIndex = 0; (int)hv_WindowIndex <= (int)((new HTuple(hv_WindowHandles.TupleLength()
                                    )) - 1); hv_WindowIndex = (int)hv_WindowIndex + 1)
                                {
                                    //Reset values of windows that have been changed temporarily.
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex),
                                            "flush", hv_FlushValues.TupleSelect(hv_Index));
                                    }
                                }
                            }
                        }
                        throw new HalconException("Key for display unknown: " + (hv_KeysForDisplay.TupleSelect(
                            hv_KeyIndex)));
                    }
                }
                //
                //Display results.
                hv_WindowHandleKeysNew.Dispose();
                HOperatorSet.GetDictParam(hv_WindowHandleDict, "keys", new HTuple(), out hv_WindowHandleKeysNew);
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_WindowHandleKeysNew.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    //Only consider the WindowHandleKeys that are needed for the current visualization.
                    hv_KeyIndex.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_KeyIndex = hv_KeysForDisplay.TupleFind(
                            hv_WindowHandleKeysNew.TupleSelect(hv_Index));
                    }
                    if ((int)((new HTuple(hv_KeyIndex.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_KeyIndex.TupleNotEqual(
                        new HTuple())))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_WindowHandles.Dispose();
                            HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKeysNew.TupleSelect(
                                hv_Index), out hv_WindowHandles);
                        }
                        for (hv_WindowIndex = 0; (int)hv_WindowIndex <= (int)((new HTuple(hv_WindowHandles.TupleLength()
                            )) - 1); hv_WindowIndex = (int)hv_WindowIndex + 1)
                        {
                            //Display content of window handle.
                            if ((int)(new HTuple((new HTuple(hv_WindowHandleKeys.TupleLength())).TupleEqual(
                                new HTuple(hv_WindowHandleKeysNew.TupleLength())))) != 0)
                            {
                                //Reset values of windows that have been changed temporarily.
                                if ((int)(new HTuple(((hv_FlushValues.TupleSelect(hv_WindowIndex))).TupleEqual(
                                    "true"))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.FlushBuffer(hv_WindowHandles.TupleSelect(hv_WindowIndex));
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex),
                                        "flush", hv_FlushValues.TupleSelect(hv_WindowIndex));
                                }
                            }
                            else
                            {
                                //Per default, 'flush' of new windows should be set to 'true'.
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.FlushBuffer(hv_WindowHandles.TupleSelect(hv_WindowIndex));
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetWindowParam(hv_WindowHandles.TupleSelect(hv_WindowIndex),
                                        "flush", "true");
                                }
                            }
                        }
                    }
                }
                //
                ho_Image.Dispose();
                ho_AnomalyImage.Dispose();
                ho_AnomalyRegion.Dispose();
                ho_PredictionColorFrame.Dispose();
                ho_ImageHeatmap.Dispose();
                ho_ImageWeight.Dispose();
                ho_ImageConfidence.Dispose();
                ho_SegmentationImagGroundTruth.Dispose();
                ho_SegmentationImageResult.Dispose();
                ho_ImageAbsDiff.Dispose();
                ho_DiffRegion.Dispose();

                hv_ThresholdWidth.Dispose();
                hv_ScaleWindows.Dispose();
                hv_Font.Dispose();
                hv_FontSize.Dispose();
                hv_LineWidth.Dispose();
                hv_MapTransparency.Dispose();
                hv_MapColorBarWidth.Dispose();
                hv_AnomalyRegionThreshold.Dispose();
                hv_AnomalyClassificationThreshold.Dispose();
                hv_AnomalyRegionLabelColor.Dispose();
                hv_AnomalyColorTransparency.Dispose();
                hv_AnomalyRegionResultColor.Dispose();
                hv_SegMaxWeight.Dispose();
                hv_SegDraw.Dispose();
                hv_SegTransparency.Dispose();
                hv_SegExcludeClassIDs.Dispose();
                hv_BboxLabelColor.Dispose();
                hv_BboxDisplayConfidence.Dispose();
                hv_BboxTextColor.Dispose();
                hv_ShowBottomDesc.Dispose();
                hv_ShowLegend.Dispose();
                hv_ShowGroundTruthAnomalyRegions.Dispose();
                hv_ShowClassificationIDs.Dispose();
                hv_ShowClassificationColorFrame.Dispose();
                hv_ShowLabels.Dispose();
                hv_ShowDirection.Dispose();
                hv_HeatmapColorScheme.Dispose();
                hv_GenParamNames.Dispose();
                hv_ParamIndex.Dispose();
                hv_GenParamName.Dispose();
                hv_GenParamValue.Dispose();
                hv_SampleKeys.Dispose();
                hv_ResultKeys.Dispose();
                hv_ImageIDExists.Dispose();
                hv_ImageID.Dispose();
                hv_ImageIDString.Dispose();
                hv_ImageIDStringBraces.Dispose();
                hv_ImageIDStringCapital.Dispose();
                hv_NeededKeys.Dispose();
                hv_Index.Dispose();
                hv_DLDatasetInfoKeys.Dispose();
                hv_ClassNames.Dispose();
                hv_ClassIDs.Dispose();
                hv_Colors.Dispose();
                hv_ClassesLegend.Dispose();
                hv_PrevWindowCoordinates.Dispose();
                hv_Keys.Dispose();
                hv_Exception.Dispose();
                hv_MetaInfoIndex.Dispose();
                hv_MetaInfo.Dispose();
                hv_FlushValues.Dispose();
                hv_WindowHandleKeys.Dispose();
                hv_KeyIndex.Dispose();
                hv_WindowHandles.Dispose();
                hv_WindowIndex.Dispose();
                hv_FlushValue.Dispose();
                hv_WidthImage.Dispose();
                hv_HeightImage.Dispose();
                hv_CurrentWindowHandle.Dispose();
                hv_WindowImageRatio.Dispose();
                hv_AnomalyLabelGroundTruth.Dispose();
                hv_AnomalyLabelIDGroundTruth.Dispose();
                hv_AnomalyRegionExists.Dispose();
                hv_Text.Dispose();
                hv_AnomalyScore.Dispose();
                hv_AnomalyClassID.Dispose();
                hv_AnomalyClassThresholdDisplay.Dispose();
                hv_AnomalyRegionThresholdDisplay.Dispose();
                hv_AnomalyRegionGroundTruthExists.Dispose();
                hv_PredictionColor.Dispose();
                hv_LineColors.Dispose();
                hv_ResultColorOffset.Dispose();
                hv_ClassificationLabelIDGroundTruth.Dispose();
                hv_ClassificationLabelIDResult.Dispose();
                hv_MarginBottom.Dispose();
                hv_WindowCoordinates.Dispose();
                hv_CurrentWindowHeight.Dispose();
                hv__.Dispose();
                hv_MaxHeight.Dispose();
                hv_PredictionText.Dispose();
                hv_BoarderOffset.Dispose();
                hv_WindowImageRatioHeight.Dispose();
                hv_WindowImageRatioWidth.Dispose();
                hv_BoarderOffsetRow.Dispose();
                hv_BoarderOffsetCol.Dispose();
                hv_SelectedHeatmapMethod.Dispose();
                hv_DictHeatmap.Dispose();
                hv_MethodName.Dispose();
                hv_HeatmapKeys.Dispose();
                hv_HeatmapImageName.Dispose();
                hv_TargetClassID.Dispose();
                hv_Confidences.Dispose();
                hv_MaxDeviation.Dispose();
                hv_ClassificationLabelNameResult.Dispose();
                hv_TargetClassConfidence.Dispose();
                hv_ClassificationLabelNamesGroundTruth.Dispose();
                hv_BboxIDs.Dispose();
                hv_BboxColors.Dispose();
                hv_BboxIDsUniq.Dispose();
                hv_BboxConfidences.Dispose();
                hv_TextConf.Dispose();
                hv_BboxClassIndex.Dispose();
                hv_BboxColorsResults.Dispose();
                hv_BboxClassIndexUniq.Dispose();
                hv_BboxLabelIndex.Dispose();
                hv_BboxColorsBoth.Dispose();
                hv_BboxClassLabelIndexUniq.Dispose();
                hv_ColorsSegmentation.Dispose();
                hv_DrawMode.Dispose();
                hv_Width.Dispose();
                hv_ImageClassIDs.Dispose();
                hv_ImageClassIDsUniq.Dispose();
                hv_ImageClassIDsIndices.Dispose();
                hv_ImageClassIDsIndex.Dispose();
                hv_ColorsResults.Dispose();
                hv_GroundTruthIDs.Dispose();
                hv_ResultIDs.Dispose();
                hv_StringSegExcludeClassIDs.Dispose();
                hv_StringIndex.Dispose();
                hv_Min.Dispose();
                hv_Max.Dispose();
                hv_Range.Dispose();
                hv_MinWeight.Dispose();
                hv_WeightsColors.Dispose();
                hv_ConfidenceColors.Dispose();
                hv_Indices.Dispose();
                hv_WindowHandleKeysNew.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Image.Dispose();
                ho_AnomalyImage.Dispose();
                ho_AnomalyRegion.Dispose();
                ho_PredictionColorFrame.Dispose();
                ho_ImageHeatmap.Dispose();
                ho_ImageWeight.Dispose();
                ho_ImageConfidence.Dispose();
                ho_SegmentationImagGroundTruth.Dispose();
                ho_SegmentationImageResult.Dispose();
                ho_ImageAbsDiff.Dispose();
                ho_DiffRegion.Dispose();

                hv_ThresholdWidth.Dispose();
                hv_ScaleWindows.Dispose();
                hv_Font.Dispose();
                hv_FontSize.Dispose();
                hv_LineWidth.Dispose();
                hv_MapTransparency.Dispose();
                hv_MapColorBarWidth.Dispose();
                hv_AnomalyRegionThreshold.Dispose();
                hv_AnomalyClassificationThreshold.Dispose();
                hv_AnomalyRegionLabelColor.Dispose();
                hv_AnomalyColorTransparency.Dispose();
                hv_AnomalyRegionResultColor.Dispose();
                hv_SegMaxWeight.Dispose();
                hv_SegDraw.Dispose();
                hv_SegTransparency.Dispose();
                hv_SegExcludeClassIDs.Dispose();
                hv_BboxLabelColor.Dispose();
                hv_BboxDisplayConfidence.Dispose();
                hv_BboxTextColor.Dispose();
                hv_ShowBottomDesc.Dispose();
                hv_ShowLegend.Dispose();
                hv_ShowGroundTruthAnomalyRegions.Dispose();
                hv_ShowClassificationIDs.Dispose();
                hv_ShowClassificationColorFrame.Dispose();
                hv_ShowLabels.Dispose();
                hv_ShowDirection.Dispose();
                hv_HeatmapColorScheme.Dispose();
                hv_GenParamNames.Dispose();
                hv_ParamIndex.Dispose();
                hv_GenParamName.Dispose();
                hv_GenParamValue.Dispose();
                hv_SampleKeys.Dispose();
                hv_ResultKeys.Dispose();
                hv_ImageIDExists.Dispose();
                hv_ImageID.Dispose();
                hv_ImageIDString.Dispose();
                hv_ImageIDStringBraces.Dispose();
                hv_ImageIDStringCapital.Dispose();
                hv_NeededKeys.Dispose();
                hv_Index.Dispose();
                hv_DLDatasetInfoKeys.Dispose();
                hv_ClassNames.Dispose();
                hv_ClassIDs.Dispose();
                hv_Colors.Dispose();
                hv_ClassesLegend.Dispose();
                hv_PrevWindowCoordinates.Dispose();
                hv_Keys.Dispose();
                hv_Exception.Dispose();
                hv_MetaInfoIndex.Dispose();
                hv_MetaInfo.Dispose();
                hv_FlushValues.Dispose();
                hv_WindowHandleKeys.Dispose();
                hv_KeyIndex.Dispose();
                hv_WindowHandles.Dispose();
                hv_WindowIndex.Dispose();
                hv_FlushValue.Dispose();
                hv_WidthImage.Dispose();
                hv_HeightImage.Dispose();
                hv_CurrentWindowHandle.Dispose();
                hv_WindowImageRatio.Dispose();
                hv_AnomalyLabelGroundTruth.Dispose();
                hv_AnomalyLabelIDGroundTruth.Dispose();
                hv_AnomalyRegionExists.Dispose();
                hv_Text.Dispose();
                hv_AnomalyScore.Dispose();
                hv_AnomalyClassID.Dispose();
                hv_AnomalyClassThresholdDisplay.Dispose();
                hv_AnomalyRegionThresholdDisplay.Dispose();
                hv_AnomalyRegionGroundTruthExists.Dispose();
                hv_PredictionColor.Dispose();
                hv_LineColors.Dispose();
                hv_ResultColorOffset.Dispose();
                hv_ClassificationLabelIDGroundTruth.Dispose();
                hv_ClassificationLabelIDResult.Dispose();
                hv_MarginBottom.Dispose();
                hv_WindowCoordinates.Dispose();
                hv_CurrentWindowHeight.Dispose();
                hv__.Dispose();
                hv_MaxHeight.Dispose();
                hv_PredictionText.Dispose();
                hv_BoarderOffset.Dispose();
                hv_WindowImageRatioHeight.Dispose();
                hv_WindowImageRatioWidth.Dispose();
                hv_BoarderOffsetRow.Dispose();
                hv_BoarderOffsetCol.Dispose();
                hv_SelectedHeatmapMethod.Dispose();
                hv_DictHeatmap.Dispose();
                hv_MethodName.Dispose();
                hv_HeatmapKeys.Dispose();
                hv_HeatmapImageName.Dispose();
                hv_TargetClassID.Dispose();
                hv_Confidences.Dispose();
                hv_MaxDeviation.Dispose();
                hv_ClassificationLabelNameResult.Dispose();
                hv_TargetClassConfidence.Dispose();
                hv_ClassificationLabelNamesGroundTruth.Dispose();
                hv_BboxIDs.Dispose();
                hv_BboxColors.Dispose();
                hv_BboxIDsUniq.Dispose();
                hv_BboxConfidences.Dispose();
                hv_TextConf.Dispose();
                hv_BboxClassIndex.Dispose();
                hv_BboxColorsResults.Dispose();
                hv_BboxClassIndexUniq.Dispose();
                hv_BboxLabelIndex.Dispose();
                hv_BboxColorsBoth.Dispose();
                hv_BboxClassLabelIndexUniq.Dispose();
                hv_ColorsSegmentation.Dispose();
                hv_DrawMode.Dispose();
                hv_Width.Dispose();
                hv_ImageClassIDs.Dispose();
                hv_ImageClassIDsUniq.Dispose();
                hv_ImageClassIDsIndices.Dispose();
                hv_ImageClassIDsIndex.Dispose();
                hv_ColorsResults.Dispose();
                hv_GroundTruthIDs.Dispose();
                hv_ResultIDs.Dispose();
                hv_StringSegExcludeClassIDs.Dispose();
                hv_StringIndex.Dispose();
                hv_Min.Dispose();
                hv_Max.Dispose();
                hv_Range.Dispose();
                hv_MinWeight.Dispose();
                hv_WeightsColors.Dispose();
                hv_ConfidenceColors.Dispose();
                hv_Indices.Dispose();
                hv_WindowHandleKeysNew.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Visualize for a given number of samples the raw image, ground truth annotation, and inferred results. 
        public void dev_display_dl_data_tiled(HTuple hv_DLDataset, HTuple hv_DLModelHandle,
            HTuple hv_NumSamples, HTuple hv_Split, HTuple hv_GenParam, HTuple hv_WindowHandle,
            out HTuple hv_WindowHandleOut)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_FinalRows, ho_SampleImages, ho_SampleImage = null;
            HObject ho_FirstChannel = null, ho_ImageScaled = null, ho_ImageConverted = null;
            HObject ho_TiledImageRow = null, ho_TiledImage = null, ho_Domain = null;
            HObject ho_RegionComplement = null, ho_Image = null, ho_ImageCleared = null;
            HObject ho_TiledResult = null;

            // Local control variables 

            HTuple hv_BackGroundColor = new HTuple();
            HTuple hv_SpacingRow = new HTuple(), hv_SpacingCol = new HTuple();
            HTuple hv_WindowRow = new HTuple(), hv_WindowCol = new HTuple();
            HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
            HTuple hv_IncludeImage = new HTuple(), hv_IncludeGroundTruth = new HTuple();
            HTuple hv_IncludeResults = new HTuple(), hv_Keys = new HTuple();
            HTuple hv_Index = new HTuple(), hv_Key = new HTuple();
            HTuple hv_Value = new HTuple(), hv_ModelType = new HTuple();
            HTuple hv_Samples = new HTuple(), hv_ClassificationLabelExists = new HTuple();
            HTuple hv_DetectionLabelExists = new HTuple(), hv_SegmentationLabelExists = new HTuple();
            HTuple hv_DLSamples = new HTuple(), hv_SampleIndices = new HTuple();
            HTuple hv_DLResult = new HTuple(), hv_ClassIDs = new HTuple();
            HTuple hv_BackGroundClass = new HTuple(), hv_RGB = new HTuple();
            HTuple hv_Scale = new HTuple(), hv_Shift = new HTuple();
            HTuple hv_KeyExists = new HTuple(), hv_DLDatasetPreprocessParam = new HTuple();
            HTuple hv_NormType = new HTuple(), hv_KeyMinExists = new HTuple();
            HTuple hv_KeyMaxExists = new HTuple(), hv_ImageRangeMin = new HTuple();
            HTuple hv_ImageRangeMax = new HTuple(), hv_Channels = new HTuple();
            HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
            HTuple hv_Crop = new HTuple(), hv_OffsetRow = new HTuple();
            HTuple hv_TiledWidth = new HTuple(), hv_TiledHeight = new HTuple();
            HTuple hv_NumResult = new HTuple(), hv_PredictionsCorrect = new HTuple();
            HTuple hv_ImageConfidences = new HTuple(), hv_ResClassIndices = new HTuple();
            HTuple hv_ResClasses = new HTuple(), hv_ImageIDs = new HTuple();
            HTuple hv_ImageLabelIDs = new HTuple(), hv_IndexResult = new HTuple();
            HTuple hv_ImageConfidence = new HTuple(), hv_ResClassIndex = new HTuple();
            HTuple hv_ResClass = new HTuple(), hv_ImageID = new HTuple();
            HTuple hv_ImageLabelID = new HTuple(), hv_PredictionCorrect = new HTuple();
            HTuple hv_TextImageRows = new HTuple(), hv_TextImageColumns = new HTuple();
            HTuple hv_TextImageWidth = new HTuple(), hv_TextImageHeight = new HTuple();
            HTuple hv_TopOffset = new HTuple(), hv_InstanceType = new HTuple();
            HTuple hv_Rect1KeyExists = new HTuple(), hv_Rect2KeyExists = new HTuple();
            HTuple hv_GTLabel = new HTuple(), hv_GTCol1 = new HTuple();
            HTuple hv_GTRow1 = new HTuple(), hv_GTCol2 = new HTuple();
            HTuple hv_GTRow2 = new HTuple(), hv_GTCol = new HTuple();
            HTuple hv_GTRow = new HTuple(), hv_GTLength1 = new HTuple();
            HTuple hv_GTLength2 = new HTuple(), hv_GTPhi = new HTuple();
            HTuple hv_LeftOffset = new HTuple(), hv_LabelId = new HTuple();
            HTuple hv_Col1 = new HTuple(), hv_Row1 = new HTuple();
            HTuple hv_Col2 = new HTuple(), hv_Row2 = new HTuple();
            HTuple hv_Col = new HTuple(), hv_Row = new HTuple(), hv_Length1 = new HTuple();
            HTuple hv_Length2 = new HTuple(), hv_Phi = new HTuple();
            HTuple hv_ResConfidence = new HTuple(), hv_ResCol1 = new HTuple();
            HTuple hv_ResRow1 = new HTuple(), hv_ResCol2 = new HTuple();
            HTuple hv_ResRow2 = new HTuple(), hv_ResCol = new HTuple();
            HTuple hv_ResRow = new HTuple(), hv_ResLength1 = new HTuple();
            HTuple hv_ResLength2 = new HTuple(), hv_ResPhi = new HTuple();
            HTuple hv_ClassId = new HTuple(), hv_Confidence = new HTuple();
            HTuple hv_TiledDLSample = new HTuple(), hv_TiledDLResult = new HTuple();
            HTuple hv_IgnoreDirection = new HTuple(), hv_WindowHandleDict = new HTuple();
            HTuple hv_Flush = new HTuple(), hv_KeyForDisplay = new HTuple();
            HTuple hv_GTText = new HTuple(), hv_PredictionText = new HTuple();
            HTuple hv__ = new HTuple(), hv_GTWidth = new HTuple();
            HTuple hv_TextHeight = new HTuple(), hv_PredictionWidth = new HTuple();
            HTuple hv_WindowImageRatio = new HTuple();
            HTuple hv_GenParam_COPY_INP_TMP = new HTuple(hv_GenParam);
            HTuple hv_NumSamples_COPY_INP_TMP = new HTuple(hv_NumSamples);
            HTuple hv_WindowHandle_COPY_INP_TMP = new HTuple(hv_WindowHandle);

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_FinalRows);
            HOperatorSet.GenEmptyObj(out ho_SampleImages);
            HOperatorSet.GenEmptyObj(out ho_SampleImage);
            HOperatorSet.GenEmptyObj(out ho_FirstChannel);
            HOperatorSet.GenEmptyObj(out ho_ImageScaled);
            HOperatorSet.GenEmptyObj(out ho_ImageConverted);
            HOperatorSet.GenEmptyObj(out ho_TiledImageRow);
            HOperatorSet.GenEmptyObj(out ho_TiledImage);
            HOperatorSet.GenEmptyObj(out ho_Domain);
            HOperatorSet.GenEmptyObj(out ho_RegionComplement);
            HOperatorSet.GenEmptyObj(out ho_Image);
            HOperatorSet.GenEmptyObj(out ho_ImageCleared);
            HOperatorSet.GenEmptyObj(out ho_TiledResult);
            hv_WindowHandleOut = new HTuple();
            try
            {
                //
                //This procedure visualizes samples, their ground truth annotations, and,
                //if not deactivated, the results obtained by applying the model given by DLModelHandle.
                //
                //** Set the default values for all the generic parameters: ***
                //
                hv_BackGroundColor.Dispose();
                hv_BackGroundColor = "#ffffff";
                hv_SpacingRow.Dispose();
                hv_SpacingRow = 0;
                hv_SpacingCol.Dispose();
                hv_SpacingCol = 0;
                hv_WindowRow.Dispose();
                hv_WindowRow = 0;
                hv_WindowCol.Dispose();
                hv_WindowCol = 0;
                hv_WindowWidth.Dispose();
                hv_WindowWidth = 640;
                hv_WindowHeight.Dispose();
                hv_WindowHeight = 480;
                //For model of type detection and segmentation, it is displayed:
                //- the plain input images in the first row,
                //- the image and their ground truth annotations in the second row,
                //- the image and their inference results in the third row.
                //
                //For models of type classification, it is displayed:
                //- the input image with a prediction box.
                hv_IncludeImage.Dispose();
                hv_IncludeImage = 1;
                hv_IncludeGroundTruth.Dispose();
                hv_IncludeGroundTruth = 1;
                hv_IncludeResults.Dispose();
                hv_IncludeResults = 1;
                //
                if ((int)(new HTuple((new HTuple(hv_GenParam_COPY_INP_TMP.TupleLength())).TupleEqual(
                    1))) != 0)
                {
                    hv_Keys.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam_COPY_INP_TMP, "keys", new HTuple(),
                        out hv_Keys);
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Keys.TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        hv_Key.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Key = hv_Keys.TupleSelect(
                                hv_Index);
                        }
                        hv_Value.Dispose();
                        HOperatorSet.GetDictTuple(hv_GenParam_COPY_INP_TMP, hv_Key, out hv_Value);
                        if ((int)(new HTuple(hv_Key.TupleEqual("background_color"))) != 0)
                        {
                            hv_BackGroundColor.Dispose();
                            hv_BackGroundColor = new HTuple(hv_Value);
                        }
                        else if ((int)(new HTuple(hv_Key.TupleEqual("spacing_row"))) != 0)
                        {
                            hv_SpacingRow.Dispose();
                            hv_SpacingRow = new HTuple(hv_Value);
                        }
                        else if ((int)(new HTuple(hv_Key.TupleEqual("spacing_col"))) != 0)
                        {
                            hv_SpacingCol.Dispose();
                            hv_SpacingCol = new HTuple(hv_Value);
                        }
                        else if ((int)(new HTuple(hv_Key.TupleEqual("window_width"))) != 0)
                        {
                            hv_WindowWidth.Dispose();
                            hv_WindowWidth = new HTuple(hv_Value);
                        }
                        else if ((int)(new HTuple(hv_Key.TupleEqual("window_height"))) != 0)
                        {
                            hv_WindowHeight.Dispose();
                            hv_WindowHeight = new HTuple(hv_Value);
                        }
                        else if ((int)(new HTuple(hv_Key.TupleEqual("window_row"))) != 0)
                        {
                            hv_WindowRow.Dispose();
                            hv_WindowRow = new HTuple(hv_Value);
                        }
                        else if ((int)(new HTuple(hv_Key.TupleEqual("window_col"))) != 0)
                        {
                            hv_WindowCol.Dispose();
                            hv_WindowCol = new HTuple(hv_Value);
                        }
                        else if ((int)(new HTuple(hv_Key.TupleEqual("display_input"))) != 0)
                        {
                            hv_IncludeImage.Dispose();
                            hv_IncludeImage = new HTuple(hv_Value);
                        }
                        else if ((int)(new HTuple(hv_Key.TupleEqual("display_ground_truth"))) != 0)
                        {
                            hv_IncludeGroundTruth.Dispose();
                            hv_IncludeGroundTruth = new HTuple(hv_Value);
                        }
                        else if ((int)(new HTuple(hv_Key.TupleEqual("display_result"))) != 0)
                        {
                            hv_IncludeResults.Dispose();
                            hv_IncludeResults = new HTuple(hv_Value);
                        }
                    }
                }
                //
                //If a model was handed over, get model type.
                if ((int)(new HTuple(hv_DLModelHandle.TupleNotEqual(new HTuple()))) != 0)
                {
                    hv_ModelType.Dispose();
                    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "type", out hv_ModelType);
                    if ((int)((new HTuple((new HTuple(hv_ModelType.TupleNotEqual("classification"))).TupleAnd(
                        new HTuple(hv_ModelType.TupleNotEqual("detection"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual(
                        "segmentation")))) != 0)
                    {
                        throw new HalconException("Invalid model type");
                    }
                }
                else
                {
                    //
                    //If no model was handed over, results are not displayed.
                    hv_IncludeResults.Dispose();
                    hv_IncludeResults = 0;
                    //Conclude the model type from the existing keys.
                    hv_Samples.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_Samples);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassificationLabelExists.Dispose();
                        HOperatorSet.GetDictParam(hv_Samples.TupleSelect(0), "key_exists", "image_label_id",
                            out hv_ClassificationLabelExists);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DetectionLabelExists.Dispose();
                        HOperatorSet.GetDictParam(hv_Samples.TupleSelect(0), "key_exists", "bbox_label_id",
                            out hv_DetectionLabelExists);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SegmentationLabelExists.Dispose();
                        HOperatorSet.GetDictParam(hv_Samples.TupleSelect(0), "key_exists", "segmentation_file_name",
                            out hv_SegmentationLabelExists);
                    }
                    if ((int)(hv_ClassificationLabelExists) != 0)
                    {
                        hv_ModelType.Dispose();
                        hv_ModelType = "classification";
                    }
                    else if ((int)(hv_DetectionLabelExists) != 0)
                    {
                        hv_ModelType.Dispose();
                        hv_ModelType = "detection";
                    }
                    else if ((int)(hv_SegmentationLabelExists) != 0)
                    {
                        hv_ModelType.Dispose();
                        hv_ModelType = "segmentation";
                    }
                    else
                    {
                        throw new HalconException("Cannot conclude model type from DLDataset.");
                    }
                }
                //
                //** Generate results for a random subset of NumSamples-many samples: ***
                //
                //Select random samples.
                hv_DLSamples.Dispose();
                HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLSamples);
                hv_SampleIndices.Dispose();
                find_dl_samples(hv_DLSamples, "split", hv_Split, "or", out hv_SampleIndices);
                {
                    HTuple ExpTmpOutVar_0;
                    tuple_shuffle(hv_SampleIndices, out ExpTmpOutVar_0);
                    hv_SampleIndices.Dispose();
                    hv_SampleIndices = ExpTmpOutVar_0;
                }
                //
                //Make sure that NumSamples is not bigger than the found number of SampleIndices
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_NumSamples = hv_NumSamples_COPY_INP_TMP.TupleMin2(
                            new HTuple(hv_SampleIndices.TupleLength()));
                        hv_NumSamples_COPY_INP_TMP.Dispose();
                        hv_NumSamples_COPY_INP_TMP = ExpTmpLocalVar_NumSamples;
                    }
                }
                //
                //Calculate the result for the selected samples.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_NumSamples = hv_NumSamples_COPY_INP_TMP.TupleMin2(
                            new HTuple(hv_SampleIndices.TupleLength()));
                        hv_NumSamples_COPY_INP_TMP.Dispose();
                        hv_NumSamples_COPY_INP_TMP = ExpTmpLocalVar_NumSamples;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_SampleIndices = hv_SampleIndices.TupleSelectRange(
                            0, hv_NumSamples_COPY_INP_TMP - 1);
                        hv_SampleIndices.Dispose();
                        hv_SampleIndices = ExpTmpLocalVar_SampleIndices;
                    }
                }
                //
                if ((int)(hv_IncludeResults) != 0)
                {
                    hv_DLSamples.Dispose();
                    read_dl_samples(hv_DLDataset, hv_SampleIndices, out hv_DLSamples);
                    hv_DLResult.Dispose();
                    HOperatorSet.ApplyDlModel(hv_DLModelHandle, hv_DLSamples, new HTuple(), out hv_DLResult);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_DLResult = hv_DLResult.TupleSelectRange(
                                0, hv_NumSamples_COPY_INP_TMP - 1);
                            hv_DLResult.Dispose();
                            hv_DLResult = ExpTmpLocalVar_DLResult;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_DLSamples = hv_DLSamples.TupleSelectRange(
                                0, hv_NumSamples_COPY_INP_TMP - 1);
                            hv_DLSamples.Dispose();
                            hv_DLSamples = ExpTmpLocalVar_DLSamples;
                        }
                    }
                }
                else
                {
                    hv_DLSamples.Dispose();
                    read_dl_samples(hv_DLDataset, hv_SampleIndices, out hv_DLSamples);
                }
                //
                //** Generate the tiled image and the tiled result data: ***
                //
                hv_ClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_DLDataset, "class_ids", out hv_ClassIDs);
                //For segmentation models, we need a class ID that is not present in class_ids, to
                //mark regions without region visualization.
                hv_BackGroundClass.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_BackGroundClass = (hv_ClassIDs.TupleMax()
                        ) + 1;
                }
                hv_RGB.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RGB = new HTuple();
                    hv_RGB = hv_RGB.TupleConcat((("0x" + (hv_BackGroundColor.TupleSubstr(
                        1, 2)))).TupleNumber());
                    hv_RGB = hv_RGB.TupleConcat((("0x" + (hv_BackGroundColor.TupleSubstr(
                        3, 4)))).TupleNumber());
                    hv_RGB = hv_RGB.TupleConcat((("0x" + (hv_BackGroundColor.TupleSubstr(
                        5, 6)))).TupleNumber());
                }
                //
                ho_FinalRows.Dispose();
                HOperatorSet.GenEmptyObj(out ho_FinalRows);
                //
                //Generate the tiled sample image.
                //For the visualization it is better to use byte images.
                //The problem is that if you don't convert to bytes the range used to display is dynamic.
                //That means there can be strong fluctuations between several images, especially if there are "outliers" in the images.
                //By default expected range of the input image is [-127,128], but this is not the case for the normalization type 'constant_values'.
                hv_Scale.Dispose();
                hv_Scale = 1.0;
                hv_Shift.Dispose();
                hv_Shift = 127.0;
                hv_KeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLDataset, "key_exists", "preprocess_param", out hv_KeyExists);
                if ((int)(hv_KeyExists) != 0)
                {
                    hv_DLDatasetPreprocessParam.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLDataset, "preprocess_param", out hv_DLDatasetPreprocessParam);
                    hv_KeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_DLDatasetPreprocessParam, "key_exists", "normalization_type",
                        out hv_KeyExists);
                    if ((int)(hv_KeyExists) != 0)
                    {
                        hv_NormType.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLDatasetPreprocessParam, "normalization_type",
                            out hv_NormType);
                        if ((int)(new HTuple(hv_NormType.TupleEqual("constant_values"))) != 0)
                        {
                            hv_KeyMinExists.Dispose();
                            HOperatorSet.GetDictParam(hv_DLDatasetPreprocessParam, "key_exists",
                                "image_range_min", out hv_KeyMinExists);
                            hv_KeyMaxExists.Dispose();
                            HOperatorSet.GetDictParam(hv_DLDatasetPreprocessParam, "key_exists",
                                "image_range_min", out hv_KeyMaxExists);
                            if ((int)(hv_KeyMinExists.TupleAnd(hv_KeyMaxExists)) != 0)
                            {
                                hv_ImageRangeMin.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLDatasetPreprocessParam, "image_range_min",
                                    out hv_ImageRangeMin);
                                hv_ImageRangeMax.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLDatasetPreprocessParam, "image_range_max",
                                    out hv_ImageRangeMax);
                            }
                            else
                            {
                                hv_ImageRangeMin.Dispose();
                                hv_ImageRangeMin = -2.0;
                                hv_ImageRangeMax.Dispose();
                                hv_ImageRangeMax = 2.0;
                            }
                            if ((int)(new HTuple(((hv_ImageRangeMax - hv_ImageRangeMin)).TupleEqual(
                                0))) != 0)
                            {
                                hv_Scale.Dispose();
                                hv_Scale = 1.0;
                            }
                            else
                            {
                                hv_Scale.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Scale = 255.0 / (hv_ImageRangeMax - hv_ImageRangeMin);
                                }
                            }
                            hv_Shift.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Shift = (-hv_Scale) * hv_ImageRangeMin;
                            }
                        }
                    }
                }
                ho_SampleImages.Dispose();
                HOperatorSet.GenEmptyObj(out ho_SampleImages);
                HTuple end_val145 = hv_NumSamples_COPY_INP_TMP - 1;
                HTuple step_val145 = 1;
                for (hv_Index = 0; hv_Index.Continue(end_val145, step_val145); hv_Index = hv_Index.TupleAdd(step_val145))
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_SampleImage.Dispose();
                        HOperatorSet.GetDictObject(out ho_SampleImage, hv_DLSamples.TupleSelect(hv_Index),
                            "image");
                    }
                    hv_Channels.Dispose();
                    HOperatorSet.CountChannels(ho_SampleImage, out hv_Channels);
                    if ((int)(new HTuple(hv_Channels.TupleNotEqual(3))) != 0)
                    {
                        //For any number of channels, that is not three, just use the first channel.
                        ho_FirstChannel.Dispose();
                        HOperatorSet.AccessChannel(ho_SampleImage, out ho_FirstChannel, 1);
                        ho_SampleImage.Dispose();
                        HOperatorSet.Compose3(ho_FirstChannel, ho_FirstChannel, ho_FirstChannel,
                            out ho_SampleImage);
                    }
                    //Convert the images back to byte.
                    ho_ImageScaled.Dispose();
                    HOperatorSet.ScaleImage(ho_SampleImage, out ho_ImageScaled, hv_Scale, hv_Shift);
                    ho_ImageConverted.Dispose();
                    HOperatorSet.ConvertImageType(ho_ImageScaled, out ho_ImageConverted, "byte");
                    //Add the image to the tuple SampleImages.
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_SampleImages, ho_ImageConverted, out ExpTmpOutVar_0
                            );
                        ho_SampleImages.Dispose();
                        ho_SampleImages = ExpTmpOutVar_0;
                    }
                }
                //Tile the images in a row.
                hv_Width.Dispose(); hv_Height.Dispose();
                HOperatorSet.GetImageSize(ho_SampleImages, out hv_Width, out hv_Height);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Crop.Dispose();
                    HOperatorSet.TupleGenConst(new HTuple(hv_Width.TupleLength()), -1, out hv_Crop);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_OffsetRow.Dispose();
                    HOperatorSet.TupleGenConst(new HTuple(hv_Width.TupleLength()), 0, out hv_OffsetRow);
                }
                if ((int)((new HTuple(hv_ModelType.TupleEqual("detection"))).TupleOr(new HTuple(hv_ModelType.TupleEqual(
                    "segmentation")))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_TiledImageRow.Dispose();
                        HOperatorSet.TileImagesOffset(ho_SampleImages, out ho_TiledImageRow, hv_OffsetRow,
                            (((new HTuple(0)).TupleConcat(((hv_Width + hv_SpacingCol)).TupleCumul()
                            ))).TupleSelectRange(0, (new HTuple(hv_Width.TupleLength())) - 1), hv_Crop,
                            hv_Crop, hv_Crop, hv_Crop, (((((hv_Width + hv_SpacingCol)).TupleCumul()
                            )).TupleSelect((new HTuple(hv_Width.TupleLength())) - 1)) - hv_SpacingCol,
                            hv_Height.TupleMax());
                    }
                }
                //
                //Generate the columns of images for the tiled output.
                if ((int)(hv_IncludeImage) != 0)
                {
                    if ((int)(new HTuple(hv_ModelType.TupleEqual("classification"))) != 0)
                    {
                        throw new HalconException("The key 'display_input' cannot be set for model type classification.");
                        ho_FinalRows.Dispose();
                        ho_SampleImages.Dispose();
                        ho_SampleImage.Dispose();
                        ho_FirstChannel.Dispose();
                        ho_ImageScaled.Dispose();
                        ho_ImageConverted.Dispose();
                        ho_TiledImageRow.Dispose();
                        ho_TiledImage.Dispose();
                        ho_Domain.Dispose();
                        ho_RegionComplement.Dispose();
                        ho_Image.Dispose();
                        ho_ImageCleared.Dispose();
                        ho_TiledResult.Dispose();

                        hv_GenParam_COPY_INP_TMP.Dispose();
                        hv_NumSamples_COPY_INP_TMP.Dispose();
                        hv_WindowHandle_COPY_INP_TMP.Dispose();
                        hv_BackGroundColor.Dispose();
                        hv_SpacingRow.Dispose();
                        hv_SpacingCol.Dispose();
                        hv_WindowRow.Dispose();
                        hv_WindowCol.Dispose();
                        hv_WindowWidth.Dispose();
                        hv_WindowHeight.Dispose();
                        hv_IncludeImage.Dispose();
                        hv_IncludeGroundTruth.Dispose();
                        hv_IncludeResults.Dispose();
                        hv_Keys.Dispose();
                        hv_Index.Dispose();
                        hv_Key.Dispose();
                        hv_Value.Dispose();
                        hv_ModelType.Dispose();
                        hv_Samples.Dispose();
                        hv_ClassificationLabelExists.Dispose();
                        hv_DetectionLabelExists.Dispose();
                        hv_SegmentationLabelExists.Dispose();
                        hv_DLSamples.Dispose();
                        hv_SampleIndices.Dispose();
                        hv_DLResult.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_BackGroundClass.Dispose();
                        hv_RGB.Dispose();
                        hv_Scale.Dispose();
                        hv_Shift.Dispose();
                        hv_KeyExists.Dispose();
                        hv_DLDatasetPreprocessParam.Dispose();
                        hv_NormType.Dispose();
                        hv_KeyMinExists.Dispose();
                        hv_KeyMaxExists.Dispose();
                        hv_ImageRangeMin.Dispose();
                        hv_ImageRangeMax.Dispose();
                        hv_Channels.Dispose();
                        hv_Width.Dispose();
                        hv_Height.Dispose();
                        hv_Crop.Dispose();
                        hv_OffsetRow.Dispose();
                        hv_TiledWidth.Dispose();
                        hv_TiledHeight.Dispose();
                        hv_NumResult.Dispose();
                        hv_PredictionsCorrect.Dispose();
                        hv_ImageConfidences.Dispose();
                        hv_ResClassIndices.Dispose();
                        hv_ResClasses.Dispose();
                        hv_ImageIDs.Dispose();
                        hv_ImageLabelIDs.Dispose();
                        hv_IndexResult.Dispose();
                        hv_ImageConfidence.Dispose();
                        hv_ResClassIndex.Dispose();
                        hv_ResClass.Dispose();
                        hv_ImageID.Dispose();
                        hv_ImageLabelID.Dispose();
                        hv_PredictionCorrect.Dispose();
                        hv_TextImageRows.Dispose();
                        hv_TextImageColumns.Dispose();
                        hv_TextImageWidth.Dispose();
                        hv_TextImageHeight.Dispose();
                        hv_TopOffset.Dispose();
                        hv_InstanceType.Dispose();
                        hv_Rect1KeyExists.Dispose();
                        hv_Rect2KeyExists.Dispose();
                        hv_GTLabel.Dispose();
                        hv_GTCol1.Dispose();
                        hv_GTRow1.Dispose();
                        hv_GTCol2.Dispose();
                        hv_GTRow2.Dispose();
                        hv_GTCol.Dispose();
                        hv_GTRow.Dispose();
                        hv_GTLength1.Dispose();
                        hv_GTLength2.Dispose();
                        hv_GTPhi.Dispose();
                        hv_LeftOffset.Dispose();
                        hv_LabelId.Dispose();
                        hv_Col1.Dispose();
                        hv_Row1.Dispose();
                        hv_Col2.Dispose();
                        hv_Row2.Dispose();
                        hv_Col.Dispose();
                        hv_Row.Dispose();
                        hv_Length1.Dispose();
                        hv_Length2.Dispose();
                        hv_Phi.Dispose();
                        hv_ResConfidence.Dispose();
                        hv_ResCol1.Dispose();
                        hv_ResRow1.Dispose();
                        hv_ResCol2.Dispose();
                        hv_ResRow2.Dispose();
                        hv_ResCol.Dispose();
                        hv_ResRow.Dispose();
                        hv_ResLength1.Dispose();
                        hv_ResLength2.Dispose();
                        hv_ResPhi.Dispose();
                        hv_ClassId.Dispose();
                        hv_Confidence.Dispose();
                        hv_TiledDLSample.Dispose();
                        hv_TiledDLResult.Dispose();
                        hv_IgnoreDirection.Dispose();
                        hv_WindowHandleDict.Dispose();
                        hv_Flush.Dispose();
                        hv_KeyForDisplay.Dispose();
                        hv_GTText.Dispose();
                        hv_PredictionText.Dispose();
                        hv__.Dispose();
                        hv_GTWidth.Dispose();
                        hv_TextHeight.Dispose();
                        hv_PredictionWidth.Dispose();
                        hv_WindowImageRatio.Dispose();

                        return;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_FinalRows, ho_TiledImageRow, out ExpTmpOutVar_0
                            );
                        ho_FinalRows.Dispose();
                        ho_FinalRows = ExpTmpOutVar_0;
                    }
                }
                if ((int)(hv_IncludeGroundTruth) != 0)
                {
                    if ((int)(new HTuple(hv_ModelType.TupleEqual("classification"))) != 0)
                    {
                        throw new HalconException("The key 'display_ground_truth' cannot be set for model type classification.");
                        ho_FinalRows.Dispose();
                        ho_SampleImages.Dispose();
                        ho_SampleImage.Dispose();
                        ho_FirstChannel.Dispose();
                        ho_ImageScaled.Dispose();
                        ho_ImageConverted.Dispose();
                        ho_TiledImageRow.Dispose();
                        ho_TiledImage.Dispose();
                        ho_Domain.Dispose();
                        ho_RegionComplement.Dispose();
                        ho_Image.Dispose();
                        ho_ImageCleared.Dispose();
                        ho_TiledResult.Dispose();

                        hv_GenParam_COPY_INP_TMP.Dispose();
                        hv_NumSamples_COPY_INP_TMP.Dispose();
                        hv_WindowHandle_COPY_INP_TMP.Dispose();
                        hv_BackGroundColor.Dispose();
                        hv_SpacingRow.Dispose();
                        hv_SpacingCol.Dispose();
                        hv_WindowRow.Dispose();
                        hv_WindowCol.Dispose();
                        hv_WindowWidth.Dispose();
                        hv_WindowHeight.Dispose();
                        hv_IncludeImage.Dispose();
                        hv_IncludeGroundTruth.Dispose();
                        hv_IncludeResults.Dispose();
                        hv_Keys.Dispose();
                        hv_Index.Dispose();
                        hv_Key.Dispose();
                        hv_Value.Dispose();
                        hv_ModelType.Dispose();
                        hv_Samples.Dispose();
                        hv_ClassificationLabelExists.Dispose();
                        hv_DetectionLabelExists.Dispose();
                        hv_SegmentationLabelExists.Dispose();
                        hv_DLSamples.Dispose();
                        hv_SampleIndices.Dispose();
                        hv_DLResult.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_BackGroundClass.Dispose();
                        hv_RGB.Dispose();
                        hv_Scale.Dispose();
                        hv_Shift.Dispose();
                        hv_KeyExists.Dispose();
                        hv_DLDatasetPreprocessParam.Dispose();
                        hv_NormType.Dispose();
                        hv_KeyMinExists.Dispose();
                        hv_KeyMaxExists.Dispose();
                        hv_ImageRangeMin.Dispose();
                        hv_ImageRangeMax.Dispose();
                        hv_Channels.Dispose();
                        hv_Width.Dispose();
                        hv_Height.Dispose();
                        hv_Crop.Dispose();
                        hv_OffsetRow.Dispose();
                        hv_TiledWidth.Dispose();
                        hv_TiledHeight.Dispose();
                        hv_NumResult.Dispose();
                        hv_PredictionsCorrect.Dispose();
                        hv_ImageConfidences.Dispose();
                        hv_ResClassIndices.Dispose();
                        hv_ResClasses.Dispose();
                        hv_ImageIDs.Dispose();
                        hv_ImageLabelIDs.Dispose();
                        hv_IndexResult.Dispose();
                        hv_ImageConfidence.Dispose();
                        hv_ResClassIndex.Dispose();
                        hv_ResClass.Dispose();
                        hv_ImageID.Dispose();
                        hv_ImageLabelID.Dispose();
                        hv_PredictionCorrect.Dispose();
                        hv_TextImageRows.Dispose();
                        hv_TextImageColumns.Dispose();
                        hv_TextImageWidth.Dispose();
                        hv_TextImageHeight.Dispose();
                        hv_TopOffset.Dispose();
                        hv_InstanceType.Dispose();
                        hv_Rect1KeyExists.Dispose();
                        hv_Rect2KeyExists.Dispose();
                        hv_GTLabel.Dispose();
                        hv_GTCol1.Dispose();
                        hv_GTRow1.Dispose();
                        hv_GTCol2.Dispose();
                        hv_GTRow2.Dispose();
                        hv_GTCol.Dispose();
                        hv_GTRow.Dispose();
                        hv_GTLength1.Dispose();
                        hv_GTLength2.Dispose();
                        hv_GTPhi.Dispose();
                        hv_LeftOffset.Dispose();
                        hv_LabelId.Dispose();
                        hv_Col1.Dispose();
                        hv_Row1.Dispose();
                        hv_Col2.Dispose();
                        hv_Row2.Dispose();
                        hv_Col.Dispose();
                        hv_Row.Dispose();
                        hv_Length1.Dispose();
                        hv_Length2.Dispose();
                        hv_Phi.Dispose();
                        hv_ResConfidence.Dispose();
                        hv_ResCol1.Dispose();
                        hv_ResRow1.Dispose();
                        hv_ResCol2.Dispose();
                        hv_ResRow2.Dispose();
                        hv_ResCol.Dispose();
                        hv_ResRow.Dispose();
                        hv_ResLength1.Dispose();
                        hv_ResLength2.Dispose();
                        hv_ResPhi.Dispose();
                        hv_ClassId.Dispose();
                        hv_Confidence.Dispose();
                        hv_TiledDLSample.Dispose();
                        hv_TiledDLResult.Dispose();
                        hv_IgnoreDirection.Dispose();
                        hv_WindowHandleDict.Dispose();
                        hv_Flush.Dispose();
                        hv_KeyForDisplay.Dispose();
                        hv_GTText.Dispose();
                        hv_PredictionText.Dispose();
                        hv__.Dispose();
                        hv_GTWidth.Dispose();
                        hv_TextHeight.Dispose();
                        hv_PredictionWidth.Dispose();
                        hv_WindowImageRatio.Dispose();

                        return;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_FinalRows, ho_TiledImageRow, out ExpTmpOutVar_0
                            );
                        ho_FinalRows.Dispose();
                        ho_FinalRows = ExpTmpOutVar_0;
                    }
                }
                if ((int)((new HTuple(hv_ModelType.TupleEqual("detection"))).TupleOr(new HTuple(hv_ModelType.TupleEqual(
                    "segmentation")))) != 0)
                {
                    if ((int)(hv_IncludeResults) != 0)
                    {
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_FinalRows, ho_TiledImageRow, out ExpTmpOutVar_0
                                );
                            ho_FinalRows.Dispose();
                            ho_FinalRows = ExpTmpOutVar_0;
                        }
                    }
                    hv_TiledWidth.Dispose(); hv_TiledHeight.Dispose();
                    HOperatorSet.GetImageSize(ho_FinalRows, out hv_TiledWidth, out hv_TiledHeight);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_TiledImage.Dispose();
                        HOperatorSet.TileImagesOffset(ho_FinalRows, out ho_TiledImage, (((new HTuple(0)).TupleConcat(
                            ((hv_TiledHeight + hv_SpacingRow)).TupleCumul()))).TupleSelectRange(0, (new HTuple(hv_TiledHeight.TupleLength()
                            )) - 1), HTuple.TupleGenConst(new HTuple(hv_TiledHeight.TupleLength()),
                            0), HTuple.TupleGenConst(new HTuple(hv_TiledHeight.TupleLength()), -1),
                            HTuple.TupleGenConst(new HTuple(hv_TiledHeight.TupleLength()), -1), HTuple.TupleGenConst(
                            new HTuple(hv_TiledHeight.TupleLength()), -1), HTuple.TupleGenConst(new HTuple(hv_TiledHeight.TupleLength()
                            ), -1), hv_TiledWidth.TupleMax(), (((((hv_TiledHeight + hv_SpacingRow)).TupleCumul()
                            )).TupleSelect((new HTuple(hv_TiledHeight.TupleLength())) - 1)) - hv_SpacingRow);
                    }
                    //Fill up with the background color.
                    ho_Domain.Dispose();
                    HOperatorSet.GetDomain(ho_TiledImage, out ho_Domain);
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.FullDomain(ho_TiledImage, out ExpTmpOutVar_0);
                        ho_TiledImage.Dispose();
                        ho_TiledImage = ExpTmpOutVar_0;
                    }
                    ho_RegionComplement.Dispose();
                    HOperatorSet.Complement(ho_Domain, out ho_RegionComplement);
                    HOperatorSet.OverpaintRegion(ho_TiledImage, ho_RegionComplement, hv_RGB,
                        "fill");
                }
                //
                //Generate the tiled data (classification prediction / segmentation regions / detection bounding boxes).
                if ((int)(new HTuple(hv_ModelType.TupleEqual("classification"))) != 0)
                {
                    //
                    //For classification results the image is shown within a colored frame.
                    //
                    ho_FinalRows.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_FinalRows);
                    //
                    if ((int)(hv_IncludeResults) != 0)
                    {
                        hv_NumResult.Dispose();
                        HOperatorSet.TupleLength(hv_DLResult, out hv_NumResult);
                        hv_PredictionsCorrect.Dispose();
                        hv_PredictionsCorrect = new HTuple();
                        hv_ImageConfidences.Dispose();
                        hv_ImageConfidences = new HTuple();
                        hv_ResClassIndices.Dispose();
                        hv_ResClassIndices = new HTuple();
                        hv_ResClasses.Dispose();
                        hv_ResClasses = new HTuple();
                        hv_ImageIDs.Dispose();
                        hv_ImageIDs = new HTuple();
                        hv_ImageLabelIDs.Dispose();
                        hv_ImageLabelIDs = new HTuple();
                        //
                        HTuple end_val211 = hv_NumResult - 1;
                        HTuple step_val211 = 1;
                        for (hv_IndexResult = 0; hv_IndexResult.Continue(end_val211, step_val211); hv_IndexResult = hv_IndexResult.TupleAdd(step_val211))
                        {
                            //
                            //Get labels and classes.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ImageConfidence.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_IndexResult), "classification_confidences",
                                    out hv_ImageConfidence);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ResClassIndex.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_IndexResult), "classification_class_ids",
                                    out hv_ResClassIndex);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ResClass.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_IndexResult), "classification_class_names",
                                    out hv_ResClass);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ImageID.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_IndexResult), "image_id",
                                    out hv_ImageID);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ImageLabelID.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_IndexResult), "image_label_id",
                                    out hv_ImageLabelID);
                            }
                            //
                            //Check whether the actual sample prediction is false or correct.
                            hv_PredictionCorrect.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_PredictionCorrect = new HTuple(((hv_ResClassIndex.TupleSelect(
                                    0))).TupleEqual(hv_ImageLabelID));
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_PredictionsCorrect = hv_PredictionsCorrect.TupleConcat(
                                        hv_PredictionCorrect);
                                    hv_PredictionsCorrect.Dispose();
                                    hv_PredictionsCorrect = ExpTmpLocalVar_PredictionsCorrect;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ImageConfidences = hv_ImageConfidences.TupleConcat(
                                        hv_ImageConfidence.TupleSelect(0));
                                    hv_ImageConfidences.Dispose();
                                    hv_ImageConfidences = ExpTmpLocalVar_ImageConfidences;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ResClassIndices = hv_ResClassIndices.TupleConcat(
                                        hv_ResClassIndex.TupleSelect(0));
                                    hv_ResClassIndices.Dispose();
                                    hv_ResClassIndices = ExpTmpLocalVar_ResClassIndices;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ResClasses = hv_ResClasses.TupleConcat(
                                        hv_ResClass.TupleSelect(0));
                                    hv_ResClasses.Dispose();
                                    hv_ResClasses = ExpTmpLocalVar_ResClasses;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ImageIDs = hv_ImageIDs.TupleConcat(
                                        hv_ImageID);
                                    hv_ImageIDs.Dispose();
                                    hv_ImageIDs = ExpTmpLocalVar_ImageIDs;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ImageLabelIDs = hv_ImageLabelIDs.TupleConcat(
                                        hv_ImageLabelID);
                                    hv_ImageLabelIDs.Dispose();
                                    hv_ImageLabelIDs = ExpTmpLocalVar_ImageLabelIDs;
                                }
                            }
                        }
                        //
                        //Tile the sample images.
                        ho_TiledImageRow.Dispose(); hv_TextImageRows.Dispose(); hv_TextImageColumns.Dispose(); hv_TextImageWidth.Dispose(); hv_TextImageHeight.Dispose();
                        gen_tiled_classification_image_result(out ho_TiledImageRow, hv_DLSamples,
                            hv_SpacingCol, hv_PredictionsCorrect, hv_ResClasses, out hv_TextImageRows,
                            out hv_TextImageColumns, out hv_TextImageWidth, out hv_TextImageHeight);
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_FinalRows, ho_TiledImageRow, out ExpTmpOutVar_0
                                );
                            ho_FinalRows.Dispose();
                            ho_FinalRows = ExpTmpOutVar_0;
                        }
                    }
                    hv_TiledWidth.Dispose(); hv_TiledHeight.Dispose();
                    HOperatorSet.GetImageSize(ho_FinalRows, out hv_TiledWidth, out hv_TiledHeight);
                    ho_TiledImage.Dispose();
                    ho_TiledImage = new HObject(ho_TiledImageRow);
                    //
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
                {
                    //
                    //For detection results the detected boxes must be moved
                    //to the positions of the respective image.
                    hv_TopOffset.Dispose();
                    hv_TopOffset = 0;
                    if ((int)(hv_IncludeImage) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_TopOffset = (hv_TopOffset + hv_SpacingRow) + (hv_TiledHeight.TupleSelect(
                                    0));
                                hv_TopOffset.Dispose();
                                hv_TopOffset = ExpTmpLocalVar_TopOffset;
                            }
                        }
                    }
                    //Check the detection type.
                    if ((int)(new HTuple((new HTuple(hv_DLModelHandle.TupleLength())).TupleGreater(
                        0))) != 0)
                    {
                        hv_InstanceType.Dispose();
                        HOperatorSet.GetDlModelParam(hv_DLModelHandle, "instance_type", out hv_InstanceType);
                    }
                    else
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Rect1KeyExists.Dispose();
                            HOperatorSet.GetDictParam(hv_DLSamples.TupleSelect(0), "key_exists", "bbox_row1",
                                out hv_Rect1KeyExists);
                        }
                        if ((int)(hv_Rect1KeyExists) != 0)
                        {
                            hv_InstanceType.Dispose();
                            hv_InstanceType = "rectangle1";
                        }
                        else
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Rect2KeyExists.Dispose();
                                HOperatorSet.GetDictParam(hv_DLSamples.TupleSelect(0), "key_exists",
                                    "bbox_phi", out hv_Rect2KeyExists);
                            }
                            if ((int)(hv_Rect2KeyExists) != 0)
                            {
                                hv_InstanceType.Dispose();
                                hv_InstanceType = "rectangle2";
                            }
                            else
                            {
                                throw new HalconException("Not suitable sample keys!");
                            }
                        }
                    }
                    //Move the ground truth labels.
                    hv_GTLabel.Dispose();
                    hv_GTLabel = new HTuple();
                    if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
                    {
                        hv_GTCol1.Dispose();
                        hv_GTCol1 = new HTuple();
                        hv_GTRow1.Dispose();
                        hv_GTRow1 = new HTuple();
                        hv_GTCol2.Dispose();
                        hv_GTCol2 = new HTuple();
                        hv_GTRow2.Dispose();
                        hv_GTRow2 = new HTuple();
                    }
                    else
                    {
                        hv_GTCol.Dispose();
                        hv_GTCol = new HTuple();
                        hv_GTRow.Dispose();
                        hv_GTRow = new HTuple();
                        hv_GTLength1.Dispose();
                        hv_GTLength1 = new HTuple();
                        hv_GTLength2.Dispose();
                        hv_GTLength2 = new HTuple();
                        hv_GTPhi.Dispose();
                        hv_GTPhi = new HTuple();
                    }
                    if ((int)(hv_IncludeGroundTruth) != 0)
                    {
                        hv_LeftOffset.Dispose();
                        hv_LeftOffset = 0;
                        HTuple end_val277 = hv_NumSamples_COPY_INP_TMP - 1;
                        HTuple step_val277 = 1;
                        for (hv_Index = 0; hv_Index.Continue(end_val277, step_val277); hv_Index = hv_Index.TupleAdd(step_val277))
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_LabelId.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_Index), "bbox_label_id",
                                    out hv_LabelId);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_GTLabel = hv_GTLabel.TupleConcat(
                                        hv_LabelId);
                                    hv_GTLabel.Dispose();
                                    hv_GTLabel = ExpTmpLocalVar_GTLabel;
                                }
                            }
                            if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Col1.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_Index), "bbox_col1",
                                        out hv_Col1);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_GTCol1 = hv_GTCol1.TupleConcat(
                                            hv_Col1 + hv_LeftOffset);
                                        hv_GTCol1.Dispose();
                                        hv_GTCol1 = ExpTmpLocalVar_GTCol1;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Row1.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_Index), "bbox_row1",
                                        out hv_Row1);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_GTRow1 = hv_GTRow1.TupleConcat(
                                            hv_Row1 + hv_TopOffset);
                                        hv_GTRow1.Dispose();
                                        hv_GTRow1 = ExpTmpLocalVar_GTRow1;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Col2.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_Index), "bbox_col2",
                                        out hv_Col2);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_GTCol2 = hv_GTCol2.TupleConcat(
                                            hv_Col2 + hv_LeftOffset);
                                        hv_GTCol2.Dispose();
                                        hv_GTCol2 = ExpTmpLocalVar_GTCol2;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Row2.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_Index), "bbox_row2",
                                        out hv_Row2);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_GTRow2 = hv_GTRow2.TupleConcat(
                                            hv_Row2 + hv_TopOffset);
                                        hv_GTRow2.Dispose();
                                        hv_GTRow2 = ExpTmpLocalVar_GTRow2;
                                    }
                                }
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Col.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_Index), "bbox_col",
                                        out hv_Col);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_GTCol = hv_GTCol.TupleConcat(
                                            hv_Col + hv_LeftOffset);
                                        hv_GTCol.Dispose();
                                        hv_GTCol = ExpTmpLocalVar_GTCol;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Row.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_Index), "bbox_row",
                                        out hv_Row);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_GTRow = hv_GTRow.TupleConcat(
                                            hv_Row + hv_TopOffset);
                                        hv_GTRow.Dispose();
                                        hv_GTRow = ExpTmpLocalVar_GTRow;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Length1.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_Index), "bbox_length1",
                                        out hv_Length1);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_GTLength1 = hv_GTLength1.TupleConcat(
                                            hv_Length1);
                                        hv_GTLength1.Dispose();
                                        hv_GTLength1 = ExpTmpLocalVar_GTLength1;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Length2.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_Index), "bbox_length2",
                                        out hv_Length2);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_GTLength2 = hv_GTLength2.TupleConcat(
                                            hv_Length2);
                                        hv_GTLength2.Dispose();
                                        hv_GTLength2 = ExpTmpLocalVar_GTLength2;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Phi.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLSamples.TupleSelect(hv_Index), "bbox_phi",
                                        out hv_Phi);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_GTPhi = hv_GTPhi.TupleConcat(
                                            hv_Phi);
                                        hv_GTPhi.Dispose();
                                        hv_GTPhi = ExpTmpLocalVar_GTPhi;
                                    }
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_LeftOffset = (hv_LeftOffset + hv_SpacingCol) + (hv_Width.TupleSelect(
                                        hv_Index));
                                    hv_LeftOffset.Dispose();
                                    hv_LeftOffset = ExpTmpLocalVar_LeftOffset;
                                }
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_TopOffset = (hv_TopOffset + hv_SpacingRow) + (hv_TiledHeight.TupleSelect(
                                    0));
                                hv_TopOffset.Dispose();
                                hv_TopOffset = ExpTmpLocalVar_TopOffset;
                            }
                        }
                    }
                    hv_ResClass.Dispose();
                    hv_ResClass = new HTuple();
                    hv_ResConfidence.Dispose();
                    hv_ResConfidence = new HTuple();
                    if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
                    {
                        hv_ResCol1.Dispose();
                        hv_ResCol1 = new HTuple();
                        hv_ResRow1.Dispose();
                        hv_ResRow1 = new HTuple();
                        hv_ResCol2.Dispose();
                        hv_ResCol2 = new HTuple();
                        hv_ResRow2.Dispose();
                        hv_ResRow2 = new HTuple();
                    }
                    else
                    {
                        hv_ResCol.Dispose();
                        hv_ResCol = new HTuple();
                        hv_ResRow.Dispose();
                        hv_ResRow = new HTuple();
                        hv_ResLength1.Dispose();
                        hv_ResLength1 = new HTuple();
                        hv_ResLength2.Dispose();
                        hv_ResLength2 = new HTuple();
                        hv_ResPhi.Dispose();
                        hv_ResPhi = new HTuple();
                    }
                    //Move the result classes.
                    if ((int)(hv_IncludeResults) != 0)
                    {
                        hv_LeftOffset.Dispose();
                        hv_LeftOffset = 0;
                        HTuple end_val322 = hv_NumSamples_COPY_INP_TMP - 1;
                        HTuple step_val322 = 1;
                        for (hv_Index = 0; hv_Index.Continue(end_val322, step_val322); hv_Index = hv_Index.TupleAdd(step_val322))
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClassId.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_Index), "bbox_class_id",
                                    out hv_ClassId);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ResClass = hv_ResClass.TupleConcat(
                                        hv_ClassId);
                                    hv_ResClass.Dispose();
                                    hv_ResClass = ExpTmpLocalVar_ResClass;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Confidence.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_Index), "bbox_confidence",
                                    out hv_Confidence);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ResConfidence = hv_ResConfidence.TupleConcat(
                                        hv_Confidence);
                                    hv_ResConfidence.Dispose();
                                    hv_ResConfidence = ExpTmpLocalVar_ResConfidence;
                                }
                            }
                            if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Col1.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_Index), "bbox_col1",
                                        out hv_Col1);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_ResCol1 = hv_ResCol1.TupleConcat(
                                            hv_Col1 + hv_LeftOffset);
                                        hv_ResCol1.Dispose();
                                        hv_ResCol1 = ExpTmpLocalVar_ResCol1;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Row1.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_Index), "bbox_row1",
                                        out hv_Row1);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_ResRow1 = hv_ResRow1.TupleConcat(
                                            hv_Row1 + hv_TopOffset);
                                        hv_ResRow1.Dispose();
                                        hv_ResRow1 = ExpTmpLocalVar_ResRow1;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Col2.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_Index), "bbox_col2",
                                        out hv_Col2);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_ResCol2 = hv_ResCol2.TupleConcat(
                                            hv_Col2 + hv_LeftOffset);
                                        hv_ResCol2.Dispose();
                                        hv_ResCol2 = ExpTmpLocalVar_ResCol2;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Row2.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_Index), "bbox_row2",
                                        out hv_Row2);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_ResRow2 = hv_ResRow2.TupleConcat(
                                            hv_Row2 + hv_TopOffset);
                                        hv_ResRow2.Dispose();
                                        hv_ResRow2 = ExpTmpLocalVar_ResRow2;
                                    }
                                }
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Col.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_Index), "bbox_col",
                                        out hv_Col);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_ResCol = hv_ResCol.TupleConcat(
                                            hv_Col + hv_LeftOffset);
                                        hv_ResCol.Dispose();
                                        hv_ResCol = ExpTmpLocalVar_ResCol;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Row.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_Index), "bbox_row",
                                        out hv_Row);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_ResRow = hv_ResRow.TupleConcat(
                                            hv_Row + hv_TopOffset);
                                        hv_ResRow.Dispose();
                                        hv_ResRow = ExpTmpLocalVar_ResRow;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Length1.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_Index), "bbox_length1",
                                        out hv_Length1);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_ResLength1 = hv_ResLength1.TupleConcat(
                                            hv_Length1);
                                        hv_ResLength1.Dispose();
                                        hv_ResLength1 = ExpTmpLocalVar_ResLength1;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Length2.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_Index), "bbox_length2",
                                        out hv_Length2);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_ResLength2 = hv_ResLength2.TupleConcat(
                                            hv_Length2);
                                        hv_ResLength2.Dispose();
                                        hv_ResLength2 = ExpTmpLocalVar_ResLength2;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Phi.Dispose();
                                    HOperatorSet.GetDictTuple(hv_DLResult.TupleSelect(hv_Index), "bbox_phi",
                                        out hv_Phi);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_ResPhi = hv_ResPhi.TupleConcat(
                                            hv_Phi);
                                        hv_ResPhi.Dispose();
                                        hv_ResPhi = ExpTmpLocalVar_ResPhi;
                                    }
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_LeftOffset = (hv_LeftOffset + hv_SpacingCol) + (hv_Width.TupleSelect(
                                        hv_Index));
                                    hv_LeftOffset.Dispose();
                                    hv_LeftOffset = ExpTmpLocalVar_LeftOffset;
                                }
                            }
                        }
                    }
                    //
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("segmentation"))) != 0)
                {
                    //
                    //The tiled segmentation result image is constructed in the same way as the tiled sample image.
                    ho_FinalRows.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_FinalRows);
                    if ((int)(hv_IncludeImage) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_Image.Dispose();
                            HOperatorSet.GenImageConst(out ho_Image, "real", hv_TiledWidth.TupleSelect(
                                0), hv_TiledHeight.TupleSelect(0));
                        }
                        //For the top (image) row, set the (virtual) background class as segmentation result.
                        ho_ImageCleared.Dispose();
                        HOperatorSet.GenImageProto(ho_Image, out ho_ImageCleared, hv_BackGroundClass);
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_FinalRows, ho_ImageCleared, out ExpTmpOutVar_0
                                );
                            ho_FinalRows.Dispose();
                            ho_FinalRows = ExpTmpOutVar_0;
                        }
                    }
                    //
                    if ((int)(hv_IncludeGroundTruth) != 0)
                    {
                        ho_TiledImageRow.Dispose();
                        gen_tiled_segmentation_image(out ho_TiledImageRow, hv_DLSamples, hv_SpacingCol,
                            hv_Width, hv_Height);
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_FinalRows, ho_TiledImageRow, out ExpTmpOutVar_0
                                );
                            ho_FinalRows.Dispose();
                            ho_FinalRows = ExpTmpOutVar_0;
                        }
                    }
                    //
                    if ((int)(hv_IncludeResults) != 0)
                    {
                        ho_TiledImageRow.Dispose();
                        gen_tiled_segmentation_image(out ho_TiledImageRow, hv_DLResult, hv_SpacingCol,
                            hv_Width, hv_Height);
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_FinalRows, ho_TiledImageRow, out ExpTmpOutVar_0
                                );
                            ho_FinalRows.Dispose();
                            ho_FinalRows = ExpTmpOutVar_0;
                        }
                    }
                    hv_TiledWidth.Dispose(); hv_TiledHeight.Dispose();
                    HOperatorSet.GetImageSize(ho_FinalRows, out hv_TiledWidth, out hv_TiledHeight);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_TiledResult.Dispose();
                        HOperatorSet.TileImagesOffset(ho_FinalRows, out ho_TiledResult, (((new HTuple(0)).TupleConcat(
                            ((hv_TiledHeight + hv_SpacingRow)).TupleCumul()))).TupleSelectRange(0, (new HTuple(hv_TiledHeight.TupleLength()
                            )) - 1), HTuple.TupleGenConst(new HTuple(hv_TiledHeight.TupleLength()),
                            0), HTuple.TupleGenConst(new HTuple(hv_TiledHeight.TupleLength()), -1),
                            HTuple.TupleGenConst(new HTuple(hv_TiledHeight.TupleLength()), -1), HTuple.TupleGenConst(
                            new HTuple(hv_TiledHeight.TupleLength()), -1), HTuple.TupleGenConst(new HTuple(hv_TiledHeight.TupleLength()
                            ), -1), hv_TiledWidth.TupleMax(), (((((hv_TiledHeight + hv_SpacingRow)).TupleCumul()
                            )).TupleSelect((new HTuple(hv_TiledHeight.TupleLength())) - 1)) - hv_SpacingRow);
                    }
                    //Fill up with the background color.
                    ho_Domain.Dispose();
                    HOperatorSet.GetDomain(ho_TiledResult, out ho_Domain);
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.FullDomain(ho_TiledResult, out ExpTmpOutVar_0);
                        ho_TiledResult.Dispose();
                        ho_TiledResult = ExpTmpOutVar_0;
                    }
                    ho_RegionComplement.Dispose();
                    HOperatorSet.Complement(ho_Domain, out ho_RegionComplement);
                    HOperatorSet.OverpaintRegion(ho_TiledResult, ho_RegionComplement, hv_BackGroundClass,
                        "fill");
                }
                //
                //** Generate a TiledDLSample and a TiledDLResult to display them with dev_display_dl_data: ***
                //
                //Generate a tiled DLSample.
                if ((int)(new HTuple(hv_ModelType.TupleEqual("classification"))) != 0)
                {
                    hv_TiledDLSample.Dispose();
                    gen_dl_samples_from_images(ho_TiledImage, out hv_TiledDLSample);
                    HOperatorSet.SetDictTuple(hv_TiledDLSample, "image_id", hv_ImageID);
                    HOperatorSet.SetDictTuple(hv_TiledDLSample, "image_label_id", hv_ImageLabelID);
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
                {
                    hv_TiledDLSample.Dispose();
                    gen_dl_samples_from_images(ho_TiledImage, out hv_TiledDLSample);
                    HOperatorSet.SetDictTuple(hv_TiledDLSample, "bbox_label_id", hv_GTLabel);
                    if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_TiledDLSample, "bbox_col1", hv_GTCol1);
                        HOperatorSet.SetDictTuple(hv_TiledDLSample, "bbox_row1", hv_GTRow1);
                        HOperatorSet.SetDictTuple(hv_TiledDLSample, "bbox_col2", hv_GTCol2);
                        HOperatorSet.SetDictTuple(hv_TiledDLSample, "bbox_row2", hv_GTRow2);
                    }
                    else
                    {
                        HOperatorSet.SetDictTuple(hv_TiledDLSample, "bbox_col", hv_GTCol);
                        HOperatorSet.SetDictTuple(hv_TiledDLSample, "bbox_row", hv_GTRow);
                        HOperatorSet.SetDictTuple(hv_TiledDLSample, "bbox_length1", hv_GTLength1);
                        HOperatorSet.SetDictTuple(hv_TiledDLSample, "bbox_length2", hv_GTLength2);
                        HOperatorSet.SetDictTuple(hv_TiledDLSample, "bbox_phi", hv_GTPhi);
                    }
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("segmentation"))) != 0)
                {
                    hv_TiledDLSample.Dispose();
                    gen_dl_samples_from_images(ho_TiledImage, out hv_TiledDLSample);
                }
                //
                //Generate a tiled DLResult.
                hv_TiledDLResult.Dispose();
                HOperatorSet.CreateDict(out hv_TiledDLResult);
                if ((int)(new HTuple(hv_ModelType.TupleEqual("classification"))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_TiledDLResult, "image_class_id", hv_ResClassIndices.TupleSelect(
                            0));
                    }
                    HOperatorSet.SetDictTuple(hv_TiledDLResult, "image_confidence", hv_ImageConfidences);
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("segmentation"))) != 0)
                {
                    HOperatorSet.SetDictObject(ho_TiledResult, hv_TiledDLResult, "segmentation_image");
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_TiledDLResult, "bbox_class_id", hv_ResClass);
                    HOperatorSet.SetDictTuple(hv_TiledDLResult, "bbox_confidence", hv_ResConfidence);
                    if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_TiledDLResult, "bbox_col1", hv_ResCol1);
                        HOperatorSet.SetDictTuple(hv_TiledDLResult, "bbox_row1", hv_ResRow1);
                        HOperatorSet.SetDictTuple(hv_TiledDLResult, "bbox_col2", hv_ResCol2);
                        HOperatorSet.SetDictTuple(hv_TiledDLResult, "bbox_row2", hv_ResRow2);
                    }
                    else
                    {
                        HOperatorSet.SetDictTuple(hv_TiledDLResult, "bbox_col", hv_ResCol);
                        HOperatorSet.SetDictTuple(hv_TiledDLResult, "bbox_row", hv_ResRow);
                        HOperatorSet.SetDictTuple(hv_TiledDLResult, "bbox_length1", hv_ResLength1);
                        HOperatorSet.SetDictTuple(hv_TiledDLResult, "bbox_length2", hv_ResLength2);
                        HOperatorSet.SetDictTuple(hv_TiledDLResult, "bbox_phi", hv_ResPhi);
                    }
                }
                //
                //Set display parameters.
                hv_GenParam_COPY_INP_TMP.Dispose();
                HOperatorSet.CreateDict(out hv_GenParam_COPY_INP_TMP);
                //Pinch off all text display from dev_display_dl_data for a clutterless visualization.
                HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "display_bottom_desc",
                    0);
                HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "display_legend", 0);
                HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "display_labels", 0);
                if ((int)((new HTuple(hv_ModelType.TupleEqual("detection"))).TupleAnd(new HTuple((new HTuple(hv_DLModelHandle.TupleLength()
                    )).TupleGreater(0)))) != 0)
                {
                    //Don't display directions if 'ignore_direction' is set to 'true'.
                    hv_IgnoreDirection.Dispose();
                    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "ignore_direction", out hv_IgnoreDirection);
                    if ((int)(new HTuple(hv_IgnoreDirection.TupleEqual("true"))) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_GenParam_COPY_INP_TMP, "display_direction",
                            0);
                    }
                }
                //
                //Initialize the window for displaying the tiled comparison of input and result.
                hv_WindowHandleDict.Dispose();
                HOperatorSet.CreateDict(out hv_WindowHandleDict);
                if ((int)(new HTuple((new HTuple(hv_WindowHandle_COPY_INP_TMP.TupleLength()
                    )).TupleEqual(0))) != 0)
                {
                    hv_Width.Dispose(); hv_Height.Dispose();
                    HOperatorSet.GetImageSize(ho_TiledImage, out hv_Width, out hv_Height);
                    hv_WindowHandle_COPY_INP_TMP.Dispose();
                    dev_open_window_fit_size(hv_WindowRow, hv_WindowCol, hv_Width, hv_Height,
                        hv_WindowWidth, hv_WindowHeight, out hv_WindowHandle_COPY_INP_TMP);
                }
                hv_Flush.Dispose();
                HOperatorSet.GetWindowParam(hv_WindowHandle_COPY_INP_TMP, "flush", out hv_Flush);
                if ((int)(new HTuple(hv_Flush.TupleEqual("true"))) != 0)
                {
                    HOperatorSet.SetWindowParam(hv_WindowHandle_COPY_INP_TMP, "flush", "false");
                }
                HOperatorSet.SetWindowParam(hv_WindowHandle_COPY_INP_TMP, "background_color",
                    hv_BackGroundColor);
                HDevWindowStack.SetActive(hv_WindowHandle_COPY_INP_TMP);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                }
                hv_WindowHandleOut.Dispose();
                hv_WindowHandleOut = new HTuple(hv_WindowHandle_COPY_INP_TMP);
                //
                if ((int)(new HTuple(hv_ModelType.TupleEqual("classification"))) != 0)
                {
                    hv_KeyForDisplay.Dispose();
                    hv_KeyForDisplay = "image";
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("segmentation"))) != 0)
                {
                    hv_KeyForDisplay.Dispose();
                    hv_KeyForDisplay = "segmentation_image_result";
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
                {
                    hv_KeyForDisplay.Dispose();
                    hv_KeyForDisplay = "bbox_both";
                }
                //
                HOperatorSet.SetDictTuple(hv_WindowHandleDict, hv_KeyForDisplay, hv_WindowHandle_COPY_INP_TMP);
                //
                //Display the tiled image.
                dev_display_dl_data(hv_TiledDLSample, hv_TiledDLResult, hv_DLDataset, hv_KeyForDisplay,
                    hv_GenParam_COPY_INP_TMP, hv_WindowHandleDict);
                //
                //For classification, display additional text.
                if ((int)(new HTuple(hv_ModelType.TupleEqual("classification"))) != 0)
                {
                    hv_Width.Dispose(); hv_Height.Dispose();
                    HOperatorSet.GetImageSize(ho_TiledImage, out hv_Width, out hv_Height);
                    HTuple end_val476 = hv_NumSamples_COPY_INP_TMP - 1;
                    HTuple step_val476 = 1;
                    for (hv_Index = 0; hv_Index.Continue(end_val476, step_val476); hv_Index = hv_Index.TupleAdd(step_val476))
                    {
                        hv_GTText.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_GTText = "Ground truth: " + (hv_ImageLabelIDs.TupleSelect(
                                hv_Index));
                        }
                        hv_PredictionText.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_PredictionText = "Prediction: " + (hv_ResClassIndices.TupleSelect(
                                hv_Index));
                        }
                        hv__.Dispose(); hv__.Dispose(); hv_GTWidth.Dispose(); hv_TextHeight.Dispose();
                        HOperatorSet.GetStringExtents(hv_WindowHandle_COPY_INP_TMP, hv_GTText,
                            out hv__, out hv__, out hv_GTWidth, out hv_TextHeight);
                        hv__.Dispose(); hv__.Dispose(); hv_PredictionWidth.Dispose(); hv__.Dispose();
                        HOperatorSet.GetStringExtents(hv_WindowHandle_COPY_INP_TMP, hv_PredictionText,
                            out hv__, out hv__, out hv_PredictionWidth, out hv__);
                        //Get ratio between image and window coordinate system.
                        hv__.Dispose(); hv__.Dispose(); hv_WindowWidth.Dispose(); hv_WindowHeight.Dispose();
                        HOperatorSet.GetWindowExtents(hv_WindowHandle_COPY_INP_TMP, out hv__, out hv__,
                            out hv_WindowWidth, out hv_WindowHeight);
                        //Adapt widths of texts to plot it correctly in window coordinate system.
                        if ((int)(new HTuple(((hv_Height / (hv_Width.TupleReal()))).TupleGreater(
                            hv_WindowHeight / (hv_WindowWidth.TupleReal())))) != 0)
                        {
                            hv_WindowImageRatio.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio = 1.0 / (hv_WindowHeight / (((hv_Height.TupleSelect(
                                    0))).TupleReal()));
                            }
                        }
                        else
                        {
                            hv_WindowImageRatio.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_WindowImageRatio = 1.0 / (hv_WindowWidth / (((hv_Width.TupleSelect(
                                    0))).TupleReal()));
                            }
                        }
                        if ((int)(new HTuple(hv_TextImageWidth.TupleLess(((hv_GTWidth + hv_PredictionWidth) * hv_WindowImageRatio) + 30))) != 0)
                        {
                            //Make shorter text.
                            hv_GTText.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_GTText = "GT: " + (hv_ImageLabelIDs.TupleSelect(
                                    hv_Index));
                            }
                            hv_PredictionText.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_PredictionText = "Pred.: " + (hv_ResClassIndices.TupleSelect(
                                    hv_Index));
                            }
                            hv__.Dispose(); hv__.Dispose(); hv_GTWidth.Dispose(); hv_TextHeight.Dispose();
                            HOperatorSet.GetStringExtents(hv_WindowHandle_COPY_INP_TMP, hv_GTText,
                                out hv__, out hv__, out hv_GTWidth, out hv_TextHeight);
                            hv__.Dispose(); hv__.Dispose(); hv_PredictionWidth.Dispose(); hv__.Dispose();
                            HOperatorSet.GetStringExtents(hv_WindowHandle_COPY_INP_TMP, hv_PredictionText,
                                out hv__, out hv__, out hv_PredictionWidth, out hv__);
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_GTText, "image",
                                    ((hv_TextImageRows.TupleSelect(hv_Index)) + (hv_TextImageHeight / 2)) - hv_TextHeight,
                                    (hv_TextImageColumns.TupleSelect(hv_Index)) + 10, "white", "box", "false");
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_PredictionText,
                                    "image", ((hv_TextImageRows.TupleSelect(hv_Index)) + (hv_TextImageHeight / 2)) - hv_TextHeight,
                                    (((hv_TextImageColumns.TupleSelect(hv_Index)) + hv_TextImageWidth) - (hv_PredictionWidth * hv_WindowImageRatio)) - 10,
                                    "white", "box", "false");
                            }
                        }
                    }
                }
                //
                if ((int)(new HTuple(hv_Flush.TupleEqual("true"))) != 0)
                {
                    //Only flush the window, if 'flush' is 'true'. Otherwise the caller
                    //(who set flush to 'false' on purpose) is responsible for flushing.
                    HOperatorSet.FlushBuffer(hv_WindowHandle_COPY_INP_TMP);
                }
                HOperatorSet.SetWindowParam(hv_WindowHandle_COPY_INP_TMP, "flush", hv_Flush);
                //
                ho_FinalRows.Dispose();
                ho_SampleImages.Dispose();
                ho_SampleImage.Dispose();
                ho_FirstChannel.Dispose();
                ho_ImageScaled.Dispose();
                ho_ImageConverted.Dispose();
                ho_TiledImageRow.Dispose();
                ho_TiledImage.Dispose();
                ho_Domain.Dispose();
                ho_RegionComplement.Dispose();
                ho_Image.Dispose();
                ho_ImageCleared.Dispose();
                ho_TiledResult.Dispose();

                hv_GenParam_COPY_INP_TMP.Dispose();
                hv_NumSamples_COPY_INP_TMP.Dispose();
                hv_WindowHandle_COPY_INP_TMP.Dispose();
                hv_BackGroundColor.Dispose();
                hv_SpacingRow.Dispose();
                hv_SpacingCol.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowCol.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_IncludeImage.Dispose();
                hv_IncludeGroundTruth.Dispose();
                hv_IncludeResults.Dispose();
                hv_Keys.Dispose();
                hv_Index.Dispose();
                hv_Key.Dispose();
                hv_Value.Dispose();
                hv_ModelType.Dispose();
                hv_Samples.Dispose();
                hv_ClassificationLabelExists.Dispose();
                hv_DetectionLabelExists.Dispose();
                hv_SegmentationLabelExists.Dispose();
                hv_DLSamples.Dispose();
                hv_SampleIndices.Dispose();
                hv_DLResult.Dispose();
                hv_ClassIDs.Dispose();
                hv_BackGroundClass.Dispose();
                hv_RGB.Dispose();
                hv_Scale.Dispose();
                hv_Shift.Dispose();
                hv_KeyExists.Dispose();
                hv_DLDatasetPreprocessParam.Dispose();
                hv_NormType.Dispose();
                hv_KeyMinExists.Dispose();
                hv_KeyMaxExists.Dispose();
                hv_ImageRangeMin.Dispose();
                hv_ImageRangeMax.Dispose();
                hv_Channels.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_Crop.Dispose();
                hv_OffsetRow.Dispose();
                hv_TiledWidth.Dispose();
                hv_TiledHeight.Dispose();
                hv_NumResult.Dispose();
                hv_PredictionsCorrect.Dispose();
                hv_ImageConfidences.Dispose();
                hv_ResClassIndices.Dispose();
                hv_ResClasses.Dispose();
                hv_ImageIDs.Dispose();
                hv_ImageLabelIDs.Dispose();
                hv_IndexResult.Dispose();
                hv_ImageConfidence.Dispose();
                hv_ResClassIndex.Dispose();
                hv_ResClass.Dispose();
                hv_ImageID.Dispose();
                hv_ImageLabelID.Dispose();
                hv_PredictionCorrect.Dispose();
                hv_TextImageRows.Dispose();
                hv_TextImageColumns.Dispose();
                hv_TextImageWidth.Dispose();
                hv_TextImageHeight.Dispose();
                hv_TopOffset.Dispose();
                hv_InstanceType.Dispose();
                hv_Rect1KeyExists.Dispose();
                hv_Rect2KeyExists.Dispose();
                hv_GTLabel.Dispose();
                hv_GTCol1.Dispose();
                hv_GTRow1.Dispose();
                hv_GTCol2.Dispose();
                hv_GTRow2.Dispose();
                hv_GTCol.Dispose();
                hv_GTRow.Dispose();
                hv_GTLength1.Dispose();
                hv_GTLength2.Dispose();
                hv_GTPhi.Dispose();
                hv_LeftOffset.Dispose();
                hv_LabelId.Dispose();
                hv_Col1.Dispose();
                hv_Row1.Dispose();
                hv_Col2.Dispose();
                hv_Row2.Dispose();
                hv_Col.Dispose();
                hv_Row.Dispose();
                hv_Length1.Dispose();
                hv_Length2.Dispose();
                hv_Phi.Dispose();
                hv_ResConfidence.Dispose();
                hv_ResCol1.Dispose();
                hv_ResRow1.Dispose();
                hv_ResCol2.Dispose();
                hv_ResRow2.Dispose();
                hv_ResCol.Dispose();
                hv_ResRow.Dispose();
                hv_ResLength1.Dispose();
                hv_ResLength2.Dispose();
                hv_ResPhi.Dispose();
                hv_ClassId.Dispose();
                hv_Confidence.Dispose();
                hv_TiledDLSample.Dispose();
                hv_TiledDLResult.Dispose();
                hv_IgnoreDirection.Dispose();
                hv_WindowHandleDict.Dispose();
                hv_Flush.Dispose();
                hv_KeyForDisplay.Dispose();
                hv_GTText.Dispose();
                hv_PredictionText.Dispose();
                hv__.Dispose();
                hv_GTWidth.Dispose();
                hv_TextHeight.Dispose();
                hv_PredictionWidth.Dispose();
                hv_WindowImageRatio.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_FinalRows.Dispose();
                ho_SampleImages.Dispose();
                ho_SampleImage.Dispose();
                ho_FirstChannel.Dispose();
                ho_ImageScaled.Dispose();
                ho_ImageConverted.Dispose();
                ho_TiledImageRow.Dispose();
                ho_TiledImage.Dispose();
                ho_Domain.Dispose();
                ho_RegionComplement.Dispose();
                ho_Image.Dispose();
                ho_ImageCleared.Dispose();
                ho_TiledResult.Dispose();

                hv_GenParam_COPY_INP_TMP.Dispose();
                hv_NumSamples_COPY_INP_TMP.Dispose();
                hv_WindowHandle_COPY_INP_TMP.Dispose();
                hv_BackGroundColor.Dispose();
                hv_SpacingRow.Dispose();
                hv_SpacingCol.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowCol.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_IncludeImage.Dispose();
                hv_IncludeGroundTruth.Dispose();
                hv_IncludeResults.Dispose();
                hv_Keys.Dispose();
                hv_Index.Dispose();
                hv_Key.Dispose();
                hv_Value.Dispose();
                hv_ModelType.Dispose();
                hv_Samples.Dispose();
                hv_ClassificationLabelExists.Dispose();
                hv_DetectionLabelExists.Dispose();
                hv_SegmentationLabelExists.Dispose();
                hv_DLSamples.Dispose();
                hv_SampleIndices.Dispose();
                hv_DLResult.Dispose();
                hv_ClassIDs.Dispose();
                hv_BackGroundClass.Dispose();
                hv_RGB.Dispose();
                hv_Scale.Dispose();
                hv_Shift.Dispose();
                hv_KeyExists.Dispose();
                hv_DLDatasetPreprocessParam.Dispose();
                hv_NormType.Dispose();
                hv_KeyMinExists.Dispose();
                hv_KeyMaxExists.Dispose();
                hv_ImageRangeMin.Dispose();
                hv_ImageRangeMax.Dispose();
                hv_Channels.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_Crop.Dispose();
                hv_OffsetRow.Dispose();
                hv_TiledWidth.Dispose();
                hv_TiledHeight.Dispose();
                hv_NumResult.Dispose();
                hv_PredictionsCorrect.Dispose();
                hv_ImageConfidences.Dispose();
                hv_ResClassIndices.Dispose();
                hv_ResClasses.Dispose();
                hv_ImageIDs.Dispose();
                hv_ImageLabelIDs.Dispose();
                hv_IndexResult.Dispose();
                hv_ImageConfidence.Dispose();
                hv_ResClassIndex.Dispose();
                hv_ResClass.Dispose();
                hv_ImageID.Dispose();
                hv_ImageLabelID.Dispose();
                hv_PredictionCorrect.Dispose();
                hv_TextImageRows.Dispose();
                hv_TextImageColumns.Dispose();
                hv_TextImageWidth.Dispose();
                hv_TextImageHeight.Dispose();
                hv_TopOffset.Dispose();
                hv_InstanceType.Dispose();
                hv_Rect1KeyExists.Dispose();
                hv_Rect2KeyExists.Dispose();
                hv_GTLabel.Dispose();
                hv_GTCol1.Dispose();
                hv_GTRow1.Dispose();
                hv_GTCol2.Dispose();
                hv_GTRow2.Dispose();
                hv_GTCol.Dispose();
                hv_GTRow.Dispose();
                hv_GTLength1.Dispose();
                hv_GTLength2.Dispose();
                hv_GTPhi.Dispose();
                hv_LeftOffset.Dispose();
                hv_LabelId.Dispose();
                hv_Col1.Dispose();
                hv_Row1.Dispose();
                hv_Col2.Dispose();
                hv_Row2.Dispose();
                hv_Col.Dispose();
                hv_Row.Dispose();
                hv_Length1.Dispose();
                hv_Length2.Dispose();
                hv_Phi.Dispose();
                hv_ResConfidence.Dispose();
                hv_ResCol1.Dispose();
                hv_ResRow1.Dispose();
                hv_ResCol2.Dispose();
                hv_ResRow2.Dispose();
                hv_ResCol.Dispose();
                hv_ResRow.Dispose();
                hv_ResLength1.Dispose();
                hv_ResLength2.Dispose();
                hv_ResPhi.Dispose();
                hv_ClassId.Dispose();
                hv_Confidence.Dispose();
                hv_TiledDLSample.Dispose();
                hv_TiledDLResult.Dispose();
                hv_IgnoreDirection.Dispose();
                hv_WindowHandleDict.Dispose();
                hv_Flush.Dispose();
                hv_KeyForDisplay.Dispose();
                hv_GTText.Dispose();
                hv_PredictionText.Dispose();
                hv__.Dispose();
                hv_GTWidth.Dispose();
                hv_TextHeight.Dispose();
                hv_PredictionWidth.Dispose();
                hv_WindowImageRatio.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection
        // Short Description: Display the ground truth anomaly regions of the given DLSample. 
        private void dev_display_ground_truth_anomaly_regions(HTuple hv_SampleKeys, HTuple hv_DLSample,
            HTuple hv_CurrentWindowHandle, HTuple hv_LineWidth, HTuple hv_AnomalyRegionLabelColor,
            HTuple hv_AnomalyColorTransparency, out HTuple hv_AnomalyRegionExists)
        {



            // Local iconic variables 

            HObject ho_AnomalyImage = null, ho_AnomalyRegion = null;

            // Local control variables 

            HTuple hv_Red = new HTuple(), hv_Green = new HTuple();
            HTuple hv_Blue = new HTuple(), hv_Alpha = new HTuple();
            HTuple hv_InitialColor = new HTuple(), hv_IndexColor = new HTuple();
            HTuple hv_Color_RGBA = new HTuple(), hv_Area = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_AnomalyImage);
            HOperatorSet.GenEmptyObj(out ho_AnomalyRegion);
            hv_AnomalyRegionExists = new HTuple();
            try
            {
                //
                //This procedure visualizes the ground truth anomalies
                //if there is an anomaly_ground_truth in DLSample.
                //
                //Get current set color.
                hv_Red.Dispose(); hv_Green.Dispose(); hv_Blue.Dispose(); hv_Alpha.Dispose();
                HOperatorSet.GetRgba(hv_CurrentWindowHandle, out hv_Red, out hv_Green, out hv_Blue,
                    out hv_Alpha);
                hv_InitialColor.Dispose();
                hv_InitialColor = new HTuple();
                for (hv_IndexColor = 0; (int)hv_IndexColor <= (int)((new HTuple(hv_Red.TupleLength()
                    )) - 1); hv_IndexColor = (int)hv_IndexColor + 1)
                {
                    hv_Color_RGBA.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Color_RGBA = ((("#" + (((hv_Red.TupleSelect(
                            hv_IndexColor))).TupleString("2x"))) + (((hv_Green.TupleSelect(hv_IndexColor))).TupleString(
                            "2x"))) + (((hv_Blue.TupleSelect(hv_IndexColor))).TupleString("2x"))) + (((hv_Alpha.TupleSelect(
                            hv_IndexColor))).TupleString("2x"));
                    }
                    {
                        HTuple ExpTmpOutVar_0;
                        HOperatorSet.TupleRegexpReplace(hv_Color_RGBA, (new HTuple(" ")).TupleConcat(
                            "replace_all"), "0", out ExpTmpOutVar_0);
                        hv_Color_RGBA.Dispose();
                        hv_Color_RGBA = ExpTmpOutVar_0;
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_InitialColor = hv_InitialColor.TupleConcat(
                                hv_Color_RGBA);
                            hv_InitialColor.Dispose();
                            hv_InitialColor = ExpTmpLocalVar_InitialColor;
                        }
                    }
                }
                //
                if ((int)(new HTuple(((hv_SampleKeys.TupleFind("anomaly_ground_truth"))).TupleNotEqual(
                    -1))) != 0)
                {
                    ho_AnomalyImage.Dispose();
                    HOperatorSet.GetDictObject(out ho_AnomalyImage, hv_DLSample, "anomaly_ground_truth");
                    ho_AnomalyRegion.Dispose();
                    HOperatorSet.Threshold(ho_AnomalyImage, out ho_AnomalyRegion, 1, 255);
                    //Get non-empty regions.
                    hv_Area.Dispose();
                    HOperatorSet.RegionFeatures(ho_AnomalyRegion, "area", out hv_Area);
                    if ((int)(new HTuple(hv_Area.TupleGreater(0))) != 0)
                    {
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_AnomalyRegionLabelColor + hv_AnomalyColorTransparency);
                            }
                        }
                        //Display the anomaly region.
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_AnomalyRegion, HDevWindowStack.GetActive());
                        }
                    }
                    hv_AnomalyRegionExists.Dispose();
                    hv_AnomalyRegionExists = "true";
                }
                else
                {
                    hv_AnomalyRegionExists.Dispose();
                    hv_AnomalyRegionExists = "false";
                }
                //
                //Reset colors.
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_InitialColor);
                }
                //
                ho_AnomalyImage.Dispose();
                ho_AnomalyRegion.Dispose();

                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();
                hv_Alpha.Dispose();
                hv_InitialColor.Dispose();
                hv_IndexColor.Dispose();
                hv_Color_RGBA.Dispose();
                hv_Area.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_AnomalyImage.Dispose();
                ho_AnomalyRegion.Dispose();

                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();
                hv_Alpha.Dispose();
                hv_InitialColor.Dispose();
                hv_IndexColor.Dispose();
                hv_Color_RGBA.Dispose();
                hv_Area.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: Display the ground truth bounding boxes of DLSample. 
        private void dev_display_ground_truth_detection(HTuple hv_DLSample, HTuple hv_SampleKeys,
            HTuple hv_LineWidthBbox, HTuple hv_ClassIDs, HTuple hv_BboxColors, HTuple hv_BboxLabelColor,
            HTuple hv_WindowImageRatio, HTuple hv_TextColor, HTuple hv_ShowLabels, HTuple hv_ShowDirection,
            HTuple hv_WindowHandle, out HTuple hv_BboxIDs)
        {



            // Local iconic variables 

            HObject ho_BboxRectangle = null, ho_OrientationArrows = null;
            HObject ho_RectangleSelected = null, ho_ArrowSelected = null;

            // Local control variables 

            HTuple hv_InstanceType = new HTuple(), hv_BboxRow1 = new HTuple();
            HTuple hv_BboxCol1 = new HTuple(), hv_BboxRow2 = new HTuple();
            HTuple hv_BboxCol2 = new HTuple(), hv_BboxLabels = new HTuple();
            HTuple hv_BboxRow = new HTuple(), hv_BboxCol = new HTuple();
            HTuple hv_BboxLength1 = new HTuple(), hv_BboxLength2 = new HTuple();
            HTuple hv_BboxPhi = new HTuple(), hv_Text = new HTuple();
            HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
            HTuple hv__ = new HTuple(), hv_TextOffset = new HTuple();
            HTuple hv_LabelRow = new HTuple(), hv_LabelCol = new HTuple();
            HTuple hv_HeadSize = new HTuple(), hv_ContourStyle = new HTuple();
            HTuple hv_Style = new HTuple(), hv_IndexBbox = new HTuple();
            HTuple hv_ClassID = new HTuple(), hv_TextColorClasses = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_BboxRectangle);
            HOperatorSet.GenEmptyObj(out ho_OrientationArrows);
            HOperatorSet.GenEmptyObj(out ho_RectangleSelected);
            HOperatorSet.GenEmptyObj(out ho_ArrowSelected);
            hv_BboxIDs = new HTuple();
            try
            {
                //
                //This procedure displays the ground truth bounding boxes of DLSample.
                //
                hv_InstanceType.Dispose();
                hv_InstanceType = "rectangle1";
                if ((int)(new HTuple(((hv_SampleKeys.TupleFind("bbox_row1"))).TupleNotEqual(
                    -1))) != 0)
                {
                    hv_BboxRow1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row1", out hv_BboxRow1);
                    hv_BboxCol1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col1", out hv_BboxCol1);
                    hv_BboxRow2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row2", out hv_BboxRow2);
                    hv_BboxCol2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col2", out hv_BboxCol2);
                    hv_BboxLabels.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_label_id", out hv_BboxLabels);
                }
                else if ((int)(new HTuple(((hv_SampleKeys.TupleFind("bbox_phi"))).TupleNotEqual(
                    -1))) != 0)
                {
                    hv_BboxRow.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_row", out hv_BboxRow);
                    hv_BboxCol.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_col", out hv_BboxCol);
                    hv_BboxLength1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_length1", out hv_BboxLength1);
                    hv_BboxLength2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_length2", out hv_BboxLength2);
                    hv_BboxPhi.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_phi", out hv_BboxPhi);
                    hv_BboxLabels.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLSample, "bbox_label_id", out hv_BboxLabels);
                    hv_InstanceType.Dispose();
                    hv_InstanceType = "rectangle2";
                }
                else
                {
                    throw new HalconException("Ground truth bounding box data could not be found in DLSample.");
                }
                if ((int)(new HTuple((new HTuple(hv_BboxLabels.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    //
                    //Get text and text size for correct positioning of label IDs.
                    if ((int)(hv_ShowLabels) != 0)
                    {
                        hv_Text.Dispose();
                        hv_Text = new HTuple(hv_BboxLabels);
                        hv_Ascent.Dispose(); hv_Descent.Dispose(); hv__.Dispose(); hv__.Dispose();
                        HOperatorSet.GetStringExtents(hv_WindowHandle, hv_Text, out hv_Ascent,
                            out hv_Descent, out hv__, out hv__);
                        hv_TextOffset.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TextOffset = (hv_Ascent + hv_Descent) / hv_WindowImageRatio;
                        }
                    }
                    //
                    //Generate bounding box XLDs.
                    if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BboxPhi.Dispose();
                            HOperatorSet.TupleGenConst(new HTuple(hv_BboxRow1.TupleLength()), 0.0,
                                out hv_BboxPhi);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_BboxRectangle.Dispose();
                            HOperatorSet.GenRectangle2ContourXld(out ho_BboxRectangle, 0.5 * (hv_BboxRow1 + hv_BboxRow2),
                                0.5 * (hv_BboxCol1 + hv_BboxCol2), hv_BboxPhi, 0.5 * (hv_BboxCol2 - hv_BboxCol1),
                                0.5 * (hv_BboxRow2 - hv_BboxRow1));
                        }
                        if ((int)(hv_ShowLabels) != 0)
                        {
                            hv_LabelRow.Dispose();
                            hv_LabelRow = new HTuple(hv_BboxRow1);
                            hv_LabelCol.Dispose();
                            hv_LabelCol = new HTuple(hv_BboxCol1);
                        }
                    }
                    else
                    {
                        ho_BboxRectangle.Dispose();
                        HOperatorSet.GenRectangle2ContourXld(out ho_BboxRectangle, hv_BboxRow,
                            hv_BboxCol, hv_BboxPhi, hv_BboxLength1, hv_BboxLength2);
                        if ((int)(hv_ShowLabels) != 0)
                        {
                            hv_LabelRow.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_LabelRow = hv_BboxRow - hv_TextOffset;
                            }
                            hv_LabelCol.Dispose();
                            hv_LabelCol = new HTuple(hv_BboxCol);
                        }
                        if ((int)(hv_ShowDirection) != 0)
                        {
                            hv_HeadSize.Dispose();
                            hv_HeadSize = 20.0;
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_OrientationArrows.Dispose();
                                gen_arrow_contour_xld(out ho_OrientationArrows, hv_BboxRow, hv_BboxCol,
                                    hv_BboxRow - ((hv_BboxLength1 + hv_HeadSize) * (hv_BboxPhi.TupleSin())),
                                    hv_BboxCol + ((hv_BboxLength1 + hv_HeadSize) * (hv_BboxPhi.TupleCos())),
                                    hv_HeadSize, hv_HeadSize);
                            }
                        }
                    }
                    //
                    //Collect the ClassIDs of the bounding boxes.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BboxIDs.Dispose();
                        HOperatorSet.TupleGenConst(new HTuple(hv_BboxLabels.TupleLength()), 0, out hv_BboxIDs);
                    }
                    //
                    //Draw the bounding boxes.
                    hv_ContourStyle.Dispose();
                    HOperatorSet.GetContourStyle(hv_WindowHandle, out hv_ContourStyle);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetContourStyle(HDevWindowStack.GetActive(), "stroke_and_fill");
                    }
                    hv_Style.Dispose();
                    HOperatorSet.GetLineStyle(hv_WindowHandle, out hv_Style);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidthBbox);
                    }
                    for (hv_IndexBbox = 0; (int)hv_IndexBbox <= (int)((new HTuple(hv_BboxLabels.TupleLength()
                        )) - 1); hv_IndexBbox = (int)hv_IndexBbox + 1)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_RectangleSelected.Dispose();
                            HOperatorSet.SelectObj(ho_BboxRectangle, out ho_RectangleSelected, hv_IndexBbox + 1);
                        }
                        hv_ClassID.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClassID = hv_ClassIDs.TupleFind(
                                hv_BboxLabels.TupleSelect(hv_IndexBbox));
                        }
                        if (hv_BboxIDs == null)
                            hv_BboxIDs = new HTuple();
                        hv_BboxIDs[hv_IndexBbox] = hv_ClassID;
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetColor(HDevWindowStack.GetActive(), (hv_BboxColors.TupleSelect(
                                    hv_ClassID)) + "60");
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_RectangleSelected, HDevWindowStack.GetActive()
                                );
                        }
                        if ((int)((new HTuple(hv_InstanceType.TupleEqual("rectangle2"))).TupleAnd(
                            hv_ShowDirection)) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_ArrowSelected.Dispose();
                                HOperatorSet.SelectObj(ho_OrientationArrows, out ho_ArrowSelected, hv_IndexBbox + 1);
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetColor(HDevWindowStack.GetActive(), (hv_BboxColors.TupleSelect(
                                        hv_ClassID)) + "FF");
                                }
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_ArrowSelected, HDevWindowStack.GetActive());
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetColor(HDevWindowStack.GetActive(), (hv_BboxColors.TupleSelect(
                                        hv_ClassID)) + "60");
                                }
                            }
                        }
                    }
                    //
                    //Write text to the bounding boxes.
                    if ((int)(hv_ShowLabels) != 0)
                    {
                        //For better visibility the text is displayed after all bounding boxes are drawn.
                        //Select text color.
                        if ((int)(new HTuple(hv_TextColor.TupleEqual(""))) != 0)
                        {
                            hv_TextColorClasses.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TextColorClasses = hv_BboxColors.TupleSelect(
                                    hv_BboxIDs);
                            }
                        }
                        else
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TextColorClasses.Dispose();
                                HOperatorSet.TupleGenConst(new HTuple(hv_BboxIDs.TupleLength()), hv_TextColor,
                                    out hv_TextColorClasses);
                            }
                        }
                        //Display text.
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_BboxLabels, "image",
                                    hv_LabelRow, hv_LabelCol, hv_TextColorClasses, ((new HTuple("box_color")).TupleConcat(
                                    "shadow")).TupleConcat("border_radius"), hv_BboxLabelColor.TupleConcat(
                                    (new HTuple("false")).TupleConcat(0)));
                            }
                        }
                    }
                    //
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetContourStyle(HDevWindowStack.GetActive(), hv_ContourStyle);
                    }
                    HOperatorSet.SetLineStyle(hv_WindowHandle, hv_Style);
                }
                else
                {
                    //Do nothing if there are no ground truth bounding boxes.
                    hv_BboxIDs.Dispose();
                    hv_BboxIDs = new HTuple();
                }
                //
                ho_BboxRectangle.Dispose();
                ho_OrientationArrows.Dispose();
                ho_RectangleSelected.Dispose();
                ho_ArrowSelected.Dispose();

                hv_InstanceType.Dispose();
                hv_BboxRow1.Dispose();
                hv_BboxCol1.Dispose();
                hv_BboxRow2.Dispose();
                hv_BboxCol2.Dispose();
                hv_BboxLabels.Dispose();
                hv_BboxRow.Dispose();
                hv_BboxCol.Dispose();
                hv_BboxLength1.Dispose();
                hv_BboxLength2.Dispose();
                hv_BboxPhi.Dispose();
                hv_Text.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv__.Dispose();
                hv_TextOffset.Dispose();
                hv_LabelRow.Dispose();
                hv_LabelCol.Dispose();
                hv_HeadSize.Dispose();
                hv_ContourStyle.Dispose();
                hv_Style.Dispose();
                hv_IndexBbox.Dispose();
                hv_ClassID.Dispose();
                hv_TextColorClasses.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_BboxRectangle.Dispose();
                ho_OrientationArrows.Dispose();
                ho_RectangleSelected.Dispose();
                ho_ArrowSelected.Dispose();

                hv_InstanceType.Dispose();
                hv_BboxRow1.Dispose();
                hv_BboxCol1.Dispose();
                hv_BboxRow2.Dispose();
                hv_BboxCol2.Dispose();
                hv_BboxLabels.Dispose();
                hv_BboxRow.Dispose();
                hv_BboxCol.Dispose();
                hv_BboxLength1.Dispose();
                hv_BboxLength2.Dispose();
                hv_BboxPhi.Dispose();
                hv_Text.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv__.Dispose();
                hv_TextOffset.Dispose();
                hv_LabelRow.Dispose();
                hv_LabelCol.Dispose();
                hv_HeadSize.Dispose();
                hv_ContourStyle.Dispose();
                hv_Style.Dispose();
                hv_IndexBbox.Dispose();
                hv_ClassID.Dispose();
                hv_TextColorClasses.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Initialize the visualization of the training progress. This includes setting default values for visualization parameters. 
        private void dev_display_init_train_dl_model(HTuple hv_DLModelHandle, HTuple hv_TrainParam,
            out HTuple hv_DisplayData)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ModelType = new HTuple(), hv_DisplayParam = new HTuple();
            HTuple hv_DisplayEnabled = new HTuple(), hv_UpdateImagesIntervalEpochs = new HTuple();
            HTuple hv_NumImagesPreview = new HTuple(), hv_ChangePlotIntervalSeconds = new HTuple();
            HTuple hv_SelectedPercentageTrainSamples = new HTuple();
            HTuple hv_XAxisLabel = new HTuple(), hv_DisplayParamNames = new HTuple();
            HTuple hv_DisplayDefaultValues = new HTuple(), hv_Index = new HTuple();
            HTuple hv_KeyExists = new HTuple(), hv_DisplayIntervalSeconds = new HTuple();
            HTuple hv_Time = new HTuple(), hv_StatusModelParamNames = new HTuple();
            HTuple hv_WindowTextWidth = new HTuple(), hv_WindowTextHeight = new HTuple();
            HTuple hv_WindowImagesWidth = new HTuple(), hv_WindowImagesHeight = new HTuple();
            HTuple hv_WindowBGColor = new HTuple(), hv_WindowHandleText = new HTuple();
            HTuple hv_WindowImagesRow = new HTuple(), hv_WindowImagesCol = new HTuple();
            HTuple hv_TiledParam = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_TiledParamNames = new HTuple(), hv_TiledDefaultValues = new HTuple();
            // Initialize local and output iconic variables 
            hv_DisplayData = new HTuple();
            try
            {
                //
                //This procedure initializes the visualization of the training progress.
                //This includes setting default values for visualization parameters.
                //
                //Get the actual model type.
                if ((int)(new HTuple(hv_DLModelHandle.TupleNotEqual(new HTuple()))) != 0)
                {
                    hv_ModelType.Dispose();
                    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "type", out hv_ModelType);
                }
                else
                {
                    hv_ModelType.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainParam, "type", out hv_ModelType);
                }
                //
                //Initialize display data.
                hv_DisplayData.Dispose();
                HOperatorSet.CreateDict(out hv_DisplayData);
                hv_DisplayParam.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainParam, "display_param", out hv_DisplayParam);
                HOperatorSet.SetDictTuple(hv_DisplayData, "display_param", hv_DisplayParam);
                hv_DisplayEnabled.Dispose();
                HOperatorSet.GetDictTuple(hv_DisplayParam, "enabled", out hv_DisplayEnabled);
                HOperatorSet.SetDictTuple(hv_DisplayData, "enabled", hv_DisplayEnabled);
                //
                //Set default values if not set by the user.
                //
                //Default interval (in epochs) for the preview update
                //depending on the model type.
                if ((int)(new HTuple(hv_ModelType.TupleEqual("classification"))) != 0)
                {
                    hv_UpdateImagesIntervalEpochs.Dispose();
                    hv_UpdateImagesIntervalEpochs = 4;
                }
                else
                {
                    hv_UpdateImagesIntervalEpochs.Dispose();
                    hv_UpdateImagesIntervalEpochs = 0.5;
                }
                //
                //Default number of images to display in the images preview.
                if ((int)(new HTuple(hv_ModelType.TupleEqual("classification"))) != 0)
                {
                    hv_NumImagesPreview.Dispose();
                    hv_NumImagesPreview = 6;
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
                {
                    hv_NumImagesPreview.Dispose();
                    hv_NumImagesPreview = 2;
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("segmentation"))) != 0)
                {
                    hv_NumImagesPreview.Dispose();
                    hv_NumImagesPreview = 4;
                }
                //
                //Default interval (in seconds) to switch between plots.
                hv_ChangePlotIntervalSeconds.Dispose();
                hv_ChangePlotIntervalSeconds = 10;
                //
                //Default percentage of images that is used for evaluation on training set.
                //If set to zero no evaluation on training set is done.
                hv_SelectedPercentageTrainSamples.Dispose();
                hv_SelectedPercentageTrainSamples = 0;
                //
                //Default x_axis_label: Show 'iterations' or 'epochs' as x-values in plots.
                hv_XAxisLabel.Dispose();
                hv_XAxisLabel = "epochs";
                //
                //Collect all display params and overwrite if user values are given.
                //Note, some parameters are also used for the evaluation.
                //Thus, write its value even for DisplayEnabled = false.
                hv_DisplayParamNames.Dispose();
                hv_DisplayParamNames = new HTuple();
                hv_DisplayParamNames[0] = "change_plot_interval_seconds";
                hv_DisplayParamNames[1] = "num_images";
                hv_DisplayParamNames[2] = "selected_percentage_train_samples";
                hv_DisplayParamNames[3] = "update_images_interval_epochs";
                hv_DisplayParamNames[4] = "x_axis_label";
                hv_DisplayDefaultValues.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_DisplayDefaultValues = new HTuple();
                    hv_DisplayDefaultValues = hv_DisplayDefaultValues.TupleConcat(hv_ChangePlotIntervalSeconds, hv_NumImagesPreview, hv_SelectedPercentageTrainSamples, hv_UpdateImagesIntervalEpochs, hv_XAxisLabel);
                }
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_DisplayParamNames.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_KeyExists.Dispose();
                        HOperatorSet.GetDictParam(hv_DisplayParam, "key_exists", hv_DisplayParamNames.TupleSelect(
                            hv_Index), out hv_KeyExists);
                    }
                    if ((int)(hv_KeyExists.TupleNot()) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_DisplayParam, hv_DisplayParamNames.TupleSelect(
                                hv_Index), hv_DisplayDefaultValues.TupleSelect(hv_Index));
                        }
                    }
                }
                //
                //Set last_update, which is needed to determine when updates are needed.
                hv_DisplayIntervalSeconds.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainParam, "update_interval_seconds", out hv_DisplayIntervalSeconds);
                hv_Time.Dispose();
                HOperatorSet.CountSeconds(out hv_Time);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_DisplayData, "last_update", hv_Time - (hv_DisplayIntervalSeconds * 2));
                }
                //
                //Some entries in DisplayParam are also needed in case of disabled display.
                //They are all set yet.
                if ((int)(hv_DisplayEnabled.TupleNot()) != 0)
                {

                    hv_ModelType.Dispose();
                    hv_DisplayParam.Dispose();
                    hv_DisplayEnabled.Dispose();
                    hv_UpdateImagesIntervalEpochs.Dispose();
                    hv_NumImagesPreview.Dispose();
                    hv_ChangePlotIntervalSeconds.Dispose();
                    hv_SelectedPercentageTrainSamples.Dispose();
                    hv_XAxisLabel.Dispose();
                    hv_DisplayParamNames.Dispose();
                    hv_DisplayDefaultValues.Dispose();
                    hv_Index.Dispose();
                    hv_KeyExists.Dispose();
                    hv_DisplayIntervalSeconds.Dispose();
                    hv_Time.Dispose();
                    hv_StatusModelParamNames.Dispose();
                    hv_WindowTextWidth.Dispose();
                    hv_WindowTextHeight.Dispose();
                    hv_WindowImagesWidth.Dispose();
                    hv_WindowImagesHeight.Dispose();
                    hv_WindowBGColor.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_WindowImagesRow.Dispose();
                    hv_WindowImagesCol.Dispose();
                    hv_TiledParam.Dispose();
                    hv_Exception.Dispose();
                    hv_TiledParamNames.Dispose();
                    hv_TiledDefaultValues.Dispose();

                    return;
                }
                //
                //Separate handling for parameters that are specified by tuples.
                //
                //These model parameters are displayed in the text window if available.
                hv_StatusModelParamNames.Dispose();
                hv_StatusModelParamNames = new HTuple();
                hv_StatusModelParamNames[0] = "learning_rate";
                hv_StatusModelParamNames[1] = "batch_size";
                hv_StatusModelParamNames[2] = "batch_size_multiplier";
                hv_StatusModelParamNames[3] = "momentum";
                hv_StatusModelParamNames[4] = "weight_prior";
                hv_StatusModelParamNames[5] = "image_dimensions";
                hv_KeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_DisplayParam, "key_exists", "status_model_params",
                    out hv_KeyExists);
                if ((int)(hv_KeyExists.TupleNot()) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_DisplayParam, "status_model_params", hv_StatusModelParamNames);
                }
                //
                //
                //Setup and open text window.
                hv_WindowTextWidth.Dispose();
                hv_WindowTextWidth = 700;
                hv_WindowTextHeight.Dispose();
                hv_WindowTextHeight = 750;
                hv_WindowImagesWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowImagesWidth = 1200 - hv_WindowTextWidth;
                }
                hv_WindowImagesHeight.Dispose();
                hv_WindowImagesHeight = new HTuple(hv_WindowTextHeight);
                hv_WindowBGColor.Dispose();
                hv_WindowBGColor = "light gray";
                //
                HOperatorSet.SetWindowAttr("background_color", hv_WindowBGColor);
                HOperatorSet.OpenWindow(0, 0, hv_WindowTextWidth, hv_WindowTextHeight, 0, "visible", "", out hv_WindowHandleText);//显示信息窗口
                HDevWindowStack.Push(hv_WindowHandleText);
                set_display_font(hv_WindowHandleText, 16, "mono", "true", "false");
                HOperatorSet.SetDictTuple(hv_DisplayData, "window_text", hv_WindowHandleText);
                HOperatorSet.SetDictTuple(hv_DisplayData, "window_text_width", hv_WindowTextWidth);
                HOperatorSet.SetDictTuple(hv_DisplayData, "window_text_height", hv_WindowTextHeight);
                //
                //Configure images window, which is opened later by another procedure.
                hv_WindowImagesRow.Dispose();
                hv_WindowImagesRow = 0;
                hv_WindowImagesCol.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowImagesCol = hv_WindowTextWidth + 10;
                }
                HOperatorSet.SetDictTuple(hv_DisplayData, "window_images", new HTuple());
                //
                //Set user specified parameters used for the display of tiled images.
                try
                {
                    hv_TiledParam.Dispose();
                    HOperatorSet.GetDictTuple(hv_DisplayParam, "tiled_param", out hv_TiledParam);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    hv_TiledParam.Dispose();
                    HOperatorSet.CreateDict(out hv_TiledParam);
                    HOperatorSet.SetDictTuple(hv_DisplayParam, "tiled_param", hv_TiledParam);
                }
                //
                //Only set values if they are not already given.
                hv_TiledParamNames.Dispose();
                hv_TiledParamNames = new HTuple();
                hv_TiledParamNames[0] = "window_row";
                hv_TiledParamNames[1] = "window_col";
                hv_TiledParamNames[2] = "window_width";
                hv_TiledParamNames[3] = "window_height";
                hv_TiledDefaultValues.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TiledDefaultValues = new HTuple();
                    hv_TiledDefaultValues = hv_TiledDefaultValues.TupleConcat(hv_WindowImagesRow, hv_WindowImagesCol, hv_WindowImagesWidth, hv_WindowImagesHeight);
                }
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_TiledParamNames.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_KeyExists.Dispose();
                        HOperatorSet.GetDictParam(hv_TiledParam, "key_exists", hv_TiledParamNames.TupleSelect(
                            hv_Index), out hv_KeyExists);
                    }
                    if ((int)(hv_KeyExists.TupleNot()) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_TiledParam, hv_TiledParamNames.TupleSelect(
                                hv_Index), hv_TiledDefaultValues.TupleSelect(hv_Index));
                        }
                    }
                }
                //
                //Set specific display parameters for all available model types.
                if ((int)(new HTuple(hv_ModelType.TupleEqual("classification"))) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_TiledParam, "display_input", 0);
                    HOperatorSet.SetDictTuple(hv_TiledParam, "display_ground_truth", 0);
                    HOperatorSet.SetDictTuple(hv_TiledParam, "display_legend", 0);
                }
                //
                //
                //Start with loss plot since usually no evaluation is available in the beginning.
                HOperatorSet.SetDictTuple(hv_DisplayData, "last_change_plot", hv_Time);
                HOperatorSet.SetDictTuple(hv_DisplayData, "plot_eval", 0);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                //

                hv_ModelType.Dispose();
                hv_DisplayParam.Dispose();
                hv_DisplayEnabled.Dispose();
                hv_UpdateImagesIntervalEpochs.Dispose();
                hv_NumImagesPreview.Dispose();
                hv_ChangePlotIntervalSeconds.Dispose();
                hv_SelectedPercentageTrainSamples.Dispose();
                hv_XAxisLabel.Dispose();
                hv_DisplayParamNames.Dispose();
                hv_DisplayDefaultValues.Dispose();
                hv_Index.Dispose();
                hv_KeyExists.Dispose();
                hv_DisplayIntervalSeconds.Dispose();
                hv_Time.Dispose();
                hv_StatusModelParamNames.Dispose();
                hv_WindowTextWidth.Dispose();
                hv_WindowTextHeight.Dispose();
                hv_WindowImagesWidth.Dispose();
                hv_WindowImagesHeight.Dispose();
                hv_WindowBGColor.Dispose();
                hv_WindowHandleText.Dispose();
                hv_WindowImagesRow.Dispose();
                hv_WindowImagesCol.Dispose();
                hv_TiledParam.Dispose();
                hv_Exception.Dispose();
                hv_TiledParamNames.Dispose();
                hv_TiledDefaultValues.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ModelType.Dispose();
                hv_DisplayParam.Dispose();
                hv_DisplayEnabled.Dispose();
                hv_UpdateImagesIntervalEpochs.Dispose();
                hv_NumImagesPreview.Dispose();
                hv_ChangePlotIntervalSeconds.Dispose();
                hv_SelectedPercentageTrainSamples.Dispose();
                hv_XAxisLabel.Dispose();
                hv_DisplayParamNames.Dispose();
                hv_DisplayDefaultValues.Dispose();
                hv_Index.Dispose();
                hv_KeyExists.Dispose();
                hv_DisplayIntervalSeconds.Dispose();
                hv_Time.Dispose();
                hv_StatusModelParamNames.Dispose();
                hv_WindowTextWidth.Dispose();
                hv_WindowTextHeight.Dispose();
                hv_WindowImagesWidth.Dispose();
                hv_WindowImagesHeight.Dispose();
                hv_WindowBGColor.Dispose();
                hv_WindowHandleText.Dispose();
                hv_WindowImagesRow.Dispose();
                hv_WindowImagesCol.Dispose();
                hv_TiledParam.Dispose();
                hv_Exception.Dispose();
                hv_TiledParamNames.Dispose();
                hv_TiledDefaultValues.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: Display a color bar next to an image. 
        private void dev_display_map_color_bar(HTuple hv_ImageWidth, HTuple hv_ImageHeight,
            HTuple hv_MapColorBarWidth, HTuple hv_Colors, HTuple hv_MaxValue, HTuple hv_WindowImageRatio,
            HTuple hv_WindowHandle)
        {



            // Local iconic variables 

            HObject ho_Rectangle = null;

            // Local control variables 

            HTuple hv_ClipRegion = new HTuple(), hv_ColorIndex = new HTuple();
            HTuple hv_RectHeight = new HTuple(), hv_DrawMode = new HTuple();
            HTuple hv_Row = new HTuple(), hv_Row1 = new HTuple(), hv_Column1 = new HTuple();
            HTuple hv_Row2 = new HTuple(), hv_Column2 = new HTuple();
            HTuple hv__ = new HTuple(), hv_TextHeight = new HTuple();
            HTuple hv_Index = new HTuple(), hv_Text = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Rectangle);
            try
            {
                //
                //This procedure displays a color bar next to the image
                //specified with ImageWidth and ImageHeight.
                //
                hv_ClipRegion.Dispose();
                HOperatorSet.GetSystem("clip_region", out hv_ClipRegion);
                HOperatorSet.SetSystem("clip_region", "false");
                //
                //Display the color bar.
                hv_ColorIndex.Dispose();
                hv_ColorIndex = 0;
                hv_RectHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RectHeight = (1.0 * hv_ImageHeight) / (new HTuple(hv_Colors.TupleLength()
                        ));
                }
                //Set draw mode to fill
                hv_DrawMode.Dispose();
                HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
                }
                HTuple end_val13 = 0;
                HTuple step_val13 = -hv_RectHeight;
                for (hv_Row = hv_ImageHeight - 1; hv_Row.Continue(end_val13, step_val13); hv_Row = hv_Row.TupleAdd(step_val13))
                {
                    //The color bar consists of multiple rectangle1.
                    hv_Row1.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Row1 = hv_Row - hv_RectHeight;
                    }
                    hv_Column1.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Column1 = hv_ImageWidth + (20 / hv_WindowImageRatio);
                    }
                    hv_Row2.Dispose();
                    hv_Row2 = new HTuple(hv_Row);
                    hv_Column2.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Column2 = (hv_ImageWidth + 20) + (hv_MapColorBarWidth / hv_WindowImageRatio);
                    }
                    ho_Rectangle.Dispose();
                    HOperatorSet.GenRectangle1(out ho_Rectangle, hv_Row1, hv_Column1, hv_Row2,
                        hv_Column2);
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Colors.TupleSelect(
                                hv_ColorIndex));
                        }
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_Rectangle, HDevWindowStack.GetActive());
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ColorIndex = hv_ColorIndex + 1;
                            hv_ColorIndex.Dispose();
                            hv_ColorIndex = ExpTmpLocalVar_ColorIndex;
                        }
                    }
                }
                //
                //Display labels for color bar.
                hv__.Dispose(); hv__.Dispose(); hv__.Dispose(); hv_TextHeight.Dispose();
                HOperatorSet.GetStringExtents(hv_WindowHandle, "0123456789", out hv__, out hv__,
                    out hv__, out hv_TextHeight);
                for (hv_Index = (double)(0); (double)hv_Index <= 1; hv_Index = (double)hv_Index + 0.2)
                {
                    hv_Text.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Text = ((hv_MaxValue - (hv_Index * hv_MaxValue))).TupleString(
                            ".1f");
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "image", hv_Index * (hv_ImageHeight - (2 * (hv_TextHeight / hv_WindowImageRatio))),
                                hv_ImageWidth + (40 / hv_WindowImageRatio), "black", "box", "false");
                        }
                    }
                }
                //
                HOperatorSet.SetSystem("clip_region", hv_ClipRegion);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
                }
                ho_Rectangle.Dispose();

                hv_ClipRegion.Dispose();
                hv_ColorIndex.Dispose();
                hv_RectHeight.Dispose();
                hv_DrawMode.Dispose();
                hv_Row.Dispose();
                hv_Row1.Dispose();
                hv_Column1.Dispose();
                hv_Row2.Dispose();
                hv_Column2.Dispose();
                hv__.Dispose();
                hv_TextHeight.Dispose();
                hv_Index.Dispose();
                hv_Text.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Rectangle.Dispose();

                hv_ClipRegion.Dispose();
                hv_ColorIndex.Dispose();
                hv_RectHeight.Dispose();
                hv_DrawMode.Dispose();
                hv_Row.Dispose();
                hv_Row1.Dispose();
                hv_Column1.Dispose();
                hv_Row2.Dispose();
                hv_Column2.Dispose();
                hv__.Dispose();
                hv_TextHeight.Dispose();
                hv_Index.Dispose();
                hv_Text.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection
        // Short Description: Display the detected anomaly regions. 
        private void dev_display_result_anomaly_regions(HObject ho_AnomalyRegion, HTuple hv_CurrentWindowHandle,
            HTuple hv_LineWidth, HTuple hv_AnomalyRegionResultColor)
        {




            // Local iconic variables 

            // Local control variables 

            HTuple hv_Red = new HTuple(), hv_Green = new HTuple();
            HTuple hv_Blue = new HTuple(), hv_Alpha = new HTuple();
            HTuple hv_InitialColor = new HTuple(), hv_IndexColor = new HTuple();
            HTuple hv_Color_RGBA = new HTuple(), hv_Area = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure displays the result anomaly regions.
                //
                //Get current set color.
                hv_Red.Dispose(); hv_Green.Dispose(); hv_Blue.Dispose(); hv_Alpha.Dispose();
                HOperatorSet.GetRgba(hv_CurrentWindowHandle, out hv_Red, out hv_Green, out hv_Blue,
                    out hv_Alpha);
                hv_InitialColor.Dispose();
                hv_InitialColor = new HTuple();
                for (hv_IndexColor = 0; (int)hv_IndexColor <= (int)((new HTuple(hv_Red.TupleLength()
                    )) - 1); hv_IndexColor = (int)hv_IndexColor + 1)
                {
                    hv_Color_RGBA.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Color_RGBA = ((("#" + (((hv_Red.TupleSelect(
                            hv_IndexColor))).TupleString("2x"))) + (((hv_Green.TupleSelect(hv_IndexColor))).TupleString(
                            "2x"))) + (((hv_Blue.TupleSelect(hv_IndexColor))).TupleString("2x"))) + (((hv_Alpha.TupleSelect(
                            hv_IndexColor))).TupleString("2x"));
                    }
                    {
                        HTuple ExpTmpOutVar_0;
                        HOperatorSet.TupleRegexpReplace(hv_Color_RGBA, (new HTuple(" ")).TupleConcat(
                            "replace_all"), "0", out ExpTmpOutVar_0);
                        hv_Color_RGBA.Dispose();
                        hv_Color_RGBA = ExpTmpOutVar_0;
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_InitialColor = hv_InitialColor.TupleConcat(
                                hv_Color_RGBA);
                            hv_InitialColor.Dispose();
                            hv_InitialColor = ExpTmpLocalVar_InitialColor;
                        }
                    }
                }
                //
                //Display anomaly regions.
                //Get non-empty regions.
                hv_Area.Dispose();
                HOperatorSet.RegionFeatures(ho_AnomalyRegion, "area", out hv_Area);
                //
                //Display all non-empty class regions in distinct colors.
                if ((int)(new HTuple(hv_Area.TupleGreater(0))) != 0)
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_AnomalyRegionResultColor);
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidth);
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_AnomalyRegion, HDevWindowStack.GetActive());
                    }
                }
                //
                //Reset colors.
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_InitialColor);
                }
                //

                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();
                hv_Alpha.Dispose();
                hv_InitialColor.Dispose();
                hv_IndexColor.Dispose();
                hv_Color_RGBA.Dispose();
                hv_Area.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();
                hv_Alpha.Dispose();
                hv_InitialColor.Dispose();
                hv_IndexColor.Dispose();
                hv_Color_RGBA.Dispose();
                hv_Area.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: Display result bounding boxes. 
        private void dev_display_result_detection(HTuple hv_DLResult, HTuple hv_ResultKeys,
            HTuple hv_LineWidthBbox, HTuple hv_ClassIDs, HTuple hv_TextConf, HTuple hv_Colors,
            HTuple hv_BoxLabelColor, HTuple hv_WindowImageRatio, HTuple hv_TextPositionRow,
            HTuple hv_TextColor, HTuple hv_ShowLabels, HTuple hv_ShowDirection, HTuple hv_WindowHandle,
            out HTuple hv_BboxClassIndices)
        {



            // Local iconic variables 

            HObject ho_BboxRectangle = null, ho_OrientationArrows = null;
            HObject ho_RectangleSelected = null, ho_ArrowSelected = null;

            // Local control variables 

            HTuple hv_InstanceType = new HTuple(), hv_BboxRow1 = new HTuple();
            HTuple hv_BboxCol1 = new HTuple(), hv_BboxRow2 = new HTuple();
            HTuple hv_BboxCol2 = new HTuple(), hv_BboxClasses = new HTuple();
            HTuple hv_BboxRow = new HTuple(), hv_BboxCol = new HTuple();
            HTuple hv_BboxLength1 = new HTuple(), hv_BboxLength2 = new HTuple();
            HTuple hv_BboxPhi = new HTuple(), hv_Text = new HTuple();
            HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
            HTuple hv__ = new HTuple(), hv_TextOffset = new HTuple();
            HTuple hv_LabelRowTop = new HTuple(), hv_LabelRowBottom = new HTuple();
            HTuple hv_LabelCol = new HTuple(), hv_HeadSize = new HTuple();
            HTuple hv_ContourStyle = new HTuple(), hv_Style = new HTuple();
            HTuple hv_IndexBbox = new HTuple(), hv_ClassID = new HTuple();
            HTuple hv_LineWidth = new HTuple(), hv_TextColorClasses = new HTuple();
            HTuple hv_LabelRow = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_BboxRectangle);
            HOperatorSet.GenEmptyObj(out ho_OrientationArrows);
            HOperatorSet.GenEmptyObj(out ho_RectangleSelected);
            HOperatorSet.GenEmptyObj(out ho_ArrowSelected);
            hv_BboxClassIndices = new HTuple();
            try
            {
                //
                //This procedure displays the bounding boxes defined by DLResult.
                //The ClassIDs are necessary to display bounding boxes from the same class
                //always with the same color.
                //
                hv_InstanceType.Dispose();
                hv_InstanceType = "rectangle1";
                if ((int)(new HTuple(((hv_ResultKeys.TupleFind("bbox_row1"))).TupleNotEqual(
                    -1))) != 0)
                {
                    hv_BboxRow1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_row1", out hv_BboxRow1);
                    hv_BboxCol1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_col1", out hv_BboxCol1);
                    hv_BboxRow2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_row2", out hv_BboxRow2);
                    hv_BboxCol2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_col2", out hv_BboxCol2);
                    hv_BboxClasses.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_class_id", out hv_BboxClasses);
                }
                else if ((int)(new HTuple(((hv_ResultKeys.TupleFind("bbox_phi"))).TupleNotEqual(
                    -1))) != 0)
                {
                    hv_BboxRow.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_row", out hv_BboxRow);
                    hv_BboxCol.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_col", out hv_BboxCol);
                    hv_BboxLength1.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_length1", out hv_BboxLength1);
                    hv_BboxLength2.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_length2", out hv_BboxLength2);
                    hv_BboxPhi.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_phi", out hv_BboxPhi);
                    hv_BboxClasses.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "bbox_class_id", out hv_BboxClasses);
                    hv_InstanceType.Dispose();
                    hv_InstanceType = "rectangle2";
                }
                else
                {
                    throw new HalconException("Result bounding box data could not be found in DLResult.");
                }
                //
                if ((int)(new HTuple((new HTuple(hv_BboxClasses.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    //
                    //Get text and text size for correct positioning of result class IDs.
                    if ((int)(hv_ShowLabels) != 0)
                    {
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = hv_BboxClasses + hv_TextConf;
                        }
                        hv_Ascent.Dispose(); hv_Descent.Dispose(); hv__.Dispose(); hv__.Dispose();
                        HOperatorSet.GetStringExtents(hv_WindowHandle, hv_Text, out hv_Ascent,
                            out hv_Descent, out hv__, out hv__);
                        hv_TextOffset.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TextOffset = (hv_Ascent + hv_Descent) / hv_WindowImageRatio;
                        }
                    }
                    //
                    //Generate bounding box XLDs.
                    if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BboxPhi.Dispose();
                            HOperatorSet.TupleGenConst(new HTuple(hv_BboxRow1.TupleLength()), 0.0,
                                out hv_BboxPhi);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_BboxRectangle.Dispose();
                            HOperatorSet.GenRectangle2ContourXld(out ho_BboxRectangle, 0.5 * (hv_BboxRow1 + hv_BboxRow2),
                                0.5 * (hv_BboxCol1 + hv_BboxCol2), hv_BboxPhi, 0.5 * (hv_BboxCol2 - hv_BboxCol1),
                                0.5 * (hv_BboxRow2 - hv_BboxRow1));
                        }
                        if ((int)(hv_ShowLabels) != 0)
                        {
                            hv_LabelRowTop.Dispose();
                            hv_LabelRowTop = new HTuple(hv_BboxRow1);
                            hv_LabelRowBottom.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_LabelRowBottom = hv_BboxRow2 - hv_TextOffset;
                            }
                            hv_LabelCol.Dispose();
                            hv_LabelCol = new HTuple(hv_BboxCol1);
                        }
                    }
                    else
                    {
                        ho_BboxRectangle.Dispose();
                        HOperatorSet.GenRectangle2ContourXld(out ho_BboxRectangle, hv_BboxRow,
                            hv_BboxCol, hv_BboxPhi, hv_BboxLength1, hv_BboxLength2);
                        if ((int)(hv_ShowLabels) != 0)
                        {
                            hv_LabelRowTop.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_LabelRowTop = hv_BboxRow - hv_TextOffset;
                            }
                            hv_LabelRowBottom.Dispose();
                            hv_LabelRowBottom = new HTuple(hv_BboxRow);
                            hv_LabelCol.Dispose();
                            hv_LabelCol = new HTuple(hv_BboxCol);
                        }
                        if ((int)(hv_ShowDirection) != 0)
                        {
                            hv_HeadSize.Dispose();
                            hv_HeadSize = 20.0;
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_OrientationArrows.Dispose();
                                gen_arrow_contour_xld(out ho_OrientationArrows, hv_BboxRow, hv_BboxCol,
                                    hv_BboxRow - ((hv_BboxLength1 + hv_HeadSize) * (hv_BboxPhi.TupleSin())),
                                    hv_BboxCol + ((hv_BboxLength1 + hv_HeadSize) * (hv_BboxPhi.TupleCos())),
                                    hv_HeadSize, hv_HeadSize);
                            }
                        }
                    }
                    //
                    hv_ContourStyle.Dispose();
                    HOperatorSet.GetContourStyle(hv_WindowHandle, out hv_ContourStyle);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetContourStyle(HDevWindowStack.GetActive(), "stroke");
                    }
                    hv_Style.Dispose();
                    HOperatorSet.GetLineStyle(hv_WindowHandle, out hv_Style);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidthBbox);
                    }
                    //
                    //Collect ClassIDs of the bounding boxes.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BboxClassIndices.Dispose();
                        HOperatorSet.TupleGenConst(new HTuple(hv_BboxClasses.TupleLength()), 0, out hv_BboxClassIndices);
                    }
                    //
                    //Draw bounding boxes.
                    for (hv_IndexBbox = 0; (int)hv_IndexBbox <= (int)((new HTuple(hv_BboxClasses.TupleLength()
                        )) - 1); hv_IndexBbox = (int)hv_IndexBbox + 1)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_RectangleSelected.Dispose();
                            HOperatorSet.SelectObj(ho_BboxRectangle, out ho_RectangleSelected, hv_IndexBbox + 1);
                        }
                        hv_ClassID.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClassID = hv_ClassIDs.TupleFind(
                                hv_BboxClasses.TupleSelect(hv_IndexBbox));
                        }
                        if (hv_BboxClassIndices == null)
                            hv_BboxClassIndices = new HTuple();
                        hv_BboxClassIndices[hv_IndexBbox] = hv_ClassID;
                        hv_LineWidth.Dispose();
                        HOperatorSet.GetLineWidth(hv_WindowHandle, out hv_LineWidth);
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), ((hv_LineWidth + 2)).TupleInt()
                                    );
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetColor(HDevWindowStack.GetActive(), "black");
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_RectangleSelected, HDevWindowStack.GetActive()
                                );
                        }
                        if ((int)((new HTuple(hv_InstanceType.TupleEqual("rectangle2"))).TupleAnd(
                            hv_ShowDirection)) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_ArrowSelected.Dispose();
                                HOperatorSet.SelectObj(ho_OrientationArrows, out ho_ArrowSelected, hv_IndexBbox + 1);
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_ArrowSelected, HDevWindowStack.GetActive());
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidth.TupleInt()
                                    );
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Colors.TupleSelect(
                                    hv_ClassID));
                            }
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_RectangleSelected, HDevWindowStack.GetActive()
                                );
                        }
                        if ((int)((new HTuple(hv_InstanceType.TupleEqual("rectangle2"))).TupleAnd(
                            hv_ShowDirection)) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_ArrowSelected, HDevWindowStack.GetActive());
                            }
                        }
                    }
                    //
                    //Draw text of bounding boxes.
                    if ((int)(hv_ShowLabels) != 0)
                    {
                        //For better visibility the text is displayed after all bounding boxes are drawn.
                        //Get text and text size for correct positioning of result class IDs.
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = hv_BboxClasses + hv_TextConf;
                        }
                        //Select text color.
                        if ((int)(new HTuple(hv_TextColor.TupleEqual(""))) != 0)
                        {
                            hv_TextColorClasses.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TextColorClasses = hv_Colors.TupleSelect(
                                    hv_BboxClassIndices);
                            }
                        }
                        else
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TextColorClasses.Dispose();
                                HOperatorSet.TupleGenConst(new HTuple(hv_BboxClassIndices.TupleLength()
                                    ), hv_TextColor, out hv_TextColorClasses);
                            }
                        }
                        //Select correct position of the text.
                        hv_LabelRow.Dispose();
                        hv_LabelRow = new HTuple(hv_LabelRowTop);
                        if ((int)(new HTuple(hv_TextPositionRow.TupleEqual("bottom"))) != 0)
                        {
                            hv_LabelRow.Dispose();
                            hv_LabelRow = new HTuple(hv_LabelRowBottom);
                        }
                        //Display text.
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "image",
                                    hv_LabelRow, hv_LabelCol, hv_TextColorClasses, ((new HTuple("box_color")).TupleConcat(
                                    "shadow")).TupleConcat("border_radius"), hv_BoxLabelColor.TupleConcat(
                                    (new HTuple("false")).TupleConcat(0)));
                            }
                        }
                    }
                    //
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetContourStyle(HDevWindowStack.GetActive(), hv_ContourStyle);
                    }
                    HOperatorSet.SetLineStyle(hv_WindowHandle, hv_Style);
                }
                else
                {
                    //Do nothing if no results are present.
                    hv_BboxClassIndices.Dispose();
                    hv_BboxClassIndices = new HTuple();
                }
                //
                ho_BboxRectangle.Dispose();
                ho_OrientationArrows.Dispose();
                ho_RectangleSelected.Dispose();
                ho_ArrowSelected.Dispose();

                hv_InstanceType.Dispose();
                hv_BboxRow1.Dispose();
                hv_BboxCol1.Dispose();
                hv_BboxRow2.Dispose();
                hv_BboxCol2.Dispose();
                hv_BboxClasses.Dispose();
                hv_BboxRow.Dispose();
                hv_BboxCol.Dispose();
                hv_BboxLength1.Dispose();
                hv_BboxLength2.Dispose();
                hv_BboxPhi.Dispose();
                hv_Text.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv__.Dispose();
                hv_TextOffset.Dispose();
                hv_LabelRowTop.Dispose();
                hv_LabelRowBottom.Dispose();
                hv_LabelCol.Dispose();
                hv_HeadSize.Dispose();
                hv_ContourStyle.Dispose();
                hv_Style.Dispose();
                hv_IndexBbox.Dispose();
                hv_ClassID.Dispose();
                hv_LineWidth.Dispose();
                hv_TextColorClasses.Dispose();
                hv_LabelRow.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_BboxRectangle.Dispose();
                ho_OrientationArrows.Dispose();
                ho_RectangleSelected.Dispose();
                ho_ArrowSelected.Dispose();

                hv_InstanceType.Dispose();
                hv_BboxRow1.Dispose();
                hv_BboxCol1.Dispose();
                hv_BboxRow2.Dispose();
                hv_BboxCol2.Dispose();
                hv_BboxClasses.Dispose();
                hv_BboxRow.Dispose();
                hv_BboxCol.Dispose();
                hv_BboxLength1.Dispose();
                hv_BboxLength2.Dispose();
                hv_BboxPhi.Dispose();
                hv_Text.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv__.Dispose();
                hv_TextOffset.Dispose();
                hv_LabelRowTop.Dispose();
                hv_LabelRowBottom.Dispose();
                hv_LabelCol.Dispose();
                hv_HeadSize.Dispose();
                hv_ContourStyle.Dispose();
                hv_Style.Dispose();
                hv_IndexBbox.Dispose();
                hv_ClassID.Dispose();
                hv_LineWidth.Dispose();
                hv_TextColorClasses.Dispose();
                hv_LabelRow.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: Display the ground truth/result segmentation as regions. 
        private void dev_display_segmentation_regions(HObject ho_SegmentationImage, HTuple hv_ClassIDs,
            HTuple hv_ColorsSegmentation, HTuple hv_ExcludeClassIDs, out HTuple hv_ImageClassIDs)
        {




            // Local iconic variables 

            HObject ho_Regions, ho_SelectedRegion = null;

            // Local control variables 

            HTuple hv_IncludedClassIDs = new HTuple();
            HTuple hv_Area = new HTuple(), hv_Index = new HTuple();
            HTuple hv_ClassID = new HTuple(), hv_IndexColor = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Regions);
            HOperatorSet.GenEmptyObj(out ho_SelectedRegion);
            hv_ImageClassIDs = new HTuple();
            try
            {
                //
                //This procedure displays the ground truth/result segmentation
                //given in SegmentationImage as regions. The ClassIDs are necessary to
                //display ground truth/result segmentations from the same class
                //always with the same color. It is possible to exclude certain ClassIDs
                //from being displayed. The displayed classes are returned in ImageClassIDs.
                //
                //
                //Remove excluded class IDs from the list.
                hv_IncludedClassIDs.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_IncludedClassIDs = hv_ClassIDs.TupleDifference(
                        hv_ExcludeClassIDs);
                }
                //
                //Get a region for each class ID.
                ho_Regions.Dispose();
                HOperatorSet.Threshold(ho_SegmentationImage, out ho_Regions, hv_IncludedClassIDs,
                    hv_IncludedClassIDs);
                //
                //Get classes with non-empty regions.
                hv_Area.Dispose();
                HOperatorSet.RegionFeatures(ho_Regions, "area", out hv_Area);
                hv_ImageClassIDs.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ImageClassIDs = hv_IncludedClassIDs.TupleSelectMask(
                        hv_Area.TupleGreaterElem(0));
                }
                //
                //Display all non-empty class regions in distinct colors.
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_IncludedClassIDs.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    if ((int)(new HTuple(((hv_Area.TupleSelect(hv_Index))).TupleGreater(0))) != 0)
                    {
                        //Use class ID to determine region color.
                        hv_ClassID.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClassID = hv_IncludedClassIDs.TupleSelect(
                                hv_Index);
                        }
                        hv_IndexColor.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_IndexColor = hv_ClassIDs.TupleFindFirst(
                                hv_ClassID);
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_ColorsSegmentation.TupleSelect(
                                    hv_IndexColor));
                            }
                        }
                        //Display the segmentation region.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_SelectedRegion.Dispose();
                            HOperatorSet.SelectObj(ho_Regions, out ho_SelectedRegion, hv_Index + 1);
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_SelectedRegion, HDevWindowStack.GetActive());
                        }
                    }
                }
                ho_Regions.Dispose();
                ho_SelectedRegion.Dispose();

                hv_IncludedClassIDs.Dispose();
                hv_Area.Dispose();
                hv_Index.Dispose();
                hv_ClassID.Dispose();
                hv_IndexColor.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Regions.Dispose();
                ho_SelectedRegion.Dispose();

                hv_IncludedClassIDs.Dispose();
                hv_Area.Dispose();
                hv_Index.Dispose();
                hv_ClassID.Dispose();
                hv_IndexColor.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Display a legend according to the generic parameters. 
        private void dev_display_tiled_legend(HTuple hv_WindowImages, HTuple hv_GenParam)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_DisplayLegend = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_LegendText = new HTuple(), hv_Flag = new HTuple();
            HTuple hv_PosTexts = new HTuple(), hv_Text = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure displays a legend of dev_display_dl_data_tiled
                //according to the generic parameters.
                //
                try
                {
                    hv_DisplayLegend.Dispose();
                    HOperatorSet.GetDictTuple(hv_GenParam, "display_legend", out hv_DisplayLegend);
                    if ((int)(hv_DisplayLegend.TupleNot()) != 0)
                    {

                        hv_DisplayLegend.Dispose();
                        hv_Exception.Dispose();
                        hv_LegendText.Dispose();
                        hv_Flag.Dispose();
                        hv_PosTexts.Dispose();
                        hv_Text.Dispose();

                        return;
                    }
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                }
                //
                hv_LegendText.Dispose();
                hv_LegendText = new HTuple();
                try
                {
                    hv_Flag.Dispose();
                    HOperatorSet.GetDictTuple(hv_GenParam, "display_input", out hv_Flag);
                    if ((int)(hv_Flag) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_LegendText = hv_LegendText.TupleConcat(
                                    "input");
                                hv_LegendText.Dispose();
                                hv_LegendText = ExpTmpLocalVar_LegendText;
                            }
                        }
                    }
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_LegendText = hv_LegendText.TupleConcat(
                                "input");
                            hv_LegendText.Dispose();
                            hv_LegendText = ExpTmpLocalVar_LegendText;
                        }
                    }
                }
                try
                {
                    hv_Flag.Dispose();
                    HOperatorSet.GetDictTuple(hv_GenParam, "display_ground_truth", out hv_Flag);
                    if ((int)(hv_Flag) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_LegendText = hv_LegendText.TupleConcat(
                                    "ground truth");
                                hv_LegendText.Dispose();
                                hv_LegendText = ExpTmpLocalVar_LegendText;
                            }
                        }
                    }
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_LegendText = hv_LegendText.TupleConcat(
                                "ground truth");
                            hv_LegendText.Dispose();
                            hv_LegendText = ExpTmpLocalVar_LegendText;
                        }
                    }
                }
                try
                {
                    hv_Flag.Dispose();
                    HOperatorSet.GetDictTuple(hv_GenParam, "display_result", out hv_Flag);
                    if ((int)(hv_Flag) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_LegendText = hv_LegendText.TupleConcat(
                                    "result");
                                hv_LegendText.Dispose();
                                hv_LegendText = ExpTmpLocalVar_LegendText;
                            }
                        }
                    }
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_LegendText = hv_LegendText.TupleConcat(
                                "result");
                            hv_LegendText.Dispose();
                            hv_LegendText = ExpTmpLocalVar_LegendText;
                        }
                    }
                }
                if ((int)(new HTuple((new HTuple(hv_LegendText.TupleLength())).TupleEqual(3))) != 0)
                {
                    hv_PosTexts.Dispose();
                    hv_PosTexts = new HTuple();
                    hv_PosTexts[0] = "Top:    ";
                    hv_PosTexts[1] = "Center: ";
                    hv_PosTexts[2] = "Bottom: ";
                }
                else if ((int)(new HTuple((new HTuple(hv_LegendText.TupleLength())).TupleEqual(
                    2))) != 0)
                {
                    hv_PosTexts.Dispose();
                    hv_PosTexts = new HTuple();
                    hv_PosTexts[0] = "Top:    ";
                    hv_PosTexts[1] = "Bottom: ";
                }
                else
                {
                    hv_PosTexts.Dispose();
                    hv_PosTexts = "";
                }
                HDevWindowStack.SetActive(hv_WindowImages);
                hv_Text.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Text = hv_PosTexts + hv_LegendText;
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "right", "black", new HTuple(), new HTuple());
                }

                hv_DisplayLegend.Dispose();
                hv_Exception.Dispose();
                hv_LegendText.Dispose();
                hv_Flag.Dispose();
                hv_PosTexts.Dispose();
                hv_Text.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_DisplayLegend.Dispose();
                hv_Exception.Dispose();
                hv_LegendText.Dispose();
                hv_Flag.Dispose();
                hv_PosTexts.Dispose();
                hv_Text.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection
        // Short Description: Display information about the training of an anomaly detection model. 
        private void dev_display_train_info_anomaly_detection(HTuple hv_TrainParam, out HTuple hv_WindowHandleInfo)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_DisplayParam = new HTuple(), hv_DisplayEnabled = new HTuple();
            HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
            HTuple hv_WindowBGColor = new HTuple(), hv_TrainParamAnomaly = new HTuple();
            HTuple hv_DomainRatio = new HTuple(), hv_ErrorThreshold = new HTuple();
            HTuple hv_RegularizationNoise = new HTuple(), hv_MaxNumEpochs = new HTuple();
            HTuple hv_TrainInformationLeft = new HTuple(), hv_TrainInformationRight = new HTuple();
            // Initialize local and output iconic variables 
            hv_WindowHandleInfo = new HTuple();
            try
            {
                //
                //This procedure displays information about the training parameters of an anomaly detection model.
                //
                //Initialize display data.
                hv_DisplayParam.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainParam, "display_param", out hv_DisplayParam);
                hv_DisplayEnabled.Dispose();
                HOperatorSet.GetDictTuple(hv_DisplayParam, "enabled", out hv_DisplayEnabled);
                //
                if ((int)(hv_DisplayEnabled.TupleNot()) != 0)
                {

                    hv_DisplayParam.Dispose();
                    hv_DisplayEnabled.Dispose();
                    hv_WindowWidth.Dispose();
                    hv_WindowHeight.Dispose();
                    hv_WindowBGColor.Dispose();
                    hv_TrainParamAnomaly.Dispose();
                    hv_DomainRatio.Dispose();
                    hv_ErrorThreshold.Dispose();
                    hv_RegularizationNoise.Dispose();
                    hv_MaxNumEpochs.Dispose();
                    hv_TrainInformationLeft.Dispose();
                    hv_TrainInformationRight.Dispose();

                    return;
                }
                //
                hv_WindowWidth.Dispose();
                hv_WindowWidth = 500;
                hv_WindowHeight.Dispose();
                hv_WindowHeight = 200;
                hv_WindowBGColor.Dispose();
                hv_WindowBGColor = "light gray";
                //
                //Open and setup text window.
                HOperatorSet.SetWindowAttr("background_color", hv_WindowBGColor);
                HOperatorSet.OpenWindow(0, 0, hv_WindowWidth, hv_WindowHeight, 0, "visible", "", out hv_WindowHandleInfo);
                HDevWindowStack.Push(hv_WindowHandleInfo);
                set_display_font(hv_WindowHandleInfo, 16, "mono", "true", "false");
                HDevWindowStack.SetActive(hv_WindowHandleInfo);
                //
                //Display information.
                hv_TrainParamAnomaly.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainParam, "anomaly_param", out hv_TrainParamAnomaly);
                hv_DomainRatio.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainParamAnomaly, "domain_ratio", out hv_DomainRatio);
                hv_ErrorThreshold.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainParamAnomaly, "error_threshold", out hv_ErrorThreshold);
                hv_RegularizationNoise.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainParamAnomaly, "regularization_noise", out hv_RegularizationNoise);
                hv_MaxNumEpochs.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainParamAnomaly, "max_num_epochs", out hv_MaxNumEpochs);
                hv_TrainInformationLeft.Dispose();
                hv_TrainInformationLeft = new HTuple();
                hv_TrainInformationLeft[0] = "Training anomaly detection model.";
                hv_TrainInformationLeft[1] = "";
                hv_TrainInformationLeft[2] = "Max. number of epochs:";
                hv_TrainInformationLeft[3] = "Domain ratio:";
                hv_TrainInformationLeft[4] = "Error threshold:";
                hv_TrainInformationLeft[5] = "Regularization noise:";
                hv_TrainInformationLeft[6] = "";
                hv_TrainInformationLeft[7] = "This may take some time...";
                hv_TrainInformationRight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TrainInformationRight = new HTuple();
                    hv_TrainInformationRight[0] = "";
                    hv_TrainInformationRight[1] = "";
                    hv_TrainInformationRight = hv_TrainInformationRight.TupleConcat(hv_MaxNumEpochs);
                    hv_TrainInformationRight = hv_TrainInformationRight.TupleConcat(hv_DomainRatio.TupleString(
                        ".4f"));
                    hv_TrainInformationRight = hv_TrainInformationRight.TupleConcat(hv_ErrorThreshold.TupleString(
                        ".4f"));
                    hv_TrainInformationRight = hv_TrainInformationRight.TupleConcat(hv_RegularizationNoise.TupleString(
                        ".4f"));
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_TrainInformationLeft,
                        "window", "top", "left", "black", "box", "false");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_TrainInformationRight,
                        "window", "top", "right", "black", "box", "false");
                }
                //

                hv_DisplayParam.Dispose();
                hv_DisplayEnabled.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_WindowBGColor.Dispose();
                hv_TrainParamAnomaly.Dispose();
                hv_DomainRatio.Dispose();
                hv_ErrorThreshold.Dispose();
                hv_RegularizationNoise.Dispose();
                hv_MaxNumEpochs.Dispose();
                hv_TrainInformationLeft.Dispose();
                hv_TrainInformationRight.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_DisplayParam.Dispose();
                hv_DisplayEnabled.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_WindowBGColor.Dispose();
                hv_TrainParamAnomaly.Dispose();
                hv_DomainRatio.Dispose();
                hv_ErrorThreshold.Dispose();
                hv_RegularizationNoise.Dispose();
                hv_MaxNumEpochs.Dispose();
                hv_TrainInformationLeft.Dispose();
                hv_TrainInformationRight.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Update the various texts and plots during training. 
        private void dev_display_update_train_dl_model(HTuple hv_TrainParam, HTuple hv_DisplayData,
            HTuple hv_TrainInfo, HTuple hv_Epochs, HTuple hv_Loss, HTuple hv_LearningRate,
            HTuple hv_EvalEpochs, HTuple hv_EvalValues, HTuple hv_EvalValuesTrain)
        {



            // Local iconic variables 

            HObject ho_PlotBackground;

            // Local control variables 

            HTuple hv_DisplayEnabled = new HTuple();
            HTuple hv_DisplayParam = new HTuple(), hv_WindowText = new HTuple();
            HTuple hv_WindowHandle = new HTuple(), hv_ChangePlotIntervalSeconds = new HTuple();
            HTuple hv_LastChange = new HTuple(), hv_Seconds = new HTuple();
            HTuple hv_PlotEval = new HTuple(), hv_PlotFunctionExists = new HTuple();
            HTuple hv_PlotFunction = new HTuple(), hv_TextPlot = new HTuple();
            HTuple hv_PlotTrainEval = new HTuple(), hv_HeadlineText = new HTuple();
            HTuple hv_Indices = new HTuple(), hv_Index = new HTuple();
            HTuple hv_PartRow1 = new HTuple(), hv_PartColumn1 = new HTuple();
            HTuple hv_PartRow2 = new HTuple(), hv_PartColumn2 = new HTuple();
            HTuple hv__ = new HTuple(), hv_Width = new HTuple(), hv_Height = new HTuple();
            HTuple hv_ClipRegionValue = new HTuple(), hv_PlotHeight = new HTuple();
            HTuple hv_LegendRow = new HTuple(), hv_LegendDistanceLeft = new HTuple();
            HTuple hv_LegendDistanceRight = new HTuple(), hv_PlotLearningRateStrategy = new HTuple();
            HTuple hv_RightMargin = new HTuple(), hv_ChangeStrategies = new HTuple();
            HTuple hv_Idx = new HTuple(), hv_ChangeStrategy = new HTuple();
            HTuple hv_ChangeStrategyName = new HTuple(), hv_ChangeStrategiesValues = new HTuple();
            HTuple hv_ChangeStrategiesInitial = new HTuple(), hv_StrategyMin = new HTuple();
            HTuple hv_StrategyMax = new HTuple(), hv_LogLRMin = new HTuple();
            HTuple hv_LogLRMax = new HTuple(), hv_LRScale = new HTuple();
            HTuple hv_LROffset = new HTuple(), hv_LogLROffset = new HTuple();
            HTuple hv_StartYLearningRate = new HTuple(), hv_EndYLearningRate = new HTuple();
            HTuple hv_TicksYLearningRate = new HTuple(), hv_LogYLearningRate = new HTuple();
            HTuple hv_LRColor = new HTuple(), hv_LRLineWidth = new HTuple();
            HTuple hv_LRTextLegend = new HTuple(), hv_TopMarginPlots = new HTuple();
            HTuple hv_NumIterationsPerEpoch = new HTuple(), hv_Iterations = new HTuple();
            HTuple hv_NumEpochs = new HTuple(), hv_NumIterations = new HTuple();
            HTuple hv_CurrentIteration = new HTuple(), hv_XAxisLabel = new HTuple();
            HTuple hv_ValuesX = new HTuple(), hv_TicksX = new HTuple();
            HTuple hv_EvalValuesX = new HTuple(), hv_EvalTicksX = new HTuple();
            HTuple hv_TitleX = new HTuple(), hv_EvalIterations = new HTuple();
            HTuple hv_EvalValuesMin = new HTuple(), hv_EvalValuesMax = new HTuple();
            HTuple hv_TicksY = new HTuple(), hv_StartY = new HTuple();
            HTuple hv_EndY = new HTuple(), hv_YAxisLabel = new HTuple();
            HTuple hv_BestEvaluationData = new HTuple(), hv_BestEvaluationComparisonKeys = new HTuple();
            HTuple hv_StringExtendsLegendRight = new HTuple(), hv_Bullet = new HTuple();
            HTuple hv_Line = new HTuple(), hv_YAxisTitle = new HTuple();
            HTuple hv_Offset = new HTuple(), hv_LogMin = new HTuple();
            HTuple hv_LogMax = new HTuple(), hv_Scale = new HTuple();
            HTuple hv_LogOffset = new HTuple(), hv_LogY = new HTuple();
            HTuple hv_TextModelParams = new HTuple(), hv_ModelParams = new HTuple();
            HTuple hv_StatusModelParamsLeft = new HTuple(), hv_StatusModelParamsRight = new HTuple();
            HTuple hv_ParName = new HTuple(), hv_Tuple = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_TupleStr = new HTuple();
            HTuple hv_StatusEvaluationLeft = new HTuple(), hv_StatusEvaluationRight = new HTuple();
            HTuple hv_BestEvaluationValue = new HTuple(), hv_BestEvaluationInfo = new HTuple();
            HTuple hv_BestEvaluationEpoch = new HTuple(), hv_BestTrainEvaluationValue = new HTuple();
            HTuple hv_BestTrainEvaluationInfo = new HTuple(), hv_BestTrainEvaluationEpoch = new HTuple();
            HTuple hv_BestEvaluationComparisonKeysStr = new HTuple();
            HTuple hv_StatusTrainLeft = new HTuple(), hv_StatusTrainRight = new HTuple();
            HTuple hv_EpochReal = new HTuple(), hv_MeanLoss = new HTuple();
            HTuple hv_MeanLossStr = new HTuple(), hv_TimeElapsedExists = new HTuple();
            HTuple hv_StartEpoch = new HTuple(), hv_StartTime = new HTuple();
            HTuple hv_SecondsElapsed = new HTuple(), hv_SecondsRemaining = new HTuple();
            HTuple hv_ProgressPercent = new HTuple(), hv_ProgressPerSecond = new HTuple();
            HTuple hv_TimeElapsedString = new HTuple(), hv_TimeRemainingString = new HTuple();
            HTuple hv_StatusDeviceLeft = new HTuple(), hv_StatusDeviceRight = new HTuple();
            HTuple hv_DeviceNameExists = new HTuple(), hv_DeviceName = new HTuple();
            HTuple hv_StatusLeft = new HTuple(), hv_StatusRight = new HTuple();
            HTuple hv_MaxChars = new HTuple(), hv_Str = new HTuple();
            HTuple hv_IsString = new HTuple(), hv_Length = new HTuple();
            HTuple hv_SubStr = new HTuple(), hv_Row1 = new HTuple();
            HTuple hv_Column1 = new HTuple(), hv_Row2 = new HTuple();
            HTuple hv_Column2 = new HTuple(), hv_WindowTextWidth = new HTuple();
            HTuple hv_WindowTextHeight = new HTuple();
            HTuple hv_EvalValuesTrain_COPY_INP_TMP = new HTuple(hv_EvalValuesTrain);

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_PlotBackground);
            try
            {
                //
                //This procedure updates the various texts and plots.
                //It uses precomputed information (TrainInfo, EvaluationInfos,...).
                //
                hv_DisplayEnabled.Dispose();
                HOperatorSet.GetDictTuple(hv_DisplayData, "enabled", out hv_DisplayEnabled);
                if ((int)(hv_DisplayEnabled.TupleNot()) != 0)
                {
                    ho_PlotBackground.Dispose();

                    hv_EvalValuesTrain_COPY_INP_TMP.Dispose();
                    hv_DisplayEnabled.Dispose();
                    hv_DisplayParam.Dispose();
                    hv_WindowText.Dispose();
                    hv_WindowHandle.Dispose();
                    hv_ChangePlotIntervalSeconds.Dispose();
                    hv_LastChange.Dispose();
                    hv_Seconds.Dispose();
                    hv_PlotEval.Dispose();
                    hv_PlotFunctionExists.Dispose();
                    hv_PlotFunction.Dispose();
                    hv_TextPlot.Dispose();
                    hv_PlotTrainEval.Dispose();
                    hv_HeadlineText.Dispose();
                    hv_Indices.Dispose();
                    hv_Index.Dispose();
                    hv_PartRow1.Dispose();
                    hv_PartColumn1.Dispose();
                    hv_PartRow2.Dispose();
                    hv_PartColumn2.Dispose();
                    hv__.Dispose();
                    hv_Width.Dispose();
                    hv_Height.Dispose();
                    hv_ClipRegionValue.Dispose();
                    hv_PlotHeight.Dispose();
                    hv_LegendRow.Dispose();
                    hv_LegendDistanceLeft.Dispose();
                    hv_LegendDistanceRight.Dispose();
                    hv_PlotLearningRateStrategy.Dispose();
                    hv_RightMargin.Dispose();
                    hv_ChangeStrategies.Dispose();
                    hv_Idx.Dispose();
                    hv_ChangeStrategy.Dispose();
                    hv_ChangeStrategyName.Dispose();
                    hv_ChangeStrategiesValues.Dispose();
                    hv_ChangeStrategiesInitial.Dispose();
                    hv_StrategyMin.Dispose();
                    hv_StrategyMax.Dispose();
                    hv_LogLRMin.Dispose();
                    hv_LogLRMax.Dispose();
                    hv_LRScale.Dispose();
                    hv_LROffset.Dispose();
                    hv_LogLROffset.Dispose();
                    hv_StartYLearningRate.Dispose();
                    hv_EndYLearningRate.Dispose();
                    hv_TicksYLearningRate.Dispose();
                    hv_LogYLearningRate.Dispose();
                    hv_LRColor.Dispose();
                    hv_LRLineWidth.Dispose();
                    hv_LRTextLegend.Dispose();
                    hv_TopMarginPlots.Dispose();
                    hv_NumIterationsPerEpoch.Dispose();
                    hv_Iterations.Dispose();
                    hv_NumEpochs.Dispose();
                    hv_NumIterations.Dispose();
                    hv_CurrentIteration.Dispose();
                    hv_XAxisLabel.Dispose();
                    hv_ValuesX.Dispose();
                    hv_TicksX.Dispose();
                    hv_EvalValuesX.Dispose();
                    hv_EvalTicksX.Dispose();
                    hv_TitleX.Dispose();
                    hv_EvalIterations.Dispose();
                    hv_EvalValuesMin.Dispose();
                    hv_EvalValuesMax.Dispose();
                    hv_TicksY.Dispose();
                    hv_StartY.Dispose();
                    hv_EndY.Dispose();
                    hv_YAxisLabel.Dispose();
                    hv_BestEvaluationData.Dispose();
                    hv_BestEvaluationComparisonKeys.Dispose();
                    hv_StringExtendsLegendRight.Dispose();
                    hv_Bullet.Dispose();
                    hv_Line.Dispose();
                    hv_YAxisTitle.Dispose();
                    hv_Offset.Dispose();
                    hv_LogMin.Dispose();
                    hv_LogMax.Dispose();
                    hv_Scale.Dispose();
                    hv_LogOffset.Dispose();
                    hv_LogY.Dispose();
                    hv_TextModelParams.Dispose();
                    hv_ModelParams.Dispose();
                    hv_StatusModelParamsLeft.Dispose();
                    hv_StatusModelParamsRight.Dispose();
                    hv_ParName.Dispose();
                    hv_Tuple.Dispose();
                    hv_Exception.Dispose();
                    hv_TupleStr.Dispose();
                    hv_StatusEvaluationLeft.Dispose();
                    hv_StatusEvaluationRight.Dispose();
                    hv_BestEvaluationValue.Dispose();
                    hv_BestEvaluationInfo.Dispose();
                    hv_BestEvaluationEpoch.Dispose();
                    hv_BestTrainEvaluationValue.Dispose();
                    hv_BestTrainEvaluationInfo.Dispose();
                    hv_BestTrainEvaluationEpoch.Dispose();
                    hv_BestEvaluationComparisonKeysStr.Dispose();
                    hv_StatusTrainLeft.Dispose();
                    hv_StatusTrainRight.Dispose();
                    hv_EpochReal.Dispose();
                    hv_MeanLoss.Dispose();
                    hv_MeanLossStr.Dispose();
                    hv_TimeElapsedExists.Dispose();
                    hv_StartEpoch.Dispose();
                    hv_StartTime.Dispose();
                    hv_SecondsElapsed.Dispose();
                    hv_SecondsRemaining.Dispose();
                    hv_ProgressPercent.Dispose();
                    hv_ProgressPerSecond.Dispose();
                    hv_TimeElapsedString.Dispose();
                    hv_TimeRemainingString.Dispose();
                    hv_StatusDeviceLeft.Dispose();
                    hv_StatusDeviceRight.Dispose();
                    hv_DeviceNameExists.Dispose();
                    hv_DeviceName.Dispose();
                    hv_StatusLeft.Dispose();
                    hv_StatusRight.Dispose();
                    hv_MaxChars.Dispose();
                    hv_Str.Dispose();
                    hv_IsString.Dispose();
                    hv_Length.Dispose();
                    hv_SubStr.Dispose();
                    hv_Row1.Dispose();
                    hv_Column1.Dispose();
                    hv_Row2.Dispose();
                    hv_Column2.Dispose();
                    hv_WindowTextWidth.Dispose();
                    hv_WindowTextHeight.Dispose();

                    return;
                }
                //
                hv_DisplayParam.Dispose();
                HOperatorSet.GetDictTuple(hv_DisplayData, "display_param", out hv_DisplayParam);
                //
                hv_WindowText.Dispose();
                HOperatorSet.GetDictTuple(hv_DisplayData, "window_text", out hv_WindowText);
                HOperatorSet.SetWindowParam(hv_WindowText, "flush", "false");
                //Only switch to window if the current window is not the text window (performance).
                if (HDevWindowStack.IsOpen())
                {
                    hv_WindowHandle = HDevWindowStack.GetActive();
                }
                if ((int)(new HTuple(hv_WindowHandle.TupleNotEqual(hv_WindowText))) != 0)
                {
                    HDevWindowStack.SetActive(hv_WindowText);
                    hv_WindowHandle.Dispose();
                    hv_WindowHandle = new HTuple(hv_WindowText);
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                }
                //
                hv_ChangePlotIntervalSeconds.Dispose();
                HOperatorSet.GetDictTuple(hv_DisplayParam, "change_plot_interval_seconds",
                    out hv_ChangePlotIntervalSeconds);
                hv_LastChange.Dispose();
                HOperatorSet.GetDictTuple(hv_DisplayData, "last_change_plot", out hv_LastChange);
                hv_Seconds.Dispose();
                HOperatorSet.CountSeconds(out hv_Seconds);
                hv_PlotEval.Dispose();
                HOperatorSet.GetDictTuple(hv_DisplayData, "plot_eval", out hv_PlotEval);
                if ((int)(new HTuple(((hv_Seconds - hv_LastChange)).TupleGreaterEqual(hv_ChangePlotIntervalSeconds))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_PlotEval = (new HTuple(hv_PlotEval.TupleNot()
                                )).TupleAnd(new HTuple((new HTuple(hv_EvalEpochs.TupleLength())).TupleGreaterEqual(
                                2)));
                            hv_PlotEval.Dispose();
                            hv_PlotEval = ExpTmpLocalVar_PlotEval;
                        }
                    }
                    HOperatorSet.SetDictTuple(hv_DisplayData, "plot_eval", hv_PlotEval);
                    HOperatorSet.SetDictTuple(hv_DisplayData, "last_change_plot", hv_Seconds);
                }
                //This procedure can also be called after a training.
                //In such a case the parameter plot_function can be set to determine,
                //which plot shall be displayed.
                hv_PlotFunctionExists.Dispose();
                HOperatorSet.GetDictParam(hv_DisplayData, "key_exists", "plot_function", out hv_PlotFunctionExists);
                if ((int)(hv_PlotFunctionExists) != 0)
                {
                    hv_PlotFunction.Dispose();
                    HOperatorSet.GetDictTuple(hv_DisplayData, "plot_function", out hv_PlotFunction);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_PlotEval = hv_PlotEval.TupleOr(
                                new HTuple(hv_PlotFunction.TupleEqual("evaluation")));
                            hv_PlotEval.Dispose();
                            hv_PlotEval = ExpTmpLocalVar_PlotEval;
                        }
                    }
                }
                if ((int)(hv_PlotEval) != 0)
                {
                    hv_TextPlot.Dispose();
                    hv_TextPlot = "2/2";
                }
                else
                {
                    hv_TextPlot.Dispose();
                    hv_TextPlot = "1/2";
                    hv_PlotTrainEval.Dispose();
                    hv_PlotTrainEval = 0;
                }
                hv_HeadlineText.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HeadlineText = ("Showing plot " + hv_TextPlot) + ":";
                }
                //
                //Shall the training evaluation be plotted?
                hv_PlotTrainEval.Dispose();
                hv_PlotTrainEval = 0;
                //
                //In case there are missing evaluation values (-1),
                //we just reuse the previous values.
                if ((int)(new HTuple(hv_EvalValuesTrain_COPY_INP_TMP.TupleLength())) != 0)
                {
                    hv_PlotTrainEval.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_PlotTrainEval = new HTuple(((hv_EvalValuesTrain_COPY_INP_TMP.TupleMax()
                            )).TupleNotEqual(-1));
                    }
                    if ((int)(hv_PlotTrainEval) != 0)
                    {
                        hv_Indices.Dispose();
                        HOperatorSet.TupleFind(hv_EvalValuesTrain_COPY_INP_TMP, -1, out hv_Indices);
                        if ((int)((new HTuple(hv_Indices.TupleNotEqual(-1))).TupleAnd(new HTuple(hv_Indices.TupleNotEqual(
                            new HTuple())))) != 0)
                        {
                            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Indices.TupleLength()
                                )) - 1); hv_Index = (int)hv_Index + 1)
                            {
                                if ((int)(new HTuple(((hv_Indices.TupleSelect(hv_Index))).TupleEqual(
                                    0))) != 0)
                                {
                                    if (hv_EvalValuesTrain_COPY_INP_TMP == null)
                                        hv_EvalValuesTrain_COPY_INP_TMP = new HTuple();
                                    hv_EvalValuesTrain_COPY_INP_TMP[0] = 0.0;
                                }
                                else
                                {
                                    if (hv_EvalValuesTrain_COPY_INP_TMP == null)
                                        hv_EvalValuesTrain_COPY_INP_TMP = new HTuple();
                                    hv_EvalValuesTrain_COPY_INP_TMP[hv_Indices.TupleSelect(hv_Index)] = hv_EvalValuesTrain_COPY_INP_TMP.TupleSelect(
                                        (hv_Indices.TupleSelect(hv_Index)) - 1);
                                }
                            }
                        }
                    }
                }
                //
                hv_PartRow1.Dispose(); hv_PartColumn1.Dispose(); hv_PartRow2.Dispose(); hv_PartColumn2.Dispose();
                HOperatorSet.GetPart(hv_WindowText, out hv_PartRow1, out hv_PartColumn1, out hv_PartRow2,
                    out hv_PartColumn2);
                hv__.Dispose(); hv__.Dispose(); hv_Width.Dispose(); hv_Height.Dispose();
                HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv__, out hv__, out hv_Width,
                    out hv_Height);
                //Generate a background rectangle for the plot.
                //For a correct visualization of the rectangle, the region
                //may not be cut off.
                hv_ClipRegionValue.Dispose();
                HOperatorSet.GetSystem("clip_region", out hv_ClipRegionValue);
                HOperatorSet.SetSystem("clip_region", "false");
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_PlotBackground.Dispose();
                    HOperatorSet.GenRectangle1(out ho_PlotBackground, 470, 9, hv_PartRow2 - 6, hv_PartColumn2 - 10);
                }
                HOperatorSet.SetSystem("clip_region", hv_ClipRegionValue);
                //
                hv_PlotHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PlotHeight = (((hv_PartRow2 - 30) - 480) * hv_Height) / ((hv_PartRow2 - hv_PartRow1) + 1);
                }
                hv_LegendRow.Dispose();
                hv_LegendRow = 479;
                hv_LegendDistanceLeft.Dispose();
                hv_LegendDistanceLeft = 65;
                hv_LegendDistanceRight.Dispose();
                hv_LegendDistanceRight = 85;
                //
                //Get change strategy parameters and check if a learning rate strategy exits
                hv_PlotLearningRateStrategy.Dispose();
                hv_PlotLearningRateStrategy = 0;
                hv_RightMargin.Dispose();
                hv_RightMargin = 35;
                hv_ChangeStrategies.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainParam, "change_strategies", out hv_ChangeStrategies);
                if ((int)(new HTuple((new HTuple(hv_ChangeStrategies.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    for (hv_Idx = 0; (int)hv_Idx <= (int)((new HTuple(hv_ChangeStrategies.TupleLength()
                        )) - 1); hv_Idx = (int)hv_Idx + 1)
                    {
                        hv_ChangeStrategy.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ChangeStrategy = hv_ChangeStrategies.TupleSelect(
                                hv_Idx);
                        }
                        hv_ChangeStrategyName.Dispose();
                        HOperatorSet.GetDictTuple(hv_ChangeStrategy, "model_param", out hv_ChangeStrategyName);
                        if ((int)(new HTuple(hv_ChangeStrategyName.TupleEqual("learning_rate"))) != 0)
                        {
                            hv_PlotLearningRateStrategy.Dispose();
                            hv_PlotLearningRateStrategy = 1;
                            hv_ChangeStrategiesValues.Dispose();
                            HOperatorSet.GetDictTuple(hv_ChangeStrategy, "values", out hv_ChangeStrategiesValues);
                            hv_ChangeStrategiesInitial.Dispose();
                            HOperatorSet.GetDictTuple(hv_ChangeStrategy, "initial_value", out hv_ChangeStrategiesInitial);
                            //
                            //Plot parameters for the learning rate
                            hv_StrategyMin.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_StrategyMin = hv_LearningRate.TupleMin()
                                    ;
                            }
                            hv_StrategyMax.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_StrategyMax = hv_LearningRate.TupleMax()
                                    ;
                            }
                            hv_LogLRMin.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_LogLRMin = (((new HTuple(1e-8)).TupleMax2(
                                    hv_StrategyMin))).TupleLog10();
                            }
                            hv_LogLRMax.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_LogLRMax = (((new HTuple(1e-8)).TupleMax2(
                                    hv_StrategyMax))).TupleLog10();
                            }
                            //
                            if ((int)(new HTuple(((((hv_LogLRMax - hv_LogLRMin)).TupleFabs())).TupleLess(
                                1e-4))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_LogLRMin = hv_LogLRMin - 5e-5;
                                        hv_LogLRMin.Dispose();
                                        hv_LogLRMin = ExpTmpLocalVar_LogLRMin;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_LogLRMax = hv_LogLRMax + 5e-5;
                                        hv_LogLRMax.Dispose();
                                        hv_LogLRMax = ExpTmpLocalVar_LogLRMax;
                                    }
                                }
                            }
                            //
                            hv_LRScale.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_LRScale = (hv_LogLRMax - hv_LogLRMin) / hv_PlotHeight;
                            }
                            hv_LROffset.Dispose();
                            hv_LROffset = 15;
                            hv_LogLROffset.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_LogLROffset = hv_LROffset * hv_LRScale;
                            }
                            //
                            hv_StartYLearningRate.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_StartYLearningRate = (new HTuple(10)).TuplePow(
                                    hv_LogLRMin - (1.0 * hv_LogLROffset));
                            }
                            hv_EndYLearningRate.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_EndYLearningRate = (new HTuple(10)).TuplePow(
                                    hv_LogLRMax + (1.0 * hv_LogLROffset));
                            }
                            hv_TicksYLearningRate.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TicksYLearningRate = (hv_PlotHeight / 5) * hv_LRScale;
                            }
                            //
                            hv_LogYLearningRate.Dispose();
                            hv_LogYLearningRate = "true";
                            hv_RightMargin.Dispose();
                            hv_RightMargin = 75;
                        }
                    }
                }
                hv_LRColor.Dispose();
                hv_LRColor = "#1332ffdd";
                hv_LRLineWidth.Dispose();
                hv_LRLineWidth = 2;
                hv_LRTextLegend.Dispose();
                hv_LRTextLegend = "'learning_rate'";
                //Space for legends
                hv_TopMarginPlots.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TopMarginPlots = 480 + 20;
                }
                //
                //Determine current number of iterations.
                hv_NumIterationsPerEpoch.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainInfo, "num_iterations_per_epoch", out hv_NumIterationsPerEpoch);
                hv_Iterations.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Iterations = ((((hv_Epochs * hv_NumIterationsPerEpoch)).TupleCeil()
                        )).TupleInt();
                }
                hv_NumEpochs.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainInfo, "num_epochs", out hv_NumEpochs);
                hv_NumIterations.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumIterations = ((((hv_NumEpochs * hv_NumIterationsPerEpoch)).TupleCeil()
                        )).TupleInt();
                }
                hv_CurrentIteration.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_CurrentIteration = hv_Iterations.TupleSelect(
                        (new HTuple(hv_Iterations.TupleLength())) - 1);
                }
                //
                //Determine x-axis values.
                hv_XAxisLabel.Dispose();
                HOperatorSet.GetDictTuple(hv_DisplayParam, "x_axis_label", out hv_XAxisLabel);
                if ((int)(new HTuple(hv_XAxisLabel.TupleEqual("epochs"))) != 0)
                {
                    hv_ValuesX.Dispose();
                    hv_ValuesX = new HTuple(hv_Epochs);
                    hv_TicksX.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TicksX = (new HTuple(0.1)).TupleMax2(
                            ((hv_Epochs.TupleMax()) - (hv_Epochs.TupleMin())) * 0.15);
                    }
                    if ((int)(new HTuple(hv_EvalEpochs.TupleNotEqual(new HTuple()))) != 0)
                    {
                        hv_EvalValuesX.Dispose();
                        hv_EvalValuesX = new HTuple(hv_EvalEpochs);
                        hv_EvalTicksX.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_EvalTicksX = (new HTuple(0.1)).TupleMax2(
                                ((hv_EvalEpochs.TupleMax()) - (hv_EvalEpochs.TupleMin())) * 0.15);
                        }
                    }
                    hv_TitleX.Dispose();
                    hv_TitleX = "Epochs";
                }
                else if ((int)(new HTuple(hv_XAxisLabel.TupleEqual("iterations"))) != 0)
                {
                    hv_ValuesX.Dispose();
                    hv_ValuesX = new HTuple(hv_Iterations);
                    hv_TicksX.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TicksX = (((new HTuple(2)).TupleMax2(
                            ((hv_Iterations.TupleMax()) - (hv_Iterations.TupleMin())) * 0.15))).TupleInt()
                            ;
                    }
                    if ((int)(new HTuple(hv_EvalEpochs.TupleNotEqual(new HTuple()))) != 0)
                    {
                        hv_EvalIterations.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_EvalIterations = ((hv_EvalEpochs * hv_NumIterationsPerEpoch)).TupleCeil()
                                ;
                        }
                        hv_EvalValuesX.Dispose();
                        hv_EvalValuesX = new HTuple(hv_EvalIterations);
                        hv_EvalTicksX.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_EvalTicksX = (((new HTuple(2)).TupleMax2(
                                ((hv_EvalIterations.TupleMax()) - (hv_EvalIterations.TupleMin())) * 0.15))).TupleInt()
                                ;
                        }
                    }
                    hv_TitleX.Dispose();
                    hv_TitleX = "Iterations";
                }
                //
                //Determine y-axis values and plot the function as well as its texts.
                if ((int)(hv_PlotEval) != 0)
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), "white");
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_PlotBackground, HDevWindowStack.GetActive());
                    }
                    hv_EvalValuesMin.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_EvalValuesMin = ((hv_EvalValues.TupleConcat(
                            (new HTuple(0.0)).TupleMax2(hv_EvalValuesTrain_COPY_INP_TMP)))).TupleMin()
                            ;
                    }
                    hv_EvalValuesMax.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_EvalValuesMax = ((hv_EvalValues.TupleConcat(
                            hv_EvalValuesTrain_COPY_INP_TMP))).TupleMax();
                    }
                    if ((int)(new HTuple(((((hv_EvalValuesMax - hv_EvalValuesMin)).TupleAbs())).TupleLess(
                        1e-3))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_EvalValuesMin = hv_EvalValuesMin - 5e-4;
                                hv_EvalValuesMin.Dispose();
                                hv_EvalValuesMin = ExpTmpLocalVar_EvalValuesMin;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_EvalValuesMax = hv_EvalValuesMax + 5e-4;
                                hv_EvalValuesMax.Dispose();
                                hv_EvalValuesMax = ExpTmpLocalVar_EvalValuesMax;
                            }
                        }
                    }
                    hv_TicksY.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TicksY = (hv_EvalValuesMax - hv_EvalValuesMin) * 0.1;
                    }
                    hv_StartY.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_StartY = hv_EvalValuesMin - ((hv_EvalValuesMax - hv_EvalValuesMin) * 0.1);
                    }
                    hv_EndY.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_EndY = hv_EvalValuesMax + ((hv_EvalValuesMax - hv_EvalValuesMin) * 0.1);
                    }
                    //
                    hv_YAxisLabel.Dispose();
                    hv_YAxisLabel = "Evaluation value";
                    hv_BestEvaluationData.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainInfo, "best_evaluation", out hv_BestEvaluationData);
                    if ((int)(new HTuple((new HTuple(hv_BestEvaluationData.TupleLength())).TupleGreater(
                        0))) != 0)
                    {
                        hv_BestEvaluationComparisonKeys.Dispose();
                        HOperatorSet.GetDictTuple(hv_BestEvaluationData, "comparison_keys", out hv_BestEvaluationComparisonKeys);
                        hv_YAxisLabel.Dispose();
                        hv_YAxisLabel = "Evaluation value";
                        if ((int)(new HTuple((new HTuple(hv_BestEvaluationComparisonKeys.TupleLength()
                            )).TupleGreater(1))) != 0)
                        {
                            hv_YAxisLabel.Dispose();
                            pretty_print_tuple(hv_BestEvaluationComparisonKeys, out hv_YAxisLabel);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_YAxisLabel = ("mean(" + hv_YAxisLabel) + ")";
                                    hv_YAxisLabel.Dispose();
                                    hv_YAxisLabel = ExpTmpLocalVar_YAxisLabel;
                                }
                            }
                        }
                        else
                        {
                            hv_YAxisLabel.Dispose();
                            hv_YAxisLabel = new HTuple(hv_BestEvaluationComparisonKeys);
                        }
                    }
                    //Use a smaller, non-bold font for the plot.
                    set_display_font(hv_WindowText, 12, "mono", "false", "false");
                    //Plot learning rate if the corresponding strategy exists.
                    if ((int)(hv_PlotLearningRateStrategy) != 0)
                    {
                        //
                        //Display current values in appropriate colors.
                        hv__.Dispose(); hv__.Dispose(); hv_StringExtendsLegendRight.Dispose(); hv__.Dispose();
                        HOperatorSet.GetStringExtents(hv_WindowText, hv_LRTextLegend, out hv__,
                            out hv__, out hv_StringExtendsLegendRight, out hv__);
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_LRTextLegend, "image",
                                    hv_LegendRow, (hv_Width - hv_StringExtendsLegendRight) - hv_LegendDistanceRight,
                                    hv_LRColor, "box", "false");
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            plot_tuple_no_window_handling(hv_WindowText, hv_ValuesX, hv_LearningRate,
                                "", "", hv_LRColor, ((((((((((((new HTuple("log_y")).TupleConcat("axes_color")).TupleConcat(
                                "start_y")).TupleConcat("end_y")).TupleConcat("ticks_y")).TupleConcat(
                                "margin_top")).TupleConcat("margin_bottom")).TupleConcat("margin_left")).TupleConcat(
                                "margin_right")).TupleConcat("line_width")).TupleConcat("axes_color")).TupleConcat(
                                "axis_location_y")).TupleConcat("format_y"), ((((((((((((((((hv_LogYLearningRate.TupleConcat(
                                "black"))).TupleConcat(hv_StartYLearningRate))).TupleConcat(hv_EndYLearningRate))).TupleConcat(
                                hv_TicksYLearningRate))).TupleConcat(hv_TopMarginPlots))).TupleConcat(
                                (new HTuple(30)).TupleConcat(65)))).TupleConcat(hv_RightMargin))).TupleConcat(
                                hv_LRLineWidth))).TupleConcat(((new HTuple("#898b8f")).TupleConcat(
                                "right")).TupleConcat(".1e")));
                        }
                    }
                    //Plot validation evaluation values.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        plot_tuple_no_window_handling(hv_WindowText, hv_EvalValuesX, hv_EvalValues,
                            hv_TitleX, "", "#36a2eb", ((((((((((new HTuple("axes_color")).TupleConcat(
                            "ticks_x")).TupleConcat("ticks_y")).TupleConcat("start_y")).TupleConcat(
                            "end_y")).TupleConcat("margin_top")).TupleConcat("margin_bottom")).TupleConcat(
                            "margin_left")).TupleConcat("margin_right")).TupleConcat("line_width")).TupleConcat(
                            "axes_color"), (((((((((((((((new HTuple("black")).TupleConcat(hv_EvalTicksX))).TupleConcat(
                            hv_TicksY))).TupleConcat(hv_StartY))).TupleConcat(hv_EndY))).TupleConcat(
                            hv_TopMarginPlots))).TupleConcat((new HTuple(30)).TupleConcat(65)))).TupleConcat(
                            hv_RightMargin))).TupleConcat((new HTuple(3)).TupleConcat("#898b8f")));
                    }
                    //Plot train evaluation values.
                    if ((int)(hv_PlotTrainEval) != 0)
                    {
                        hv_Bullet.Dispose();
                        hv_Bullet = "●";
                        hv_Line.Dispose();
                        hv_Line = "―";
                        hv_YAxisTitle.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YAxisTitle = ((((("  '" + hv_YAxisLabel) + "' (") + hv_Line) + new HTuple(" validation, ")) + hv_Bullet) + "-- training)";
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            plot_tuple_no_window_handling(hv_WindowText, hv_EvalValuesX, hv_EvalValuesTrain_COPY_INP_TMP,
                                hv_TitleX, "", "#36a2eb", (((((((((((new HTuple("style")).TupleConcat(
                                "axes_color")).TupleConcat("ticks_x")).TupleConcat("ticks_y")).TupleConcat(
                                "start_y")).TupleConcat("end_y")).TupleConcat("margin_top")).TupleConcat(
                                "margin_bottom")).TupleConcat("margin_left")).TupleConcat("margin_right")).TupleConcat(
                                "line_width")).TupleConcat("axes_color"), ((((((((((((((((new HTuple(20)).TupleConcat(
                                "black")).TupleConcat(hv_EvalTicksX))).TupleConcat(hv_TicksY))).TupleConcat(
                                hv_StartY))).TupleConcat(hv_EndY))).TupleConcat(hv_TopMarginPlots))).TupleConcat(
                                (new HTuple(30)).TupleConcat(65)))).TupleConcat(hv_RightMargin))).TupleConcat(
                                (new HTuple(3)).TupleConcat("#898b8f")));
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            plot_tuple_no_window_handling(hv_WindowText, hv_EvalValuesX, hv_EvalValuesTrain_COPY_INP_TMP,
                                hv_TitleX, "", "#36a2eb", (((((((((((new HTuple("style")).TupleConcat(
                                "axes_color")).TupleConcat("ticks_x")).TupleConcat("ticks_y")).TupleConcat(
                                "start_y")).TupleConcat("end_y")).TupleConcat("margin_top")).TupleConcat(
                                "margin_bottom")).TupleConcat("margin_left")).TupleConcat("margin_right")).TupleConcat(
                                "line_width")).TupleConcat("axes_color"), ((((((((((((((((new HTuple("circle")).TupleConcat(
                                "black")).TupleConcat(hv_EvalTicksX))).TupleConcat(hv_TicksY))).TupleConcat(
                                hv_StartY))).TupleConcat(hv_EndY))).TupleConcat(hv_TopMarginPlots))).TupleConcat(
                                (new HTuple(30)).TupleConcat(65)))).TupleConcat(hv_RightMargin))).TupleConcat(
                                (new HTuple(3)).TupleConcat("#898b8f")));
                        }
                    }
                    else
                    {
                        hv_YAxisTitle.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YAxisTitle = ("  '" + hv_YAxisLabel) + "'";
                        }
                    }
                    //Display title of y-axis.
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_YAxisTitle, "image",
                            hv_LegendRow, hv_LegendDistanceLeft, "#36a2eb", "box", "false");
                    }
                    //Reset font.
                    set_display_font(hv_WindowText, 16, "mono", "true", "false");
                }
                else
                {
                    if ((int)(new HTuple((new HTuple(hv_Epochs.TupleLength())).TupleGreater(3))) != 0)
                    {
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetColor(HDevWindowStack.GetActive(), "white");
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispObj(ho_PlotBackground, HDevWindowStack.GetActive());
                        }
                        //
                        //Set StartY and EndY, such that there is a margin on top and bottom to
                        //avoid that the plot overlaps with the axis captions. (With respect to
                        //the logarithmic plotting of the Loss function)
                        //Set this offset in window coordinates:
                        hv_Offset.Dispose();
                        hv_Offset = 15;
                        //Calculate min max values to determine the correct offset in log
                        //coordinates.
                        hv_LogMin.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_LogMin = (((new HTuple(0.00001)).TupleMax2(
                                hv_Loss.TupleMin()))).TupleLog10();
                        }
                        hv_LogMax.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_LogMax = (((new HTuple(0.00001)).TupleMax2(
                                hv_Loss.TupleMax()))).TupleLog10();
                        }
                        //
                        if ((int)(new HTuple(((((hv_LogMax - hv_LogMin)).TupleFabs())).TupleLess(
                            0.0001))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_LogMin = hv_LogMin - 0.00005;
                                    hv_LogMin.Dispose();
                                    hv_LogMin = ExpTmpLocalVar_LogMin;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_LogMax = hv_LogMax + 0.00005;
                                    hv_LogMax.Dispose();
                                    hv_LogMax = ExpTmpLocalVar_LogMax;
                                }
                            }
                        }
                        //
                        hv_Scale.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Scale = (hv_LogMax - hv_LogMin) / hv_PlotHeight;
                        }
                        hv_LogOffset.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_LogOffset = hv_Offset * hv_Scale;
                        }
                        hv_StartY.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_StartY = (new HTuple(10)).TuplePow(
                                hv_LogMin - hv_LogOffset);
                        }
                        hv_EndY.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_EndY = (new HTuple(10)).TuplePow(
                                hv_LogMax + hv_LogOffset);
                        }
                        hv_TicksY.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TicksY = (hv_PlotHeight / 10) * hv_Scale;
                        }
                        //
                        //Use a smaller, non-bold font for the plot.
                        set_display_font(hv_WindowText, 12, "mono", "false", "false");
                        hv_LogY.Dispose();
                        hv_LogY = "true";
                        //Plot learning rate if the corresponding strategy exists.
                        if ((int)(hv_PlotLearningRateStrategy) != 0)
                        {
                            //
                            //Display current values in appropriate colors.
                            hv__.Dispose(); hv__.Dispose(); hv_StringExtendsLegendRight.Dispose(); hv__.Dispose();
                            HOperatorSet.GetStringExtents(hv_WindowText, hv_LRTextLegend, out hv__,
                                out hv__, out hv_StringExtendsLegendRight, out hv__);
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_LRTextLegend,
                                        "image", hv_LegendRow, (hv_Width - hv_StringExtendsLegendRight) - hv_LegendDistanceRight,
                                        hv_LRColor, "box", "false");
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                plot_tuple_no_window_handling(hv_WindowText, hv_ValuesX, hv_LearningRate,
                                    "", "", hv_LRColor, ((((((((((((new HTuple("log_y")).TupleConcat(
                                    "axes_color")).TupleConcat("start_y")).TupleConcat("end_y")).TupleConcat(
                                    "ticks_y")).TupleConcat("margin_top")).TupleConcat("margin_bottom")).TupleConcat(
                                    "margin_left")).TupleConcat("margin_right")).TupleConcat("line_width")).TupleConcat(
                                    "axes_color")).TupleConcat("axis_location_y")).TupleConcat("format_y"),
                                    ((((((((((((((((hv_LogY.TupleConcat("black"))).TupleConcat(hv_StartYLearningRate))).TupleConcat(
                                    hv_EndYLearningRate))).TupleConcat(hv_TicksYLearningRate))).TupleConcat(
                                    hv_TopMarginPlots))).TupleConcat((new HTuple(30)).TupleConcat(65)))).TupleConcat(
                                    hv_RightMargin))).TupleConcat(hv_LRLineWidth))).TupleConcat(((new HTuple("#898b8f")).TupleConcat(
                                    "right")).TupleConcat(".1e")));
                            }
                        }
                        hv_YAxisLabel.Dispose();
                        hv_YAxisLabel = "Loss";
                        if (HDevWindowStack.IsOpen())
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.DispText(HDevWindowStack.GetActive(), "  " + hv_YAxisLabel,
                                    "image", hv_LegendRow, hv_LegendDistanceLeft, "#ff6384", "box", "false");
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            plot_tuple_no_window_handling(hv_WindowText, hv_ValuesX, hv_Loss, hv_TitleX,
                                "", "#ff6384", (((((((((((new HTuple("log_y")).TupleConcat("axes_color")).TupleConcat(
                                "ticks_x")).TupleConcat("ticks_y")).TupleConcat("start_y")).TupleConcat(
                                "end_y")).TupleConcat("margin_top")).TupleConcat("margin_bottom")).TupleConcat(
                                "margin_left")).TupleConcat("margin_right")).TupleConcat("line_width")).TupleConcat(
                                "axes_color"), ((((((((((((((((hv_LogY.TupleConcat("black"))).TupleConcat(
                                hv_TicksX))).TupleConcat(hv_TicksY))).TupleConcat(hv_StartY))).TupleConcat(
                                hv_EndY))).TupleConcat(hv_TopMarginPlots))).TupleConcat((new HTuple(30)).TupleConcat(
                                65)))).TupleConcat(hv_RightMargin))).TupleConcat((new HTuple(3)).TupleConcat(
                                "#898b8f")));
                        }
                        set_display_font(hv_WindowText, 16, "mono", "true", "false");
                    }
                    else
                    {
                        hv_HeadlineText.Dispose();
                        hv_HeadlineText = "Waiting for data to initialize the plot...";
                    }
                }

                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_HeadlineText, "image",
                        445, 9, "black", "box", "false");
                }
                //
                //Model parameter status.
                hv_TextModelParams.Dispose();
                HOperatorSet.GetDictTuple(hv_DisplayParam, "status_model_params", out hv_TextModelParams);
                hv_ModelParams.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainInfo, "model_params", out hv_ModelParams);
                hv_StatusModelParamsLeft.Dispose();
                hv_StatusModelParamsLeft = new HTuple();
                hv_StatusModelParamsRight.Dispose();
                hv_StatusModelParamsRight = new HTuple();
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_TextModelParams.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    hv_ParName.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ParName = hv_TextModelParams.TupleSelect(
                            hv_Index);
                    }
                    try
                    {
                        hv_Tuple.Dispose();
                        HOperatorSet.GetDictTuple(hv_ModelParams, hv_ParName, out hv_Tuple);
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException1)
                    {
                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        continue;
                    }
                    if ((int)((new HTuple(hv_ParName.TupleEqual("batch_size_multiplier"))).TupleAnd(
                        new HTuple(hv_Tuple.TupleEqual(1)))) != 0)
                    {
                        continue;
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_StatusModelParamsLeft = hv_StatusModelParamsLeft.TupleConcat(
                                ("'" + hv_ParName) + "'");
                            hv_StatusModelParamsLeft.Dispose();
                            hv_StatusModelParamsLeft = ExpTmpLocalVar_StatusModelParamsLeft;
                        }
                    }

                    hv_TupleStr.Dispose();
                    pretty_print_tuple(hv_Tuple, out hv_TupleStr);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_StatusModelParamsRight = hv_StatusModelParamsRight.TupleConcat(
                                hv_TupleStr);
                            hv_StatusModelParamsRight.Dispose();
                            hv_StatusModelParamsRight = ExpTmpLocalVar_StatusModelParamsRight;
                        }
                    }
                }
                if ((int)(new HTuple((new HTuple(hv_StatusModelParamsLeft.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_StatusModelParamsLeft = (new HTuple("Model parameters:")).TupleConcat(
                                "  " + hv_StatusModelParamsLeft);
                            hv_StatusModelParamsLeft.Dispose();
                            hv_StatusModelParamsLeft = ExpTmpLocalVar_StatusModelParamsLeft;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_StatusModelParamsRight = (new HTuple(" ")).TupleConcat(
                                hv_StatusModelParamsRight);
                            hv_StatusModelParamsRight.Dispose();
                            hv_StatusModelParamsRight = ExpTmpLocalVar_StatusModelParamsRight;
                        }
                    }
                }
                //
                //Evaluation status.
                hv_StatusEvaluationLeft.Dispose();
                hv_StatusEvaluationLeft = new HTuple();
                hv_StatusEvaluationRight.Dispose();
                hv_StatusEvaluationRight = new HTuple();
                hv_BestEvaluationData.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainInfo, "best_evaluation", out hv_BestEvaluationData);
                if ((int)(new HTuple((new HTuple(hv_BestEvaluationData.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    hv_BestEvaluationComparisonKeys.Dispose();
                    HOperatorSet.GetDictTuple(hv_BestEvaluationData, "comparison_keys", out hv_BestEvaluationComparisonKeys);
                    hv_BestEvaluationValue.Dispose();
                    HOperatorSet.GetDictTuple(hv_BestEvaluationData, "best_value", out hv_BestEvaluationValue);
                    hv_BestEvaluationInfo.Dispose();
                    HOperatorSet.GetDictTuple(hv_BestEvaluationData, "best_info", out hv_BestEvaluationInfo);
                    hv_BestEvaluationEpoch.Dispose();
                    HOperatorSet.GetDictTuple(hv_BestEvaluationInfo, "epoch", out hv_BestEvaluationEpoch);
                    hv_BestTrainEvaluationValue.Dispose();
                    HOperatorSet.GetDictTuple(hv_BestEvaluationData, "best_value_train", out hv_BestTrainEvaluationValue);
                    hv_BestTrainEvaluationInfo.Dispose();
                    HOperatorSet.GetDictTuple(hv_BestEvaluationData, "best_info_train", out hv_BestTrainEvaluationInfo);
                    hv_BestTrainEvaluationEpoch.Dispose();
                    HOperatorSet.GetDictTuple(hv_BestTrainEvaluationInfo, "epoch", out hv_BestTrainEvaluationEpoch);
                    if ((int)(new HTuple((new HTuple(hv_BestEvaluationComparisonKeys.TupleLength()
                        )).TupleGreater(1))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_StatusEvaluationLeft = hv_StatusEvaluationLeft.TupleConcat(
                                    "Measures");
                                hv_StatusEvaluationLeft.Dispose();
                                hv_StatusEvaluationLeft = ExpTmpLocalVar_StatusEvaluationLeft;
                            }
                        }
                        hv_BestEvaluationComparisonKeysStr.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BestEvaluationComparisonKeysStr = new HTuple(new HTuple("multiple (") + (new HTuple(hv_BestEvaluationComparisonKeys.TupleLength()
                                ))) + ")";
                        }
                    }
                    else
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_StatusEvaluationLeft = hv_StatusEvaluationLeft.TupleConcat(
                                    "Measure");
                                hv_StatusEvaluationLeft.Dispose();
                                hv_StatusEvaluationLeft = ExpTmpLocalVar_StatusEvaluationLeft;
                            }
                        }
                        hv_BestEvaluationComparisonKeysStr.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BestEvaluationComparisonKeysStr = ("'" + hv_BestEvaluationComparisonKeys) + "'";
                        }
                    }
                    //
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_StatusEvaluationRight = hv_StatusEvaluationRight.TupleConcat(
                                hv_BestEvaluationComparisonKeysStr);
                            hv_StatusEvaluationRight.Dispose();
                            hv_StatusEvaluationRight = ExpTmpLocalVar_StatusEvaluationRight;
                        }
                    }
                    //Validation value.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_StatusEvaluationLeft = hv_StatusEvaluationLeft.TupleConcat(
                                "Best value validation (value / epoch)");
                            hv_StatusEvaluationLeft.Dispose();
                            hv_StatusEvaluationLeft = ExpTmpLocalVar_StatusEvaluationLeft;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_StatusEvaluationRight = hv_StatusEvaluationRight.TupleConcat(
                                ((hv_BestEvaluationValue.TupleString("0.3f")) + " / ") + (hv_BestEvaluationEpoch.TupleString(
                                "0.1f")));
                            hv_StatusEvaluationRight.Dispose();
                            hv_StatusEvaluationRight = ExpTmpLocalVar_StatusEvaluationRight;
                        }
                    }
                    //Training value.
                    if ((int)(hv_PlotTrainEval) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_StatusEvaluationLeft = hv_StatusEvaluationLeft.TupleConcat(
                                    "Best value training (value / epoch)");
                                hv_StatusEvaluationLeft.Dispose();
                                hv_StatusEvaluationLeft = ExpTmpLocalVar_StatusEvaluationLeft;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_StatusEvaluationRight = hv_StatusEvaluationRight.TupleConcat(
                                    ((hv_BestTrainEvaluationValue.TupleString("0.3f")) + " / ") + (hv_BestTrainEvaluationEpoch.TupleString(
                                    "0.1f")));
                                hv_StatusEvaluationRight.Dispose();
                                hv_StatusEvaluationRight = ExpTmpLocalVar_StatusEvaluationRight;
                            }
                        }
                    }
                    //
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_StatusEvaluationLeft = (new HTuple("Evaluation:")).TupleConcat(
                                "  " + hv_StatusEvaluationLeft);
                            hv_StatusEvaluationLeft.Dispose();
                            hv_StatusEvaluationLeft = ExpTmpLocalVar_StatusEvaluationLeft;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_StatusEvaluationRight = (new HTuple(" ")).TupleConcat(
                                hv_StatusEvaluationRight);
                            hv_StatusEvaluationRight.Dispose();
                            hv_StatusEvaluationRight = ExpTmpLocalVar_StatusEvaluationRight;
                        }
                    }
                }
                //
                //Train status.
                hv_StatusTrainLeft.Dispose();
                hv_StatusTrainLeft = new HTuple();
                hv_StatusTrainRight.Dispose();
                hv_StatusTrainRight = new HTuple();
                hv_EpochReal.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainInfo, "epoch", out hv_EpochReal);
                hv_NumEpochs.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainInfo, "num_epochs", out hv_NumEpochs);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_StatusTrainLeft = hv_StatusTrainLeft.TupleConcat(
                            "Epoch");
                        hv_StatusTrainLeft.Dispose();
                        hv_StatusTrainLeft = ExpTmpLocalVar_StatusTrainLeft;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_StatusTrainRight = hv_StatusTrainRight.TupleConcat(
                            ((hv_EpochReal.TupleString(".1f")) + " of ") + (hv_NumEpochs.TupleString(".1f")));
                        hv_StatusTrainRight.Dispose();
                        hv_StatusTrainRight = ExpTmpLocalVar_StatusTrainRight;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_StatusTrainLeft = hv_StatusTrainLeft.TupleConcat(
                            "Iteration");
                        hv_StatusTrainLeft.Dispose();
                        hv_StatusTrainLeft = ExpTmpLocalVar_StatusTrainLeft;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_StatusTrainRight = hv_StatusTrainRight.TupleConcat(
                            (hv_CurrentIteration + " of ") + hv_NumIterations);
                        hv_StatusTrainRight.Dispose();
                        hv_StatusTrainRight = ExpTmpLocalVar_StatusTrainRight;
                    }
                }
                hv_MeanLoss.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainInfo, "mean_loss", out hv_MeanLoss);
                if ((int)(new HTuple((new HTuple(hv_MeanLoss.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_MeanLossStr.Dispose();
                    hv_MeanLossStr = "";
                }
                else
                {
                    hv_MeanLossStr.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MeanLossStr = hv_MeanLoss.TupleString(
                            "0.4f");
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_StatusTrainLeft = hv_StatusTrainLeft.TupleConcat(
                            "Loss");
                        hv_StatusTrainLeft.Dispose();
                        hv_StatusTrainLeft = ExpTmpLocalVar_StatusTrainLeft;
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_StatusTrainRight = hv_StatusTrainRight.TupleConcat(
                            hv_MeanLossStr);
                        hv_StatusTrainRight.Dispose();
                        hv_StatusTrainRight = ExpTmpLocalVar_StatusTrainRight;
                    }
                }
                //
                //Elapsed and remaining time.
                hv_TimeElapsedExists.Dispose();
                HOperatorSet.GetDictParam(hv_DisplayData, "key_exists", "time_elapsed", out hv_TimeElapsedExists);
                if ((int)(hv_TimeElapsedExists.TupleNot()) != 0)
                {
                    //During training the key is not set and the time has to be determined.
                    hv_StartEpoch.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainInfo, "start_epoch", out hv_StartEpoch);
                    hv_StartTime.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainInfo, "start_time", out hv_StartTime);
                    hv_SecondsElapsed.Dispose(); hv_SecondsRemaining.Dispose(); hv_ProgressPercent.Dispose(); hv_ProgressPerSecond.Dispose();
                    estimate_progress(hv_StartTime, hv_StartEpoch, hv_EpochReal, hv_NumEpochs,
                        out hv_SecondsElapsed, out hv_SecondsRemaining, out hv_ProgressPercent,
                        out hv_ProgressPerSecond);
                    hv_TimeElapsedString.Dispose();
                    timespan_string(hv_SecondsElapsed, "auto", out hv_TimeElapsedString);
                    hv_TimeRemainingString.Dispose();
                    timespan_string(hv_SecondsRemaining, "top2", out hv_TimeRemainingString);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_StatusTrainLeft = hv_StatusTrainLeft.TupleConcat(
                                (new HTuple("Time elapsed")).TupleConcat("Time left"));
                            hv_StatusTrainLeft.Dispose();
                            hv_StatusTrainLeft = ExpTmpLocalVar_StatusTrainLeft;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_StatusTrainRight = ((hv_StatusTrainRight.TupleConcat(
                                hv_TimeElapsedString))).TupleConcat(hv_TimeRemainingString);
                            hv_StatusTrainRight.Dispose();
                            hv_StatusTrainRight = ExpTmpLocalVar_StatusTrainRight;
                        }
                    }
                }
                else
                {
                    //For display after the finished training the key may be set.
                    //In case of a given value, display it.
                    hv_TimeElapsedString.Dispose();
                    HOperatorSet.GetDictTuple(hv_DisplayData, "time_elapsed", out hv_TimeElapsedString);
                    if ((int)(new HTuple(hv_TimeElapsedString.TupleNotEqual(""))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_StatusTrainLeft = hv_StatusTrainLeft.TupleConcat(
                                    "Time elapsed");
                                hv_StatusTrainLeft.Dispose();
                                hv_StatusTrainLeft = ExpTmpLocalVar_StatusTrainLeft;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_StatusTrainRight = hv_StatusTrainRight.TupleConcat(
                                    hv_TimeElapsedString);
                                hv_StatusTrainRight.Dispose();
                                hv_StatusTrainRight = ExpTmpLocalVar_StatusTrainRight;
                            }
                        }
                    }
                }
                //
                //Device Status.
                hv_StatusDeviceLeft.Dispose();
                hv_StatusDeviceLeft = new HTuple();
                hv_StatusDeviceRight.Dispose();
                hv_StatusDeviceRight = new HTuple();
                hv_DeviceNameExists.Dispose();
                HOperatorSet.GetDictParam(hv_ModelParams, "key_exists", "device_name", out hv_DeviceNameExists);
                if ((int)(hv_DeviceNameExists) != 0)
                {
                    hv_DeviceName.Dispose();
                    HOperatorSet.GetDictTuple(hv_ModelParams, "device_name", out hv_DeviceName);
                    hv_StatusDeviceLeft.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_StatusDeviceLeft = "Used Device: " + hv_DeviceName;
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_StatusDeviceRight = hv_StatusDeviceRight.TupleConcat(
                                " ");
                            hv_StatusDeviceRight.Dispose();
                            hv_StatusDeviceRight = ExpTmpLocalVar_StatusDeviceRight;
                        }
                    }
                }
                //
                //Combine all.
                hv_StatusLeft.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_StatusLeft = new HTuple();
                    hv_StatusLeft[0] = "train_dl_model";
                    hv_StatusLeft[1] = " ";
                    hv_StatusLeft[2] = " ";
                    hv_StatusLeft = hv_StatusLeft.TupleConcat(hv_StatusTrainLeft);
                    hv_StatusLeft = hv_StatusLeft.TupleConcat(" ");
                    hv_StatusLeft = hv_StatusLeft.TupleConcat(hv_StatusEvaluationLeft);
                    hv_StatusLeft = hv_StatusLeft.TupleConcat(" ");
                    hv_StatusLeft = hv_StatusLeft.TupleConcat(hv_StatusModelParamsLeft);
                    hv_StatusLeft = hv_StatusLeft.TupleConcat(" ");
                    hv_StatusLeft = hv_StatusLeft.TupleConcat(hv_StatusDeviceLeft);
                }
                hv_StatusRight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_StatusRight = new HTuple();
                    hv_StatusRight[0] = " ";
                    hv_StatusRight[1] = " ";
                    hv_StatusRight[2] = " ";
                    hv_StatusRight = hv_StatusRight.TupleConcat(hv_StatusTrainRight);
                    hv_StatusRight = hv_StatusRight.TupleConcat(" ");
                    hv_StatusRight = hv_StatusRight.TupleConcat(hv_StatusEvaluationRight);
                    hv_StatusRight = hv_StatusRight.TupleConcat(" ");
                    hv_StatusRight = hv_StatusRight.TupleConcat(hv_StatusModelParamsRight);
                    hv_StatusRight = hv_StatusRight.TupleConcat(" ");
                    hv_StatusRight = hv_StatusRight.TupleConcat(hv_StatusDeviceRight);
                }
                //
                //Cut strings with too many chars.
                hv_MaxChars.Dispose();
                hv_MaxChars = 14;
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_StatusRight.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    hv_Str.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Str = hv_StatusRight.TupleSelect(
                            hv_Index);
                    }
                    hv_IsString.Dispose();
                    HOperatorSet.TupleIsString(hv_Str, out hv_IsString);
                    if ((int)(hv_IsString) != 0)
                    {
                        hv_Length.Dispose();
                        HOperatorSet.TupleStrlen(hv_Str, out hv_Length);
                        if ((int)(new HTuple(hv_Length.TupleGreater(hv_MaxChars))) != 0)
                        {
                            hv_SubStr.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_SubStr = (hv_Str.TupleSubstr(
                                    0, hv_MaxChars - 3)) + "...";
                            }
                            if (hv_StatusRight == null)
                                hv_StatusRight = new HTuple();
                            hv_StatusRight[hv_Index] = hv_SubStr;
                        }
                    }
                }
                //
                //Display the text.
                hv_WindowText.Dispose();
                HOperatorSet.GetDictTuple(hv_DisplayData, "window_text", out hv_WindowText);
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_StatusLeft, "window",
                        "top", "left", "black", "box", "false");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_StatusRight, "window",
                        "top", "right", "black", "box", "false");
                }
                HOperatorSet.FlushBuffer(hv_WindowText);
                HOperatorSet.SetWindowParam(hv_WindowText, "flush", "true");
                hv_Row1.Dispose(); hv_Column1.Dispose(); hv_Row2.Dispose(); hv_Column2.Dispose();
                HOperatorSet.GetPart(hv_WindowText, out hv_Row1, out hv_Column1, out hv_Row2,
                    out hv_Column2);
                hv_WindowTextWidth.Dispose();
                HOperatorSet.GetDictTuple(hv_DisplayData, "window_text_width", out hv_WindowTextWidth);
                hv_WindowTextHeight.Dispose();
                HOperatorSet.GetDictTuple(hv_DisplayData, "window_text_height", out hv_WindowTextHeight);
                if ((int)((new HTuple(((hv_WindowTextWidth - 1)).TupleNotEqual(hv_Column2 - hv_Column1))).TupleOr(
                    new HTuple(((hv_WindowTextHeight - 1)).TupleNotEqual(hv_Row2 - hv_Row1)))) != 0)
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetPart(HDevWindowStack.GetActive(), hv_Row1, hv_Column1,
                                (hv_Row1 + hv_WindowTextHeight) - 1, (hv_Column1 + hv_WindowTextWidth) - 1);
                        }
                    }
                }
                //
                ho_PlotBackground.Dispose();

                hv_EvalValuesTrain_COPY_INP_TMP.Dispose();
                hv_DisplayEnabled.Dispose();
                hv_DisplayParam.Dispose();
                hv_WindowText.Dispose();
                hv_WindowHandle.Dispose();
                hv_ChangePlotIntervalSeconds.Dispose();
                hv_LastChange.Dispose();
                hv_Seconds.Dispose();
                hv_PlotEval.Dispose();
                hv_PlotFunctionExists.Dispose();
                hv_PlotFunction.Dispose();
                hv_TextPlot.Dispose();
                hv_PlotTrainEval.Dispose();
                hv_HeadlineText.Dispose();
                hv_Indices.Dispose();
                hv_Index.Dispose();
                hv_PartRow1.Dispose();
                hv_PartColumn1.Dispose();
                hv_PartRow2.Dispose();
                hv_PartColumn2.Dispose();
                hv__.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_ClipRegionValue.Dispose();
                hv_PlotHeight.Dispose();
                hv_LegendRow.Dispose();
                hv_LegendDistanceLeft.Dispose();
                hv_LegendDistanceRight.Dispose();
                hv_PlotLearningRateStrategy.Dispose();
                hv_RightMargin.Dispose();
                hv_ChangeStrategies.Dispose();
                hv_Idx.Dispose();
                hv_ChangeStrategy.Dispose();
                hv_ChangeStrategyName.Dispose();
                hv_ChangeStrategiesValues.Dispose();
                hv_ChangeStrategiesInitial.Dispose();
                hv_StrategyMin.Dispose();
                hv_StrategyMax.Dispose();
                hv_LogLRMin.Dispose();
                hv_LogLRMax.Dispose();
                hv_LRScale.Dispose();
                hv_LROffset.Dispose();
                hv_LogLROffset.Dispose();
                hv_StartYLearningRate.Dispose();
                hv_EndYLearningRate.Dispose();
                hv_TicksYLearningRate.Dispose();
                hv_LogYLearningRate.Dispose();
                hv_LRColor.Dispose();
                hv_LRLineWidth.Dispose();
                hv_LRTextLegend.Dispose();
                hv_TopMarginPlots.Dispose();
                hv_NumIterationsPerEpoch.Dispose();
                hv_Iterations.Dispose();
                hv_NumEpochs.Dispose();
                hv_NumIterations.Dispose();
                hv_CurrentIteration.Dispose();
                hv_XAxisLabel.Dispose();
                hv_ValuesX.Dispose();
                hv_TicksX.Dispose();
                hv_EvalValuesX.Dispose();
                hv_EvalTicksX.Dispose();
                hv_TitleX.Dispose();
                hv_EvalIterations.Dispose();
                hv_EvalValuesMin.Dispose();
                hv_EvalValuesMax.Dispose();
                hv_TicksY.Dispose();
                hv_StartY.Dispose();
                hv_EndY.Dispose();
                hv_YAxisLabel.Dispose();
                hv_BestEvaluationData.Dispose();
                hv_BestEvaluationComparisonKeys.Dispose();
                hv_StringExtendsLegendRight.Dispose();
                hv_Bullet.Dispose();
                hv_Line.Dispose();
                hv_YAxisTitle.Dispose();
                hv_Offset.Dispose();
                hv_LogMin.Dispose();
                hv_LogMax.Dispose();
                hv_Scale.Dispose();
                hv_LogOffset.Dispose();
                hv_LogY.Dispose();
                hv_TextModelParams.Dispose();
                hv_ModelParams.Dispose();
                hv_StatusModelParamsLeft.Dispose();
                hv_StatusModelParamsRight.Dispose();
                hv_ParName.Dispose();
                hv_Tuple.Dispose();
                hv_Exception.Dispose();
                hv_TupleStr.Dispose();
                hv_StatusEvaluationLeft.Dispose();
                hv_StatusEvaluationRight.Dispose();
                hv_BestEvaluationValue.Dispose();
                hv_BestEvaluationInfo.Dispose();
                hv_BestEvaluationEpoch.Dispose();
                hv_BestTrainEvaluationValue.Dispose();
                hv_BestTrainEvaluationInfo.Dispose();
                hv_BestTrainEvaluationEpoch.Dispose();
                hv_BestEvaluationComparisonKeysStr.Dispose();
                hv_StatusTrainLeft.Dispose();
                hv_StatusTrainRight.Dispose();
                hv_EpochReal.Dispose();
                hv_MeanLoss.Dispose();
                hv_MeanLossStr.Dispose();
                hv_TimeElapsedExists.Dispose();
                hv_StartEpoch.Dispose();
                hv_StartTime.Dispose();
                hv_SecondsElapsed.Dispose();
                hv_SecondsRemaining.Dispose();
                hv_ProgressPercent.Dispose();
                hv_ProgressPerSecond.Dispose();
                hv_TimeElapsedString.Dispose();
                hv_TimeRemainingString.Dispose();
                hv_StatusDeviceLeft.Dispose();
                hv_StatusDeviceRight.Dispose();
                hv_DeviceNameExists.Dispose();
                hv_DeviceName.Dispose();
                hv_StatusLeft.Dispose();
                hv_StatusRight.Dispose();
                hv_MaxChars.Dispose();
                hv_Str.Dispose();
                hv_IsString.Dispose();
                hv_Length.Dispose();
                hv_SubStr.Dispose();
                hv_Row1.Dispose();
                hv_Column1.Dispose();
                hv_Row2.Dispose();
                hv_Column2.Dispose();
                hv_WindowTextWidth.Dispose();
                hv_WindowTextHeight.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_PlotBackground.Dispose();

                hv_EvalValuesTrain_COPY_INP_TMP.Dispose();
                hv_DisplayEnabled.Dispose();
                hv_DisplayParam.Dispose();
                hv_WindowText.Dispose();
                hv_WindowHandle.Dispose();
                hv_ChangePlotIntervalSeconds.Dispose();
                hv_LastChange.Dispose();
                hv_Seconds.Dispose();
                hv_PlotEval.Dispose();
                hv_PlotFunctionExists.Dispose();
                hv_PlotFunction.Dispose();
                hv_TextPlot.Dispose();
                hv_PlotTrainEval.Dispose();
                hv_HeadlineText.Dispose();
                hv_Indices.Dispose();
                hv_Index.Dispose();
                hv_PartRow1.Dispose();
                hv_PartColumn1.Dispose();
                hv_PartRow2.Dispose();
                hv_PartColumn2.Dispose();
                hv__.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_ClipRegionValue.Dispose();
                hv_PlotHeight.Dispose();
                hv_LegendRow.Dispose();
                hv_LegendDistanceLeft.Dispose();
                hv_LegendDistanceRight.Dispose();
                hv_PlotLearningRateStrategy.Dispose();
                hv_RightMargin.Dispose();
                hv_ChangeStrategies.Dispose();
                hv_Idx.Dispose();
                hv_ChangeStrategy.Dispose();
                hv_ChangeStrategyName.Dispose();
                hv_ChangeStrategiesValues.Dispose();
                hv_ChangeStrategiesInitial.Dispose();
                hv_StrategyMin.Dispose();
                hv_StrategyMax.Dispose();
                hv_LogLRMin.Dispose();
                hv_LogLRMax.Dispose();
                hv_LRScale.Dispose();
                hv_LROffset.Dispose();
                hv_LogLROffset.Dispose();
                hv_StartYLearningRate.Dispose();
                hv_EndYLearningRate.Dispose();
                hv_TicksYLearningRate.Dispose();
                hv_LogYLearningRate.Dispose();
                hv_LRColor.Dispose();
                hv_LRLineWidth.Dispose();
                hv_LRTextLegend.Dispose();
                hv_TopMarginPlots.Dispose();
                hv_NumIterationsPerEpoch.Dispose();
                hv_Iterations.Dispose();
                hv_NumEpochs.Dispose();
                hv_NumIterations.Dispose();
                hv_CurrentIteration.Dispose();
                hv_XAxisLabel.Dispose();
                hv_ValuesX.Dispose();
                hv_TicksX.Dispose();
                hv_EvalValuesX.Dispose();
                hv_EvalTicksX.Dispose();
                hv_TitleX.Dispose();
                hv_EvalIterations.Dispose();
                hv_EvalValuesMin.Dispose();
                hv_EvalValuesMax.Dispose();
                hv_TicksY.Dispose();
                hv_StartY.Dispose();
                hv_EndY.Dispose();
                hv_YAxisLabel.Dispose();
                hv_BestEvaluationData.Dispose();
                hv_BestEvaluationComparisonKeys.Dispose();
                hv_StringExtendsLegendRight.Dispose();
                hv_Bullet.Dispose();
                hv_Line.Dispose();
                hv_YAxisTitle.Dispose();
                hv_Offset.Dispose();
                hv_LogMin.Dispose();
                hv_LogMax.Dispose();
                hv_Scale.Dispose();
                hv_LogOffset.Dispose();
                hv_LogY.Dispose();
                hv_TextModelParams.Dispose();
                hv_ModelParams.Dispose();
                hv_StatusModelParamsLeft.Dispose();
                hv_StatusModelParamsRight.Dispose();
                hv_ParName.Dispose();
                hv_Tuple.Dispose();
                hv_Exception.Dispose();
                hv_TupleStr.Dispose();
                hv_StatusEvaluationLeft.Dispose();
                hv_StatusEvaluationRight.Dispose();
                hv_BestEvaluationValue.Dispose();
                hv_BestEvaluationInfo.Dispose();
                hv_BestEvaluationEpoch.Dispose();
                hv_BestTrainEvaluationValue.Dispose();
                hv_BestTrainEvaluationInfo.Dispose();
                hv_BestTrainEvaluationEpoch.Dispose();
                hv_BestEvaluationComparisonKeysStr.Dispose();
                hv_StatusTrainLeft.Dispose();
                hv_StatusTrainRight.Dispose();
                hv_EpochReal.Dispose();
                hv_MeanLoss.Dispose();
                hv_MeanLossStr.Dispose();
                hv_TimeElapsedExists.Dispose();
                hv_StartEpoch.Dispose();
                hv_StartTime.Dispose();
                hv_SecondsElapsed.Dispose();
                hv_SecondsRemaining.Dispose();
                hv_ProgressPercent.Dispose();
                hv_ProgressPerSecond.Dispose();
                hv_TimeElapsedString.Dispose();
                hv_TimeRemainingString.Dispose();
                hv_StatusDeviceLeft.Dispose();
                hv_StatusDeviceRight.Dispose();
                hv_DeviceNameExists.Dispose();
                hv_DeviceName.Dispose();
                hv_StatusLeft.Dispose();
                hv_StatusRight.Dispose();
                hv_MaxChars.Dispose();
                hv_Str.Dispose();
                hv_IsString.Dispose();
                hv_Length.Dispose();
                hv_SubStr.Dispose();
                hv_Row1.Dispose();
                hv_Column1.Dispose();
                hv_Row2.Dispose();
                hv_Column2.Dispose();
                hv_WindowTextWidth.Dispose();
                hv_WindowTextHeight.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: Display a map of weights. 
        private void dev_display_weight_regions(HObject ho_ImageWeight, HTuple hv_DrawTransparency,
            HTuple hv_SegMaxWeight, out HTuple hv_Colors)
        {




            // Local iconic variables 

            HObject ho_Domain, ho_WeightsRegion = null;

            // Local control variables 

            HTuple hv_NumColors = new HTuple(), hv_WeightsColorsAlpha = new HTuple();
            HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
            HTuple hv_GrayVal = new HTuple(), hv_GrayValWeight = new HTuple();
            HTuple hv_ColorIndex = new HTuple(), hv_ClassColor = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Domain);
            HOperatorSet.GenEmptyObj(out ho_WeightsRegion);
            hv_Colors = new HTuple();
            try
            {
                //
                //This procedure displays a map of the weights
                //given in ImageWeight as regions.
                //The transparency can be adjusted.
                //The used colors are returned.
                //
                //Define colors.
                hv_NumColors.Dispose();
                hv_NumColors = 20;
                hv_Colors.Dispose();
                get_distinct_colors(hv_NumColors, 0, 0, 160, out hv_Colors);
                {
                    HTuple ExpTmpOutVar_0;
                    HOperatorSet.TupleInverse(hv_Colors, out ExpTmpOutVar_0);
                    hv_Colors.Dispose();
                    hv_Colors = ExpTmpOutVar_0;
                }
                hv_WeightsColorsAlpha.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WeightsColorsAlpha = hv_Colors + hv_DrawTransparency;
                }
                //
                //Get gay values of ImageWeight.
                ho_Domain.Dispose();
                HOperatorSet.GetDomain(ho_ImageWeight, out ho_Domain);
                hv_Rows.Dispose(); hv_Columns.Dispose();
                HOperatorSet.GetRegionPoints(ho_Domain, out hv_Rows, out hv_Columns);
                hv_GrayVal.Dispose();
                HOperatorSet.GetGrayval(ho_ImageWeight, hv_Rows, hv_Columns, out hv_GrayVal);
                //
                //Check that the gray values of the image
                //are below the specified maximum.
                if ((int)(new HTuple(((hv_GrayVal.TupleMax())).TupleGreater(hv_SegMaxWeight))) != 0)
                {
                    throw new HalconException(((("The maximum weight (" + (hv_GrayVal.TupleMax()
                        )) + ") in the weight image is greater than the given SegMaxWeight (") + hv_SegMaxWeight) + ").");
                }
                //
                while ((int)(new HTuple(hv_GrayVal.TupleNotEqual(new HTuple()))) != 0)
                {
                    //Go through all gray value 'groups',
                    //starting from the maximum.
                    hv_GrayValWeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_GrayValWeight = hv_GrayVal.TupleMax()
                            ;
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_GrayVal = hv_GrayVal.TupleRemove(
                                hv_GrayVal.TupleFind(hv_GrayValWeight));
                            hv_GrayVal.Dispose();
                            hv_GrayVal = ExpTmpLocalVar_GrayVal;
                        }
                    }
                    ho_WeightsRegion.Dispose();
                    HOperatorSet.Threshold(ho_ImageWeight, out ho_WeightsRegion, hv_GrayValWeight,
                        hv_GrayValWeight);
                    //
                    //Visualize the respective group.
                    hv_ColorIndex.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ColorIndex = (((((hv_GrayValWeight / hv_SegMaxWeight) * (hv_NumColors - 1))).TupleCeil()
                            )).TupleInt();
                    }
                    hv_ClassColor.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassColor = hv_WeightsColorsAlpha.TupleSelect(
                            hv_ColorIndex);
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_ClassColor);
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_WeightsRegion, HDevWindowStack.GetActive());
                    }
                }
                ho_Domain.Dispose();
                ho_WeightsRegion.Dispose();

                hv_NumColors.Dispose();
                hv_WeightsColorsAlpha.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_GrayVal.Dispose();
                hv_GrayValWeight.Dispose();
                hv_ColorIndex.Dispose();
                hv_ClassColor.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Domain.Dispose();
                ho_WeightsRegion.Dispose();

                hv_NumColors.Dispose();
                hv_WeightsColorsAlpha.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_GrayVal.Dispose();
                hv_GrayValWeight.Dispose();
                hv_ColorIndex.Dispose();
                hv_ClassColor.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Develop
        // Short Description: Open a new graphics window that preserves the aspect ratio of the given image size. 
        public void dev_open_window_fit_size(HTuple hv_Row, HTuple hv_Column, HTuple hv_Width,
            HTuple hv_Height, HTuple hv_WidthLimit, HTuple hv_HeightLimit, out HTuple hv_WindowHandle)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_MinWidth = new HTuple(), hv_MaxWidth = new HTuple();
            HTuple hv_MinHeight = new HTuple(), hv_MaxHeight = new HTuple();
            HTuple hv_ResizeFactor = new HTuple(), hv_TempWidth = new HTuple();
            HTuple hv_TempHeight = new HTuple(), hv_WindowWidth = new HTuple();
            HTuple hv_WindowHeight = new HTuple();
            // Initialize local and output iconic variables 
            hv_WindowHandle = new HTuple();
            try
            {
                //This procedure open a new graphic window
                //such that it fits into the limits specified by WidthLimit
                //and HeightLimit, but also maintains the correct aspect ratio
                //given by Width and Height.
                //
                //If it is impossible to match the minimum and maximum extent requirements
                //at the same time (f.e. if the image is very long but narrow),
                //the maximum value gets a higher priority.
                //
                //Parse input tuple WidthLimit
                if ((int)((new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_WidthLimit.TupleLess(0)))) != 0)
                {
                    hv_MinWidth.Dispose();
                    hv_MinWidth = 500;
                    hv_MaxWidth.Dispose();
                    hv_MaxWidth = 800;
                }
                else if ((int)(new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
                    1))) != 0)
                {
                    hv_MinWidth.Dispose();
                    hv_MinWidth = 0;
                    hv_MaxWidth.Dispose();
                    hv_MaxWidth = new HTuple(hv_WidthLimit);
                }
                else
                {
                    hv_MinWidth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MinWidth = hv_WidthLimit.TupleSelect(
                            0);
                    }
                    hv_MaxWidth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxWidth = hv_WidthLimit.TupleSelect(
                            1);
                    }
                }
                //Parse input tuple HeightLimit
                if ((int)((new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_HeightLimit.TupleLess(0)))) != 0)
                {
                    hv_MinHeight.Dispose();
                    hv_MinHeight = 400;
                    hv_MaxHeight.Dispose();
                    hv_MaxHeight = 600;
                }
                else if ((int)(new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
                    1))) != 0)
                {
                    hv_MinHeight.Dispose();
                    hv_MinHeight = 0;
                    hv_MaxHeight.Dispose();
                    hv_MaxHeight = new HTuple(hv_HeightLimit);
                }
                else
                {
                    hv_MinHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MinHeight = hv_HeightLimit.TupleSelect(
                            0);
                    }
                    hv_MaxHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxHeight = hv_HeightLimit.TupleSelect(
                            1);
                    }
                }
                //
                //Test, if window size has to be changed.
                hv_ResizeFactor.Dispose();
                hv_ResizeFactor = 1;
                //First, expand window to the minimum extents (if necessary).
                if ((int)((new HTuple(hv_MinWidth.TupleGreater(hv_Width))).TupleOr(new HTuple(hv_MinHeight.TupleGreater(
                    hv_Height)))) != 0)
                {
                    hv_ResizeFactor.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ResizeFactor = (((((hv_MinWidth.TupleReal()
                            ) / hv_Width)).TupleConcat((hv_MinHeight.TupleReal()) / hv_Height))).TupleMax()
                            ;
                    }
                }
                hv_TempWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TempWidth = hv_Width * hv_ResizeFactor;
                }
                hv_TempHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TempHeight = hv_Height * hv_ResizeFactor;
                }
                //Then, shrink window to maximum extents (if necessary).
                if ((int)((new HTuple(hv_MaxWidth.TupleLess(hv_TempWidth))).TupleOr(new HTuple(hv_MaxHeight.TupleLess(
                    hv_TempHeight)))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResizeFactor = hv_ResizeFactor * ((((((hv_MaxWidth.TupleReal()
                                ) / hv_TempWidth)).TupleConcat((hv_MaxHeight.TupleReal()) / hv_TempHeight))).TupleMin()
                                );
                            hv_ResizeFactor.Dispose();
                            hv_ResizeFactor = ExpTmpLocalVar_ResizeFactor;
                        }
                    }
                }
                hv_WindowWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowWidth = hv_Width * hv_ResizeFactor;
                }
                hv_WindowHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowHeight = hv_Height * hv_ResizeFactor;
                }
                //Resize window
                HOperatorSet.SetWindowAttr("background_color", "black");
                HOperatorSet.OpenWindow(hv_Row, hv_Column, hv_WindowWidth, hv_WindowHeight, 0, "visible", "", out hv_WindowHandle);//显示图像窗口
                HDevWindowStack.Push(hv_WindowHandle);
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_Height - 1, hv_Width - 1);
                    }
                }

                hv_MinWidth.Dispose();
                hv_MaxWidth.Dispose();
                hv_MinHeight.Dispose();
                hv_MaxHeight.Dispose();
                hv_ResizeFactor.Dispose();
                hv_TempWidth.Dispose();
                hv_TempHeight.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_MinWidth.Dispose();
                hv_MaxWidth.Dispose();
                hv_MinHeight.Dispose();
                hv_MaxHeight.Dispose();
                hv_ResizeFactor.Dispose();
                hv_TempWidth.Dispose();
                hv_TempHeight.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Develop
        // Short Description: Resizes a graphics window with a given maximum extent such that it preserves the aspect ratio of a given width and height 
        public void dev_resize_window_fit_size(HTuple hv_Row, HTuple hv_Column, HTuple hv_Width,
            HTuple hv_Height, HTuple hv_WidthLimit, HTuple hv_HeightLimit)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_MinWidth = new HTuple(), hv_MaxWidth = new HTuple();
            HTuple hv_MinHeight = new HTuple(), hv_MaxHeight = new HTuple();
            HTuple hv_ResizeFactor = new HTuple(), hv_TempWidth = new HTuple();
            HTuple hv_TempHeight = new HTuple(), hv_WindowWidth = new HTuple();
            HTuple hv_WindowHeight = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure adjusts the size of the current window
                //such that it fits into the limits specified by WidthLimit
                //and HeightLimit, but also maintains the correct aspect ratio
                //given by Width and Height.
                //
                //If it is impossible to match the minimum and maximum extent requirements
                //at the same time (f.e. if the image is very long but narrow),
                //the maximum value gets a higher priority.
                //
                //Parse input tuple WidthLimit
                if ((int)((new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_WidthLimit.TupleLess(0)))) != 0)
                {
                    hv_MinWidth.Dispose();
                    hv_MinWidth = 500;
                    hv_MaxWidth.Dispose();
                    hv_MaxWidth = 800;
                }
                else if ((int)(new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
                    1))) != 0)
                {
                    hv_MinWidth.Dispose();
                    hv_MinWidth = 0;
                    hv_MaxWidth.Dispose();
                    hv_MaxWidth = new HTuple(hv_WidthLimit);
                }
                else
                {
                    hv_MinWidth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MinWidth = hv_WidthLimit.TupleSelect(
                            0);
                    }
                    hv_MaxWidth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxWidth = hv_WidthLimit.TupleSelect(
                            1);
                    }
                }
                //Parse input tuple HeightLimit
                if ((int)((new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_HeightLimit.TupleLess(0)))) != 0)
                {
                    hv_MinHeight.Dispose();
                    hv_MinHeight = 400;
                    hv_MaxHeight.Dispose();
                    hv_MaxHeight = 600;
                }
                else if ((int)(new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
                    1))) != 0)
                {
                    hv_MinHeight.Dispose();
                    hv_MinHeight = 0;
                    hv_MaxHeight.Dispose();
                    hv_MaxHeight = new HTuple(hv_HeightLimit);
                }
                else
                {
                    hv_MinHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MinHeight = hv_HeightLimit.TupleSelect(
                            0);
                    }
                    hv_MaxHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxHeight = hv_HeightLimit.TupleSelect(
                            1);
                    }
                }
                //
                //Test, if window size has to be changed.
                hv_ResizeFactor.Dispose();
                hv_ResizeFactor = 1;
                //First, expand window to the minimum extents (if necessary).
                if ((int)((new HTuple(hv_MinWidth.TupleGreater(hv_Width))).TupleOr(new HTuple(hv_MinHeight.TupleGreater(
                    hv_Height)))) != 0)
                {
                    hv_ResizeFactor.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ResizeFactor = (((((hv_MinWidth.TupleReal()
                            ) / hv_Width)).TupleConcat((hv_MinHeight.TupleReal()) / hv_Height))).TupleMax()
                            ;
                    }
                }
                hv_TempWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TempWidth = hv_Width * hv_ResizeFactor;
                }
                hv_TempHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TempHeight = hv_Height * hv_ResizeFactor;
                }
                //Then, shrink window to maximum extents (if necessary).
                if ((int)((new HTuple(hv_MaxWidth.TupleLess(hv_TempWidth))).TupleOr(new HTuple(hv_MaxHeight.TupleLess(
                    hv_TempHeight)))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResizeFactor = hv_ResizeFactor * ((((((hv_MaxWidth.TupleReal()
                                ) / hv_TempWidth)).TupleConcat((hv_MaxHeight.TupleReal()) / hv_TempHeight))).TupleMin()
                                );
                            hv_ResizeFactor.Dispose();
                            hv_ResizeFactor = ExpTmpLocalVar_ResizeFactor;
                        }
                    }
                }
                hv_WindowWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowWidth = hv_Width * hv_ResizeFactor;
                }
                hv_WindowHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowHeight = hv_Height * hv_ResizeFactor;
                }
                //Resize window
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_Row, hv_Column,
                        hv_WindowWidth, hv_WindowHeight);
                }
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_Height - 1, hv_Width - 1);
                    }
                }

                hv_MinWidth.Dispose();
                hv_MaxWidth.Dispose();
                hv_MinHeight.Dispose();
                hv_MaxHeight.Dispose();
                hv_ResizeFactor.Dispose();
                hv_TempWidth.Dispose();
                hv_TempHeight.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_MinWidth.Dispose();
                hv_MaxWidth.Dispose();
                hv_MinHeight.Dispose();
                hv_MaxHeight.Dispose();
                hv_ResizeFactor.Dispose();
                hv_TempWidth.Dispose();
                hv_TempHeight.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Develop
        // Short Description: Switch dev_update_pc, dev_update_var and dev_update_window to 'off'. 
        public void dev_update_off()
        {

            // Initialize local and output iconic variables 
            //This procedure sets different update settings to 'off'.
            //This is useful to get the best performance and reduce overhead.
            //
            // dev_update_pc(...); only in hdevelop
            // dev_update_var(...); only in hdevelop
            // dev_update_window(...); only in hdevelop


            return;
        }

        // Chapter: Time
        // Short Description: Estimate the remaining time for a task given the current progress. 
        public void estimate_progress(HTuple hv_SecondsStart, HTuple hv_ProgressMin, HTuple hv_ProgressCurrent,
            HTuple hv_ProgressMax, out HTuple hv_SecondsElapsed, out HTuple hv_SecondsRemaining,
            out HTuple hv_ProgressPercent, out HTuple hv_ProgressPerSecond)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_SecondsNow = new HTuple(), hv_Epsilon = new HTuple();
            HTuple hv_ProgressRemaining = new HTuple();
            // Initialize local and output iconic variables 
            hv_SecondsElapsed = new HTuple();
            hv_SecondsRemaining = new HTuple();
            hv_ProgressPercent = new HTuple();
            hv_ProgressPerSecond = new HTuple();
            try
            {
                //
                //This procedure estimates the remaining time in seconds,
                //given a start time and a progress value.
                //
                //Get current time.
                hv_SecondsNow.Dispose();
                HOperatorSet.CountSeconds(out hv_SecondsNow);
                //
                //Get elapsed time span.
                hv_SecondsElapsed.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SecondsElapsed = hv_SecondsNow - hv_SecondsStart;
                }
                //
                //A very small additive constant to avoid division by zero.
                hv_Epsilon.Dispose();
                hv_Epsilon = 1e-6;
                //
                //Estimate remaining time based on elapsed time.
                hv_ProgressRemaining.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ProgressRemaining = hv_ProgressMax - hv_ProgressCurrent;
                }
                hv_ProgressPerSecond.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ProgressPerSecond = (((hv_ProgressCurrent - hv_ProgressMin)).TupleReal()
                        ) / ((hv_SecondsElapsed.TupleReal()) + hv_Epsilon);
                }
                hv_SecondsRemaining.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SecondsRemaining = hv_ProgressRemaining / (hv_ProgressPerSecond + hv_Epsilon);
                }
                //
                //Get current progress in percent.
                hv_ProgressPercent.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ProgressPercent = (100 * (((hv_ProgressCurrent - hv_ProgressMin)).TupleReal()
                        )) / ((((hv_ProgressMax - hv_ProgressMin)).TupleReal()) + hv_Epsilon);
                }

                hv_SecondsNow.Dispose();
                hv_Epsilon.Dispose();
                hv_ProgressRemaining.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_SecondsNow.Dispose();
                hv_Epsilon.Dispose();
                hv_ProgressRemaining.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Evaluate the model given by DLModelHandle on the selected samples of DLDataset. 
        public void evaluate_dl_model(HTuple hv_DLDataset, HTuple hv_DLModelHandle, HTuple hv_SampleSelectMethod,
            HTuple hv_SampleSelectValues, HTuple hv_GenParam, out HTuple hv_EvaluationResult,
            out HTuple hv_EvalParams)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ModelType = new HTuple(), hv_ClassIDs = new HTuple();
            HTuple hv_BatchSize = new HTuple(), hv_InstanceType = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_IgnoreDirection = new HTuple();
            HTuple hv_Measures = new HTuple(), hv_ModelIgnoreClassIDs = new HTuple();
            HTuple hv_ShowProgress = new HTuple(), hv_GenParamKeys = new HTuple();
            HTuple hv_GenParamIndex = new HTuple(), hv_EvaluationType = new HTuple();
            HTuple hv_NumClasses = new HTuple(), hv_EvaluateInstances = new HTuple();
            HTuple hv_IoUThreshold = new HTuple(), hv_MaxNumDetections = new HTuple();
            HTuple hv_AreaRanges = new HTuple(), hv_DetailedEvaluation = new HTuple();
            HTuple hv_AllocationBlockLength = new HTuple(), hv_IgnoreClassIDs = new HTuple();
            HTuple hv_AllIgnoreClassIDs = new HTuple(), hv_EvaluateClassIDs = new HTuple();
            HTuple hv_ClassesToEvaluate = new HTuple(), hv_ClassNames = new HTuple();
            HTuple hv_KeyExists = new HTuple(), hv_ClassIDsToEvaluate = new HTuple();
            HTuple hv_AnomalyClassificationThresholds = new HTuple();
            HTuple hv_ClassInfoExists = new HTuple(), hv_DatasetClassIDs = new HTuple();
            HTuple hv_ClassIDsToClassNames = new HTuple(), hv_EvaluateClassNames = new HTuple();
            HTuple hv_DLSamples = new HTuple(), hv_SampleIndices = new HTuple();
            HTuple hv_NumSamples = new HTuple(), hv_NumBatches = new HTuple();
            HTuple hv_RunningMeasures = new HTuple(), hv_Progress = new HTuple();
            HTuple hv_TaskInfo = new HTuple(), hv_SecondsStart = new HTuple();
            HTuple hv_BatchIndex = new HTuple(), hv_BatchStart = new HTuple();
            HTuple hv_BatchEnd = new HTuple(), hv_SamplesIndicesBatch = new HTuple();
            HTuple hv_DLSamplesBatch = new HTuple(), hv_DLResultsBatch = new HTuple();
            HTuple hv_SecondsElapsed = new HTuple(), hv_SecondsRemaining = new HTuple();
            HTuple hv_ProgressPercent = new HTuple(), hv_ProgressPerSecond = new HTuple();
            HTuple hv_TimeElapsedString = new HTuple(), hv_TimeRemainingString = new HTuple();
            // Initialize local and output iconic variables 
            hv_EvaluationResult = new HTuple();
            hv_EvalParams = new HTuple();
            try
            {
                //This procedure applies the model given by DLModelHandle on the selected samples
                //of DLDataset and evaluates the results against the ground truth annotations
                //to calculate evaluation measures.
                //
                //Input:
                // - DLDataset.
                // - DLModelHandle.
                // - SampleSelectMethod: Method by which the samples are selected.
                // - SampleSelectValues: Identifier used to retrieve the samples from the DLDataset
                //                       for the corresponding selection method.
                // - GenParam: Parameters of the evaluation that should be changed from the default.
                //
                //Output:
                // - EvaluationResult: Dictionary containing the output measures.
                // - EvalParams: Dictionary with the used evaluation parameters.
                //
                //** Initialization: ***
                //
                hv_ModelType.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "type", out hv_ModelType);
                if ((int)((new HTuple((new HTuple((new HTuple(hv_ModelType.TupleNotEqual("anomaly_detection"))).TupleAnd(
                    new HTuple(hv_ModelType.TupleNotEqual("classification"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual(
                    "detection"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual("segmentation")))) != 0)
                {
                    throw new HalconException("Unknown model type");
                }
                //
                //Get the class IDs as set in the model.
                if ((int)(new HTuple(hv_ModelType.TupleEqual("anomaly_detection"))) != 0)
                {
                    //Default for anomaly detection is 0,1.
                    hv_ClassIDs.Dispose();
                    hv_ClassIDs = new HTuple();
                    hv_ClassIDs[0] = 0;
                    hv_ClassIDs[1] = 1;
                }
                else
                {
                    hv_ClassIDs.Dispose();
                    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "class_ids", out hv_ClassIDs);
                }
                //
                //Get the batch size as set in the model.
                hv_BatchSize.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "batch_size", out hv_BatchSize);
                //
                //Generate default parameters.
                hv_EvalParams.Dispose();
                create_evaluation_default_param(hv_ModelType, hv_ClassIDs, out hv_EvalParams);
                //
                //Get model specific information.
                if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
                {
                    try
                    {
                        hv_InstanceType.Dispose();
                        HOperatorSet.GetDlModelParam(hv_DLModelHandle, "instance_type", out hv_InstanceType);
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException1)
                    {
                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        hv_InstanceType.Dispose();
                        hv_InstanceType = "rectangle1";
                    }
                    //Overwrite the instance_type.
                    HOperatorSet.SetDictTuple(hv_EvalParams, "instance_type", hv_InstanceType);
                    //For rectangle2 detection with ignore_direction set to false, we also evaluate the
                    //precision of the predicted angle using the Score of Angle Precision (SoAP).
                    if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
                    {
                        hv_IgnoreDirection.Dispose();
                        HOperatorSet.GetDlModelParam(hv_DLModelHandle, "ignore_direction", out hv_IgnoreDirection);
                        if ((int)(new HTuple(hv_IgnoreDirection.TupleEqual("false"))) != 0)
                        {
                            hv_Measures.Dispose();
                            HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_EvalParams, "measures", hv_Measures.TupleConcat(
                                    "soap"));
                            }
                        }
                    }
                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("segmentation"))) != 0)
                {
                    hv_ModelIgnoreClassIDs.Dispose();
                    HOperatorSet.GetDlModelParam(hv_DLModelHandle, "ignore_class_ids", out hv_ModelIgnoreClassIDs);
                }
                //
                //By default we do not show the progress of evaluation.
                hv_ShowProgress.Dispose();
                hv_ShowProgress = 0;
                //
                //Set user specified parameters.
                if ((int)(new HTuple(hv_GenParam.TupleNotEqual(new HTuple()))) != 0)
                {
                    hv_GenParamKeys.Dispose();
                    HOperatorSet.GetDictParam(hv_GenParam, "keys", new HTuple(), out hv_GenParamKeys);
                    for (hv_GenParamIndex = 0; (int)hv_GenParamIndex <= (int)((new HTuple(hv_GenParamKeys.TupleLength()
                        )) - 1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
                    {
                        if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "measures"))) != 0)
                        {
                            //Set measures.
                            hv_Measures.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "measures", out hv_Measures);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "measures", hv_Measures);
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "evaluation_type"))) != 0)
                        {
                            //Set evaluation type.
                            hv_EvaluationType.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "evaluation_type", out hv_EvaluationType);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "evaluation_type", hv_EvaluationType);
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "class_ids"))) != 0)
                        {
                            //Set class ids.
                            hv_ClassIDs.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "class_ids", out hv_ClassIDs);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "class_ids", hv_ClassIDs);
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "num_classes"))) != 0)
                        {
                            //Set number of classes.
                            hv_NumClasses.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "num_classes", out hv_NumClasses);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "num_classes", hv_NumClasses);
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "evaluate_instances"))) != 0)
                        {
                            //Set boolean for instance-based evaluation.
                            hv_EvaluateInstances.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "evaluate_instances", out hv_EvaluateInstances);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "evaluate_instances", hv_EvaluateInstances);
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "show_progress"))) != 0)
                        {
                            //Show the progress of the evaluation.
                            hv_ShowProgress.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "show_progress", out hv_ShowProgress);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ShowProgress = (new HTuple(hv_ShowProgress.TupleEqual(
                                        "true"))).TupleOr(new HTuple(hv_ShowProgress.TupleEqual(1)));
                                    hv_ShowProgress.Dispose();
                                    hv_ShowProgress = ExpTmpLocalVar_ShowProgress;
                                }
                            }
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "iou_threshold"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual("detection")))) != 0)
                        {
                            //Set IoU threshold.
                            hv_IoUThreshold.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "iou_threshold", out hv_IoUThreshold);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "iou_threshold", hv_IoUThreshold);
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "max_num_detections"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual(
                            "detection")))) != 0)
                        {
                            //Set maximal number detections.
                            hv_MaxNumDetections.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "max_num_detections", out hv_MaxNumDetections);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "max_num_detections", hv_MaxNumDetections);
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "area_ranges"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual("detection")))) != 0)
                        {
                            //Set area ranges.
                            hv_AreaRanges.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "area_ranges", out hv_AreaRanges);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "area_ranges", hv_AreaRanges);
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "detailed_evaluation"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual(
                            "detection")))) != 0)
                        {
                            //Set detailed evaluation.
                            hv_DetailedEvaluation.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "detailed_evaluation", out hv_DetailedEvaluation);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "detailed_evaluation", hv_DetailedEvaluation);
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "allocation_block_length"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual(
                            "detection")))) != 0)
                        {
                            //Set length of blocks that are allocated during evaluation.
                            hv_AllocationBlockLength.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "allocation_block_length", out hv_AllocationBlockLength);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "allocation_block_length", hv_AllocationBlockLength);
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "interpolate_pr_curves"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual(
                            "detection")))) != 0)
                        {
                            //Set interpolation of precision-recall curves.
                            hv_DetailedEvaluation.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "interpolate_pr_curves", out hv_DetailedEvaluation);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "interpolate_pr_curves", hv_DetailedEvaluation);
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "ignore_class_ids"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual("segmentation")))) != 0)
                        {
                            //Set ignore class IDs.
                            hv_IgnoreClassIDs.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "ignore_class_ids", out hv_IgnoreClassIDs);
                            //Merge the specified ignore class IDs with the model ignore class IDs.
                            hv_AllIgnoreClassIDs.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_AllIgnoreClassIDs = ((((hv_ModelIgnoreClassIDs.TupleConcat(
                                    hv_IgnoreClassIDs))).TupleSort())).TupleUniq();
                            }
                            HOperatorSet.SetDictTuple(hv_EvalParams, "ignore_class_ids", hv_AllIgnoreClassIDs);
                            //Remove the ignore class IDs from the model class IDs.
                            hv_EvaluateClassIDs.Dispose();
                            HOperatorSet.TupleDifference(hv_ClassIDs, hv_IgnoreClassIDs, out hv_EvaluateClassIDs);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "class_ids", hv_EvaluateClassIDs);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_EvalParams, "num_classes", new HTuple(hv_EvaluateClassIDs.TupleLength()
                                    ));
                            }
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "class_names_to_evaluate"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual(
                            "classification")))) != 0)
                        {
                            //Class names to be used in evaluation.
                            //To transform the names to IDs later, one has to remember the class names.
                            hv_ClassesToEvaluate.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "class_names_to_evaluate", out hv_ClassesToEvaluate);
                            hv_ClassNames.Dispose();
                            HOperatorSet.GetDlModelParam(hv_DLModelHandle, "class_names", out hv_ClassNames);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "class_names_to_evaluate", hv_ClassesToEvaluate);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "class_names", hv_ClassNames);
                            hv_KeyExists.Dispose();
                            HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "class_ids_to_evaluate",
                                out hv_KeyExists);
                            if ((int)(hv_KeyExists) != 0)
                            {
                                //To avoid inconsistent class names/IDs, remove the older ones.
                                HOperatorSet.RemoveDictKey(hv_EvalParams, "class_ids_to_evaluate");
                            }
                        }
                        else if ((int)((new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "class_ids_to_evaluate"))).TupleAnd(new HTuple(hv_ModelType.TupleEqual(
                            "classification")))) != 0)
                        {
                            //Class IDs to be used in evaluation.
                            hv_ClassIDsToEvaluate.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "class_ids_to_evaluate", out hv_ClassIDsToEvaluate);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "class_ids_to_evaluate", hv_ClassIDsToEvaluate);
                            hv_KeyExists.Dispose();
                            HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "class_names_to_evaluate",
                                out hv_KeyExists);
                            if ((int)(hv_KeyExists) != 0)
                            {
                                //To avoid inconsistent class names/IDs, remove the older ones.
                                HOperatorSet.RemoveDictKey(hv_EvalParams, "class_names_to_evaluate");
                            }
                        }
                        else if ((int)(new HTuple(((hv_GenParamKeys.TupleSelect(hv_GenParamIndex))).TupleEqual(
                            "anomaly_classification_thresholds"))) != 0)
                        {
                            //Set anomaly classification threshold for confusion matrices.
                            hv_AnomalyClassificationThresholds.Dispose();
                            HOperatorSet.GetDictTuple(hv_GenParam, "anomaly_classification_thresholds",
                                out hv_AnomalyClassificationThresholds);
                            HOperatorSet.SetDictTuple(hv_EvalParams, "anomaly_classification_thresholds",
                                hv_AnomalyClassificationThresholds);
                        }
                        else
                        {
                            throw new HalconException(("Unknown parameter : '" + (hv_GenParamKeys.TupleSelect(
                                hv_GenParamIndex))) + "'");
                        }
                    }
                }
                //
                //Get the class names from the dataset if present.
                hv_ClassInfoExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLDataset, "key_exists", (new HTuple("class_names")).TupleConcat(
                    "class_ids"), out hv_ClassInfoExists);
                if ((int)(new HTuple(((hv_ClassInfoExists.TupleSum())).TupleEqual(new HTuple(hv_ClassInfoExists.TupleLength()
                    )))) != 0)
                {
                    hv_ClassNames.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLDataset, "class_names", out hv_ClassNames);
                    hv_DatasetClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLDataset, "class_ids", out hv_DatasetClassIDs);
                    //Set the class names only for the class IDs that are evaluated.
                    hv_EvaluateClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_EvaluateClassIDs);
                    hv_ClassIDsToClassNames.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassIDsToClassNames = HTuple.TupleGenConst(
                            (hv_DatasetClassIDs.TupleMax()) + 1, "");
                    }
                    if (hv_ClassIDsToClassNames == null)
                        hv_ClassIDsToClassNames = new HTuple();
                    hv_ClassIDsToClassNames[hv_DatasetClassIDs] = hv_ClassNames;
                    hv_EvaluateClassNames.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_EvaluateClassNames = hv_ClassIDsToClassNames.TupleSelect(
                            hv_EvaluateClassIDs);
                    }
                    //Set the class names to EvalParams.
                    HOperatorSet.SetDictTuple(hv_EvalParams, "class_names", hv_EvaluateClassNames);
                }
                //
                //Get indices of samples to read from the dataset.
                hv_DLSamples.Dispose();
                HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLSamples);
                //
                //Check if there are samples present in the dataset.
                if ((int)(new HTuple((new HTuple(hv_DLSamples.TupleLength())).TupleEqual(0))) != 0)
                {
                    throw new HalconException("The provided set of samples in the dataset must be non-empty.");
                }
                //
                //Check for empty SampleSelectValues.
                if ((int)(new HTuple((new HTuple(hv_SampleSelectValues.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    if ((int)(new HTuple(hv_SampleSelectMethod.TupleEqual("image_ids"))) != 0)
                    {
                        throw new HalconException("The provided set of samples of the 'image_ids' selection must be non-empty.");
                    }
                    else if ((int)(new HTuple(hv_SampleSelectMethod.TupleEqual("sample_indices"))) != 0)
                    {
                        throw new HalconException("The provided set of samples of the 'sample_indices' selection must be non-empty.");
                    }
                    else
                    {
                        throw new HalconException("Provide a name for 'split' selection.");
                    }
                }
                //
                //
                //Get the sample indices according to the sample selection method.
                hv_SampleIndices.Dispose();
                hv_SampleIndices = new HTuple();
                if ((int)(new HTuple(hv_SampleSelectMethod.TupleEqual("split"))) != 0)
                {
                    //Get the samples of the split specified.
                    hv_SampleIndices.Dispose();
                    find_dl_samples(hv_DLSamples, "split", hv_SampleSelectValues, "or", out hv_SampleIndices);
                }
                else if ((int)(new HTuple(hv_SampleSelectMethod.TupleEqual("image_ids"))) != 0)
                {
                    //Get the samples specified by 'image_ids'.
                    if ((int)(new HTuple((new HTuple(hv_SampleSelectValues.TupleLength())).TupleGreater(
                        new HTuple(hv_DLSamples.TupleLength())))) != 0)
                    {
                        throw new HalconException("The number of the image ids provided through 'image_id' is invalid.");
                    }
                    hv_SampleIndices.Dispose();
                    find_dl_samples(hv_DLSamples, "image_id", hv_SampleSelectValues, "or", out hv_SampleIndices);
                }
                else if ((int)(new HTuple(hv_SampleSelectMethod.TupleEqual("sample_indices"))) != 0)
                {
                    //Get the samples specified by 'sample_indices'.
                    if ((int)((new HTuple(((hv_SampleSelectValues.TupleMin())).TupleLess(0))).TupleOr(
                        new HTuple(((hv_SampleSelectValues.TupleMax())).TupleGreater((new HTuple(hv_DLSamples.TupleLength()
                        )) - 1)))) != 0)
                    {
                        throw new HalconException("The range of the indices provided through 'sample_indices' is invalid.");
                    }
                    hv_SampleIndices.Dispose();
                    hv_SampleIndices = new HTuple(hv_SampleSelectValues);
                }
                else
                {
                    throw new HalconException(("Unknown sample selection method : '" + hv_SampleSelectMethod) + "'");
                }
                //
                //Get the number of batches.
                hv_NumSamples.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumSamples = new HTuple(hv_SampleIndices.TupleLength()
                        );
                }
                hv_NumBatches.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumBatches = ((((hv_NumSamples / (hv_BatchSize.TupleReal()
                        ))).TupleCeil())).TupleInt();
                }
                //
                //Check for empty samples selected by the selection method.
                if ((int)(new HTuple(hv_NumSamples.TupleEqual(0))) != 0)
                {
                    throw new HalconException(("No samples present in the dataset that are part of the '" + hv_SampleSelectMethod) + "' selection.");
                }
                //
                //
                //** Running measures are initialized according to evaluation method.
                //
                hv_RunningMeasures.Dispose();
                init_running_evaluation_measures(hv_EvalParams, out hv_RunningMeasures);
                //
                //
                //** Apply model to each image and gather evaluation information: ***
                //
                //Initialize progress variables.
                if ((int)(hv_ShowProgress) != 0)
                {
                    hv_Progress.Dispose();
                    hv_Progress = new HTuple();
                    hv_Progress[0] = "Procedure: evaluate_dl_model";
                    hv_Progress[1] = "";
                    hv_Progress[2] = "";
                    hv_Progress[3] = "";
                    if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
                    {
                        hv_TaskInfo.Dispose();
                        hv_TaskInfo = "Task: 1/2: Applying the model and collecting running evaluation measures";
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Progress = hv_Progress.TupleConcat(
                                    hv_TaskInfo);
                                hv_Progress.Dispose();
                                hv_Progress = ExpTmpLocalVar_Progress;
                            }
                        }
                    }
                    hv_SecondsStart.Dispose();
                    HOperatorSet.CountSeconds(out hv_SecondsStart);
                    // dev_inspect_ctrl(...); only in hdevelop
                }
                //
                //Loop batchwise over the samples to be evaluated.
                HTuple end_val239 = hv_NumBatches - 1;
                HTuple step_val239 = 1;
                for (hv_BatchIndex = 0; hv_BatchIndex.Continue(end_val239, step_val239); hv_BatchIndex = hv_BatchIndex.TupleAdd(step_val239))
                {
                    hv_BatchStart.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BatchStart = hv_BatchIndex * hv_BatchSize;
                    }
                    hv_BatchEnd.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BatchEnd = (((hv_BatchStart + hv_BatchSize) - 1)).TupleMin2(
                            hv_NumSamples - 1);
                    }
                    hv_SamplesIndicesBatch.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SamplesIndicesBatch = hv_SampleIndices.TupleSelectRange(
                            hv_BatchStart, hv_BatchEnd);
                    }
                    //
                    //Read samples
                    hv_DLSamplesBatch.Dispose();
                    read_dl_samples(hv_DLDataset, hv_SamplesIndicesBatch, out hv_DLSamplesBatch);
                    //
                    //Apply the model.
                    hv_DLResultsBatch.Dispose();
                    HOperatorSet.ApplyDlModel(hv_DLModelHandle, hv_DLSamplesBatch, new HTuple(),
                        out hv_DLResultsBatch);
                    //
                    //Update the running measures.
                    update_running_evaluation_measures(hv_DLSamplesBatch, hv_DLResultsBatch,
                        hv_EvalParams, hv_RunningMeasures);
                    //
                    //Provide progress information.
                    if ((int)(hv_ShowProgress) != 0)
                    {
                        if ((int)((new HTuple(((hv_BatchIndex % 10)).TupleEqual(1))).TupleOr(new HTuple(hv_BatchIndex.TupleEqual(
                            hv_NumBatches - 1)))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_SecondsElapsed.Dispose(); hv_SecondsRemaining.Dispose(); hv_ProgressPercent.Dispose(); hv_ProgressPerSecond.Dispose();
                                estimate_progress(hv_SecondsStart, 0, hv_BatchIndex, hv_NumBatches - 1,
                                    out hv_SecondsElapsed, out hv_SecondsRemaining, out hv_ProgressPercent,
                                    out hv_ProgressPerSecond);
                            }
                            hv_TimeElapsedString.Dispose();
                            timespan_string(hv_SecondsElapsed, "auto", out hv_TimeElapsedString);
                            hv_TimeRemainingString.Dispose();
                            timespan_string(hv_SecondsRemaining, "top2", out hv_TimeRemainingString);
                            if (hv_Progress == null)
                                hv_Progress = new HTuple();
                            hv_Progress[1] = ("Progress: " + (hv_ProgressPercent.TupleRound())) + " %";
                            if (hv_Progress == null)
                                hv_Progress = new HTuple();
                            hv_Progress[2] = "Time elapsed: " + hv_TimeElapsedString;
                            if (hv_Progress == null)
                                hv_Progress = new HTuple();
                            hv_Progress[3] = "Time left: " + hv_TimeRemainingString;
                        }
                    }
                }
                //
                //Provide progress information.
                if ((int)(hv_ShowProgress.TupleAnd(new HTuple(hv_ModelType.TupleEqual("detection")))) != 0)
                {
                    hv_Progress.Dispose();
                    hv_Progress = new HTuple();
                    hv_Progress[0] = "Procedure: evaluate_dl_model";
                    hv_Progress[1] = "";
                    hv_Progress[2] = "";
                    if (hv_Progress == null)
                        hv_Progress = new HTuple();
                    hv_Progress[1] = "Please wait...";
                    if (hv_Progress == null)
                        hv_Progress = new HTuple();
                    hv_Progress[2] = "Task: 2/2: Calculating final evaluation measures";
                }
                //
                //
                //** Do the actual calculation of measures: ***
                //
                hv_EvaluationResult.Dispose();
                calculate_evaluation_measures(hv_RunningMeasures, hv_EvalParams, out hv_EvaluationResult);
                //
                //Close progress inspect.
                if ((int)(hv_ShowProgress) != 0)
                {
                    hv_Progress.Dispose();
                    hv_Progress = "Done.";
                    // dev_close_inspect_ctrl(...); only in hdevelop
                }
                //

                hv_ModelType.Dispose();
                hv_ClassIDs.Dispose();
                hv_BatchSize.Dispose();
                hv_InstanceType.Dispose();
                hv_Exception.Dispose();
                hv_IgnoreDirection.Dispose();
                hv_Measures.Dispose();
                hv_ModelIgnoreClassIDs.Dispose();
                hv_ShowProgress.Dispose();
                hv_GenParamKeys.Dispose();
                hv_GenParamIndex.Dispose();
                hv_EvaluationType.Dispose();
                hv_NumClasses.Dispose();
                hv_EvaluateInstances.Dispose();
                hv_IoUThreshold.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_AllIgnoreClassIDs.Dispose();
                hv_EvaluateClassIDs.Dispose();
                hv_ClassesToEvaluate.Dispose();
                hv_ClassNames.Dispose();
                hv_KeyExists.Dispose();
                hv_ClassIDsToEvaluate.Dispose();
                hv_AnomalyClassificationThresholds.Dispose();
                hv_ClassInfoExists.Dispose();
                hv_DatasetClassIDs.Dispose();
                hv_ClassIDsToClassNames.Dispose();
                hv_EvaluateClassNames.Dispose();
                hv_DLSamples.Dispose();
                hv_SampleIndices.Dispose();
                hv_NumSamples.Dispose();
                hv_NumBatches.Dispose();
                hv_RunningMeasures.Dispose();
                hv_Progress.Dispose();
                hv_TaskInfo.Dispose();
                hv_SecondsStart.Dispose();
                hv_BatchIndex.Dispose();
                hv_BatchStart.Dispose();
                hv_BatchEnd.Dispose();
                hv_SamplesIndicesBatch.Dispose();
                hv_DLSamplesBatch.Dispose();
                hv_DLResultsBatch.Dispose();
                hv_SecondsElapsed.Dispose();
                hv_SecondsRemaining.Dispose();
                hv_ProgressPercent.Dispose();
                hv_ProgressPerSecond.Dispose();
                hv_TimeElapsedString.Dispose();
                hv_TimeRemainingString.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ModelType.Dispose();
                hv_ClassIDs.Dispose();
                hv_BatchSize.Dispose();
                hv_InstanceType.Dispose();
                hv_Exception.Dispose();
                hv_IgnoreDirection.Dispose();
                hv_Measures.Dispose();
                hv_ModelIgnoreClassIDs.Dispose();
                hv_ShowProgress.Dispose();
                hv_GenParamKeys.Dispose();
                hv_GenParamIndex.Dispose();
                hv_EvaluationType.Dispose();
                hv_NumClasses.Dispose();
                hv_EvaluateInstances.Dispose();
                hv_IoUThreshold.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_AllIgnoreClassIDs.Dispose();
                hv_EvaluateClassIDs.Dispose();
                hv_ClassesToEvaluate.Dispose();
                hv_ClassNames.Dispose();
                hv_KeyExists.Dispose();
                hv_ClassIDsToEvaluate.Dispose();
                hv_AnomalyClassificationThresholds.Dispose();
                hv_ClassInfoExists.Dispose();
                hv_DatasetClassIDs.Dispose();
                hv_ClassIDsToClassNames.Dispose();
                hv_EvaluateClassNames.Dispose();
                hv_DLSamples.Dispose();
                hv_SampleIndices.Dispose();
                hv_NumSamples.Dispose();
                hv_NumBatches.Dispose();
                hv_RunningMeasures.Dispose();
                hv_Progress.Dispose();
                hv_TaskInfo.Dispose();
                hv_SecondsStart.Dispose();
                hv_BatchIndex.Dispose();
                hv_BatchStart.Dispose();
                hv_BatchEnd.Dispose();
                hv_SamplesIndicesBatch.Dispose();
                hv_DLSamplesBatch.Dispose();
                hv_DLResultsBatch.Dispose();
                hv_SecondsElapsed.Dispose();
                hv_SecondsRemaining.Dispose();
                hv_ProgressPercent.Dispose();
                hv_ProgressPerSecond.Dispose();
                hv_TimeElapsedString.Dispose();
                hv_TimeRemainingString.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Retrieve the indices of Samples that contain KeyName matching KeyValue according to the Mode set. 
        public void find_dl_samples(HTuple hv_Samples, HTuple hv_KeyName, HTuple hv_KeyValue,
            HTuple hv_Mode, out HTuple hv_SampleIndices)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_NumKeyValues = new HTuple(), hv_NumFound = new HTuple();
            HTuple hv_SampleIndex = new HTuple(), hv_Sample = new HTuple();
            HTuple hv_KeyExists = new HTuple(), hv_Tuple = new HTuple();
            HTuple hv_Hit = new HTuple(), hv_ValueIndex = new HTuple();
            HTuple hv_Value = new HTuple();
            // Initialize local and output iconic variables 
            hv_SampleIndices = new HTuple();
            try
            {
                //
                //This procedure gets the indices of the samples that contain the
                //requested KeyName matching the requested KeyValue according to the Mode.
                //If there is no match, an empty tuple [] will be returned.
                //
                //Check input parameters.
                if ((int)(new HTuple((new HTuple(hv_KeyName.TupleLength())).TupleNotEqual(1))) != 0)
                {
                    throw new HalconException(new HTuple("Invalid KeyName size: ") + (new HTuple(hv_KeyName.TupleLength()
                        )));
                }
                if ((int)(new HTuple((new HTuple(hv_Mode.TupleLength())).TupleNotEqual(1))) != 0)
                {
                    throw new HalconException(new HTuple("Invalid Mode size: ") + (new HTuple(hv_Mode.TupleLength()
                        )));
                }
                if ((int)((new HTuple((new HTuple(hv_Mode.TupleNotEqual("match"))).TupleAnd(
                    new HTuple(hv_Mode.TupleNotEqual("or"))))).TupleAnd(new HTuple(hv_Mode.TupleNotEqual(
                    "contain")))) != 0)
                {
                    throw new HalconException("Invalid Mode value: " + hv_Mode);
                }
                hv_NumKeyValues.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumKeyValues = new HTuple(hv_KeyValue.TupleLength()
                        );
                }
                if ((int)((new HTuple(hv_Mode.TupleEqual("contain"))).TupleAnd(new HTuple(hv_NumKeyValues.TupleLess(
                    1)))) != 0)
                {
                    throw new HalconException("Invalid KeyValue size for contain Mode: " + hv_NumKeyValues);
                }
                //
                //Find the indices.
                hv_SampleIndices.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SampleIndices = HTuple.TupleGenConst(
                        new HTuple(hv_Samples.TupleLength()), 0);
                }
                hv_NumFound.Dispose();
                hv_NumFound = 0;
                //
                for (hv_SampleIndex = 0; (int)hv_SampleIndex <= (int)((new HTuple(hv_Samples.TupleLength()
                    )) - 1); hv_SampleIndex = (int)hv_SampleIndex + 1)
                {
                    hv_Sample.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Sample = hv_Samples.TupleSelect(
                            hv_SampleIndex);
                    }
                    hv_KeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_Sample, "key_exists", hv_KeyName, out hv_KeyExists);
                    if ((int)(hv_KeyExists) != 0)
                    {
                        hv_Tuple.Dispose();
                        HOperatorSet.GetDictTuple(hv_Sample, hv_KeyName, out hv_Tuple);
                        if ((int)(new HTuple(hv_Mode.TupleEqual("match"))) != 0)
                        {
                            //Mode 'match': Tuple must be equal KeyValue.
                            hv_Hit.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Hit = new HTuple(hv_Tuple.TupleEqual(
                                    hv_KeyValue));
                            }
                        }
                        else if ((int)((new HTuple(hv_Mode.TupleEqual("or"))).TupleAnd(
                            new HTuple((new HTuple(hv_Tuple.TupleLength())).TupleEqual(1)))) != 0)
                        {
                            //Mode 'or': Tuple must have only 1 element and it has to be equal to any of KeyValues elements.
                            hv_Hit.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Hit = new HTuple(((hv_KeyValue.TupleFindFirst(
                                    hv_Tuple))).TupleGreaterEqual(0));
                            }
                        }
                        else if ((int)(new HTuple(hv_Mode.TupleEqual("contain"))) != 0)
                        {
                            //Mode 'contain': Tuple must contain any of the elements in KeyValue.
                            HTuple end_val37 = hv_NumKeyValues - 1;
                            HTuple step_val37 = 1;
                            for (hv_ValueIndex = 0; hv_ValueIndex.Continue(end_val37, step_val37); hv_ValueIndex = hv_ValueIndex.TupleAdd(step_val37))
                            {
                                hv_Value.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Value = hv_KeyValue.TupleSelect(
                                        hv_ValueIndex);
                                }
                                hv_Hit.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Hit = new HTuple(((hv_Tuple.TupleFindFirst(
                                        hv_Value))).TupleGreaterEqual(0));
                                }
                                if ((int)(hv_Hit) != 0)
                                {
                                    break;
                                }
                            }
                        }
                        else
                        {
                            //Unsupported configuration.
                            hv_Hit.Dispose();
                            hv_Hit = 0;
                        }
                        if ((int)(hv_Hit) != 0)
                        {
                            if (hv_SampleIndices == null)
                                hv_SampleIndices = new HTuple();
                            hv_SampleIndices[hv_NumFound] = hv_SampleIndex;
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_NumFound = hv_NumFound + 1;
                                    hv_NumFound.Dispose();
                                    hv_NumFound = ExpTmpLocalVar_NumFound;
                                }
                            }
                        }
                    }
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_SampleIndices = hv_SampleIndices.TupleSelectRange(
                            0, hv_NumFound - 1);
                        hv_SampleIndices.Dispose();
                        hv_SampleIndices = ExpTmpLocalVar_SampleIndices;
                    }
                }

                hv_NumKeyValues.Dispose();
                hv_NumFound.Dispose();
                hv_SampleIndex.Dispose();
                hv_Sample.Dispose();
                hv_KeyExists.Dispose();
                hv_Tuple.Dispose();
                hv_Hit.Dispose();
                hv_ValueIndex.Dispose();
                hv_Value.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_NumKeyValues.Dispose();
                hv_NumFound.Dispose();
                hv_SampleIndex.Dispose();
                hv_Sample.Dispose();
                hv_KeyExists.Dispose();
                hv_Tuple.Dispose();
                hv_Hit.Dispose();
                hv_ValueIndex.Dispose();
                hv_Value.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: XLD / Creation
        // Short Description: Creates an arrow shaped XLD contour. 
        public void gen_arrow_contour_xld(out HObject ho_Arrow, HTuple hv_Row1, HTuple hv_Column1,
            HTuple hv_Row2, HTuple hv_Column2, HTuple hv_HeadLength, HTuple hv_HeadWidth)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_TempArrow = null;

            // Local control variables 

            HTuple hv_Length = new HTuple(), hv_ZeroLengthIndices = new HTuple();
            HTuple hv_DR = new HTuple(), hv_DC = new HTuple(), hv_HalfHeadWidth = new HTuple();
            HTuple hv_RowP1 = new HTuple(), hv_ColP1 = new HTuple();
            HTuple hv_RowP2 = new HTuple(), hv_ColP2 = new HTuple();
            HTuple hv_Index = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Arrow);
            HOperatorSet.GenEmptyObj(out ho_TempArrow);
            try
            {
                //This procedure generates arrow shaped XLD contours,
                //pointing from (Row1, Column1) to (Row2, Column2).
                //If starting and end point are identical, a contour consisting
                //of a single point is returned.
                //
                //input parameteres:
                //Row1, Column1: Coordinates of the arrows' starting points
                //Row2, Column2: Coordinates of the arrows' end points
                //HeadLength, HeadWidth: Size of the arrow heads in pixels
                //
                //output parameter:
                //Arrow: The resulting XLD contour
                //
                //The input tuples Row1, Column1, Row2, and Column2 have to be of
                //the same length.
                //HeadLength and HeadWidth either have to be of the same length as
                //Row1, Column1, Row2, and Column2 or have to be a single element.
                //If one of the above restrictions is violated, an error will occur.
                //
                //
                //Init
                ho_Arrow.Dispose();
                HOperatorSet.GenEmptyObj(out ho_Arrow);
                //
                //Calculate the arrow length
                hv_Length.Dispose();
                HOperatorSet.DistancePp(hv_Row1, hv_Column1, hv_Row2, hv_Column2, out hv_Length);
                //
                //Mark arrows with identical start and end point
                //(set Length to -1 to avoid division-by-zero exception)
                hv_ZeroLengthIndices.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ZeroLengthIndices = hv_Length.TupleFind(
                        0);
                }
                if ((int)(new HTuple(hv_ZeroLengthIndices.TupleNotEqual(-1))) != 0)
                {
                    if (hv_Length == null)
                        hv_Length = new HTuple();
                    hv_Length[hv_ZeroLengthIndices] = -1;
                }
                //
                //Calculate auxiliary variables.
                hv_DR.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_DR = (1.0 * (hv_Row2 - hv_Row1)) / hv_Length;
                }
                hv_DC.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_DC = (1.0 * (hv_Column2 - hv_Column1)) / hv_Length;
                }
                hv_HalfHeadWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HalfHeadWidth = hv_HeadWidth / 2.0;
                }
                //
                //Calculate end points of the arrow head.
                hv_RowP1.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RowP1 = (hv_Row1 + ((hv_Length - hv_HeadLength) * hv_DR)) + (hv_HalfHeadWidth * hv_DC);
                }
                hv_ColP1.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ColP1 = (hv_Column1 + ((hv_Length - hv_HeadLength) * hv_DC)) - (hv_HalfHeadWidth * hv_DR);
                }
                hv_RowP2.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RowP2 = (hv_Row1 + ((hv_Length - hv_HeadLength) * hv_DR)) - (hv_HalfHeadWidth * hv_DC);
                }
                hv_ColP2.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ColP2 = (hv_Column1 + ((hv_Length - hv_HeadLength) * hv_DC)) + (hv_HalfHeadWidth * hv_DR);
                }
                //
                //Finally create output XLD contour for each input point pair
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Length.TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
                {
                    if ((int)(new HTuple(((hv_Length.TupleSelect(hv_Index))).TupleEqual(-1))) != 0)
                    {
                        //Create_ single points for arrows with identical start and end point
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_TempArrow.Dispose();
                            HOperatorSet.GenContourPolygonXld(out ho_TempArrow, hv_Row1.TupleSelect(
                                hv_Index), hv_Column1.TupleSelect(hv_Index));
                        }
                    }
                    else
                    {
                        //Create arrow contour
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_TempArrow.Dispose();
                            HOperatorSet.GenContourPolygonXld(out ho_TempArrow, ((((((((((hv_Row1.TupleSelect(
                                hv_Index))).TupleConcat(hv_Row2.TupleSelect(hv_Index)))).TupleConcat(
                                hv_RowP1.TupleSelect(hv_Index)))).TupleConcat(hv_Row2.TupleSelect(hv_Index)))).TupleConcat(
                                hv_RowP2.TupleSelect(hv_Index)))).TupleConcat(hv_Row2.TupleSelect(hv_Index)),
                                ((((((((((hv_Column1.TupleSelect(hv_Index))).TupleConcat(hv_Column2.TupleSelect(
                                hv_Index)))).TupleConcat(hv_ColP1.TupleSelect(hv_Index)))).TupleConcat(
                                hv_Column2.TupleSelect(hv_Index)))).TupleConcat(hv_ColP2.TupleSelect(
                                hv_Index)))).TupleConcat(hv_Column2.TupleSelect(hv_Index)));
                        }
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_Arrow, ho_TempArrow, out ExpTmpOutVar_0);
                        ho_Arrow.Dispose();
                        ho_Arrow = ExpTmpOutVar_0;
                    }
                }
                ho_TempArrow.Dispose();

                hv_Length.Dispose();
                hv_ZeroLengthIndices.Dispose();
                hv_DR.Dispose();
                hv_DC.Dispose();
                hv_HalfHeadWidth.Dispose();
                hv_RowP1.Dispose();
                hv_ColP1.Dispose();
                hv_RowP2.Dispose();
                hv_ColP2.Dispose();
                hv_Index.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_TempArrow.Dispose();

                hv_Length.Dispose();
                hv_ZeroLengthIndices.Dispose();
                hv_DR.Dispose();
                hv_DC.Dispose();
                hv_HalfHeadWidth.Dispose();
                hv_RowP1.Dispose();
                hv_ColP1.Dispose();
                hv_RowP2.Dispose();
                hv_ColP2.Dispose();
                hv_Index.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Create blank train sample dicts for a given model. 
        private void gen_blank_dl_train_samples(HTuple hv_DLModelHandle, out HTuple hv_TrainSamples)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Images = null, ho_Image = null, ho_Target = null;
            HObject ho_Weight = null;

            // Local control variables 

            HTuple hv_BatchSize = new HTuple(), hv_ImageWidth = new HTuple();
            HTuple hv_ImageHeight = new HTuple(), hv_ImageNumChannels = new HTuple();
            HTuple hv_ClassIDs = new HTuple(), hv_ModelType = new HTuple();
            HTuple hv_I = new HTuple(), hv_Index = new HTuple(), hv_TrainInput = new HTuple();
            HTuple hv_InstanceType = new HTuple(), hv_Exception = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Images);
            HOperatorSet.GenEmptyObj(out ho_Image);
            HOperatorSet.GenEmptyObj(out ho_Target);
            HOperatorSet.GenEmptyObj(out ho_Weight);
            hv_TrainSamples = new HTuple();
            try
            {
                //
                //This procedure generates blank input data for the given model.
                //
                //Get model parameters.
                hv_BatchSize.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "batch_size", out hv_BatchSize);
                hv_ImageWidth.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "image_width", out hv_ImageWidth);
                hv_ImageHeight.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "image_height", out hv_ImageHeight);
                hv_ImageNumChannels.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "image_num_channels", out hv_ImageNumChannels);
                hv_ClassIDs.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "class_ids", out hv_ClassIDs);
                hv_ModelType.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "type", out hv_ModelType);
                //
                //Collect train inputs.
                hv_TrainSamples.Dispose();
                hv_TrainSamples = new HTuple();
                //
                HTuple end_val14 = hv_BatchSize - 1;
                HTuple step_val14 = 1;
                for (hv_I = 0; hv_I.Continue(end_val14, step_val14); hv_I = hv_I.TupleAdd(step_val14))
                {
                    //Create blank image.
                    ho_Images.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_Images);
                    HTuple end_val17 = hv_ImageNumChannels - 1;
                    HTuple step_val17 = 1;
                    for (hv_Index = 0; hv_Index.Continue(end_val17, step_val17); hv_Index = hv_Index.TupleAdd(step_val17))
                    {
                        ho_Image.Dispose();
                        HOperatorSet.GenImageConst(out ho_Image, "real", hv_ImageWidth, hv_ImageHeight);
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_Images, ho_Image, out ExpTmpOutVar_0);
                            ho_Images.Dispose();
                            ho_Images = ExpTmpOutVar_0;
                        }
                    }
                    ho_Image.Dispose();
                    HOperatorSet.ChannelsToImage(ho_Images, out ho_Image);
                    //
                    //Create train data.
                    hv_TrainInput.Dispose();
                    HOperatorSet.CreateDict(out hv_TrainInput);
                    HOperatorSet.SetDictObject(ho_Image, hv_TrainInput, "image");
                    //
                    //Add model specific blank training data.
                    if ((int)(new HTuple(hv_ModelType.TupleEqual("classification"))) != 0)
                    {
                        //Assign arbitrary label for image.
                        HOperatorSet.SetDictTuple(hv_TrainInput, "image_label_id", 0);
                    }
                    else if ((int)(new HTuple(hv_ModelType.TupleEqual("detection"))) != 0)
                    {
                        //Generate blank bounding box labels depending on the instance type.
                        hv_InstanceType.Dispose();
                        hv_InstanceType = "rectangle1";
                        try
                        {
                            hv_InstanceType.Dispose();
                            HOperatorSet.GetDlModelParam(hv_DLModelHandle, "instance_type", out hv_InstanceType);
                        }
                        // catch (Exception) 
                        catch (HalconException HDevExpDefaultException1)
                        {
                            HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        }
                        if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle1"))) != 0)
                        {
                            HOperatorSet.SetDictTuple(hv_TrainInput, "bbox_label_id", new HTuple());
                            HOperatorSet.SetDictTuple(hv_TrainInput, "bbox_row1", new HTuple());
                            HOperatorSet.SetDictTuple(hv_TrainInput, "bbox_row2", new HTuple());
                            HOperatorSet.SetDictTuple(hv_TrainInput, "bbox_col1", new HTuple());
                            HOperatorSet.SetDictTuple(hv_TrainInput, "bbox_col2", new HTuple());
                        }
                        else if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
                        {
                            HOperatorSet.SetDictTuple(hv_TrainInput, "bbox_label_id", new HTuple());
                            HOperatorSet.SetDictTuple(hv_TrainInput, "bbox_row", new HTuple());
                            HOperatorSet.SetDictTuple(hv_TrainInput, "bbox_col", new HTuple());
                            HOperatorSet.SetDictTuple(hv_TrainInput, "bbox_length1", new HTuple());
                            HOperatorSet.SetDictTuple(hv_TrainInput, "bbox_length2", new HTuple());
                            HOperatorSet.SetDictTuple(hv_TrainInput, "bbox_phi", new HTuple());
                        }
                        else
                        {
                            throw new HalconException(("The current instance type is not supported: \"" + hv_InstanceType) + "\"");
                        }
                    }
                    else if ((int)(new HTuple(hv_ModelType.TupleEqual("segmentation"))) != 0)
                    {
                        //Generate blank weights and targets.
                        ho_Target.Dispose();
                        HOperatorSet.GenImageConst(out ho_Target, "real", hv_ImageWidth, hv_ImageHeight);
                        ho_Weight.Dispose();
                        HOperatorSet.GenImageConst(out ho_Weight, "real", hv_ImageWidth, hv_ImageHeight);
                        //Fill with first color background.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.OverpaintRegion(ho_Target, ho_Target, hv_ClassIDs.TupleSelect(
                                0), "fill");
                        }
                        HOperatorSet.OverpaintRegion(ho_Weight, ho_Weight, 1, "fill");
                        HOperatorSet.SetDictObject(ho_Target, hv_TrainInput, "segmentation_image");
                        HOperatorSet.SetDictObject(ho_Weight, hv_TrainInput, "weight_image");
                    }
                    else
                    {
                        throw new HalconException(("The current model type is not supported: \"" + hv_ModelType) + "\"");
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_TrainSamples = hv_TrainSamples.TupleConcat(
                                hv_TrainInput);
                            hv_TrainSamples.Dispose();
                            hv_TrainSamples = ExpTmpLocalVar_TrainSamples;
                        }
                    }
                }
                ho_Images.Dispose();
                ho_Image.Dispose();
                ho_Target.Dispose();
                ho_Weight.Dispose();

                hv_BatchSize.Dispose();
                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_ImageNumChannels.Dispose();
                hv_ClassIDs.Dispose();
                hv_ModelType.Dispose();
                hv_I.Dispose();
                hv_Index.Dispose();
                hv_TrainInput.Dispose();
                hv_InstanceType.Dispose();
                hv_Exception.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Images.Dispose();
                ho_Image.Dispose();
                ho_Target.Dispose();
                ho_Weight.Dispose();

                hv_BatchSize.Dispose();
                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_ImageNumChannels.Dispose();
                hv_ClassIDs.Dispose();
                hv_ModelType.Dispose();
                hv_I.Dispose();
                hv_Index.Dispose();
                hv_TrainInput.Dispose();
                hv_InstanceType.Dispose();
                hv_Exception.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Classification
        // Short Description: Compute a confusion matrix, which an be visualized and/or returned. 
        public void gen_confusion_matrix(HTuple hv_GroundTruthLabels, HTuple hv_PredictedClasses,
            HTuple hv_GenParamName, HTuple hv_GenParamValue, HTuple hv_WindowHandle, out HTuple hv_ConfusionMatrix)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_DisplayMatrix = new HTuple(), hv_ReturnMatrix = new HTuple();
            HTuple hv_DisplayColor = new HTuple(), hv_DisplayColumnWidth = new HTuple();
            HTuple hv_GenParamIndex = new HTuple(), hv_CalculateRelativeMatrix = new HTuple();
            HTuple hv_Classes = new HTuple(), hv_NumClasses = new HTuple();
            HTuple hv_AbsoluteMatrixID = new HTuple(), hv_RelativeMatrixID = new HTuple();
            HTuple hv_ColumnMatrix = new HTuple(), hv_Class = new HTuple();
            HTuple hv_ThisLabel = new HTuple(), hv_NumClassGroundTruth = new HTuple();
            HTuple hv_RowMatrix = new HTuple(), hv_PredictedClass = new HTuple();
            HTuple hv_ThisPredictedClass = new HTuple(), hv_NumMatches = new HTuple();
            HTuple hv_RelativeError = new HTuple(), hv_StringWidths = new HTuple();
            HTuple hv_StringIndex = new HTuple(), hv_String = new HTuple();
            HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
            HTuple hv_StringWidth = new HTuple(), hv_StringHeight = new HTuple();
            HTuple hv_MaxStringWidth = new HTuple(), hv_RowStart = new HTuple();
            HTuple hv_RowDistance = new HTuple(), hv_RowEnd = new HTuple();
            HTuple hv_ColumnStart = new HTuple(), hv_ColumnOffset = new HTuple();
            HTuple hv_ColumnEnd = new HTuple(), hv_Width = new HTuple();
            HTuple hv_Height = new HTuple(), hv_WidthLimit = new HTuple();
            HTuple hv_HeightLimit = new HTuple(), hv_TextRow = new HTuple();
            HTuple hv_TextColumn = new HTuple(), hv_Index = new HTuple();
            HTuple hv_Text = new HTuple(), hv_Row = new HTuple(), hv_Column = new HTuple();
            HTuple hv_AbsoluteTransposedMatrixID = new HTuple(), hv_MatrixText = new HTuple();
            HTuple hv_MatrixMaxID = new HTuple(), hv_MaxValue = new HTuple();
            HTuple hv_StringConversion = new HTuple(), hv_RelativeTransposedMatrixID = new HTuple();
            HTuple hv_TextColor = new HTuple(), hv_RelativeValues = new HTuple();
            HTuple hv_Thresholds = new HTuple(), hv_Colors = new HTuple();
            HTuple hv_Greater = new HTuple(), hv_Indices = new HTuple();
            HTuple hv_DiagonalIndex = new HTuple(), hv_Value = new HTuple();
            // Initialize local and output iconic variables 
            hv_ConfusionMatrix = new HTuple();
            try
            {
                //This procedure computes a confusion matrix.
                //Therefore, it compares the classes
                //assigned in GroundTruthLabels and PredictedClasses.
                //The resulting confusion matrix can be
                //visualized, returned, or both.
                //In each case, the output can be changed
                //via generic parameters using GenParamName and GenParamValue.
                //For the visualization, the graphics window
                //must be specified with WindowHandle.
                //
                if ((int)(new HTuple((new HTuple(hv_GroundTruthLabels.TupleLength())).TupleNotEqual(
                    new HTuple(hv_PredictedClasses.TupleLength())))) != 0)
                {
                    throw new HalconException("Number of ground truth labels and predicted classes must be equal.");
                }
                //
                //Set generic parameter defaults.
                hv_DisplayMatrix.Dispose();
                hv_DisplayMatrix = "absolute";
                hv_ReturnMatrix.Dispose();
                hv_ReturnMatrix = "absolute";
                hv_DisplayColor.Dispose();
                hv_DisplayColor = "true";
                hv_DisplayColumnWidth.Dispose();
                hv_DisplayColumnWidth = "minimal";
                //
                //Parse generic parameters.
                for (hv_GenParamIndex = 0; (int)hv_GenParamIndex <= (int)((new HTuple(hv_GenParamName.TupleLength()
                    )) - 1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
                {
                    if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "display_matrix"))) != 0)
                    {
                        //Set 'display_matrix'.
                        hv_DisplayMatrix.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_DisplayMatrix = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "return_matrix"))) != 0)
                    {
                        //Set 'return_matrix'.
                        hv_ReturnMatrix.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ReturnMatrix = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "display_color"))) != 0)
                    {
                        //Set 'display_color'.
                        hv_DisplayColor.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_DisplayColor = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "display_column_width"))) != 0)
                    {
                        //Set 'display_column_width'.
                        hv_DisplayColumnWidth.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_DisplayColumnWidth = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                    }
                    else
                    {
                        throw new HalconException(("Unknown generic parameter: '" + (hv_GenParamName.TupleSelect(
                            hv_GenParamIndex))) + "'");
                    }
                }
                //
                if ((int)((new HTuple((new HTuple(hv_DisplayMatrix.TupleEqual("relative"))).TupleOr(
                    new HTuple(hv_ReturnMatrix.TupleEqual("relative"))))).TupleOr(new HTuple(hv_DisplayColor.TupleEqual(
                    "true")))) != 0)
                {
                    hv_CalculateRelativeMatrix.Dispose();
                    hv_CalculateRelativeMatrix = 1;
                }
                else
                {
                    hv_CalculateRelativeMatrix.Dispose();
                    hv_CalculateRelativeMatrix = 0;
                }
                //
                //Calculate the confusion matrix with absolute values
                //and the confusion matrix with relative errors.
                //We start with an empty matrix
                //and add the number of matching labels.
                hv_Classes.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Classes = ((hv_GroundTruthLabels.TupleSort()
                        )).TupleUniq();
                }
                hv_NumClasses.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumClasses = new HTuple(hv_Classes.TupleLength()
                        );
                }
                hv_AbsoluteMatrixID.Dispose();
                HOperatorSet.CreateMatrix(hv_NumClasses, hv_NumClasses, 0, out hv_AbsoluteMatrixID);
                if ((int)(hv_CalculateRelativeMatrix) != 0)
                {
                    hv_RelativeMatrixID.Dispose();
                    HOperatorSet.CreateMatrix(hv_NumClasses, hv_NumClasses, 0, out hv_RelativeMatrixID);
                }
                HTuple end_val55 = hv_NumClasses - 1;
                HTuple step_val55 = 1;
                for (hv_ColumnMatrix = 0; hv_ColumnMatrix.Continue(end_val55, step_val55); hv_ColumnMatrix = hv_ColumnMatrix.TupleAdd(step_val55))
                {
                    hv_Class.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Class = hv_Classes.TupleSelect(
                            hv_ColumnMatrix);
                    }
                    hv_ThisLabel.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ThisLabel = hv_GroundTruthLabels.TupleEqualElem(
                            hv_Class);
                    }
                    if ((int)(hv_CalculateRelativeMatrix) != 0)
                    {
                        //Obtain the number of ground truth labels per class.
                        hv_NumClassGroundTruth.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_NumClassGroundTruth = hv_ThisLabel.TupleSum()
                                ;
                        }
                    }
                    HTuple end_val62 = hv_NumClasses - 1;
                    HTuple step_val62 = 1;
                    for (hv_RowMatrix = 0; hv_RowMatrix.Continue(end_val62, step_val62); hv_RowMatrix = hv_RowMatrix.TupleAdd(step_val62))
                    {
                        //Select classes for this row/column.
                        hv_PredictedClass.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_PredictedClass = hv_Classes.TupleSelect(
                                hv_RowMatrix);
                        }
                        //Check whether the input data
                        //corresponds to these classes.
                        hv_ThisPredictedClass.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ThisPredictedClass = hv_PredictedClasses.TupleEqualElem(
                                hv_PredictedClass);
                        }
                        //Count the number of elements where the predicted class
                        //matches the ground truth label.
                        hv_NumMatches.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_NumMatches = ((((hv_ThisLabel + hv_ThisPredictedClass)).TupleEqualElem(
                                2))).TupleSum();
                        }
                        //Set value in matrix.
                        HOperatorSet.SetValueMatrix(hv_AbsoluteMatrixID, hv_RowMatrix, hv_ColumnMatrix,
                            hv_NumMatches);
                        if ((int)(hv_CalculateRelativeMatrix) != 0)
                        {
                            if ((int)(new HTuple(hv_NumClassGroundTruth.TupleGreater(0))) != 0)
                            {
                                hv_RelativeError.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_RelativeError = (hv_NumMatches.TupleReal()
                                        ) / hv_NumClassGroundTruth;
                                }
                            }
                            else
                            {
                                hv_RelativeError.Dispose();
                                hv_RelativeError = 0;
                            }
                            HOperatorSet.SetValueMatrix(hv_RelativeMatrixID, hv_RowMatrix, hv_ColumnMatrix,
                                hv_RelativeError);
                        }
                    }
                }
                //
                //Return the result.
                if ((int)(new HTuple(hv_ReturnMatrix.TupleEqual("absolute"))) != 0)
                {
                    hv_ConfusionMatrix.Dispose();
                    HOperatorSet.CopyMatrix(hv_AbsoluteMatrixID, out hv_ConfusionMatrix);
                }
                else if ((int)(new HTuple(hv_ReturnMatrix.TupleEqual("relative"))) != 0)
                {
                    hv_ConfusionMatrix.Dispose();
                    HOperatorSet.CopyMatrix(hv_RelativeMatrixID, out hv_ConfusionMatrix);
                }
                else if ((int)(new HTuple(hv_ReturnMatrix.TupleEqual("none"))) != 0)
                {
                    //No matrix is returned.
                }
                else
                {
                    throw new HalconException("Unsupported mode for 'return_matrix'");
                }
                //
                //Display the matrix.
                if ((int)(new HTuple(hv_DisplayMatrix.TupleNotEqual("none"))) != 0)
                {
                    //
                    //Find maximal string width and set display position parameters.
                    hv_StringWidths.Dispose();
                    hv_StringWidths = new HTuple();
                    //Get the string width of each class.
                    for (hv_StringIndex = 0; (int)hv_StringIndex <= (int)((new HTuple(hv_Classes.TupleLength()
                        )) - 1); hv_StringIndex = (int)hv_StringIndex + 1)
                    {
                        hv_String.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_String = hv_Classes.TupleSelect(
                                hv_StringIndex);
                        }
                        hv_Ascent.Dispose(); hv_Descent.Dispose(); hv_StringWidth.Dispose(); hv_StringHeight.Dispose();
                        HOperatorSet.GetStringExtents(hv_WindowHandle, hv_String, out hv_Ascent,
                            out hv_Descent, out hv_StringWidth, out hv_StringHeight);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_StringWidths = hv_StringWidths.TupleConcat(
                                    hv_StringWidth);
                                hv_StringWidths.Dispose();
                                hv_StringWidths = ExpTmpLocalVar_StringWidths;
                            }
                        }
                    }
                    //The columns should have a minimum width for 4 characters.
                    hv_Ascent.Dispose(); hv_Descent.Dispose(); hv_StringWidth.Dispose(); hv_StringHeight.Dispose();
                    HOperatorSet.GetStringExtents(hv_WindowHandle, "test", out hv_Ascent, out hv_Descent,
                        out hv_StringWidth, out hv_StringHeight);
                    hv_MaxStringWidth.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MaxStringWidth = ((hv_StringWidths.TupleMax()
                            )).TupleMax2(hv_StringWidth);
                    }
                    //Get the maximum string width
                    //and resize the window accordingly.
                    hv_RowStart.Dispose();
                    hv_RowStart = 80;
                    hv_RowDistance.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_RowDistance = hv_StringHeight + 10;
                    }
                    hv_RowEnd.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_RowEnd = hv_StringHeight * 7;
                    }
                    hv_ColumnStart.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ColumnStart = 50 + hv_MaxStringWidth;
                    }
                    hv_ColumnOffset.Dispose();
                    hv_ColumnOffset = 20;
                    hv_ColumnEnd.Dispose();
                    hv_ColumnEnd = new HTuple(hv_ColumnOffset);
                    //
                    //Adapt the window size to fit the confusion matrix.
                    if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("minimal"))) != 0)
                    {
                        //Every column of the confusion matrix is as narrow as possible
                        //based to the respective string widths.
                        hv_Width.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Width = (((hv_StringWidths.TupleSum()
                                ) + (hv_ColumnOffset * hv_NumClasses)) + hv_ColumnStart) + hv_ColumnEnd;
                        }
                    }
                    else if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("equal"))) != 0)
                    {
                        //Every column of the confusion matrix should have the same width.
                        //based on the maximum string width.
                        hv_Width.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Width = (((hv_MaxStringWidth + hv_ColumnOffset) * hv_NumClasses) + hv_ColumnStart) + hv_ColumnEnd;
                        }
                    }
                    else
                    {
                        throw new HalconException("");
                    }
                    hv_Height.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Height = ((hv_RowDistance * hv_NumClasses) + hv_RowStart) + hv_RowEnd;
                    }
                    HDevWindowStack.SetActive(hv_WindowHandle);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                    }
                    //
                    //Set reasonable limits for graphics window (adapt if necessary).
                    hv_WidthLimit.Dispose();
                    hv_WidthLimit = new HTuple();
                    hv_WidthLimit[0] = 450;
                    hv_WidthLimit[1] = 1920;
                    hv_HeightLimit.Dispose();
                    hv_HeightLimit = new HTuple();
                    hv_HeightLimit[0] = 250;
                    hv_HeightLimit[1] = 1080;
                    if ((int)((new HTuple(hv_Width.TupleGreater(hv_WidthLimit.TupleSelect(1)))).TupleOr(
                        new HTuple(hv_Height.TupleGreater(hv_HeightLimit.TupleSelect(1))))) != 0)
                    {
                        throw new HalconException("Confusion Matrix does not fit into graphics window. Please adapt font and/or size limits.");
                    }
                    dev_resize_window_fit_size(0, 0, hv_Width, hv_Height, hv_WidthLimit, hv_HeightLimit);
                    //
                    //Get display coordinates.
                    //Get row coordinates for display.
                    hv_TextRow.Dispose();
                    hv_TextRow = new HTuple();
                    HTuple end_val145 = hv_NumClasses - 1;
                    HTuple step_val145 = 1;
                    for (hv_ColumnMatrix = 0; hv_ColumnMatrix.Continue(end_val145, step_val145); hv_ColumnMatrix = hv_ColumnMatrix.TupleAdd(step_val145))
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_TextRow = hv_TextRow.TupleConcat(
                                    HTuple.TupleGenSequence(0, (hv_NumClasses - 1) * hv_RowDistance, hv_RowDistance));
                                hv_TextRow.Dispose();
                                hv_TextRow = ExpTmpLocalVar_TextRow;
                            }
                        }
                    }
                    //Get column coordinates for display.
                    hv_TextColumn.Dispose();
                    hv_TextColumn = new HTuple();
                    HTuple end_val150 = hv_NumClasses - 1;
                    HTuple step_val150 = 1;
                    for (hv_Index = 0; hv_Index.Continue(end_val150, step_val150); hv_Index = hv_Index.TupleAdd(step_val150))
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_TextColumn = hv_TextColumn.TupleConcat(
                                    HTuple.TupleGenConst(hv_NumClasses, hv_ColumnStart));
                                hv_TextColumn.Dispose();
                                hv_TextColumn = ExpTmpLocalVar_TextColumn;
                            }
                        }
                        if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual("minimal"))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ColumnStart = (hv_ColumnStart + (hv_StringWidths.TupleSelect(
                                        hv_Index))) + hv_ColumnOffset;
                                    hv_ColumnStart.Dispose();
                                    hv_ColumnStart = ExpTmpLocalVar_ColumnStart;
                                }
                            }
                        }
                        else if ((int)(new HTuple(hv_DisplayColumnWidth.TupleEqual(
                            "equal"))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ColumnStart = (hv_ColumnStart + hv_MaxStringWidth) + hv_ColumnOffset;
                                    hv_ColumnStart.Dispose();
                                    hv_ColumnStart = ExpTmpLocalVar_ColumnStart;
                                }
                            }
                        }
                    }
                    //Display the confusion matrix with a margin from the top.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_TextRow = hv_TextRow + hv_RowStart;
                            hv_TextRow.Dispose();
                            hv_TextRow = ExpTmpLocalVar_TextRow;
                        }
                    }
                    //Display axis titles.
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Ground truth labels",
                            "window", "top", "right", "white", "box", "false");
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Predicted classes",
                            "window", "bottom", "left", "white", "box", "false");
                    }
                    for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Classes.TupleLength()
                        )) - 1); hv_Index = (int)hv_Index + 1)
                    {
                        hv_Text.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Text = hv_Classes.TupleSelect(
                                hv_Index);
                        }
                        //Display predicted class names.
                        hv_Row.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Row = hv_TextRow.TupleSelect(
                                hv_Index);
                        }
                        hv_Column.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Column = ((hv_TextColumn.TupleSelect(
                                0)) - hv_MaxStringWidth) - hv_ColumnOffset;
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                hv_Row, hv_Column, "light gray", "box", "false");
                        }
                        //Display ground truth label names.
                        hv_Row.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Row = (hv_TextRow.TupleSelect(
                                0)) - hv_RowDistance;
                        }
                        hv_Column.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Column = hv_TextColumn.TupleSelect(
                                hv_Index * hv_NumClasses);
                        }
                        if (HDevWindowStack.IsOpen())
                        {
                            HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window",
                                hv_Row, hv_Column, "light gray", "box", "false");
                        }
                    }
                    //
                    //Get the confusion matrix values for display.
                    if ((int)(new HTuple(hv_DisplayMatrix.TupleEqual("absolute"))) != 0)
                    {
                        //Displayed matrix corresponds to the transposed returned matrix.
                        hv_AbsoluteTransposedMatrixID.Dispose();
                        HOperatorSet.TransposeMatrix(hv_AbsoluteMatrixID, out hv_AbsoluteTransposedMatrixID);
                        hv_MatrixText.Dispose();
                        HOperatorSet.GetFullMatrix(hv_AbsoluteTransposedMatrixID, out hv_MatrixText);
                        HOperatorSet.ClearMatrix(hv_AbsoluteTransposedMatrixID);
                        //Align the numbers right.
                        hv_MatrixMaxID.Dispose();
                        HOperatorSet.MaxMatrix(hv_AbsoluteMatrixID, "full", out hv_MatrixMaxID);
                        hv_MaxValue.Dispose();
                        HOperatorSet.GetFullMatrix(hv_MatrixMaxID, out hv_MaxValue);
                        HOperatorSet.ClearMatrix(hv_MatrixMaxID);
                        hv_StringConversion.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_StringConversion = (((((hv_MaxValue.TupleLog10()
                                )).TupleCeil())).TupleInt()) + ".0f";
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_MatrixText = hv_MatrixText.TupleString(
                                    hv_StringConversion);
                                hv_MatrixText.Dispose();
                                hv_MatrixText = ExpTmpLocalVar_MatrixText;
                            }
                        }
                    }
                    else
                    {
                        //Displayed matrix corresponds to the transposed returned matrix.
                        hv_RelativeTransposedMatrixID.Dispose();
                        HOperatorSet.TransposeMatrix(hv_RelativeMatrixID, out hv_RelativeTransposedMatrixID);
                        hv_MatrixText.Dispose();
                        HOperatorSet.GetFullMatrix(hv_RelativeTransposedMatrixID, out hv_MatrixText);
                        HOperatorSet.ClearMatrix(hv_RelativeTransposedMatrixID);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_MatrixText = hv_MatrixText.TupleString(
                                    ".2f");
                                hv_MatrixText.Dispose();
                                hv_MatrixText = ExpTmpLocalVar_MatrixText;
                            }
                        }
                    }
                    //Set color for displayed confusion matrix.
                    if ((int)(new HTuple(hv_DisplayColor.TupleEqual("true"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TextColor.Dispose();
                            HOperatorSet.TupleGenConst(new HTuple(hv_MatrixText.TupleLength()), "#666666",
                                out hv_TextColor);
                        }
                        //Use the relative values to adapt the color of the text.
                        hv_RelativeTransposedMatrixID.Dispose();
                        HOperatorSet.TransposeMatrix(hv_RelativeMatrixID, out hv_RelativeTransposedMatrixID);
                        hv_RelativeValues.Dispose();
                        HOperatorSet.GetFullMatrix(hv_RelativeTransposedMatrixID, out hv_RelativeValues);
                        HOperatorSet.ClearMatrix(hv_RelativeTransposedMatrixID);
                        //Set the colors and respective thresholds for the off-diagonal values.
                        hv_Thresholds.Dispose();
                        hv_Thresholds = new HTuple();
                        hv_Thresholds[0] = 0.0;
                        hv_Thresholds[1] = 0.05;
                        hv_Thresholds[2] = 0.1;
                        hv_Thresholds[3] = 0.2;
                        hv_Colors.Dispose();
                        hv_Colors = new HTuple();
                        hv_Colors[0] = "#8C4D4D";
                        hv_Colors[1] = "#B33333";
                        hv_Colors[2] = "#D91A1A";
                        hv_Colors[3] = "#FF0000";
                        for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Thresholds.TupleLength()
                            )) - 1); hv_Index = (int)hv_Index + 1)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Greater.Dispose();
                                HOperatorSet.TupleGreaterElem(hv_RelativeValues, hv_Thresholds.TupleSelect(
                                    hv_Index), out hv_Greater);
                            }
                            hv_Indices.Dispose();
                            HOperatorSet.TupleFind(hv_Greater, 1, out hv_Indices);
                            if ((int)(new HTuple(hv_Indices.TupleNotEqual(-1))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HTuple ExpTmpOutVar_0;
                                    HOperatorSet.TupleReplace(hv_TextColor, hv_Indices, hv_Colors.TupleSelect(
                                        hv_Index), out ExpTmpOutVar_0);
                                    hv_TextColor.Dispose();
                                    hv_TextColor = ExpTmpOutVar_0;
                                }
                            }
                            else
                            {
                                break;
                            }
                        }
                        //Set the colors and respective thresholds for the diagonal values.
                        hv_Thresholds.Dispose();
                        hv_Thresholds = new HTuple();
                        hv_Thresholds[0] = -0.01;
                        hv_Thresholds[1] = 0.60;
                        hv_Thresholds[2] = 0.80;
                        hv_Thresholds[3] = 0.90;
                        hv_Thresholds[4] = 0.95;
                        hv_Thresholds[5] = 0.98;
                        hv_Colors.Dispose();
                        hv_Colors = new HTuple();
                        hv_Colors[0] = "#666666";
                        hv_Colors[1] = "#508650";
                        hv_Colors[2] = "#419C41";
                        hv_Colors[3] = "#2BBD2B";
                        hv_Colors[4] = "#15DE15";
                        hv_Colors[5] = "#00FF00";
                        HTuple end_val216 = hv_NumClasses - 1;
                        HTuple step_val216 = 1;
                        for (hv_DiagonalIndex = 0; hv_DiagonalIndex.Continue(end_val216, step_val216); hv_DiagonalIndex = hv_DiagonalIndex.TupleAdd(step_val216))
                        {
                            hv_Value.Dispose();
                            HOperatorSet.GetValueMatrix(hv_RelativeMatrixID, hv_DiagonalIndex, hv_DiagonalIndex,
                                out hv_Value);
                            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Thresholds.TupleLength()
                                )) - 1); hv_Index = (int)hv_Index + 1)
                            {
                                if ((int)(new HTuple(hv_Value.TupleGreater(hv_Thresholds.TupleSelect(
                                    hv_Index)))) != 0)
                                {
                                    if (hv_TextColor == null)
                                        hv_TextColor = new HTuple();
                                    hv_TextColor[hv_DiagonalIndex * (hv_NumClasses + 1)] = hv_Colors.TupleSelect(
                                        hv_Index);
                                }
                                else
                                {
                                    break;
                                }
                            }
                        }
                    }
                    else
                    {
                        //Default value for the text color.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TextColor.Dispose();
                            HOperatorSet.TupleGenConst(new HTuple(hv_MatrixText.TupleLength()), "white",
                                out hv_TextColor);
                        }
                    }
                    //
                    //Display confusion matrix.
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_MatrixText, "window",
                            hv_TextRow, hv_TextColumn, hv_TextColor, "box", "false");
                    }
                    //
                    //Clean up.
                    if ((int)(hv_CalculateRelativeMatrix) != 0)
                    {
                        HOperatorSet.ClearMatrix(hv_RelativeMatrixID);
                    }
                    HOperatorSet.ClearMatrix(hv_AbsoluteMatrixID);
                }

                hv_DisplayMatrix.Dispose();
                hv_ReturnMatrix.Dispose();
                hv_DisplayColor.Dispose();
                hv_DisplayColumnWidth.Dispose();
                hv_GenParamIndex.Dispose();
                hv_CalculateRelativeMatrix.Dispose();
                hv_Classes.Dispose();
                hv_NumClasses.Dispose();
                hv_AbsoluteMatrixID.Dispose();
                hv_RelativeMatrixID.Dispose();
                hv_ColumnMatrix.Dispose();
                hv_Class.Dispose();
                hv_ThisLabel.Dispose();
                hv_NumClassGroundTruth.Dispose();
                hv_RowMatrix.Dispose();
                hv_PredictedClass.Dispose();
                hv_ThisPredictedClass.Dispose();
                hv_NumMatches.Dispose();
                hv_RelativeError.Dispose();
                hv_StringWidths.Dispose();
                hv_StringIndex.Dispose();
                hv_String.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_StringWidth.Dispose();
                hv_StringHeight.Dispose();
                hv_MaxStringWidth.Dispose();
                hv_RowStart.Dispose();
                hv_RowDistance.Dispose();
                hv_RowEnd.Dispose();
                hv_ColumnStart.Dispose();
                hv_ColumnOffset.Dispose();
                hv_ColumnEnd.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_WidthLimit.Dispose();
                hv_HeightLimit.Dispose();
                hv_TextRow.Dispose();
                hv_TextColumn.Dispose();
                hv_Index.Dispose();
                hv_Text.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();
                hv_AbsoluteTransposedMatrixID.Dispose();
                hv_MatrixText.Dispose();
                hv_MatrixMaxID.Dispose();
                hv_MaxValue.Dispose();
                hv_StringConversion.Dispose();
                hv_RelativeTransposedMatrixID.Dispose();
                hv_TextColor.Dispose();
                hv_RelativeValues.Dispose();
                hv_Thresholds.Dispose();
                hv_Colors.Dispose();
                hv_Greater.Dispose();
                hv_Indices.Dispose();
                hv_DiagonalIndex.Dispose();
                hv_Value.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_DisplayMatrix.Dispose();
                hv_ReturnMatrix.Dispose();
                hv_DisplayColor.Dispose();
                hv_DisplayColumnWidth.Dispose();
                hv_GenParamIndex.Dispose();
                hv_CalculateRelativeMatrix.Dispose();
                hv_Classes.Dispose();
                hv_NumClasses.Dispose();
                hv_AbsoluteMatrixID.Dispose();
                hv_RelativeMatrixID.Dispose();
                hv_ColumnMatrix.Dispose();
                hv_Class.Dispose();
                hv_ThisLabel.Dispose();
                hv_NumClassGroundTruth.Dispose();
                hv_RowMatrix.Dispose();
                hv_PredictedClass.Dispose();
                hv_ThisPredictedClass.Dispose();
                hv_NumMatches.Dispose();
                hv_RelativeError.Dispose();
                hv_StringWidths.Dispose();
                hv_StringIndex.Dispose();
                hv_String.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_StringWidth.Dispose();
                hv_StringHeight.Dispose();
                hv_MaxStringWidth.Dispose();
                hv_RowStart.Dispose();
                hv_RowDistance.Dispose();
                hv_RowEnd.Dispose();
                hv_ColumnStart.Dispose();
                hv_ColumnOffset.Dispose();
                hv_ColumnEnd.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_WidthLimit.Dispose();
                hv_HeightLimit.Dispose();
                hv_TextRow.Dispose();
                hv_TextColumn.Dispose();
                hv_Index.Dispose();
                hv_Text.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();
                hv_AbsoluteTransposedMatrixID.Dispose();
                hv_MatrixText.Dispose();
                hv_MatrixMaxID.Dispose();
                hv_MaxValue.Dispose();
                hv_StringConversion.Dispose();
                hv_RelativeTransposedMatrixID.Dispose();
                hv_TextColor.Dispose();
                hv_RelativeValues.Dispose();
                hv_Thresholds.Dispose();
                hv_Colors.Dispose();
                hv_Greater.Dispose();
                hv_Indices.Dispose();
                hv_DiagonalIndex.Dispose();
                hv_Value.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Store the given images in a tuple of dictionaries DLSamples. 
        public void gen_dl_samples_from_images(HObject ho_Images, out HTuple hv_DLSampleBatch)
        {



            // Local iconic variables 

            HObject ho_Image = null;

            // Local control variables 

            HTuple hv_NumImages = new HTuple(), hv_ImageIndex = new HTuple();
            HTuple hv_DLSample = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Image);
            hv_DLSampleBatch = new HTuple();
            try
            {
                //
                //This procedure creates DLSampleBatch, a tuple
                //containing a dictionary DLSample
                //for every image given in Images.
                //
                //Initialize output tuple.
                hv_NumImages.Dispose();
                HOperatorSet.CountObj(ho_Images, out hv_NumImages);
                hv_DLSampleBatch.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_DLSampleBatch = HTuple.TupleGenConst(
                        hv_NumImages, -1);
                }
                //
                //Loop through all given images.
                HTuple end_val10 = hv_NumImages - 1;
                HTuple step_val10 = 1;
                for (hv_ImageIndex = 0; hv_ImageIndex.Continue(end_val10, step_val10); hv_ImageIndex = hv_ImageIndex.TupleAdd(step_val10))
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_Image.Dispose();
                        HOperatorSet.SelectObj(ho_Images, out ho_Image, hv_ImageIndex + 1);
                    }
                    //Create DLSample from image.
                    hv_DLSample.Dispose();
                    HOperatorSet.CreateDict(out hv_DLSample);
                    HOperatorSet.SetDictObject(ho_Image, hv_DLSample, "image");
                    //
                    //Collect the DLSamples.
                    if (hv_DLSampleBatch == null)
                        hv_DLSampleBatch = new HTuple();
                    hv_DLSampleBatch[hv_ImageIndex] = hv_DLSample;
                }
                ho_Image.Dispose();

                hv_NumImages.Dispose();
                hv_ImageIndex.Dispose();
                hv_DLSample.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Image.Dispose();

                hv_NumImages.Dispose();
                hv_ImageIndex.Dispose();
                hv_DLSample.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Classification
        // Short Description: Generate a tiled image for the classified DLSamples and add indications whether the predictions are true or not. 
        private void gen_tiled_classification_image_result(out HObject ho_TiledImageRow,
            HTuple hv_DLSamples, HTuple hv_SpacingCol, HTuple hv_PredictionsCorrect, HTuple hv_ResClasses,
            out HTuple hv_TextImageRows, out HTuple hv_TextImageColumns, out HTuple hv_TextImageWidth,
            out HTuple hv_TextImageHeight)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_GTImagesRaw, ho_GTImage = null, ho_Channel = null;
            HObject ho_RegionContourCheck, ho_Rectangle1, ho_Rectangle2;
            HObject ho_RegionContourCross, ho_TopContour, ho_LeftContour;
            HObject ho_RightContour, ho_BottomContour, ho_Frame, ho_TextImageOneChannel;
            HObject ho_TextImageOneChannels, ho_TextImage, ho_SeparateImageOneChannel;
            HObject ho_SeparateImageOneChannels, ho_SeparateImage, ho_GTImages;
            HObject ho_GTImageChannelsScaled = null, ho_GTImageChannel = null;
            HObject ho_GTImageChannelScaled = null, ho_GTImageR = null;
            HObject ho_GTImageG = null, ho_GTImageB = null, ho_RegionContour = null;

            // Local control variables 

            HTuple hv_NumSamples = new HTuple(), hv_NumRows = new HTuple();
            HTuple hv_NumColumns = new HTuple(), hv_Index = new HTuple();
            HTuple hv_NumChannels = new HTuple(), hv_GrayMin = new HTuple();
            HTuple hv_GrayMax = new HTuple(), hv_IndexChannel = new HTuple();
            HTuple hv_GrayMinTmp = new HTuple(), hv_GrayMaxTmp = new HTuple();
            HTuple hv__ = new HTuple(), hv_ImageWidth = new HTuple();
            HTuple hv_ImageHeight = new HTuple(), hv_Length1 = new HTuple();
            HTuple hv_Length2 = new HTuple(), hv_HomMat2DIdentity = new HTuple();
            HTuple hv_HomMat2DRotate = new HTuple(), hv_HomMat2DCompose = new HTuple();
            HTuple hv_FrameSize = new HTuple(), hv_SeparateImageHeight = new HTuple();
            HTuple hv_SeparateImageWidth = new HTuple(), hv_ScaleMax = new HTuple();
            HTuple hv_ScaleMin = new HTuple(), hv_Color = new HTuple();
            HTuple hv_Number = new HTuple(), hv_TiledRows = new HTuple();
            HTuple hv_TiledColumns = new HTuple(), hv_TiledHeights = new HTuple();
            HTuple hv_TiledWidths = new HTuple(), hv_MinusOnes = new HTuple();

            HTupleVector hvec_GrayMins = new HTupleVector(1);
            HTupleVector hvec_GrayMaxs = new HTupleVector(1);
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_TiledImageRow);
            HOperatorSet.GenEmptyObj(out ho_GTImagesRaw);
            HOperatorSet.GenEmptyObj(out ho_GTImage);
            HOperatorSet.GenEmptyObj(out ho_Channel);
            HOperatorSet.GenEmptyObj(out ho_RegionContourCheck);
            HOperatorSet.GenEmptyObj(out ho_Rectangle1);
            HOperatorSet.GenEmptyObj(out ho_Rectangle2);
            HOperatorSet.GenEmptyObj(out ho_RegionContourCross);
            HOperatorSet.GenEmptyObj(out ho_TopContour);
            HOperatorSet.GenEmptyObj(out ho_LeftContour);
            HOperatorSet.GenEmptyObj(out ho_RightContour);
            HOperatorSet.GenEmptyObj(out ho_BottomContour);
            HOperatorSet.GenEmptyObj(out ho_Frame);
            HOperatorSet.GenEmptyObj(out ho_TextImageOneChannel);
            HOperatorSet.GenEmptyObj(out ho_TextImageOneChannels);
            HOperatorSet.GenEmptyObj(out ho_TextImage);
            HOperatorSet.GenEmptyObj(out ho_SeparateImageOneChannel);
            HOperatorSet.GenEmptyObj(out ho_SeparateImageOneChannels);
            HOperatorSet.GenEmptyObj(out ho_SeparateImage);
            HOperatorSet.GenEmptyObj(out ho_GTImages);
            HOperatorSet.GenEmptyObj(out ho_GTImageChannelsScaled);
            HOperatorSet.GenEmptyObj(out ho_GTImageChannel);
            HOperatorSet.GenEmptyObj(out ho_GTImageChannelScaled);
            HOperatorSet.GenEmptyObj(out ho_GTImageR);
            HOperatorSet.GenEmptyObj(out ho_GTImageG);
            HOperatorSet.GenEmptyObj(out ho_GTImageB);
            HOperatorSet.GenEmptyObj(out ho_RegionContour);
            hv_TextImageRows = new HTuple();
            hv_TextImageColumns = new HTuple();
            hv_TextImageWidth = new HTuple();
            hv_TextImageHeight = new HTuple();
            try
            {
                //
                //This procedure generates a tiled image for the classified DLSamples.
                //In the process it adds indications if the prediction was
                //correct (green frame and checkmark) or wrong (red frame and cross).
                //
                hv_NumSamples.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumSamples = new HTuple(hv_DLSamples.TupleLength()
                        );
                }
                //
                //Get number of rows/columns of tiled image.
                if ((int)(new HTuple(hv_NumSamples.TupleGreater(9))) != 0)
                {
                    throw new HalconException("More than 9 images cannot be shown in the training progress.");
                }
                if ((int)((new HTuple((new HTuple(hv_NumSamples.TupleEqual(1))).TupleOr(new HTuple(hv_NumSamples.TupleEqual(
                    4))))).TupleOr(new HTuple(hv_NumSamples.TupleEqual(9)))) != 0)
                {
                    hv_NumRows.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumRows = ((hv_NumSamples.TupleSqrt()
                            )).TupleInt();
                    }
                    hv_NumColumns.Dispose();
                    hv_NumColumns = new HTuple(hv_NumRows);
                }
                else
                {
                    hv_NumRows.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumRows = hv_NumSamples.TupleMin2(
                            3);
                    }
                    hv_NumColumns.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumColumns = ((hv_NumSamples - 1) / hv_NumRows) + 1;
                    }
                }
                //
                //Get images and minimal/maximal gray values.
                ho_GTImagesRaw.Dispose();
                HOperatorSet.GenEmptyObj(out ho_GTImagesRaw);
                HTuple end_val21 = hv_NumSamples - 1;
                HTuple step_val21 = 1;
                for (hv_Index = 0; hv_Index.Continue(end_val21, step_val21); hv_Index = hv_Index.TupleAdd(step_val21))
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_GTImage.Dispose();
                        HOperatorSet.GetDictObject(out ho_GTImage, hv_DLSamples.TupleSelect(hv_Index),
                            "image");
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_GTImagesRaw, ho_GTImage, out ExpTmpOutVar_0);
                        ho_GTImagesRaw.Dispose();
                        ho_GTImagesRaw = ExpTmpOutVar_0;
                    }
                    hv_NumChannels.Dispose();
                    HOperatorSet.CountChannels(ho_GTImage, out hv_NumChannels);
                    hv_GrayMin.Dispose();
                    hv_GrayMin = new HTuple();
                    hv_GrayMax.Dispose();
                    hv_GrayMax = new HTuple();
                    HTuple end_val27 = hv_NumChannels - 1;
                    HTuple step_val27 = 1;
                    for (hv_IndexChannel = 0; hv_IndexChannel.Continue(end_val27, step_val27); hv_IndexChannel = hv_IndexChannel.TupleAdd(step_val27))
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_Channel.Dispose();
                            HOperatorSet.AccessChannel(ho_GTImage, out ho_Channel, hv_IndexChannel + 1);
                        }
                        hv_GrayMinTmp.Dispose(); hv_GrayMaxTmp.Dispose(); hv__.Dispose();
                        HOperatorSet.MinMaxGray(ho_Channel, ho_Channel, 0, out hv_GrayMinTmp, out hv_GrayMaxTmp,
                            out hv__);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_GrayMin = hv_GrayMin.TupleConcat(
                                    hv_GrayMinTmp);
                                hv_GrayMin.Dispose();
                                hv_GrayMin = ExpTmpLocalVar_GrayMin;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_GrayMax = hv_GrayMax.TupleConcat(
                                    hv_GrayMaxTmp);
                                hv_GrayMax.Dispose();
                                hv_GrayMax = ExpTmpLocalVar_GrayMax;
                            }
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hvec_GrayMins[hv_Index] = dh.Add(new HTupleVector(hv_GrayMin));
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hvec_GrayMaxs[hv_Index] = dh.Add(new HTupleVector(hv_GrayMax));
                    }
                }
                //
                //Create a checkmark, a cross, and a frame.
                //Note: It is assumed that all images have the same size.
                //Set parameters for displaying crosses/hooks at the bottom-right corner.
                hv_ImageWidth.Dispose(); hv_ImageHeight.Dispose();
                HOperatorSet.GetImageSize(ho_GTImage, out hv_ImageWidth, out hv_ImageHeight);
                hv_Length1.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Length1 = (hv_ImageWidth.TupleMin2(
                        hv_ImageHeight)) / 5;
                }
                hv_Length2.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Length2 = (hv_ImageWidth.TupleMin2(
                        hv_ImageHeight)) / 25;
                }
                hv_HomMat2DIdentity.Dispose();
                HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HomMat2DRotate.Dispose();
                    HOperatorSet.HomMat2dRotate(hv_HomMat2DIdentity, (new HTuple(45)).TupleRad()
                        , 0, 0, out hv_HomMat2DRotate);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_HomMat2DCompose.Dispose();
                    HOperatorSet.HomMat2dTranslate(hv_HomMat2DRotate, hv_ImageHeight - (0.75 * hv_Length1),
                        hv_ImageWidth - (0.75 * hv_Length1), out hv_HomMat2DCompose);
                }
                //Generate checkmark.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_RegionContourCheck.Dispose();
                    HOperatorSet.GenContourPolygonXld(out ho_RegionContourCheck, ((((((((((-hv_Length2)).TupleConcat(
                        hv_Length2))).TupleConcat(hv_Length2))).TupleConcat((new HTuple(0)).TupleConcat(
                        0)))).TupleConcat(-hv_Length2))).TupleConcat(-hv_Length2), (((((((((((new HTuple(0)).TupleConcat(
                        0)).TupleConcat(hv_Length1))).TupleConcat(hv_Length1))).TupleConcat(hv_Length2))).TupleConcat(
                        hv_Length2))).TupleConcat(0)) - (hv_Length1 / 2));
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.AffineTransContourXld(ho_RegionContourCheck, out ExpTmpOutVar_0,
                        hv_HomMat2DCompose);
                    ho_RegionContourCheck.Dispose();
                    ho_RegionContourCheck = ExpTmpOutVar_0;
                }
                //Generate cross.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_Rectangle1.Dispose();
                    HOperatorSet.GenRectangle2ContourXld(out ho_Rectangle1, 0, 0, 0, hv_Length1 / 2,
                        hv_Length2 / 2);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_Rectangle2.Dispose();
                    HOperatorSet.GenRectangle2ContourXld(out ho_Rectangle2, 0, 0, 0, hv_Length2 / 2,
                        hv_Length1 / 2);
                }
                ho_RegionContourCross.Dispose();
                HOperatorSet.ConcatObj(ho_Rectangle1, ho_Rectangle2, out ho_RegionContourCross
                    );
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.AffineTransContourXld(ho_RegionContourCross, out ExpTmpOutVar_0,
                        hv_HomMat2DCompose);
                    ho_RegionContourCross.Dispose();
                    ho_RegionContourCross = ExpTmpOutVar_0;
                }
                //Generate the color frame.
                hv_FrameSize.Dispose();
                hv_FrameSize = 7;
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_TopContour.Dispose();
                    HOperatorSet.GenContourPolygonXld(out ho_TopContour, (((((((new HTuple(0)).TupleConcat(
                        0)).TupleConcat(hv_FrameSize))).TupleConcat(hv_FrameSize))).TupleConcat(
                        0)) - 0.5, ((((((new HTuple(0)).TupleConcat(hv_ImageWidth))).TupleConcat(
                        hv_ImageWidth))).TupleConcat((new HTuple(0)).TupleConcat(0))) - 0.5);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_LeftContour.Dispose();
                    HOperatorSet.GenContourPolygonXld(out ho_LeftContour, (((((((new HTuple(0)).TupleConcat(
                        0)).TupleConcat(hv_ImageHeight))).TupleConcat(hv_ImageHeight))).TupleConcat(
                        0)) - 0.5, ((((((new HTuple(0)).TupleConcat(hv_FrameSize))).TupleConcat(hv_FrameSize))).TupleConcat(
                        (new HTuple(0)).TupleConcat(0))) - 0.5);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_RightContour.Dispose();
                    HOperatorSet.GenContourPolygonXld(out ho_RightContour, ((((((new HTuple(0)).TupleConcat(
                        hv_ImageHeight))).TupleConcat(hv_ImageHeight))).TupleConcat((new HTuple(0)).TupleConcat(
                        0))) - 0.5, (((((((hv_ImageWidth.TupleConcat(hv_ImageWidth))).TupleConcat(
                        hv_ImageWidth - hv_FrameSize))).TupleConcat(hv_ImageWidth - hv_FrameSize))).TupleConcat(
                        hv_ImageWidth)) - 0.5);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_BottomContour.Dispose();
                    HOperatorSet.GenContourPolygonXld(out ho_BottomContour, (((((((hv_ImageHeight.TupleConcat(
                        hv_ImageHeight - hv_FrameSize))).TupleConcat(hv_ImageHeight - hv_FrameSize))).TupleConcat(
                        hv_ImageHeight))).TupleConcat(hv_ImageHeight)) - 0.5, (((((((new HTuple(0)).TupleConcat(
                        0)).TupleConcat(hv_ImageWidth))).TupleConcat(hv_ImageWidth))).TupleConcat(
                        0)) - 0.5);
                }
                ho_Frame.Dispose();
                HOperatorSet.ConcatObj(ho_TopContour, ho_RightContour, out ho_Frame);
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_Frame, ho_BottomContour, out ExpTmpOutVar_0);
                    ho_Frame.Dispose();
                    ho_Frame = ExpTmpOutVar_0;
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_Frame, ho_LeftContour, out ExpTmpOutVar_0);
                    ho_Frame.Dispose();
                    ho_Frame = ExpTmpOutVar_0;
                }
                //
                //Greate black image to print in text later.
                hv_TextImageHeight.Dispose();
                hv_TextImageHeight = 40;
                hv_TextImageWidth.Dispose();
                hv_TextImageWidth = new HTuple(hv_ImageWidth);
                ho_TextImageOneChannel.Dispose();
                HOperatorSet.GenImageConst(out ho_TextImageOneChannel, "real", hv_TextImageWidth,
                    hv_TextImageHeight);
                ho_TextImageOneChannels.Dispose();
                HOperatorSet.ConcatObj(ho_TextImageOneChannel, ho_TextImageOneChannel, out ho_TextImageOneChannels
                    );
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_TextImageOneChannels, ho_TextImageOneChannel, out ExpTmpOutVar_0
                        );
                    ho_TextImageOneChannels.Dispose();
                    ho_TextImageOneChannels = ExpTmpOutVar_0;
                }
                ho_TextImage.Dispose();
                HOperatorSet.ChannelsToImage(ho_TextImageOneChannels, out ho_TextImage);
                //
                //Greate black image to separate columns.
                hv_SeparateImageHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SeparateImageHeight = hv_NumRows * (hv_ImageHeight + hv_TextImageHeight);
                }
                hv_SeparateImageWidth.Dispose();
                hv_SeparateImageWidth = 4;
                ho_SeparateImageOneChannel.Dispose();
                HOperatorSet.GenImageConst(out ho_SeparateImageOneChannel, "real", hv_SeparateImageWidth,
                    hv_SeparateImageHeight);
                ho_SeparateImageOneChannels.Dispose();
                HOperatorSet.ConcatObj(ho_SeparateImageOneChannel, ho_SeparateImageOneChannel,
                    out ho_SeparateImageOneChannels);
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_SeparateImageOneChannels, ho_SeparateImageOneChannel,
                        out ExpTmpOutVar_0);
                    ho_SeparateImageOneChannels.Dispose();
                    ho_SeparateImageOneChannels = ExpTmpOutVar_0;
                }
                ho_SeparateImage.Dispose();
                HOperatorSet.ChannelsToImage(ho_SeparateImageOneChannels, out ho_SeparateImage
                    );
                //
                //Adapt images with frame and checkmark/cross.
                ho_GTImages.Dispose();
                HOperatorSet.GenEmptyObj(out ho_GTImages);
                HTuple end_val82 = hv_NumSamples - 1;
                HTuple step_val82 = 1;
                for (hv_Index = 0; hv_Index.Continue(end_val82, step_val82); hv_Index = hv_Index.TupleAdd(step_val82))
                {
                    //Scale iamges to [0,1] to have identical color ranges.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_GTImage.Dispose();
                        HOperatorSet.SelectObj(ho_GTImagesRaw, out ho_GTImage, hv_Index + 1);
                    }
                    hv_NumChannels.Dispose();
                    HOperatorSet.CountChannels(ho_GTImage, out hv_NumChannels);
                    ho_GTImageChannelsScaled.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_GTImageChannelsScaled);
                    HTuple end_val87 = hv_NumChannels - 1;
                    HTuple step_val87 = 1;
                    for (hv_IndexChannel = 0; hv_IndexChannel.Continue(end_val87, step_val87); hv_IndexChannel = hv_IndexChannel.TupleAdd(step_val87))
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_GTImageChannel.Dispose();
                            HOperatorSet.AccessChannel(ho_GTImage, out ho_GTImageChannel, hv_IndexChannel + 1);
                        }
                        hv_ScaleMax.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ScaleMax = (hvec_GrayMaxs[hv_Index].T).TupleSelect(
                                hv_IndexChannel);
                        }
                        hv_ScaleMin.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ScaleMin = (hvec_GrayMins[hv_Index].T).TupleSelect(
                                hv_IndexChannel);
                        }
                        if ((int)(new HTuple(((hv_ScaleMax - hv_ScaleMin)).TupleGreater(1e-5))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_GTImageChannelScaled.Dispose();
                                HOperatorSet.ScaleImage(ho_GTImageChannel, out ho_GTImageChannelScaled,
                                    1.0 / (hv_ScaleMax - hv_ScaleMin), (-hv_ScaleMin) / (hv_ScaleMax - hv_ScaleMin));
                            }
                        }
                        else
                        {
                            ho_GTImageChannelScaled.Dispose();
                            HOperatorSet.ScaleImage(ho_GTImageChannel, out ho_GTImageChannelScaled,
                                0, 0);
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_GTImageChannelsScaled, ho_GTImageChannelScaled,
                                out ExpTmpOutVar_0);
                            ho_GTImageChannelsScaled.Dispose();
                            ho_GTImageChannelsScaled = ExpTmpOutVar_0;
                        }
                    }
                    ho_GTImage.Dispose();
                    HOperatorSet.ChannelsToImage(ho_GTImageChannelsScaled, out ho_GTImage);
                    //The frame has 3 channels, hence ensure that GTImage
                    //has equal number of channels for display.
                    if ((int)(new HTuple(hv_NumChannels.TupleNotEqual(3))) != 0)
                    {
                        //Just take the first channel and use this to generate
                        //an image with 3 channels for visualization.
                        ho_GTImageR.Dispose();
                        HOperatorSet.AccessChannel(ho_GTImage, out ho_GTImageR, 1);
                        ho_GTImageG.Dispose();
                        HOperatorSet.CopyImage(ho_GTImageR, out ho_GTImageG);
                        ho_GTImageB.Dispose();
                        HOperatorSet.CopyImage(ho_GTImageR, out ho_GTImageB);
                        ho_GTImage.Dispose();
                        HOperatorSet.Compose3(ho_GTImageR, ho_GTImageG, ho_GTImageB, out ho_GTImage
                            );
                    }
                    //
                    if ((int)(new HTuple(((hv_PredictionsCorrect.TupleSelect(hv_Index))).TupleEqual(
                        1))) != 0)
                    {
                        //If the actual image is predicted correctly, plot a green frame and
                        //a green checkmark.
                        ho_RegionContour.Dispose();
                        ho_RegionContour = new HObject(ho_RegionContourCheck);
                        hv_Color.Dispose();
                        hv_Color = new HTuple();
                        hv_Color[0] = 0;
                        hv_Color[1] = 1;
                        hv_Color[2] = 0;
                    }
                    else
                    {
                        //Same as for the correct predictions, plot red frame and
                        //a red cross for uncorrect predictions.
                        ho_RegionContour.Dispose();
                        ho_RegionContour = new HObject(ho_RegionContourCross);
                        hv_Color.Dispose();
                        hv_Color = new HTuple();
                        hv_Color[0] = 1;
                        hv_Color[1] = 0;
                        hv_Color[2] = 0;
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.PaintXld(ho_Frame, ho_GTImage, out ExpTmpOutVar_0, hv_Color);
                        ho_GTImage.Dispose();
                        ho_GTImage = ExpTmpOutVar_0;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.PaintXld(ho_RegionContour, ho_GTImage, out ExpTmpOutVar_0, hv_Color);
                        ho_GTImage.Dispose();
                        ho_GTImage = ExpTmpOutVar_0;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_GTImages, ho_GTImage, out ExpTmpOutVar_0);
                        ho_GTImages.Dispose();
                        ho_GTImages = ExpTmpOutVar_0;
                    }
                    //Add TextImage.
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_GTImages, ho_TextImage, out ExpTmpOutVar_0);
                        ho_GTImages.Dispose();
                        ho_GTImages = ExpTmpOutVar_0;
                    }
                }
                //
                //Tile the images. The maximum is 3x3=9 samples.
                //Set row/column positions of upper-left corners of images and text images.
                hv_Number.Dispose();
                HOperatorSet.CountObj(ho_GTImages, out hv_Number);
                hv_TiledRows.Dispose();
                HOperatorSet.TupleGenConst(hv_Number, 0, out hv_TiledRows);
                hv_TiledColumns.Dispose();
                HOperatorSet.TupleGenConst(hv_Number, 0, out hv_TiledColumns);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TextImageRows.Dispose();
                    HOperatorSet.TupleGenConst(hv_Number / 2, 0, out hv_TextImageRows);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TextImageColumns.Dispose();
                    HOperatorSet.TupleGenConst(hv_Number / 2, 0, out hv_TextImageColumns);
                }
                HTuple end_val136 = (hv_Number / 2) - 1;
                HTuple step_val136 = 1;
                for (hv_Index = 0; hv_Index.Continue(end_val136, step_val136); hv_Index = hv_Index.TupleAdd(step_val136))
                {
                    if (hv_TiledRows == null)
                        hv_TiledRows = new HTuple();
                    hv_TiledRows[2 * hv_Index] = (hv_TextImageHeight + hv_ImageHeight) * (hv_Index % hv_NumRows);
                    if (hv_TextImageRows == null)
                        hv_TextImageRows = new HTuple();
                    hv_TextImageRows[hv_Index] = ((hv_TextImageHeight + hv_ImageHeight) * (hv_Index % hv_NumRows)) + hv_ImageHeight;
                    if (hv_TiledRows == null)
                        hv_TiledRows = new HTuple();
                    hv_TiledRows[(2 * hv_Index) + 1] = hv_TextImageRows.TupleSelect(hv_Index);
                    if (hv_TiledColumns == null)
                        hv_TiledColumns = new HTuple();
                    hv_TiledColumns[2 * hv_Index] = (hv_ImageWidth + hv_SeparateImageWidth) * (hv_Index / hv_NumRows);
                    if (hv_TextImageColumns == null)
                        hv_TextImageColumns = new HTuple();
                    hv_TextImageColumns[hv_Index] = hv_TiledColumns.TupleSelect(2 * hv_Index);
                    if (hv_TiledColumns == null)
                        hv_TiledColumns = new HTuple();
                    hv_TiledColumns[(2 * hv_Index) + 1] = hv_TextImageColumns.TupleSelect(hv_Index);
                }
                //Add images and row/column positions of upper-left corners of SeparateImages.
                HTuple end_val145 = hv_NumColumns - 2;
                HTuple step_val145 = 1;
                for (hv_Index = 0; hv_Index.Continue(end_val145, step_val145); hv_Index = hv_Index.TupleAdd(step_val145))
                {
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_GTImages, ho_SeparateImage, out ExpTmpOutVar_0);
                        ho_GTImages.Dispose();
                        ho_GTImages = ExpTmpOutVar_0;
                    }
                    if (hv_TiledRows == null)
                        hv_TiledRows = new HTuple();
                    hv_TiledRows[new HTuple(hv_TiledRows.TupleLength())] = 0;
                    if (hv_TiledColumns == null)
                        hv_TiledColumns = new HTuple();
                    hv_TiledColumns[new HTuple(hv_TiledColumns.TupleLength())] = (hv_Index + 1) * hv_ImageWidth;
                }
                //
                hv_TiledHeights.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TiledHeights = hv_NumRows * (hv_TextImageHeight + hv_ImageHeight);
                }
                hv_TiledWidths.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TiledWidths = (hv_NumColumns * hv_ImageWidth) + ((hv_NumColumns - 1) * hv_SeparateImageWidth);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_MinusOnes.Dispose();
                    HOperatorSet.TupleGenConst(new HTuple(hv_TiledRows.TupleLength()), -1, out hv_MinusOnes);
                }
                ho_TiledImageRow.Dispose();
                HOperatorSet.TileImagesOffset(ho_GTImages, out ho_TiledImageRow, hv_TiledRows,
                    hv_TiledColumns, hv_MinusOnes, hv_MinusOnes, hv_MinusOnes, hv_MinusOnes,
                    hv_TiledWidths, hv_TiledHeights);
                //
                ho_GTImagesRaw.Dispose();
                ho_GTImage.Dispose();
                ho_Channel.Dispose();
                ho_RegionContourCheck.Dispose();
                ho_Rectangle1.Dispose();
                ho_Rectangle2.Dispose();
                ho_RegionContourCross.Dispose();
                ho_TopContour.Dispose();
                ho_LeftContour.Dispose();
                ho_RightContour.Dispose();
                ho_BottomContour.Dispose();
                ho_Frame.Dispose();
                ho_TextImageOneChannel.Dispose();
                ho_TextImageOneChannels.Dispose();
                ho_TextImage.Dispose();
                ho_SeparateImageOneChannel.Dispose();
                ho_SeparateImageOneChannels.Dispose();
                ho_SeparateImage.Dispose();
                ho_GTImages.Dispose();
                ho_GTImageChannelsScaled.Dispose();
                ho_GTImageChannel.Dispose();
                ho_GTImageChannelScaled.Dispose();
                ho_GTImageR.Dispose();
                ho_GTImageG.Dispose();
                ho_GTImageB.Dispose();
                ho_RegionContour.Dispose();

                hv_NumSamples.Dispose();
                hv_NumRows.Dispose();
                hv_NumColumns.Dispose();
                hv_Index.Dispose();
                hv_NumChannels.Dispose();
                hv_GrayMin.Dispose();
                hv_GrayMax.Dispose();
                hv_IndexChannel.Dispose();
                hv_GrayMinTmp.Dispose();
                hv_GrayMaxTmp.Dispose();
                hv__.Dispose();
                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_Length1.Dispose();
                hv_Length2.Dispose();
                hv_HomMat2DIdentity.Dispose();
                hv_HomMat2DRotate.Dispose();
                hv_HomMat2DCompose.Dispose();
                hv_FrameSize.Dispose();
                hv_SeparateImageHeight.Dispose();
                hv_SeparateImageWidth.Dispose();
                hv_ScaleMax.Dispose();
                hv_ScaleMin.Dispose();
                hv_Color.Dispose();
                hv_Number.Dispose();
                hv_TiledRows.Dispose();
                hv_TiledColumns.Dispose();
                hv_TiledHeights.Dispose();
                hv_TiledWidths.Dispose();
                hv_MinusOnes.Dispose();
                hvec_GrayMins.Dispose();
                hvec_GrayMaxs.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_GTImagesRaw.Dispose();
                ho_GTImage.Dispose();
                ho_Channel.Dispose();
                ho_RegionContourCheck.Dispose();
                ho_Rectangle1.Dispose();
                ho_Rectangle2.Dispose();
                ho_RegionContourCross.Dispose();
                ho_TopContour.Dispose();
                ho_LeftContour.Dispose();
                ho_RightContour.Dispose();
                ho_BottomContour.Dispose();
                ho_Frame.Dispose();
                ho_TextImageOneChannel.Dispose();
                ho_TextImageOneChannels.Dispose();
                ho_TextImage.Dispose();
                ho_SeparateImageOneChannel.Dispose();
                ho_SeparateImageOneChannels.Dispose();
                ho_SeparateImage.Dispose();
                ho_GTImages.Dispose();
                ho_GTImageChannelsScaled.Dispose();
                ho_GTImageChannel.Dispose();
                ho_GTImageChannelScaled.Dispose();
                ho_GTImageR.Dispose();
                ho_GTImageG.Dispose();
                ho_GTImageB.Dispose();
                ho_RegionContour.Dispose();

                hv_NumSamples.Dispose();
                hv_NumRows.Dispose();
                hv_NumColumns.Dispose();
                hv_Index.Dispose();
                hv_NumChannels.Dispose();
                hv_GrayMin.Dispose();
                hv_GrayMax.Dispose();
                hv_IndexChannel.Dispose();
                hv_GrayMinTmp.Dispose();
                hv_GrayMaxTmp.Dispose();
                hv__.Dispose();
                hv_ImageWidth.Dispose();
                hv_ImageHeight.Dispose();
                hv_Length1.Dispose();
                hv_Length2.Dispose();
                hv_HomMat2DIdentity.Dispose();
                hv_HomMat2DRotate.Dispose();
                hv_HomMat2DCompose.Dispose();
                hv_FrameSize.Dispose();
                hv_SeparateImageHeight.Dispose();
                hv_SeparateImageWidth.Dispose();
                hv_ScaleMax.Dispose();
                hv_ScaleMin.Dispose();
                hv_Color.Dispose();
                hv_Number.Dispose();
                hv_TiledRows.Dispose();
                hv_TiledColumns.Dispose();
                hv_TiledHeights.Dispose();
                hv_TiledWidths.Dispose();
                hv_MinusOnes.Dispose();
                hvec_GrayMins.Dispose();
                hvec_GrayMaxs.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Semantic Segmentation
        // Short Description: Generate a tiled image for segmentation DLSamples. 
        private void gen_tiled_segmentation_image(out HObject ho_TiledImageRow, HTuple hv_DLSamples,
            HTuple hv_SpacingCol, HTuple hv_Width, HTuple hv_Height)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_GTImages, ho_GTImage = null;

            // Local control variables 

            HTuple hv_Crop = new HTuple(), hv_OffsetRow = new HTuple();
            HTuple hv_NumSamples = new HTuple(), hv_Index = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_TiledImageRow);
            HOperatorSet.GenEmptyObj(out ho_GTImages);
            HOperatorSet.GenEmptyObj(out ho_GTImage);
            try
            {
                //
                //This procedure tiles the segmentation images of given samples in a row.
                //
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Crop.Dispose();
                    HOperatorSet.TupleGenConst(new HTuple(hv_Width.TupleLength()), -1, out hv_Crop);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_OffsetRow.Dispose();
                    HOperatorSet.TupleGenConst(new HTuple(hv_Width.TupleLength()), 0, out hv_OffsetRow);
                }
                hv_NumSamples.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumSamples = new HTuple(hv_DLSamples.TupleLength()
                        );
                }
                ho_GTImages.Dispose();
                HOperatorSet.GenEmptyObj(out ho_GTImages);
                HTuple end_val7 = hv_NumSamples - 1;
                HTuple step_val7 = 1;
                for (hv_Index = 0; hv_Index.Continue(end_val7, step_val7); hv_Index = hv_Index.TupleAdd(step_val7))
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_GTImage.Dispose();
                        HOperatorSet.GetDictObject(out ho_GTImage, hv_DLSamples.TupleSelect(hv_Index),
                            "segmentation_image");
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_GTImages, ho_GTImage, out ExpTmpOutVar_0);
                        ho_GTImages.Dispose();
                        ho_GTImages = ExpTmpOutVar_0;
                    }
                }
                //
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_TiledImageRow.Dispose();
                    HOperatorSet.TileImagesOffset(ho_GTImages, out ho_TiledImageRow, hv_OffsetRow,
                        (((new HTuple(0)).TupleConcat(((hv_Width + hv_SpacingCol)).TupleCumul()))).TupleSelectRange(
                        0, (new HTuple(hv_Width.TupleLength())) - 1), hv_Crop, hv_Crop, hv_Crop, hv_Crop,
                        (((((hv_Width + hv_SpacingCol)).TupleCumul())).TupleSelect((new HTuple(hv_Width.TupleLength()
                        )) - 1)) - hv_SpacingCol, hv_Height.TupleMax());
                }
                ho_GTImages.Dispose();
                ho_GTImage.Dispose();

                hv_Crop.Dispose();
                hv_OffsetRow.Dispose();
                hv_NumSamples.Dispose();
                hv_Index.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_GTImages.Dispose();
                ho_GTImage.Dispose();

                hv_Crop.Dispose();
                hv_OffsetRow.Dispose();
                hv_NumSamples.Dispose();
                hv_Index.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection
        // Short Description: Get the ground truth anomaly label and label ID. 
        private void get_anomaly_ground_truth_label(HTuple hv_SampleKeys, HTuple hv_DLSample,
            out HTuple hv_AnomalyLabelGroundTruth, out HTuple hv_AnomalyLabelIDGroundTruth)
        {


            // Initialize local and output iconic variables 
            hv_AnomalyLabelGroundTruth = new HTuple();
            hv_AnomalyLabelIDGroundTruth = new HTuple();
            //
            //This procedure returns the anomaly ground truth label.
            //
            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("anomaly_label"))).TupleNotEqual(
                -1))) != 0)
            {
                hv_AnomalyLabelGroundTruth.Dispose();
                HOperatorSet.GetDictTuple(hv_DLSample, "anomaly_label", out hv_AnomalyLabelGroundTruth);
            }
            else
            {
                throw new HalconException("Ground truth class label cannot be found in DLSample.");
            }
            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("anomaly_label_id"))).TupleNotEqual(
                -1))) != 0)
            {
                hv_AnomalyLabelIDGroundTruth.Dispose();
                HOperatorSet.GetDictTuple(hv_DLSample, "anomaly_label_id", out hv_AnomalyLabelIDGroundTruth);
            }
            else
            {
                throw new HalconException("Ground truth class label id cannot be found in DLSample.");
            }
            //


            return;
        }

        // Chapter: Deep Learning / Anomaly Detection
        // Short Description: Get the anomaly results out of DLResult and apply thresholds (if specified). 
        private void get_anomaly_result(out HObject ho_AnomalyImage, out HObject ho_AnomalyRegion,
            HTuple hv_DLResult, HTuple hv_ResultKeys, HTuple hv_AnomalyClassThreshold, HTuple hv_AnomalyRegionThreshold,
            out HTuple hv_AnomalyScore, out HTuple hv_AnomalyClassID, out HTuple hv_AnomalyClassThresholdDisplay,
            out HTuple hv_AnomalyRegionThresholdDisplay)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_AnomalyImageExists = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_AnomalyImage);
            HOperatorSet.GenEmptyObj(out ho_AnomalyRegion);
            hv_AnomalyScore = new HTuple();
            hv_AnomalyClassID = new HTuple();
            hv_AnomalyClassThresholdDisplay = new HTuple();
            hv_AnomalyRegionThresholdDisplay = new HTuple();
            try
            {
                //
                //This procedure returns the inference results in DLResult which are
                //the anomaly image and the anomaly score. It also returns the
                //classification of the anomaly score and segmentation of anomalous
                //pixels in the anomaly image by applying the specified thresholds if
                //given. Otherwise the results from DLResult are used.
                //
                if ((int)(new HTuple(((hv_ResultKeys.TupleFind("anomaly_image"))).TupleNotEqual(
                    -1))) != 0)
                {
                    hv_AnomalyImageExists.Dispose();
                    HOperatorSet.GetDictParam(hv_DLResult, "key_exists", "anomaly_image", out hv_AnomalyImageExists);
                    if ((int)(hv_AnomalyImageExists) != 0)
                    {
                        ho_AnomalyImage.Dispose();
                        HOperatorSet.GetDictObject(out ho_AnomalyImage, hv_DLResult, "anomaly_image");
                    }
                    else
                    {
                        throw new HalconException("Result anomaly image could not be found in DLResult.");
                    }
                }
                else
                {
                    throw new HalconException("Result anomaly image could not be found in DLResult.");
                }
                //
                if ((int)(new HTuple(((hv_ResultKeys.TupleFind("anomaly_score"))).TupleNotEqual(
                    -1))) != 0)
                {
                    hv_AnomalyScore.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLResult, "anomaly_score", out hv_AnomalyScore);
                }
                else
                {
                    throw new HalconException("Result anomaly score could not be found in DLResult.");
                }
                //
                hv_AnomalyRegionThresholdDisplay.Dispose();
                hv_AnomalyRegionThresholdDisplay = -1;
                if ((int)(new HTuple(hv_AnomalyRegionThreshold.TupleNotEqual(-1))) != 0)
                {
                    //Apply threshold for segmentation result.
                    if ((int)(new HTuple((new HTuple(hv_AnomalyRegionThreshold.TupleLength())).TupleNotEqual(
                        1))) != 0)
                    {
                        throw new HalconException("Selected 'anomaly_region_threshold' must be specified by exactly one value.");
                    }
                    if ((int)((new HTuple(hv_AnomalyRegionThreshold.TupleGreater(1))).TupleOr(
                        new HTuple(hv_AnomalyRegionThreshold.TupleLess(0)))) != 0)
                    {
                        throw new HalconException("Selected 'anomaly_region_threshold' out of range. It must be between 0 and 1.");
                    }
                    ho_AnomalyRegion.Dispose();
                    HOperatorSet.Threshold(ho_AnomalyImage, out ho_AnomalyRegion, hv_AnomalyRegionThreshold,
                        1);
                    hv_AnomalyRegionThresholdDisplay.Dispose();
                    hv_AnomalyRegionThresholdDisplay = new HTuple(hv_AnomalyRegionThreshold);
                }
                else
                {
                    //If no threshold is given, use the threshold and resulting anomaly region out of DLResult.
                    if ((int)(new HTuple(((hv_ResultKeys.TupleFind("anomaly_region"))).TupleNotEqual(
                        -1))) != 0)
                    {
                        ho_AnomalyRegion.Dispose();
                        HOperatorSet.GetDictObject(out ho_AnomalyRegion, hv_DLResult, "anomaly_region");
                        hv_AnomalyRegionThresholdDisplay.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLResult, "anomaly_segmentation_threshold",
                            out hv_AnomalyRegionThresholdDisplay);
                    }
                    else
                    {
                        ho_AnomalyRegion.Dispose();
                        HOperatorSet.GenEmptyObj(out ho_AnomalyRegion);
                    }
                }
                //
                hv_AnomalyClassThresholdDisplay.Dispose();
                hv_AnomalyClassThresholdDisplay = -1;
                hv_AnomalyClassID.Dispose();
                hv_AnomalyClassID = -1;
                if ((int)(new HTuple(hv_AnomalyClassThreshold.TupleNotEqual(-1))) != 0)
                {
                    //Apply threshold for classification result.
                    if ((int)(new HTuple((new HTuple(hv_AnomalyClassThreshold.TupleLength())).TupleNotEqual(
                        1))) != 0)
                    {
                        throw new HalconException("Selected 'anomaly_classification_threshold' must be specified by exactly one value.");
                    }
                    if ((int)(new HTuple(hv_AnomalyClassThreshold.TupleLess(0.0))) != 0)
                    {
                        throw new HalconException("Selected 'anomaly_classification_threshold' cannot be negative.");
                    }
                    if ((int)(new HTuple(hv_AnomalyScore.TupleLess(hv_AnomalyClassThreshold))) != 0)
                    {
                        hv_AnomalyClassID.Dispose();
                        hv_AnomalyClassID = 0;
                    }
                    else
                    {
                        hv_AnomalyClassID.Dispose();
                        hv_AnomalyClassID = 1;
                    }
                    hv_AnomalyClassThresholdDisplay.Dispose();
                    hv_AnomalyClassThresholdDisplay = new HTuple(hv_AnomalyClassThreshold);
                }
                else
                {
                    //If no threshold is given, use the threshold and resulting class id out of DLResult.
                    if ((int)(new HTuple(((hv_ResultKeys.TupleFind("anomaly_class_id"))).TupleNotEqual(
                        -1))) != 0)
                    {
                        hv_AnomalyClassID.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLResult, "anomaly_class_id", out hv_AnomalyClassID);
                        hv_AnomalyClassThresholdDisplay.Dispose();
                        HOperatorSet.GetDictTuple(hv_DLResult, "anomaly_classification_threshold",
                            out hv_AnomalyClassThresholdDisplay);
                    }
                    else
                    {
                        hv_AnomalyClassID.Dispose();
                        hv_AnomalyClassID = -1;
                    }
                }
                //

                hv_AnomalyImageExists.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_AnomalyImageExists.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Window
        // Short Description: Get the next child window that can be used for visualization. 
        private void get_child_window(HTuple hv_HeightImage, HTuple hv_Font, HTuple hv_FontSize,
            HTuple hv_Text, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict,
            HTuple hv_WindowHandleKey, out HTuple hv_WindowImageRatio, out HTuple hv_PrevWindowCoordinatesOut)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_OpenNewWindow = new HTuple(), hv_WindowHandles = new HTuple();
            HTuple hv_ParentWindowHandle = new HTuple(), hv_ChildWindowHandle = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_MetaInfo = new HTuple();
            HTuple hv_WindowRow = new HTuple(), hv_WindowColumn = new HTuple();
            HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
            // Initialize local and output iconic variables 
            hv_WindowImageRatio = new HTuple();
            hv_PrevWindowCoordinatesOut = new HTuple();
            try
            {
                //
                //This procedure returns the next child window that
                //is used for visualization. If ReuseWindows is true
                //and WindowHandleList is suitable, the window handles
                //that are passed over are used. Else, this procedure
                //opens a new window, either next to the last ones, or
                //in a new row.
                //
                //First, check if the requested window is already available.
                hv_OpenNewWindow.Dispose();
                hv_OpenNewWindow = 0;
                try
                {
                    hv_WindowHandles.Dispose();
                    HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, out hv_WindowHandles);
                    hv_ParentWindowHandle.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ParentWindowHandle = hv_WindowHandles.TupleSelect(
                            0);
                    }
                    hv_ChildWindowHandle.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ChildWindowHandle = hv_WindowHandles.TupleSelect(
                            1);
                    }
                    //Check if window handle is valid.
                    try
                    {
                        HOperatorSet.FlushBuffer(hv_ChildWindowHandle);
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException2)
                    {
                        HDevExpDefaultException2.ToHTuple(out hv_Exception);
                        //Since there is something wrong with the current window, create a new one.
                        hv_OpenNewWindow.Dispose();
                        hv_OpenNewWindow = 1;
                    }
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    hv_OpenNewWindow.Dispose();
                    hv_OpenNewWindow = 1;
                }
                //
                //Get next child window.
                if ((int)(hv_OpenNewWindow.TupleNot()) != 0)
                {
                    //
                    //If possible, reuse existing window handles.
                    HDevWindowStack.SetActive(hv_ChildWindowHandle);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                    }
                    set_display_font(hv_ChildWindowHandle, hv_FontSize, hv_Font, "true", "false");
                    //
                    hv_MetaInfo.Dispose();
                    HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
                    //
                    //Get previous window coordinates.
                    hv_WindowRow.Dispose(); hv_WindowColumn.Dispose(); hv_WindowWidth.Dispose(); hv_WindowHeight.Dispose();
                    HOperatorSet.GetWindowExtents(hv_ParentWindowHandle, out hv_WindowRow, out hv_WindowColumn,
                        out hv_WindowWidth, out hv_WindowHeight);
                    hv_WindowImageRatio.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_WindowImageRatio = hv_WindowHeight / (hv_HeightImage * 1.0);
                    }
                    //
                    try
                    {
                        //
                        //Get WindowImageRatio from parent window.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_WindowImageRatio.Dispose();
                            HOperatorSet.GetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_window_image_ratio_height",
                                out hv_WindowImageRatio);
                        }
                        //
                        //Get previous window coordinates.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_PrevWindowCoordinatesOut.Dispose();
                            HOperatorSet.GetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_child_window_coordinates",
                                out hv_PrevWindowCoordinatesOut);
                        }
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException1)
                    {
                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        //
                        //Set WindowImageRatio from parent window.
                        hv_WindowRow.Dispose(); hv_WindowColumn.Dispose(); hv_WindowWidth.Dispose(); hv_WindowHeight.Dispose();
                        HOperatorSet.GetWindowExtents(hv_ParentWindowHandle, out hv_WindowRow,
                            out hv_WindowColumn, out hv_WindowWidth, out hv_WindowHeight);
                        hv_WindowImageRatio.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_WindowImageRatio = hv_WindowHeight / (hv_HeightImage * 1.0);
                        }
                        //
                        //Set previous window coordinates.
                        if (hv_PrevWindowCoordinatesOut == null)
                            hv_PrevWindowCoordinatesOut = new HTuple();
                        hv_PrevWindowCoordinatesOut[0] = hv_WindowRow;
                        if (hv_PrevWindowCoordinatesOut == null)
                            hv_PrevWindowCoordinatesOut = new HTuple();
                        hv_PrevWindowCoordinatesOut[1] = hv_WindowColumn;
                        if (hv_PrevWindowCoordinatesOut == null)
                            hv_PrevWindowCoordinatesOut = new HTuple();
                        hv_PrevWindowCoordinatesOut[2] = hv_WindowWidth;
                        if (hv_PrevWindowCoordinatesOut == null)
                            hv_PrevWindowCoordinatesOut = new HTuple();
                        hv_PrevWindowCoordinatesOut[3] = hv_WindowHeight;
                    }
                }
                else
                {
                    //
                    //Open a new child window.
                    hv_ChildWindowHandle.Dispose(); hv_PrevWindowCoordinatesOut.Dispose();
                    open_child_window(hv_ParentWindowHandle, hv_Font, hv_FontSize, hv_Text, hv_PrevWindowCoordinates,
                        hv_WindowHandleDict, hv_WindowHandleKey, out hv_ChildWindowHandle, out hv_PrevWindowCoordinatesOut);
                    HOperatorSet.SetWindowParam(hv_ChildWindowHandle, "flush", "false");
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, hv_ParentWindowHandle.TupleConcat(
                            hv_ChildWindowHandle));
                    }
                }
                //

                hv_OpenNewWindow.Dispose();
                hv_WindowHandles.Dispose();
                hv_ParentWindowHandle.Dispose();
                hv_ChildWindowHandle.Dispose();
                hv_Exception.Dispose();
                hv_MetaInfo.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowColumn.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_OpenNewWindow.Dispose();
                hv_WindowHandles.Dispose();
                hv_ParentWindowHandle.Dispose();
                hv_ChildWindowHandle.Dispose();
                hv_Exception.Dispose();
                hv_MetaInfo.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowColumn.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Classification
        // Short Description: Get the ground truth classification label id. 
        private void get_classification_ground_truth(HTuple hv_SampleKeys, HTuple hv_DLSample,
            out HTuple hv_ClassificationLabelIDGroundTruth)
        {


            // Initialize local and output iconic variables 
            hv_ClassificationLabelIDGroundTruth = new HTuple();
            //
            //This procedure returns the classification ground truth label ID.
            //
            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("image_label_id"))).TupleNotEqual(
                -1))) != 0)
            {
                hv_ClassificationLabelIDGroundTruth.Dispose();
                HOperatorSet.GetDictTuple(hv_DLSample, "image_label_id", out hv_ClassificationLabelIDGroundTruth);
            }
            else
            {
                throw new HalconException("Ground truth class label cannot be found in DLSample.");
            }
            //


            return;
        }

        // Chapter: Deep Learning / Classification
        // Short Description: Get the predicted classification class ID. 
        private void get_classification_result(HTuple hv_ResultKeys, HTuple hv_DLResult,
            out HTuple hv_ClassificationClassID)
        {



            // Local iconic variables 
            // Initialize local and output iconic variables 
            hv_ClassificationClassID = new HTuple();
            //
            //This procedure returns the predicted classification class ID.
            //
            if ((int)(new HTuple(((hv_ResultKeys.TupleFind("classification_class_ids"))).TupleNotEqual(
                -1))) != 0)
            {
                hv_ClassificationClassID.Dispose();
                HOperatorSet.GetDictTuple(hv_DLResult, "classification_class_ids", out hv_ClassificationClassID);
                if ((int)(new HTuple((new HTuple(hv_ClassificationClassID.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ClassificationClassID = hv_ClassificationClassID.TupleSelect(
                                0);
                            hv_ClassificationClassID.Dispose();
                            hv_ClassificationClassID = ExpTmpLocalVar_ClassificationClassID;
                        }
                    }
                }
            }
            else
            {
                throw new HalconException("Key entry 'classification_class_ids' could not be found in DLResult.");
            }
            //


            return;
        }

        // Chapter: Deep Learning / Semantic Segmentation
        // Short Description: Get the confidences of the segmentation result. 
        private void get_confidence_image(out HObject ho_ImageConfidence, HTuple hv_ResultKeys,
            HTuple hv_DLResult)
        {


            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ImageConfidence);
            //
            //This procedure returns confidences of the segmentation result.
            //
            if ((int)(new HTuple(((hv_ResultKeys.TupleFind("segmentation_confidence"))).TupleNotEqual(
                -1))) != 0)
            {
                ho_ImageConfidence.Dispose();
                HOperatorSet.GetDictObject(out ho_ImageConfidence, hv_DLResult, "segmentation_confidence");
            }
            else if ((int)(new HTuple(((hv_ResultKeys.TupleFind("segmentation_confidences"))).TupleNotEqual(
                -1))) != 0)
            {
                ho_ImageConfidence.Dispose();
                HOperatorSet.GetDictObject(out ho_ImageConfidence, hv_DLResult, "segmentation_confidences");
            }
            else
            {
                throw new HalconException("Confidence image could not be found in DLSample.");
            }


            return;
        }

        // Chapter: Deep Learning / Model
        // Short Description: Generate NumColors distinct colors 
        private void get_distinct_colors(HTuple hv_NumColors, HTuple hv_Random, HTuple hv_StartColor,
            HTuple hv_EndColor, out HTuple hv_Colors)
        {



            // Local iconic variables 

            HObject ho_HLSImageH, ho_HLSImageL, ho_HLSImageS;
            HObject ho_ImageR, ho_ImageG, ho_ImageB;

            // Local control variables 

            HTuple hv_IsString = new HTuple(), hv_Hue = new HTuple();
            HTuple hv_Lightness = new HTuple(), hv_Saturation = new HTuple();
            HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
            HTuple hv_Red = new HTuple(), hv_Green = new HTuple();
            HTuple hv_Blue = new HTuple();
            HTuple hv_EndColor_COPY_INP_TMP = new HTuple(hv_EndColor);
            HTuple hv_Random_COPY_INP_TMP = new HTuple(hv_Random);

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_HLSImageH);
            HOperatorSet.GenEmptyObj(out ho_HLSImageL);
            HOperatorSet.GenEmptyObj(out ho_HLSImageS);
            HOperatorSet.GenEmptyObj(out ho_ImageR);
            HOperatorSet.GenEmptyObj(out ho_ImageG);
            HOperatorSet.GenEmptyObj(out ho_ImageB);
            hv_Colors = new HTuple();
            try
            {
                //
                //We get distinct color-values first in HLS color-space.
                //Assumes hue [0, EndColor), lightness [0, 1), saturation [0, 1).
                //
                //Parameter checks.
                //NumColors.
                if ((int)(new HTuple(hv_NumColors.TupleLess(1))) != 0)
                {
                    throw new HalconException("NumColors should be at least 1");
                }
                if ((int)(((hv_NumColors.TupleIsInt())).TupleNot()) != 0)
                {
                    throw new HalconException("NumColors should be of type int");
                }
                if ((int)(new HTuple((new HTuple(hv_NumColors.TupleLength())).TupleNotEqual(
                    1))) != 0)
                {
                    throw new HalconException("NumColors should have length 1");
                }
                //Random.
                if ((int)((new HTuple(hv_Random_COPY_INP_TMP.TupleNotEqual(0))).TupleAnd(new HTuple(hv_Random_COPY_INP_TMP.TupleNotEqual(
                    1)))) != 0)
                {
                    hv_IsString.Dispose();
                    HOperatorSet.TupleIsString(hv_Random_COPY_INP_TMP, out hv_IsString);
                    if ((int)(hv_IsString) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Random = (new HTuple(hv_Random_COPY_INP_TMP.TupleEqual(
                                    "true"))).TupleOr("false");
                                hv_Random_COPY_INP_TMP.Dispose();
                                hv_Random_COPY_INP_TMP = ExpTmpLocalVar_Random;
                            }
                        }
                    }
                    else
                    {
                        throw new HalconException("Random should be either true or false");
                    }
                }
                //StartColor.
                if ((int)(new HTuple((new HTuple(hv_StartColor.TupleLength())).TupleNotEqual(
                    1))) != 0)
                {
                    throw new HalconException("StartColor should have length 1");
                }
                if ((int)((new HTuple(hv_StartColor.TupleLess(0))).TupleOr(new HTuple(hv_StartColor.TupleGreater(
                    255)))) != 0)
                {
                    throw new HalconException(new HTuple("StartColor should be in the range [0, 255]"));
                }
                if ((int)(((hv_StartColor.TupleIsInt())).TupleNot()) != 0)
                {
                    throw new HalconException("StartColor should be of type int");
                }
                //EndColor.
                if ((int)(new HTuple((new HTuple(hv_EndColor_COPY_INP_TMP.TupleLength())).TupleNotEqual(
                    1))) != 0)
                {
                    throw new HalconException("EndColor should have length 1");
                }
                if ((int)((new HTuple(hv_EndColor_COPY_INP_TMP.TupleLess(0))).TupleOr(new HTuple(hv_EndColor_COPY_INP_TMP.TupleGreater(
                    255)))) != 0)
                {
                    throw new HalconException(new HTuple("EndColor should be in the range [0, 255]"));
                }
                if ((int)(((hv_EndColor_COPY_INP_TMP.TupleIsInt())).TupleNot()) != 0)
                {
                    throw new HalconException("EndColor should be of type int");
                }
                //
                //Color generation.
                if ((int)(new HTuple(hv_StartColor.TupleGreater(hv_EndColor_COPY_INP_TMP))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_EndColor = hv_EndColor_COPY_INP_TMP + 255;
                            hv_EndColor_COPY_INP_TMP.Dispose();
                            hv_EndColor_COPY_INP_TMP = ExpTmpLocalVar_EndColor;
                        }
                    }
                }
                if ((int)(new HTuple(hv_NumColors.TupleNotEqual(1))) != 0)
                {
                    hv_Hue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Hue = (hv_StartColor + (((((hv_EndColor_COPY_INP_TMP - hv_StartColor) * ((HTuple.TupleGenSequence(
                            0, hv_NumColors - 1, 1)).TupleReal())) / (((hv_NumColors - 1)).TupleReal()))).TupleInt()
                            )) % 255;
                    }
                }
                else
                {
                    hv_Hue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Hue = ((hv_StartColor.TupleConcat(
                            hv_EndColor_COPY_INP_TMP))).TupleMean();
                    }
                }
                if ((int)(hv_Random_COPY_INP_TMP) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Hue = hv_Hue.TupleSelect(
                                (HTuple.TupleRand(hv_NumColors)).TupleSortIndex());
                            hv_Hue.Dispose();
                            hv_Hue = ExpTmpLocalVar_Hue;
                        }
                    }
                    hv_Lightness.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Lightness = ((((5.0 + HTuple.TupleRand(
                            hv_NumColors)) * 255.0) / 10.0)).TupleInt();
                    }
                    hv_Saturation.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Saturation = ((((9.0 + HTuple.TupleRand(
                            hv_NumColors)) * 255.0) / 10.0)).TupleInt();
                    }
                }
                else
                {
                    hv_Lightness.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Lightness = ((HTuple.TupleGenConst(
                            hv_NumColors, 0.55) * 255.0)).TupleInt();
                    }
                    hv_Saturation.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Saturation = ((HTuple.TupleGenConst(
                            hv_NumColors, 0.95) * 255.0)).TupleInt();
                    }
                }
                //
                //Write colors to a 3-channel image in order to transform easier.
                ho_HLSImageH.Dispose();
                HOperatorSet.GenImageConst(out ho_HLSImageH, "byte", 1, hv_NumColors);
                ho_HLSImageL.Dispose();
                HOperatorSet.GenImageConst(out ho_HLSImageL, "byte", 1, hv_NumColors);
                ho_HLSImageS.Dispose();
                HOperatorSet.GenImageConst(out ho_HLSImageS, "byte", 1, hv_NumColors);
                hv_Rows.Dispose(); hv_Columns.Dispose();
                HOperatorSet.GetRegionPoints(ho_HLSImageH, out hv_Rows, out hv_Columns);
                HOperatorSet.SetGrayval(ho_HLSImageH, hv_Rows, hv_Columns, hv_Hue);
                HOperatorSet.SetGrayval(ho_HLSImageL, hv_Rows, hv_Columns, hv_Lightness);
                HOperatorSet.SetGrayval(ho_HLSImageS, hv_Rows, hv_Columns, hv_Saturation);
                //
                //Convert from HLS to RGB.
                ho_ImageR.Dispose(); ho_ImageG.Dispose(); ho_ImageB.Dispose();
                HOperatorSet.TransToRgb(ho_HLSImageH, ho_HLSImageL, ho_HLSImageS, out ho_ImageR,
                    out ho_ImageG, out ho_ImageB, "hls");
                //
                //Get RGB-values and transform to Hex.
                hv_Red.Dispose();
                HOperatorSet.GetGrayval(ho_ImageR, hv_Rows, hv_Columns, out hv_Red);
                hv_Green.Dispose();
                HOperatorSet.GetGrayval(ho_ImageG, hv_Rows, hv_Columns, out hv_Green);
                hv_Blue.Dispose();
                HOperatorSet.GetGrayval(ho_ImageB, hv_Rows, hv_Columns, out hv_Blue);
                hv_Colors.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Colors = (("#" + (hv_Red.TupleString(
                        "02x"))) + (hv_Green.TupleString("02x"))) + (hv_Blue.TupleString("02x"));
                }
                ho_HLSImageH.Dispose();
                ho_HLSImageL.Dispose();
                ho_HLSImageS.Dispose();
                ho_ImageR.Dispose();
                ho_ImageG.Dispose();
                ho_ImageB.Dispose();

                hv_EndColor_COPY_INP_TMP.Dispose();
                hv_Random_COPY_INP_TMP.Dispose();
                hv_IsString.Dispose();
                hv_Hue.Dispose();
                hv_Lightness.Dispose();
                hv_Saturation.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();

                return;
                //
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_HLSImageH.Dispose();
                ho_HLSImageL.Dispose();
                ho_HLSImageS.Dispose();
                ho_ImageR.Dispose();
                ho_ImageG.Dispose();
                ho_ImageB.Dispose();

                hv_EndColor_COPY_INP_TMP.Dispose();
                hv_Random_COPY_INP_TMP.Dispose();
                hv_IsString.Dispose();
                hv_Hue.Dispose();
                hv_Lightness.Dispose();
                hv_Saturation.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Generates certain colors for different ClassNames 
        private void get_dl_class_colors(HTuple hv_ClassNames, out HTuple hv_Colors)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_NumColors = new HTuple(), hv_ColorsRainbow = new HTuple();
            HTuple hv_ClassNamesGood = new HTuple(), hv_IndexFind = new HTuple();
            HTuple hv_GoodIdx = new HTuple(), hv_CurrentColor = new HTuple();
            HTuple hv_GreenIdx = new HTuple();
            // Initialize local and output iconic variables 
            hv_Colors = new HTuple();
            try
            {
                //
                //This procedure returns for each class a certain color.
                //
                //Define distinct colors for the classes.
                hv_NumColors.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumColors = new HTuple(hv_ClassNames.TupleLength()
                        );
                }
                //Get distinct colors without randomness makes neighboring colors look very similar.
                //We use a workaround to get deterministic colors where subsequent colors are distinguishable.
                hv_ColorsRainbow.Dispose();
                get_distinct_colors(hv_NumColors, 0, 0, 200, out hv_ColorsRainbow);
                {
                    HTuple ExpTmpOutVar_0;
                    HOperatorSet.TupleInverse(hv_ColorsRainbow, out ExpTmpOutVar_0);
                    hv_ColorsRainbow.Dispose();
                    hv_ColorsRainbow = ExpTmpOutVar_0;
                }
                hv_Colors.Dispose();
                make_neighboring_colors_distinguishable(hv_ColorsRainbow, out hv_Colors);
                //If a class 'OK','ok', 'good' or 'GOOD' is present set this class to green.
                //Only the first occurrence found is set to a green shade.
                hv_ClassNamesGood.Dispose();
                hv_ClassNamesGood = new HTuple();
                hv_ClassNamesGood[0] = "good";
                hv_ClassNamesGood[1] = "GOOD";
                hv_ClassNamesGood[2] = "ok";
                hv_ClassNamesGood[3] = "OK";
                for (hv_IndexFind = 0; (int)hv_IndexFind <= (int)((new HTuple(hv_ClassNamesGood.TupleLength()
                    )) - 1); hv_IndexFind = (int)hv_IndexFind + 1)
                {
                    hv_GoodIdx.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_GoodIdx = hv_ClassNames.TupleFindFirst(
                            hv_ClassNamesGood.TupleSelect(hv_IndexFind));
                    }
                    if ((int)((new HTuple(hv_GoodIdx.TupleNotEqual(-1))).TupleAnd(new HTuple((new HTuple(hv_ClassNames.TupleLength()
                        )).TupleLessEqual(8)))) != 0)
                    {
                        //If number of classes is <= 8, swap color with a green color.
                        hv_CurrentColor.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentColor = hv_Colors.TupleSelect(
                                hv_GoodIdx);
                        }
                        hv_GreenIdx.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_GreenIdx = (new HTuple((new HTuple(hv_ClassNames.TupleLength()
                                )) / 2.0)).TupleFloor();
                        }
                        //Set to pure green.
                        if (hv_Colors == null)
                            hv_Colors = new HTuple();
                        hv_Colors[hv_GoodIdx] = "#00ff00";
                        //Write original color to a green entry.
                        if (hv_Colors == null)
                            hv_Colors = new HTuple();
                        hv_Colors[hv_GreenIdx] = hv_CurrentColor;
                        break;
                    }
                    else if ((int)((new HTuple(hv_GoodIdx.TupleNotEqual(-1))).TupleAnd(
                        new HTuple((new HTuple(hv_ClassNames.TupleLength())).TupleGreater(8)))) != 0)
                    {
                        //If number of classes is larger than 8, set the respective color to green.
                        if (hv_Colors == null)
                            hv_Colors = new HTuple();
                        hv_Colors[hv_GoodIdx] = "#00ff00";
                        break;
                    }
                }

                hv_NumColors.Dispose();
                hv_ColorsRainbow.Dispose();
                hv_ClassNamesGood.Dispose();
                hv_IndexFind.Dispose();
                hv_GoodIdx.Dispose();
                hv_CurrentColor.Dispose();
                hv_GreenIdx.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_NumColors.Dispose();
                hv_ColorsRainbow.Dispose();
                hv_ClassNamesGood.Dispose();
                hv_IndexFind.Dispose();
                hv_GoodIdx.Dispose();
                hv_CurrentColor.Dispose();
                hv_GreenIdx.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Get a parameter value from GenParamValue with the name RequestedGenParamName. 
        private void get_genparam_single_value(HTuple hv_GenParamName, HTuple hv_GenParamValue,
            HTuple hv_RequestedGenParamName, out HTuple hv_FoundGenParamValue)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Indices = new HTuple();
            // Initialize local and output iconic variables 
            hv_FoundGenParamValue = new HTuple();
            try
            {
                //
                //Get a parameter value from GenParamValue with the name RequestedGenParamName,
                //which is allowed to appear only once in GenParamName.
                //
                //Set a default in case no value is provided.
                hv_FoundGenParamValue.Dispose();
                hv_FoundGenParamValue = new HTuple();
                //Set user provided values, if provided.
                hv_Indices.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Indices = hv_GenParamName.TupleFind(
                        hv_RequestedGenParamName);
                }
                if ((int)((new HTuple((new HTuple(hv_Indices.TupleLength())).TupleEqual(1))).TupleAnd(
                    new HTuple(hv_Indices.TupleNotEqual(-1)))) != 0)
                {
                    hv_FoundGenParamValue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_FoundGenParamValue = hv_GenParamValue.TupleSelect(
                            hv_Indices);
                    }
                }
                else if ((int)(new HTuple((new HTuple(hv_Indices.TupleLength())).TupleGreater(
                    1))) != 0)
                {
                    //Throw an error if more than one value was provided for RequestedGenParamName.
                    throw new HalconException(("Only a single parameter dictionary or none is allowed for '" + hv_RequestedGenParamName) + "'.");
                }

                hv_Indices.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Indices.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Get the image of a sample. 
        private void get_image(out HObject ho_Image, HTuple hv_SampleKeys, HTuple hv_DLSample)
        {


            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Image);
            //
            //This procedure returns the image of a sample.
            //
            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("image"))).TupleNotEqual(-1))) != 0)
            {
                ho_Image.Dispose();
                HOperatorSet.GetDictObject(out ho_Image, hv_DLSample, "image");
            }
            else
            {
                throw new HalconException("Image could not be found in DLSample.");
            }


            return;
        }

        // Chapter: Graphics / Window
        // Short Description: Get the next window that can be used for visualization. 
        private void get_next_window(HTuple hv_Font, HTuple hv_FontSize, HTuple hv_ShowBottomDesc,
            HTuple hv_WidthImage, HTuple hv_HeightImage, HTuple hv_MapColorBarWidth, HTuple hv_ScaleWindows,
            HTuple hv_ThresholdWidth, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict,
            HTuple hv_WindowHandleKey, out HTuple hv_CurrentWindowHandle, out HTuple hv_WindowImageRatioHeight,
            out HTuple hv_PrevWindowCoordinatesOut)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_OpenNewWindow = new HTuple(), hv_WindowHandles = new HTuple();
            HTuple hv_Value = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
            HTuple hv__ = new HTuple(), hv_MarginBottom = new HTuple();
            HTuple hv_WindowImageRatioWidth = new HTuple(), hv_SetPartRow2 = new HTuple();
            HTuple hv_SetPartColumn2 = new HTuple(), hv_MetaInfo = new HTuple();
            // Initialize local and output iconic variables 
            hv_CurrentWindowHandle = new HTuple();
            hv_WindowImageRatioHeight = new HTuple();
            hv_PrevWindowCoordinatesOut = new HTuple();
            try
            {
                //
                //This procedure returns the next window that
                //is used for visualization. If ReuseWindows is true
                //and WindowHandleList is suitable, the window handles
                //that are passed over are used. Else, this procedure
                //opens a new window, either next to the last ones, or
                //in a new row.
                //
                //First, check if the requested window is already available.
                hv_OpenNewWindow.Dispose();
                hv_OpenNewWindow = 0;
                try
                {
                    hv_WindowHandles.Dispose();
                    HOperatorSet.GetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, out hv_WindowHandles);
                    hv_CurrentWindowHandle.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentWindowHandle = hv_WindowHandles.TupleSelect(
                            0);
                    }
                    //Check if window handle is valid.
                    try
                    {
                        hv_Value.Dispose();
                        HOperatorSet.GetWindowParam(hv_CurrentWindowHandle, "flush", out hv_Value);
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException2)
                    {
                        HDevExpDefaultException2.ToHTuple(out hv_Exception);
                        //If there is something wrong with the current window, create a new one.
                        hv_OpenNewWindow.Dispose();
                        hv_OpenNewWindow = 1;
                        HOperatorSet.RemoveDictKey(hv_WindowHandleDict, hv_WindowHandleKey);
                    }
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    hv_OpenNewWindow.Dispose();
                    hv_OpenNewWindow = 1;
                }
                //
                //Get next window.
                if ((int)(hv_OpenNewWindow.TupleNot()) != 0)
                {
                    //
                    //If possible, reuse existing window handles.
                    HDevWindowStack.SetActive(hv_CurrentWindowHandle);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                    }
                    set_display_font(hv_CurrentWindowHandle, hv_FontSize, hv_Font, "true", "false");
                    //
                    //Calculate MarginBottom.
                    if ((int)(hv_ShowBottomDesc) != 0)
                    {
                        hv_Ascent.Dispose(); hv_Descent.Dispose(); hv__.Dispose(); hv__.Dispose();
                        HOperatorSet.GetStringExtents(hv_CurrentWindowHandle, "test_string", out hv_Ascent,
                            out hv_Descent, out hv__, out hv__);
                        hv_MarginBottom.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MarginBottom = ((2 * 12) + hv_Ascent) + hv_Descent;
                        }
                    }
                    else
                    {
                        hv_MarginBottom.Dispose();
                        hv_MarginBottom = 0;
                    }
                    //
                    //Get and set meta information for current window.
                    hv_WindowImageRatioHeight.Dispose(); hv_WindowImageRatioWidth.Dispose(); hv_SetPartRow2.Dispose(); hv_SetPartColumn2.Dispose(); hv_PrevWindowCoordinatesOut.Dispose();
                    update_window_meta_information(hv_CurrentWindowHandle, hv_WidthImage, hv_HeightImage,
                        0, 0, hv_MapColorBarWidth, hv_MarginBottom, out hv_WindowImageRatioHeight,
                        out hv_WindowImageRatioWidth, out hv_SetPartRow2, out hv_SetPartColumn2,
                        out hv_PrevWindowCoordinatesOut);
                    //
                    //Update meta information.
                    hv_MetaInfo.Dispose();
                    HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_window_image_ratio_height",
                            hv_WindowImageRatioHeight);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_window_image_ratio_width",
                            hv_WindowImageRatioWidth);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_set_part_row2",
                            hv_SetPartRow2);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_set_part_column2",
                            hv_SetPartColumn2);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_margin_bottom",
                            hv_MarginBottom);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_map_color_bar_with",
                            hv_MapColorBarWidth);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_window_coordinates",
                            hv_PrevWindowCoordinatesOut);
                    }
                }
                else
                {
                    //
                    //Open a new window.
                    hv_CurrentWindowHandle.Dispose(); hv_WindowImageRatioHeight.Dispose(); hv_PrevWindowCoordinatesOut.Dispose();
                    open_next_window(hv_Font, hv_FontSize, hv_ShowBottomDesc, hv_WidthImage,
                        hv_HeightImage, hv_MapColorBarWidth, hv_ScaleWindows, hv_ThresholdWidth,
                        hv_PrevWindowCoordinates, hv_WindowHandleDict, hv_WindowHandleKey, out hv_CurrentWindowHandle,
                        out hv_WindowImageRatioHeight, out hv_PrevWindowCoordinatesOut);
                    HOperatorSet.SetWindowParam(hv_CurrentWindowHandle, "flush", "false");
                }
                //

                hv_OpenNewWindow.Dispose();
                hv_WindowHandles.Dispose();
                hv_Value.Dispose();
                hv_Exception.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv__.Dispose();
                hv_MarginBottom.Dispose();
                hv_WindowImageRatioWidth.Dispose();
                hv_SetPartRow2.Dispose();
                hv_SetPartColumn2.Dispose();
                hv_MetaInfo.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_OpenNewWindow.Dispose();
                hv_WindowHandles.Dispose();
                hv_Value.Dispose();
                hv_Exception.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv__.Dispose();
                hv_MarginBottom.Dispose();
                hv_WindowImageRatioWidth.Dispose();
                hv_SetPartRow2.Dispose();
                hv_SetPartColumn2.Dispose();
                hv_MetaInfo.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Semantic Segmentation
        // Short Description: Get the ground truth segmentation image. 
        private void get_segmentation_image_ground_truth(out HObject ho_SegmentationImagGroundTruth,
            HTuple hv_SampleKeys, HTuple hv_DLSample)
        {


            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_SegmentationImagGroundTruth);
            //
            //This procedure returns the ground truth segmentation image.
            //
            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("segmentation_image"))).TupleNotEqual(
                -1))) != 0)
            {
                ho_SegmentationImagGroundTruth.Dispose();
                HOperatorSet.GetDictObject(out ho_SegmentationImagGroundTruth, hv_DLSample,
                    "segmentation_image");
            }
            else
            {
                throw new HalconException("Ground truth segmentation image could not be found in DLSample.");
            }


            return;
        }

        // Chapter: Deep Learning / Semantic Segmentation
        // Short Description: Get the predicted segmentation result image. 
        private void get_segmentation_image_result(out HObject ho_SegmentationImageResult,
            HTuple hv_ResultKeys, HTuple hv_DLResult)
        {


            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_SegmentationImageResult);
            //
            //This procedure returns the predicted segmentation result image.
            //
            if ((int)(new HTuple(((hv_ResultKeys.TupleFind("segmentation_image"))).TupleNotEqual(
                -1))) != 0)
            {
                ho_SegmentationImageResult.Dispose();
                HOperatorSet.GetDictObject(out ho_SegmentationImageResult, hv_DLResult, "segmentation_image");
            }
            else
            {
                throw new HalconException("Result segmentation data could not be found in DLSample.");
            }


            return;
        }

        // Chapter: Deep Learning / Semantic Segmentation
        // Short Description: Get the weight image of a sample. 
        private void get_weight_image(out HObject ho_ImageWeight, HTuple hv_SampleKeys,
            HTuple hv_DLSample)
        {


            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ImageWeight);
            //
            //This procedure returns the segmentation weight image of a sample.
            //
            if ((int)(new HTuple(((hv_SampleKeys.TupleFind("weight_image"))).TupleNotEqual(
                -1))) != 0)
            {
                ho_ImageWeight.Dispose();
                HOperatorSet.GetDictObject(out ho_ImageWeight, hv_DLSample, "weight_image");
            }
            else
            {
                throw new HalconException("Weight image could not be found in DLSample.");
            }


            return;
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Initialize the dictionary RunningMeasures for the evaluation. 
        public void init_running_evaluation_measures(HTuple hv_EvalParams, out HTuple hv_RunningMeasures)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Valid = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_NumClasses = new HTuple(), hv_EvaluationType = new HTuple();
            HTuple hv_Measures = new HTuple(), hv_ClassIDs = new HTuple();
            HTuple hv_InstanceType = new HTuple(), hv_EvalOrientation = new HTuple();
            HTuple hv_AllocationBlockLength = new HTuple(), hv_IoUThreshs = new HTuple();
            HTuple hv_MaxNumDetections = new HTuple(), hv_AreaRanges = new HTuple();
            HTuple hv_AreaNames = new HTuple(), hv_MinAreas = new HTuple();
            HTuple hv_MaxAreas = new HTuple(), hv_DetailedEvaluation = new HTuple();
            HTuple hv_MaxNumIdx = new HTuple(), hv_MaxNum = new HTuple();
            HTuple hv_CurrentRunningMeasure = new HTuple(), hv_AreaIdx = new HTuple();
            HTuple hv_AreaRunningMeasure = new HTuple(), hv_I = new HTuple();
            HTuple hv_IoURunningMeasure = new HTuple(), hv_ClsIdx = new HTuple();
            HTuple hv_ClassRunningMeasures = new HTuple(), hv_Confidence = new HTuple();
            HTuple hv_IgnoreClassIDs = new HTuple(), hv_CalcConfMatrix = new HTuple();
            HTuple hv_MatrixSize = new HTuple(), hv_PixelConfusionMatrix = new HTuple();
            HTuple hv_MaxId = new HTuple(), hv_ClsIDToClsIdx = new HTuple();
            HTuple hv_TP = new HTuple(), hv_FP = new HTuple(), hv_FN = new HTuple();
            // Initialize local and output iconic variables 
            hv_RunningMeasures = new HTuple();
            try
            {
                //
                //This procedure initializes the dictionary RunningMeasures for evaluation.
                //It uses the evaluation parameters to initialize the running measures accordingly.
                //
                //The structure of RunningMeasures depends on the entry 'evaluate_instances' in the dictionary EvalParams.
                //
                //The dictionary RunningMeasures can be updated based on the per-batch/per-image evaluation results.
                //
                hv_RunningMeasures.Dispose();
                HOperatorSet.CreateDict(out hv_RunningMeasures);
                //Check that the necessary evaluation parameters exist.
                hv_Valid.Dispose(); hv_Exception.Dispose();
                validate_evaluation_param(hv_EvalParams, out hv_Valid, out hv_Exception);
                if ((int)(hv_Valid.TupleNot()) != 0)
                {
                    throw new HalconException(new HTuple("Invalid EvalParams, ") + hv_Exception);
                }
                //
                //Get general evaluation parameters.
                hv_NumClasses.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
                hv_EvaluationType.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "evaluation_type", out hv_EvaluationType);
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                hv_ClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                //
                if ((int)(new HTuple(hv_EvaluationType.TupleEqual("anomaly_detection"))) != 0)
                {
                    //RunningMeasures contains:
                    //- image_ids:          IDs of the images.
                    //- anomaly_label_ids:  Class IDs of ground truth labels.
                    //- anomaly_scores:     Predicted image level anomaly scores.
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_ids", new HTuple());
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "anomaly_label_ids", new HTuple());
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "anomaly_scores", new HTuple());
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("classification"))) != 0)
                {
                    //RunningMeasures contains:
                    //- image_ids:          IDs of the images.
                    //- image_label_ids:    Class IDs of ground truth labels.
                    //- top1_predictions:   Class IDs of the top predicted class.
                    //- topk_predictions:   Class IDs of top-K predicted classes.
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_ids", new HTuple());
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_label_ids", new HTuple());
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "top1_predictions", new HTuple());
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "topk_predictions", new HTuple());
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("detection"))) != 0)
                {
                    //RunningMeasures contains:
                    //For each maximal number of regions (MaxNumDetections):
                    // - For each area range (AreaRanges):
                    //   -- confidence:     Confidence (score) of each result.
                    //   -- num_gt:         Total number of ground truth instances per class.
                    //   -- num_pred:       Total number of predictions per class.
                    //   -- num_gt_ignore:  Number of ignored ground truth instances per class.
                    //   -- for each IoU-threshold:
                    //      --- For each class:
                    //          ---- is_tp:                  TP/FP assignment of result.
                    //          ---- ignore:                 Ignore/Not-Ignore assignment of result.
                    //          ---- abs_orientation_diff (for instance_type 'rectangle2' with measure SoAP):
                    //                                       Absolute orientation difference of the result.
                    //
                    //Check if the orientation difference is to be evaluated.
                    hv_InstanceType.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "instance_type", out hv_InstanceType);
                    hv_EvalOrientation.Dispose();
                    hv_EvalOrientation = 0;
                    if ((int)((new HTuple(hv_InstanceType.TupleEqual("rectangle2"))).TupleAnd(
                        (new HTuple(((hv_Measures.TupleFind("soap"))).TupleNotEqual(-1))).TupleOr(
                        new HTuple(((hv_Measures.TupleFind("all"))).TupleNotEqual(-1))))) != 0)
                    {
                        hv_EvalOrientation.Dispose();
                        hv_EvalOrientation = 1;
                    }
                    //
                    //Calculating the measures confidence, is_tp, ignore, and abs_orientation_diff,
                    //arrays are allocated with -1 in blocks of AllocationBlockLength
                    //(thus, if a block is filled, the next block is allocated).
                    //Otherwise the arrays have to be concatenated which is rather slow.
                    //The actual length of the array is garnered in num_pred.
                    hv_AllocationBlockLength.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "allocation_block_length", out hv_AllocationBlockLength);
                    hv_IoUThreshs.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "iou_threshold", out hv_IoUThreshs);
                    hv_MaxNumDetections.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "max_num_detections", out hv_MaxNumDetections);
                    hv_AreaRanges.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "area_ranges", out hv_AreaRanges);
                    //AreaRanges is a dictionary containing 'name', 'min_area', 'max_area'.
                    hv_AreaNames.Dispose();
                    HOperatorSet.GetDictTuple(hv_AreaRanges, "name", out hv_AreaNames);
                    hv_MinAreas.Dispose();
                    HOperatorSet.GetDictTuple(hv_AreaRanges, "min", out hv_MinAreas);
                    hv_MaxAreas.Dispose();
                    HOperatorSet.GetDictTuple(hv_AreaRanges, "max", out hv_MaxAreas);
                    //Check if a detailed evaluation will be performed.
                    hv_DetailedEvaluation.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "detailed_evaluation", out hv_DetailedEvaluation);
                    //Set a result dictionary for each maximal number of detections and IoU-threshold.
                    for (hv_MaxNumIdx = 0; (int)hv_MaxNumIdx <= (int)((new HTuple(hv_MaxNumDetections.TupleLength()
                        )) - 1); hv_MaxNumIdx = (int)hv_MaxNumIdx + 1)
                    {
                        hv_MaxNum.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MaxNum = hv_MaxNumDetections.TupleSelect(
                                hv_MaxNumIdx);
                        }
                        hv_CurrentRunningMeasure.Dispose();
                        HOperatorSet.CreateDict(out hv_CurrentRunningMeasure);
                        for (hv_AreaIdx = 0; (int)hv_AreaIdx <= (int)((new HTuple(hv_AreaNames.TupleLength()
                            )) - 1); hv_AreaIdx = (int)hv_AreaIdx + 1)
                        {
                            hv_AreaRunningMeasure.Dispose();
                            HOperatorSet.CreateDict(out hv_AreaRunningMeasure);
                            for (hv_I = 0; (int)hv_I <= (int)((new HTuple(hv_IoUThreshs.TupleLength()
                                )) - 1); hv_I = (int)hv_I + 1)
                            {
                                hv_IoURunningMeasure.Dispose();
                                HOperatorSet.CreateDict(out hv_IoURunningMeasure);
                                HTuple end_val84 = hv_NumClasses - 1;
                                HTuple step_val84 = 1;
                                for (hv_ClsIdx = 0; hv_ClsIdx.Continue(end_val84, step_val84); hv_ClsIdx = hv_ClsIdx.TupleAdd(step_val84))
                                {
                                    hv_ClassRunningMeasures.Dispose();
                                    HOperatorSet.CreateDict(out hv_ClassRunningMeasures);
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_tp", HTuple.TupleGenConst(
                                            hv_AllocationBlockLength, -1));
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "ignore", HTuple.TupleGenConst(
                                            hv_AllocationBlockLength, -1));
                                    }
                                    if ((int)(hv_EvalOrientation) != 0)
                                    {
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "abs_orientation_diff",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                    }
                                    if ((int)(hv_DetailedEvaluation) != 0)
                                    {
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_fp_class",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_fp_background",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_fp_localization",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_fp_duplicate",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "is_fp_multiple",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                        if ((int)(hv_EvalOrientation) != 0)
                                        {
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "abs_orientation_diff_class",
                                                    HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                            }
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "abs_orientation_diff_localization",
                                                    HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                            }
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "abs_orientation_diff_duplicate",
                                                    HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                            }
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                HOperatorSet.SetDictTuple(hv_ClassRunningMeasures, "abs_orientation_diff_multiple",
                                                    HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                            }
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_IoURunningMeasure, "image_ids_with_false_negatives",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_IoURunningMeasure, "image_ids_with_false_positives",
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                        }
                                        HOperatorSet.SetDictTuple(hv_IoURunningMeasure, "num_image_ids_with_false_negatives",
                                            0);
                                        HOperatorSet.SetDictTuple(hv_IoURunningMeasure, "num_image_ids_with_false_positives",
                                            0);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetDictTuple(hv_IoURunningMeasure, "class_" + (hv_ClassIDs.TupleSelect(
                                            hv_ClsIdx)), hv_ClassRunningMeasures);
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_AreaRunningMeasure, "iou_" + ((("" + (hv_IoUThreshs.TupleSelect(
                                        hv_I)))).TupleRegexpReplace("\\.", "")), hv_IoURunningMeasure);
                                }
                            }
                            hv_Confidence.Dispose();
                            HOperatorSet.CreateDict(out hv_Confidence);
                            HTuple end_val113 = hv_NumClasses - 1;
                            HTuple step_val113 = 1;
                            for (hv_ClsIdx = 0; hv_ClsIdx.Continue(end_val113, step_val113); hv_ClsIdx = hv_ClsIdx.TupleAdd(step_val113))
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_Confidence, "class_" + (hv_ClassIDs.TupleSelect(
                                        hv_ClsIdx)), HTuple.TupleGenConst(hv_AllocationBlockLength, -1.0));
                                }
                            }
                            HOperatorSet.SetDictTuple(hv_AreaRunningMeasure, "confidence", hv_Confidence);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_AreaRunningMeasure, "num_gt", HTuple.TupleGenConst(
                                    hv_NumClasses, 0));
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_AreaRunningMeasure, "num_pred", HTuple.TupleGenConst(
                                    hv_NumClasses, 0));
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_AreaRunningMeasure, "num_gt_ignore", HTuple.TupleGenConst(
                                    hv_NumClasses, 0));
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_CurrentRunningMeasure, "area_" + (hv_AreaNames.TupleSelect(
                                    hv_AreaIdx)), hv_AreaRunningMeasure);
                            }
                        }
                        if ((int)(new HTuple(hv_MaxNum.TupleEqual(-1))) != 0)
                        {
                            hv_MaxNum.Dispose();
                            hv_MaxNum = "all";
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_RunningMeasures, "max_num_detections_" + hv_MaxNum,
                                hv_CurrentRunningMeasure);
                        }
                    }
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("segmentation"))) != 0)
                {
                    //RunningMeasures contains:
                    //if confusion matrix in Measures (slower but more information).
                    // - confusion matrix per pixel.
                    //else:
                    // - TP/FP/FN (pixel numbers per class).
                    //
                    //Incorporate ignore class IDs.
                    hv_IgnoreClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "ignore_class_ids", out hv_IgnoreClassIDs);
                    //
                    //Check if we need to compute/update the confusion matrix.
                    hv_CalcConfMatrix.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CalcConfMatrix = (new HTuple(((hv_Measures.TupleFind(
                            "pixel_confusion_matrix"))).TupleGreater(-1))).TupleOr(new HTuple(((hv_Measures.TupleFind(
                            "all"))).TupleGreater(-1)));
                    }
                    if ((int)(hv_CalcConfMatrix) != 0)
                    {
                        //Define the size of the confusion matrix.
                        hv_MatrixSize.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MatrixSize = hv_NumClasses + (new HTuple((new HTuple(hv_IgnoreClassIDs.TupleLength()
                                )).TupleGreater(0)));
                        }
                        hv_PixelConfusionMatrix.Dispose();
                        HOperatorSet.CreateMatrix(hv_MatrixSize, hv_MatrixSize, 0, out hv_PixelConfusionMatrix);
                        HOperatorSet.SetDictTuple(hv_RunningMeasures, "pixel_confusion_matrix",
                            hv_PixelConfusionMatrix);
                        //
                        //If the class IDs are not running indices from 0 to NumClasses we
                        //define a mapping from class IDs to class indices.
                        if ((int)((new HTuple(hv_ClassIDs.TupleNotEqual(HTuple.TupleGenSequence(
                            0, (new HTuple(hv_ClassIDs.TupleLength())) - 1, 1)))).TupleOr(new HTuple((new HTuple(hv_IgnoreClassIDs.TupleLength()
                            )).TupleGreater(0)))) != 0)
                        {
                            //Get the max ID that can occur.
                            hv_MaxId.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_MaxId = (hv_ClassIDs.TupleMax()
                                    ) + (new HTuple((new HTuple(hv_IgnoreClassIDs.TupleLength())).TupleGreater(
                                    0)));
                            }
                            //Define the basic mapping.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClsIDToClsIdx.Dispose();
                                HOperatorSet.TupleGenConst(hv_MaxId + 1, -1, out hv_ClsIDToClsIdx);
                            }
                            if (hv_ClsIDToClsIdx == null)
                                hv_ClsIDToClsIdx = new HTuple();
                            hv_ClsIDToClsIdx[hv_ClassIDs] = HTuple.TupleGenSequence(0, (new HTuple(hv_ClassIDs.TupleLength()
                                )) - 1, 1);
                            //Map ignore IDs to the next higher one.
                            if (hv_ClsIDToClsIdx == null)
                                hv_ClsIDToClsIdx = new HTuple();
                            hv_ClsIDToClsIdx[hv_IgnoreClassIDs] = (hv_ClsIDToClsIdx.TupleMax()) + 1;
                            //Set the mapping to the evaluation parameters.
                            HOperatorSet.SetDictTuple(hv_EvalParams, "class_id_mapping", hv_ClsIDToClsIdx);
                        }
                    }
                    else
                    {
                        hv_TP.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TP = HTuple.TupleGenConst(
                                hv_NumClasses, 0);
                        }
                        hv_FP.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FP = HTuple.TupleGenConst(
                                hv_NumClasses, 0);
                        }
                        hv_FN.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FN = HTuple.TupleGenConst(
                                hv_NumClasses, 0);
                        }
                        HOperatorSet.SetDictTuple(hv_RunningMeasures, "tp", hv_TP);
                        HOperatorSet.SetDictTuple(hv_RunningMeasures, "fp", hv_FP);
                        HOperatorSet.SetDictTuple(hv_RunningMeasures, "fn", hv_FN);
                    }
                }
                //

                hv_Valid.Dispose();
                hv_Exception.Dispose();
                hv_NumClasses.Dispose();
                hv_EvaluationType.Dispose();
                hv_Measures.Dispose();
                hv_ClassIDs.Dispose();
                hv_InstanceType.Dispose();
                hv_EvalOrientation.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_IoUThreshs.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_MaxNumIdx.Dispose();
                hv_MaxNum.Dispose();
                hv_CurrentRunningMeasure.Dispose();
                hv_AreaIdx.Dispose();
                hv_AreaRunningMeasure.Dispose();
                hv_I.Dispose();
                hv_IoURunningMeasure.Dispose();
                hv_ClsIdx.Dispose();
                hv_ClassRunningMeasures.Dispose();
                hv_Confidence.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_CalcConfMatrix.Dispose();
                hv_MatrixSize.Dispose();
                hv_PixelConfusionMatrix.Dispose();
                hv_MaxId.Dispose();
                hv_ClsIDToClsIdx.Dispose();
                hv_TP.Dispose();
                hv_FP.Dispose();
                hv_FN.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Valid.Dispose();
                hv_Exception.Dispose();
                hv_NumClasses.Dispose();
                hv_EvaluationType.Dispose();
                hv_Measures.Dispose();
                hv_ClassIDs.Dispose();
                hv_InstanceType.Dispose();
                hv_EvalOrientation.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_IoUThreshs.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_MaxNumIdx.Dispose();
                hv_MaxNum.Dispose();
                hv_CurrentRunningMeasure.Dispose();
                hv_AreaIdx.Dispose();
                hv_AreaRunningMeasure.Dispose();
                hv_I.Dispose();
                hv_IoURunningMeasure.Dispose();
                hv_ClsIdx.Dispose();
                hv_ClassRunningMeasures.Dispose();
                hv_Confidence.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_CalcConfMatrix.Dispose();
                hv_MatrixSize.Dispose();
                hv_PixelConfusionMatrix.Dispose();
                hv_MaxId.Dispose();
                hv_ClsIDToClsIdx.Dispose();
                hv_TP.Dispose();
                hv_FP.Dispose();
                hv_FN.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Initialize change strategies data. 
        private void init_train_dl_model_change_strategies(HTuple hv_TrainParam, out HTuple hv_ChangeStrategyData)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ChangeStrategies = new HTuple();
            HTuple hv_Enabled = new HTuple(), hv_Index = new HTuple();
            HTuple hv_ChangeStrategy = new HTuple(), hv_ModelParam = new HTuple();
            HTuple hv_Epochs = new HTuple(), hv_Values = new HTuple();
            HTuple hv_Initial = new HTuple(), hv_Indices = new HTuple();
            HTuple hv_ScaleThresholdExists = new HTuple();
            // Initialize local and output iconic variables 
            hv_ChangeStrategyData = new HTuple();
            try
            {
                //
                //Initialize a dictionary with the change strategies data.
                hv_ChangeStrategyData.Dispose();
                HOperatorSet.CreateDict(out hv_ChangeStrategyData);
                hv_ChangeStrategies.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainParam, "change_strategies", out hv_ChangeStrategies);
                hv_Enabled.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Enabled = new HTuple((new HTuple(hv_ChangeStrategies.TupleLength()
                        )).TupleGreater(0));
                }
                HOperatorSet.SetDictTuple(hv_ChangeStrategyData, "enabled", hv_Enabled);
                if ((int)(hv_Enabled.TupleNot()) != 0)
                {

                    hv_ChangeStrategies.Dispose();
                    hv_Enabled.Dispose();
                    hv_Index.Dispose();
                    hv_ChangeStrategy.Dispose();
                    hv_ModelParam.Dispose();
                    hv_Epochs.Dispose();
                    hv_Values.Dispose();
                    hv_Initial.Dispose();
                    hv_Indices.Dispose();
                    hv_ScaleThresholdExists.Dispose();

                    return;
                }
                //
                //Sort all epochs in all change strategies.
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_ChangeStrategies.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    hv_ChangeStrategy.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ChangeStrategy = hv_ChangeStrategies.TupleSelect(
                            hv_Index);
                    }
                    hv_ModelParam.Dispose();
                    HOperatorSet.GetDictTuple(hv_ChangeStrategy, "model_param", out hv_ModelParam);
                    hv_Epochs.Dispose();
                    HOperatorSet.GetDictTuple(hv_ChangeStrategy, "epochs", out hv_Epochs);
                    hv_Values.Dispose();
                    HOperatorSet.GetDictTuple(hv_ChangeStrategy, "values", out hv_Values);
                    hv_Initial.Dispose();
                    HOperatorSet.GetDictTuple(hv_ChangeStrategy, "initial_value", out hv_Initial);
                    //Check that the length are equal.
                    if ((int)(new HTuple((new HTuple(hv_Epochs.TupleLength())).TupleNotEqual(
                        new HTuple(hv_Values.TupleLength())))) != 0)
                    {
                        throw new HalconException("ChangeStrategy parameter error: 'epochs' and 'values' need to have same length.");
                    }
                    //We need sorted arrays for faster access.
                    hv_Indices.Dispose();
                    HOperatorSet.TupleSortIndex(hv_Epochs, out hv_Indices);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_ChangeStrategy, "epochs", hv_Epochs.TupleSelect(
                            hv_Indices));
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_ChangeStrategy, "values", hv_Values.TupleSelect(
                            hv_Indices));
                    }
                    //
                    //For the learning rate, there can be an additional parameter
                    //indicating if the momentum should be scaled as well.
                    if ((int)(new HTuple(hv_ModelParam.TupleEqual("learning_rate"))) != 0)
                    {
                        hv_ScaleThresholdExists.Dispose();
                        HOperatorSet.GetDictParam(hv_ChangeStrategy, "key_exists", "scale_momentum_threshold",
                            out hv_ScaleThresholdExists);
                        if ((int)(hv_ScaleThresholdExists.TupleNot()) != 0)
                        {
                            //If not given, the threshold is set to an empty tuple such that no scaling is performed.
                            HOperatorSet.SetDictTuple(hv_ChangeStrategy, "scale_momentum_threshold",
                                new HTuple());
                        }
                    }
                }
                HOperatorSet.SetDictTuple(hv_ChangeStrategyData, "strategies", hv_ChangeStrategies);

                hv_ChangeStrategies.Dispose();
                hv_Enabled.Dispose();
                hv_Index.Dispose();
                hv_ChangeStrategy.Dispose();
                hv_ModelParam.Dispose();
                hv_Epochs.Dispose();
                hv_Values.Dispose();
                hv_Initial.Dispose();
                hv_Indices.Dispose();
                hv_ScaleThresholdExists.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ChangeStrategies.Dispose();
                hv_Enabled.Dispose();
                hv_Index.Dispose();
                hv_ChangeStrategy.Dispose();
                hv_ModelParam.Dispose();
                hv_Epochs.Dispose();
                hv_Values.Dispose();
                hv_Initial.Dispose();
                hv_Indices.Dispose();
                hv_ScaleThresholdExists.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Initializes the dictionary setting the serialization strategies. 
        private void init_train_dl_model_serialization_strategies(HTuple hv_TrainParam,
            out HTuple hv_SerializationData)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_SerializationStrategies = new HTuple();
            HTuple hv_RawData = new HTuple(), hv_Types = new HTuple();
            HTuple hv_SerializeFinal = new HTuple(), hv_Index = new HTuple();
            HTuple hv_Strategy = new HTuple(), hv_Type = new HTuple();
            HTuple hv_Data = new HTuple(), hv_Epochs = new HTuple();
            HTuple hv_NumEpochs = new HTuple();
            // Initialize local and output iconic variables 
            hv_SerializationData = new HTuple();
            try
            {
                //
                //This procedure initializes the dictionary setting the serialization strategies.
                //
                //Initialize each serialization strategy.
                hv_SerializationStrategies.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainParam, "serialization_strategies", out hv_SerializationStrategies);
                hv_SerializationData.Dispose();
                HOperatorSet.CreateDict(out hv_SerializationData);
                HOperatorSet.SetDictTuple(hv_SerializationData, "strategies", hv_SerializationStrategies);
                hv_RawData.Dispose();
                hv_RawData = new HTuple();
                hv_Types.Dispose();
                hv_Types = new HTuple();
                hv_SerializeFinal.Dispose();
                hv_SerializeFinal = 0;
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_SerializationStrategies.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    hv_Strategy.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Strategy = hv_SerializationStrategies.TupleSelect(
                            hv_Index);
                    }
                    hv_Type.Dispose();
                    HOperatorSet.GetDictTuple(hv_Strategy, "type", out hv_Type);
                    hv_Data.Dispose();
                    HOperatorSet.CreateDict(out hv_Data);
                    if ((int)(new HTuple(hv_Type.TupleEqual("best"))) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_Data, "best_value", -1);
                    }
                    else if ((int)(new HTuple(hv_Type.TupleEqual("epochs"))) != 0)
                    {
                        hv_Epochs.Dispose();
                        HOperatorSet.GetDictTuple(hv_Strategy, "epochs", out hv_Epochs);
                        //Store sorted values in order to search faster during updates.
                        {
                            HTuple ExpTmpOutVar_0;
                            HOperatorSet.TupleSort(hv_Epochs, out ExpTmpOutVar_0);
                            hv_Epochs.Dispose();
                            hv_Epochs = ExpTmpOutVar_0;
                        }
                        HOperatorSet.SetDictTuple(hv_Data, "epochs", hv_Epochs);
                        HOperatorSet.SetDictTuple(hv_Data, "last_epoch_index", -1);
                    }
                    else if ((int)(new HTuple(hv_Type.TupleEqual("current"))) != 0)
                    {
                        hv_NumEpochs.Dispose();
                        HOperatorSet.GetDictTuple(hv_TrainParam, "num_epochs", out hv_NumEpochs);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_Data, "epochs", HTuple.TupleGenSequence(1,
                                hv_NumEpochs, 1));
                        }
                        HOperatorSet.SetDictTuple(hv_Data, "last_epoch_index", -1);
                    }
                    else if ((int)(new HTuple(hv_Type.TupleEqual("final"))) != 0)
                    {
                        HOperatorSet.SetDictTuple(hv_Data, "serialize_final", 1);
                    }
                    else
                    {
                        throw new HalconException(("Unknown serialization strategy type: '" + hv_Type) + "'");
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Types = hv_Types.TupleConcat(
                                hv_Type);
                            hv_Types.Dispose();
                            hv_Types = ExpTmpLocalVar_Types;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_RawData = hv_RawData.TupleConcat(
                                hv_Data);
                            hv_RawData.Dispose();
                            hv_RawData = ExpTmpLocalVar_RawData;
                        }
                    }
                }
                HOperatorSet.SetDictTuple(hv_SerializationData, "raw_data", hv_RawData);
                HOperatorSet.SetDictTuple(hv_SerializationData, "types", hv_Types);

                hv_SerializationStrategies.Dispose();
                hv_RawData.Dispose();
                hv_Types.Dispose();
                hv_SerializeFinal.Dispose();
                hv_Index.Dispose();
                hv_Strategy.Dispose();
                hv_Type.Dispose();
                hv_Data.Dispose();
                hv_Epochs.Dispose();
                hv_NumEpochs.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_SerializationStrategies.Dispose();
                hv_RawData.Dispose();
                hv_Types.Dispose();
                hv_SerializeFinal.Dispose();
                hv_Index.Dispose();
                hv_Strategy.Dispose();
                hv_Type.Dispose();
                hv_Data.Dispose();
                hv_Epochs.Dispose();
                hv_NumEpochs.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: shuffles the input colors in a deterministic way 
        private void make_neighboring_colors_distinguishable(HTuple hv_ColorsRainbow,
            out HTuple hv_Colors)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_NumColors = new HTuple(), hv_NumChunks = new HTuple();
            HTuple hv_NumLeftOver = new HTuple(), hv_ColorsPerChunk = new HTuple();
            HTuple hv_StartIdx = new HTuple(), hv_S = new HTuple();
            HTuple hv_EndIdx = new HTuple(), hv_IdxsLeft = new HTuple();
            HTuple hv_IdxsRight = new HTuple();
            // Initialize local and output iconic variables 
            hv_Colors = new HTuple();
            try
            {
                //
                //Shuffle the input colors in a deterministic way
                //to make adjacent colors more distinguishable.
                //Neighboring colors from the input are distributed to every NumChunks
                //position in the output.
                //Depending on the number of colors, increase NumChunks.
                hv_NumColors.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumColors = new HTuple(hv_ColorsRainbow.TupleLength()
                        );
                }
                if ((int)(new HTuple(hv_NumColors.TupleGreaterEqual(8))) != 0)
                {
                    hv_NumChunks.Dispose();
                    hv_NumChunks = 3;
                    if ((int)(new HTuple(hv_NumColors.TupleGreaterEqual(40))) != 0)
                    {
                        hv_NumChunks.Dispose();
                        hv_NumChunks = 6;
                    }
                    else if ((int)(new HTuple(hv_NumColors.TupleGreaterEqual(20))) != 0)
                    {
                        hv_NumChunks.Dispose();
                        hv_NumChunks = 4;
                    }
                    hv_Colors.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Colors = HTuple.TupleGenConst(
                            hv_NumColors, -1);
                    }
                    //Check if the Number of Colors is dividable by NumChunks.
                    hv_NumLeftOver.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumLeftOver = hv_NumColors % hv_NumChunks;
                    }
                    hv_ColorsPerChunk.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ColorsPerChunk = ((hv_NumColors / hv_NumChunks)).TupleInt()
                            ;
                    }
                    hv_StartIdx.Dispose();
                    hv_StartIdx = 0;
                    HTuple end_val19 = hv_NumChunks - 1;
                    HTuple step_val19 = 1;
                    for (hv_S = 0; hv_S.Continue(end_val19, step_val19); hv_S = hv_S.TupleAdd(step_val19))
                    {
                        hv_EndIdx.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_EndIdx = (hv_StartIdx + hv_ColorsPerChunk) - 1;
                        }
                        if ((int)(new HTuple(hv_S.TupleLess(hv_NumLeftOver))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_EndIdx = hv_EndIdx + 1;
                                    hv_EndIdx.Dispose();
                                    hv_EndIdx = ExpTmpLocalVar_EndIdx;
                                }
                            }
                        }
                        hv_IdxsLeft.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_IdxsLeft = HTuple.TupleGenSequence(
                                hv_S, hv_NumColors - 1, hv_NumChunks);
                        }
                        hv_IdxsRight.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_IdxsRight = HTuple.TupleGenSequence(
                                hv_StartIdx, hv_EndIdx, 1);
                        }
                        if (hv_Colors == null)
                            hv_Colors = new HTuple();
                        hv_Colors[HTuple.TupleGenSequence(hv_S, hv_NumColors - 1, hv_NumChunks)] = hv_ColorsRainbow.TupleSelectRange(
                            hv_StartIdx, hv_EndIdx);
                        hv_StartIdx.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_StartIdx = hv_EndIdx + 1;
                        }
                    }
                }
                else
                {
                    hv_Colors.Dispose();
                    hv_Colors = new HTuple(hv_ColorsRainbow);
                }

                hv_NumColors.Dispose();
                hv_NumChunks.Dispose();
                hv_NumLeftOver.Dispose();
                hv_ColorsPerChunk.Dispose();
                hv_StartIdx.Dispose();
                hv_S.Dispose();
                hv_EndIdx.Dispose();
                hv_IdxsLeft.Dispose();
                hv_IdxsRight.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_NumColors.Dispose();
                hv_NumChunks.Dispose();
                hv_NumLeftOver.Dispose();
                hv_ColorsPerChunk.Dispose();
                hv_StartIdx.Dispose();
                hv_S.Dispose();
                hv_EndIdx.Dispose();
                hv_IdxsLeft.Dispose();
                hv_IdxsRight.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Window
        // Short Description: Open a window next to the given WindowHandleFather.  
        private void open_child_window(HTuple hv_WindowHandleFather, HTuple hv_Font, HTuple hv_FontSize,
            HTuple hv_Text, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict,
            HTuple hv_WindowHandleKey, out HTuple hv_WindowHandleChild, out HTuple hv_PrevWindowCoordinatesOut)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_StringWidth = new HTuple(), hv_IndexText = new HTuple();
            HTuple hv__ = new HTuple(), hv_TextWidth = new HTuple();
            HTuple hv_WindowRow = new HTuple(), hv_WindowColumn = new HTuple();
            HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
            HTuple hv_MetaInfo = new HTuple();
            // Initialize local and output iconic variables 
            hv_WindowHandleChild = new HTuple();
            hv_PrevWindowCoordinatesOut = new HTuple();
            try
            {
                //
                //This procedure opens a window next to the given WindowHandleFather.
                //
                //Get the maximum width of the text to be displayed.
                //The width should be at leat 200.
                hv_StringWidth.Dispose();
                hv_StringWidth = 150;
                for (hv_IndexText = 0; (int)hv_IndexText <= (int)((new HTuple(hv_Text.TupleLength()
                    )) - 1); hv_IndexText = (int)hv_IndexText + 1)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv__.Dispose(); hv__.Dispose(); hv_TextWidth.Dispose(); hv__.Dispose();
                        HOperatorSet.GetStringExtents(hv_WindowHandleFather, hv_Text.TupleSelect(
                            hv_IndexText), out hv__, out hv__, out hv_TextWidth, out hv__);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_StringWidth = hv_StringWidth.TupleMax2(
                                hv_TextWidth);
                            hv_StringWidth.Dispose();
                            hv_StringWidth = ExpTmpLocalVar_StringWidth;
                        }
                    }
                }
                //
                //Define window coordinates.
                hv_WindowRow.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowRow = hv_PrevWindowCoordinates.TupleSelect(
                        0);
                }
                hv_WindowColumn.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowColumn = ((hv_PrevWindowCoordinates.TupleSelect(
                        1)) + (hv_PrevWindowCoordinates.TupleSelect(2))) + 5;
                }
                hv_WindowWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowWidth = hv_StringWidth + (2 * 12.0);
                }
                hv_WindowHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowHeight = hv_PrevWindowCoordinates.TupleSelect(
                        3);
                }
                //
                HOperatorSet.SetWindowAttr("background_color", "black");
                HOperatorSet.OpenWindow(hv_WindowRow, hv_WindowColumn, hv_WindowWidth, hv_WindowHeight, 0, "visible", "", out hv_WindowHandleChild);
                HDevWindowStack.Push(hv_WindowHandleChild);
                set_display_font(hv_WindowHandleChild, hv_FontSize, hv_Font, "true", "false");
                //
                //Return the coordinates of the new window.
                hv_PrevWindowCoordinatesOut.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PrevWindowCoordinatesOut = new HTuple();
                    hv_PrevWindowCoordinatesOut = hv_PrevWindowCoordinatesOut.TupleConcat(hv_WindowRow, hv_WindowColumn, hv_WindowWidth, hv_WindowHeight);
                }
                //
                //Set some meta information about the new child window handle.
                hv_MetaInfo.Dispose();
                HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_child_window_coordinates",
                        hv_PrevWindowCoordinatesOut);
                }
                HOperatorSet.SetDictTuple(hv_WindowHandleDict, "meta_information", hv_MetaInfo);
                //

                hv_StringWidth.Dispose();
                hv_IndexText.Dispose();
                hv__.Dispose();
                hv_TextWidth.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowColumn.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_MetaInfo.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_StringWidth.Dispose();
                hv_IndexText.Dispose();
                hv__.Dispose();
                hv_TextWidth.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowColumn.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_MetaInfo.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Window
        // Short Description: Open a new window, either next to the last ones, or in a new row. 
        private void open_next_window(HTuple hv_Font, HTuple hv_FontSize, HTuple hv_ShowBottomDesc,
            HTuple hv_WidthImage, HTuple hv_HeightImage, HTuple hv_MapColorBarWidth, HTuple hv_ScaleWindows,
            HTuple hv_ThresholdWidth, HTuple hv_PrevWindowCoordinates, HTuple hv_WindowHandleDict,
            HTuple hv_WindowHandleKey, out HTuple hv_WindowHandleNew, out HTuple hv_WindowImageRatioHeight,
            out HTuple hv_PrevWindowCoordinatesOut)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_PrevWindowRow = new HTuple(), hv_PrevWindowColumn = new HTuple();
            HTuple hv_PrevWindowWidth = new HTuple(), hv_PrevWindowHeight = new HTuple();
            HTuple hv_WindowRow = new HTuple(), hv_WindowColumn = new HTuple();
            HTuple hv_Ascent = new HTuple(), hv_Descent = new HTuple();
            HTuple hv__ = new HTuple(), hv_MarginBottom = new HTuple();
            HTuple hv_WindowWidth = new HTuple(), hv_WindowHeight = new HTuple();
            HTuple hv_WindowImageRatioWidth = new HTuple(), hv_SetPartRow2 = new HTuple();
            HTuple hv_SetPartColumn2 = new HTuple(), hv_MetaInfo = new HTuple();
            // Initialize local and output iconic variables 
            hv_WindowHandleNew = new HTuple();
            hv_WindowImageRatioHeight = new HTuple();
            hv_PrevWindowCoordinatesOut = new HTuple();
            try
            {
                //
                //This procedure opens a new window, either next to
                //the last ones, or in a new row.
                //
                //Get coordinates of previous window.
                hv_PrevWindowRow.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PrevWindowRow = hv_PrevWindowCoordinates.TupleSelect(
                        0);
                }
                hv_PrevWindowColumn.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PrevWindowColumn = hv_PrevWindowCoordinates.TupleSelect(
                        1);
                }
                hv_PrevWindowWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PrevWindowWidth = hv_PrevWindowCoordinates.TupleSelect(
                        2);
                }
                hv_PrevWindowHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PrevWindowHeight = hv_PrevWindowCoordinates.TupleSelect(
                        3);
                }
                //
                if ((int)(new HTuple(((hv_PrevWindowColumn + hv_PrevWindowWidth)).TupleGreater(
                    hv_ThresholdWidth))) != 0)
                {
                    //Open window in new row.
                    hv_WindowRow.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_WindowRow = (hv_PrevWindowRow + hv_PrevWindowHeight) + 55;
                    }
                    hv_WindowColumn.Dispose();
                    hv_WindowColumn = 0;
                }
                else
                {
                    //Open window in same row.
                    hv_WindowRow.Dispose();
                    hv_WindowRow = new HTuple(hv_PrevWindowRow);
                    hv_WindowColumn.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_WindowColumn = hv_PrevWindowColumn + hv_PrevWindowWidth;
                    }
                    if ((int)(new HTuple(hv_WindowColumn.TupleNotEqual(0))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_WindowColumn = hv_WindowColumn + 5;
                                hv_WindowColumn.Dispose();
                                hv_WindowColumn = ExpTmpLocalVar_WindowColumn;
                            }
                        }
                    }
                }
                //
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowHandleNew.Dispose();
                    dev_open_window_fit_size(hv_WindowRow, hv_WindowColumn, hv_WidthImage, hv_HeightImage,
                        (new HTuple(500)).TupleConcat(800) * hv_ScaleWindows, (new HTuple(400)).TupleConcat(
                        600) * hv_ScaleWindows, out hv_WindowHandleNew);
                }
                set_display_font(hv_WindowHandleNew, hv_FontSize, hv_Font, "true", "false");
                //
                //Add MarginBottom and MapColorBarWidth to window.
                if ((int)(hv_ShowBottomDesc) != 0)
                {
                    hv_Ascent.Dispose(); hv_Descent.Dispose(); hv__.Dispose(); hv__.Dispose();
                    HOperatorSet.GetStringExtents(hv_WindowHandleNew, "Test_string", out hv_Ascent,
                        out hv_Descent, out hv__, out hv__);
                    hv_MarginBottom.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MarginBottom = ((2 * 12) + hv_Ascent) + hv_Descent;
                    }
                }
                else
                {
                    hv_MarginBottom.Dispose();
                    hv_MarginBottom = 0;
                }
                hv__.Dispose(); hv__.Dispose(); hv_WindowWidth.Dispose(); hv_WindowHeight.Dispose();
                HOperatorSet.GetWindowExtents(hv_WindowHandleNew, out hv__, out hv__, out hv_WindowWidth,
                    out hv_WindowHeight);
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), hv_WindowRow,
                            hv_WindowColumn, hv_WindowWidth + hv_MapColorBarWidth, hv_WindowHeight + hv_MarginBottom);
                    }
                }
                //
                //Get and set meta information of new window handle.
                hv_WindowImageRatioHeight.Dispose(); hv_WindowImageRatioWidth.Dispose(); hv_SetPartRow2.Dispose(); hv_SetPartColumn2.Dispose(); hv_PrevWindowCoordinatesOut.Dispose();
                update_window_meta_information(hv_WindowHandleNew, hv_WidthImage, hv_HeightImage,
                    hv_WindowRow, hv_WindowColumn, hv_MapColorBarWidth, hv_MarginBottom, out hv_WindowImageRatioHeight,
                    out hv_WindowImageRatioWidth, out hv_SetPartRow2, out hv_SetPartColumn2,
                    out hv_PrevWindowCoordinatesOut);
                //
                //Set window handle and some meta information about the new window handle.
                HOperatorSet.SetDictTuple(hv_WindowHandleDict, hv_WindowHandleKey, hv_WindowHandleNew);
                hv_MetaInfo.Dispose();
                HOperatorSet.GetDictTuple(hv_WindowHandleDict, "meta_information", out hv_MetaInfo);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_window_image_ratio_height",
                        hv_WindowImageRatioHeight);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_window_image_ratio_width",
                        hv_WindowImageRatioWidth);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_set_part_row2",
                        hv_SetPartRow2);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_set_part_column2",
                        hv_SetPartColumn2);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_margin_bottom",
                        hv_MarginBottom);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_map_color_bar_with",
                        hv_MapColorBarWidth);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    HOperatorSet.SetDictTuple(hv_MetaInfo, hv_WindowHandleKey + "_window_coordinates",
                        hv_PrevWindowCoordinatesOut);
                }
                HOperatorSet.SetDictTuple(hv_WindowHandleDict, "meta_information", hv_MetaInfo);
                //

                hv_PrevWindowRow.Dispose();
                hv_PrevWindowColumn.Dispose();
                hv_PrevWindowWidth.Dispose();
                hv_PrevWindowHeight.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowColumn.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv__.Dispose();
                hv_MarginBottom.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_WindowImageRatioWidth.Dispose();
                hv_SetPartRow2.Dispose();
                hv_SetPartColumn2.Dispose();
                hv_MetaInfo.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_PrevWindowRow.Dispose();
                hv_PrevWindowColumn.Dispose();
                hv_PrevWindowWidth.Dispose();
                hv_PrevWindowHeight.Dispose();
                hv_WindowRow.Dispose();
                hv_WindowColumn.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv__.Dispose();
                hv_MarginBottom.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_WindowImageRatioWidth.Dispose();
                hv_SetPartRow2.Dispose();
                hv_SetPartColumn2.Dispose();
                hv_MetaInfo.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Output
        // Short Description: This procedure plots tuples representing functions or curves in a coordinate system. 
        private void plot_tuple_no_window_handling(HTuple hv_WindowHandle, HTuple hv_XValues,
            HTuple hv_YValues, HTuple hv_XLabel, HTuple hv_YLabel, HTuple hv_Color, HTuple hv_GenParamName,
            HTuple hv_GenParamValue)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_ContourXGrid = null, ho_ContourYGrid = null;
            HObject ho_XArrow = null, ho_YArrow = null, ho_ContourXTick = null;
            HObject ho_ContourYTick = null, ho_Contour = null, ho_Cross = null;
            HObject ho_Circle = null, ho_Filled = null, ho_Stair = null, ho_StairTmp = null;

            // Local control variables 

            HTuple hv_ClipRegion = new HTuple(), hv_Row = new HTuple();
            HTuple hv_Column = new HTuple(), hv_Width = new HTuple();
            HTuple hv_Height = new HTuple(), hv_PartRow1 = new HTuple();
            HTuple hv_PartColumn1 = new HTuple(), hv_PartRow2 = new HTuple();
            HTuple hv_PartColumn2 = new HTuple(), hv_Red = new HTuple();
            HTuple hv_Green = new HTuple(), hv_Blue = new HTuple();
            HTuple hv_DrawMode = new HTuple(), hv_OriginStyle = new HTuple();
            HTuple hv_PartDiffers = new HTuple(), hv_PlotYLog = new HTuple();
            HTuple hv_YLogIndices = new HTuple(), hv_PlotYLogUser = new HTuple();
            HTuple hv_IsString = new HTuple(), hv_YInd = new HTuple();
            HTuple hv_Indices1 = new HTuple(), hv_XAxisEndValue = new HTuple();
            HTuple hv_YAxisEndValue = new HTuple(), hv_XAxisStartValue = new HTuple();
            HTuple hv_YAxisStartValue = new HTuple(), hv_XValuesAreStrings = new HTuple();
            HTuple hv_XTickValues = new HTuple(), hv_XTicks = new HTuple();
            HTuple hv_YAxisPosition = new HTuple(), hv_XAxisPosition = new HTuple();
            HTuple hv_LeftBorder = new HTuple(), hv_RightBorder = new HTuple();
            HTuple hv_UpperBorder = new HTuple(), hv_LowerBorder = new HTuple();
            HTuple hv_AxesColor = new HTuple(), hv_Style = new HTuple();
            HTuple hv_Clip = new HTuple(), hv_YTicks = new HTuple();
            HTuple hv_XGrid = new HTuple(), hv_YGrid = new HTuple();
            HTuple hv_GridColor = new HTuple(), hv_YPosition = new HTuple();
            HTuple hv_FormatX = new HTuple(), hv_FormatY = new HTuple();
            HTuple hv_LineWidth = new HTuple(), hv_NumGenParamNames = new HTuple();
            HTuple hv_NumGenParamValues = new HTuple(), hv_GenParamIndex = new HTuple();
            HTuple hv_XGridTicks = new HTuple(), hv_YTickDirection = new HTuple();
            HTuple hv_XTickDirection = new HTuple(), hv_XAxisWidthPx = new HTuple();
            HTuple hv_XAxisWidth = new HTuple(), hv_XScaleFactor = new HTuple();
            HTuple hv_YAxisHeightPx = new HTuple(), hv_YAxisHeight = new HTuple();
            HTuple hv_YScaleFactor = new HTuple(), hv_YAxisOffsetPx = new HTuple();
            HTuple hv_XAxisOffsetPx = new HTuple(), hv_DotStyle = new HTuple();
            HTuple hv_XGridValues = new HTuple(), hv_XGridStart = new HTuple();
            HTuple hv_XCoord = new HTuple(), hv_IndexGrid = new HTuple();
            HTuple hv_YGridValues = new HTuple(), hv_YGridStart = new HTuple();
            HTuple hv_YCoord = new HTuple(), hv_Ascent = new HTuple();
            HTuple hv_Descent = new HTuple(), hv_TextWidthXLabel = new HTuple();
            HTuple hv_TextHeightXLabel = new HTuple(), hv_TextWidthYLabel = new HTuple();
            HTuple hv_TextHeightYLabel = new HTuple(), hv_XTickStart = new HTuple();
            HTuple hv_Indices = new HTuple(), hv_TypeTicks = new HTuple();
            HTuple hv_IndexTicks = new HTuple(), hv_Ascent1 = new HTuple();
            HTuple hv_Descent1 = new HTuple(), hv_TextWidthXTicks = new HTuple();
            HTuple hv_TextHeightXTicks = new HTuple(), hv_YTickValues = new HTuple();
            HTuple hv_YTickStart = new HTuple(), hv_TextWidthYTicks = new HTuple();
            HTuple hv_TextHeightYTicks = new HTuple(), hv_Num = new HTuple();
            HTuple hv_I = new HTuple(), hv_YSelected = new HTuple();
            HTuple hv_StyleOriginal = new HTuple(), hv_OldLineWidth = new HTuple();
            HTuple hv_Radii = new HTuple(), hv_OldContourStyle = new HTuple();
            HTuple hv_Y1Selected = new HTuple(), hv_X1Selected = new HTuple();
            HTuple hv_Index = new HTuple(), hv_Row1 = new HTuple();
            HTuple hv_Row2 = new HTuple(), hv_Col1 = new HTuple();
            HTuple hv_Col2 = new HTuple();
            HTuple hv_XValues_COPY_INP_TMP = new HTuple(hv_XValues);
            HTuple hv_YValues_COPY_INP_TMP = new HTuple(hv_YValues);

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ContourXGrid);
            HOperatorSet.GenEmptyObj(out ho_ContourYGrid);
            HOperatorSet.GenEmptyObj(out ho_XArrow);
            HOperatorSet.GenEmptyObj(out ho_YArrow);
            HOperatorSet.GenEmptyObj(out ho_ContourXTick);
            HOperatorSet.GenEmptyObj(out ho_ContourYTick);
            HOperatorSet.GenEmptyObj(out ho_Contour);
            HOperatorSet.GenEmptyObj(out ho_Cross);
            HOperatorSet.GenEmptyObj(out ho_Circle);
            HOperatorSet.GenEmptyObj(out ho_Filled);
            HOperatorSet.GenEmptyObj(out ho_Stair);
            HOperatorSet.GenEmptyObj(out ho_StairTmp);
            try
            {
                //
                //This procedure plots tuples representing functions
                //or curves in a coordinate system.

                //In the following, the possible values are listed for the parameters:
                //
                //- XValues: X values of the function to be plotted. Thereby you have the following options:
                //  -- []: XValues are internally set to 0,1,2,...,|YValues|-1.
                //  -- a tuple of strings: These values are taken as categories.
                //
                //- YValues: Y values of the function(s) to be plotted. Thereby you have the following options:
                //  -- []: YValues are internally set to 0,1,2,...,|XValues|-1.
                //  -- a tuple of values: The number of y values must be equal to the number of x values or an integral multiple.
                //     In the latter case, multiple functions are plotted, that share the same x values.
                //
                //- XLabel: X-axis label.
                //
                //- YLabel: Y-axis label.
                //
                //- Color: Color of the plotted function. Thereby you have the following options:
                //  -- []: The currently set display color is used.
                //  -- 'none': The function is not plotted, but only the coordinate axes as specified.
                //  -- string: Defining the color of the plotted function.
                //  -- tuple of strings: -nultiple functions can be displayed in different colors.
                //
                //- GenParamName: Generic parameter names to control the presentation.
                // The corresponding values are taken from GenParamValue. Possible Values string/value pairs:
                //  -- 'axes_color': Color of the coordinate axes. The default value is 'white'.
                //     If 'none' is given, no coordinate axes are shown.
                //  -- 'style': Graph style. Possible values:
                //     --- 'line' (default)
                //     --- 'cross'
                //     --- 'circle'
                //     --- 'step'
                //     --- 'filled'
                //  -- 'clip': Clip graph to coordinate system area. Possible values:
                //     --- 'no' (default)
                //     --- 'yes''
                //  -- 'ticks': Control display of ticks on the axes. Thereby you have the following options:
                //     --- 'min_max_origin' (default): Ticks are shown at the minimum and maximum values
                //         of the axes and at the intercept point of x- and y-axis.
                //     --- 'none': No ticks are shown.
                //     --- any number != 0: This number specifies the distance between the ticks.
                //  -- 'ticks_x': Control display of ticks on x-axis only. You have the same options as for 'ticks'.
                //  -- 'ticks_y': Control display of ticks on y-axis only. You have the same options as for 'ticks'.
                //  -- 'format_x': Format of the values next to the ticks of the x-axis (see tuple_string for more details).
                //  -- 'format_y': Format of the values next to the ticks of the y-axis (see tuple_string for more details).
                //  -- 'grid': Control display of grid lines within the coordinate system.
                //     Thereby you have the following options:
                //    --- 'min_max_origin' (default): Grid lines are shown at the minimum and maximum values of the axes.
                //    --- 'none': No grid lines are shown.
                //    --- If any number != 0: This number specifies the distance between the grid lines.
                //  -- 'grid_x': Control display of grid lines for the x-axis only.
                //  -- 'grid_y': Control display of grid lines for the y-axis only.
                //  -- 'grid_color': Color of the grid (default: 'dim gray').
                //  -- 'margin': The distance in pixels of the plot area to all four window borders.
                //  -- 'margin_left': The distance in pixels of the plot area to the left window border.
                //  -- 'margin_right': The distance in pixels of the plot area to the right window border.
                //  -- 'margin_top': The distance in pixels of the plot area to the upper window border.
                //  -- 'margin_bottom'': The distance in pixels of the plot area to the lower window border.
                //  -- 'start_x': Lowest x value of the x-axis. The default value is min(XValues).
                //  -- 'end_x': Highest x value of the x-axis. The default value is max(XValues).
                //  -- 'start_y': Lowest y value of the y-axis. The default value is min(YValues).
                //  -- 'end_y': Highest y value of the y-axis. The default value is max(YValues).
                //  -- 'axis_location_x': Position of the x-axis (Used to be called 'origin_y').
                //     Thereby you have the following options:
                //     --- 'bottom' (default)
                //     --- 'origin'
                //     --- 'top'
                //     --- Y coordinate of the intercept point of x- and y-axis.
                //  -- 'axis_location_y': Position of the y-axis (Used to be called 'origin_x').
                //     Thereby you have the following options:
                //     --- 'left' (default)
                //     --- 'right'
                //     --- 'origin'
                //     --- X coordinate of the intercept point of x- and y-axis.
                //  -- 'line_width': Line width of the plot.
                //  -- 'log_y': If 'true', plot the YValue in logarithmic scale. Default is 'false'.
                //
                //
                hv_ClipRegion.Dispose();
                HOperatorSet.GetSystem("clip_region", out hv_ClipRegion);
                hv_Row.Dispose(); hv_Column.Dispose(); hv_Width.Dispose(); hv_Height.Dispose();
                HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv_Row, out hv_Column, out hv_Width,
                    out hv_Height);
                hv_PartRow1.Dispose(); hv_PartColumn1.Dispose(); hv_PartRow2.Dispose(); hv_PartColumn2.Dispose();
                HOperatorSet.GetPart(hv_WindowHandle, out hv_PartRow1, out hv_PartColumn1,
                    out hv_PartRow2, out hv_PartColumn2);
                hv_Width.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Width = (hv_PartColumn2 - hv_PartColumn1) + 1;
                }
                hv_Height.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Height = (hv_PartRow2 - hv_PartRow1) + 1;
                }
                hv_Red.Dispose(); hv_Green.Dispose(); hv_Blue.Dispose();
                HOperatorSet.GetRgb(hv_WindowHandle, out hv_Red, out hv_Green, out hv_Blue);
                hv_DrawMode.Dispose();
                HOperatorSet.GetDraw(hv_WindowHandle, out hv_DrawMode);
                hv_OriginStyle.Dispose();
                HOperatorSet.GetLineStyle(hv_WindowHandle, out hv_OriginStyle);
                //
                //Set the display parameters.
                HOperatorSet.SetLineStyle(hv_WindowHandle, new HTuple());
                HOperatorSet.SetSystem("clip_region", "false");

                hv_PartDiffers.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PartDiffers = (new HTuple((new HTuple((new HTuple((new HTuple(0)).TupleNotEqual(
                        hv_PartRow1))).TupleOr(new HTuple((new HTuple(0)).TupleNotEqual(hv_Column))))).TupleOr(
                        new HTuple(((hv_Width - 1)).TupleNotEqual(hv_PartColumn2))))).TupleOr(new HTuple(((hv_Height - 1)).TupleNotEqual(
                        hv_PartRow2)));
                }
                //Only use set part if it differs.
                if ((int)(hv_PartDiffers) != 0)
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_Height - 1, hv_Width - 1);
                        }
                    }
                }
                //
                //Check if we need to plot y-values logarithmically.
                //It is checked here because we want to convert the YValues tuple
                //immediately so that derived values will be correct.
                hv_PlotYLog.Dispose();
                hv_PlotYLog = 0;
                if ((int)((new HTuple((new HTuple(hv_GenParamName.TupleLength())).TupleGreater(
                    0))).TupleAnd(new HTuple((new HTuple(hv_GenParamName.TupleLength())).TupleEqual(
                    new HTuple(hv_GenParamValue.TupleLength()))))) != 0)
                {
                    hv_YLogIndices.Dispose();
                    HOperatorSet.TupleFind(hv_GenParamName, "log_y", out hv_YLogIndices);
                    if ((int)(new HTuple(hv_YLogIndices.TupleGreaterEqual(0))) != 0)
                    {
                        hv_PlotYLogUser.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_PlotYLogUser = hv_GenParamValue.TupleSelect(
                                hv_YLogIndices.TupleSelect(0));
                        }
                        hv_IsString.Dispose();
                        HOperatorSet.TupleIsString(hv_PlotYLogUser, out hv_IsString);
                        if ((int)(hv_IsString) != 0)
                        {
                            if ((int)(new HTuple(hv_PlotYLogUser.TupleEqual("true"))) != 0)
                            {
                                hv_PlotYLog.Dispose();
                                hv_PlotYLog = 1;
                            }
                            else if ((int)(new HTuple(hv_PlotYLogUser.TupleEqual("false"))) != 0)
                            {
                                hv_PlotYLog.Dispose();
                                hv_PlotYLog = 0;
                            }
                            else
                            {
                                throw new HalconException(("Unknown generic param value: '" + hv_PlotYLogUser) + "' for value: 'log_y'");
                            }
                            hv_PlotYLog.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_PlotYLog = new HTuple(hv_PlotYLogUser.TupleEqual(
                                    "true"));
                            }
                        }
                        else
                        {
                            hv_PlotYLog.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_PlotYLog = new HTuple(hv_PlotYLogUser.TupleEqual(
                                    1));
                            }
                        }
                    }
                }
                if ((int)(hv_PlotYLog) != 0)
                {
                    //Clamp values to be >= 0.00001.
                    hv_YInd.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_YInd = hv_YValues_COPY_INP_TMP.TupleLessEqualElem(
                            0);
                    }
                    hv_Indices1.Dispose();
                    HOperatorSet.TupleFind(hv_YInd, 1, out hv_Indices1);
                    if ((int)(new HTuple(hv_Indices1.TupleGreaterEqual(0))) != 0)
                    {
                        if (hv_YValues_COPY_INP_TMP == null)
                            hv_YValues_COPY_INP_TMP = new HTuple();
                        hv_YValues_COPY_INP_TMP[hv_Indices1] = 0.00001;
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_YValues = hv_YValues_COPY_INP_TMP.TupleLog10()
                                ;
                            hv_YValues_COPY_INP_TMP.Dispose();
                            hv_YValues_COPY_INP_TMP = ExpTmpLocalVar_YValues;
                        }
                    }
                }
                //
                //Check input coordinate values.
                //
                if ((int)((new HTuple(hv_XValues_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleAnd(
                    new HTuple(hv_YValues_COPY_INP_TMP.TupleEqual(new HTuple())))) != 0)
                {
                    //Neither XValues nor YValues are given:
                    //Set axes to interval [0,1]
                    hv_XAxisEndValue.Dispose();
                    hv_XAxisEndValue = 1;
                    hv_YAxisEndValue.Dispose();
                    hv_YAxisEndValue = 1;
                    hv_XAxisStartValue.Dispose();
                    hv_XAxisStartValue = 0;
                    hv_YAxisStartValue.Dispose();
                    hv_YAxisStartValue = 0;
                    hv_XValuesAreStrings.Dispose();
                    hv_XValuesAreStrings = 0;
                }
                else
                {
                    if ((int)(new HTuple(hv_XValues_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
                    {
                        //XValues are omitted: Set equidistant XValues.
                        hv_XValues_COPY_INP_TMP.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XValues_COPY_INP_TMP = HTuple.TupleGenSequence(
                                0, (new HTuple(hv_YValues_COPY_INP_TMP.TupleLength())) - 1, 1);
                        }
                        hv_XValuesAreStrings.Dispose();
                        hv_XValuesAreStrings = 0;
                    }
                    else if ((int)(new HTuple(hv_YValues_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
                    {
                        //YValues are omitted: Set equidistant YValues.
                        hv_YValues_COPY_INP_TMP.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YValues_COPY_INP_TMP = HTuple.TupleGenSequence(
                                0, (new HTuple(hv_XValues_COPY_INP_TMP.TupleLength())) - 1, 1);
                        }
                    }
                    if ((int)(new HTuple((new HTuple((new HTuple(hv_YValues_COPY_INP_TMP.TupleLength()
                        )) % (new HTuple(hv_XValues_COPY_INP_TMP.TupleLength())))).TupleNotEqual(
                        0))) != 0)
                    {
                        //Number of YValues does not match number of XValues.
                        throw new HalconException("Number of YValues is no multiple of the number of XValues.");
                        ho_ContourXGrid.Dispose();
                        ho_ContourYGrid.Dispose();
                        ho_XArrow.Dispose();
                        ho_YArrow.Dispose();
                        ho_ContourXTick.Dispose();
                        ho_ContourYTick.Dispose();
                        ho_Contour.Dispose();
                        ho_Cross.Dispose();
                        ho_Circle.Dispose();
                        ho_Filled.Dispose();
                        ho_Stair.Dispose();
                        ho_StairTmp.Dispose();

                        hv_XValues_COPY_INP_TMP.Dispose();
                        hv_YValues_COPY_INP_TMP.Dispose();
                        hv_ClipRegion.Dispose();
                        hv_Row.Dispose();
                        hv_Column.Dispose();
                        hv_Width.Dispose();
                        hv_Height.Dispose();
                        hv_PartRow1.Dispose();
                        hv_PartColumn1.Dispose();
                        hv_PartRow2.Dispose();
                        hv_PartColumn2.Dispose();
                        hv_Red.Dispose();
                        hv_Green.Dispose();
                        hv_Blue.Dispose();
                        hv_DrawMode.Dispose();
                        hv_OriginStyle.Dispose();
                        hv_PartDiffers.Dispose();
                        hv_PlotYLog.Dispose();
                        hv_YLogIndices.Dispose();
                        hv_PlotYLogUser.Dispose();
                        hv_IsString.Dispose();
                        hv_YInd.Dispose();
                        hv_Indices1.Dispose();
                        hv_XAxisEndValue.Dispose();
                        hv_YAxisEndValue.Dispose();
                        hv_XAxisStartValue.Dispose();
                        hv_YAxisStartValue.Dispose();
                        hv_XValuesAreStrings.Dispose();
                        hv_XTickValues.Dispose();
                        hv_XTicks.Dispose();
                        hv_YAxisPosition.Dispose();
                        hv_XAxisPosition.Dispose();
                        hv_LeftBorder.Dispose();
                        hv_RightBorder.Dispose();
                        hv_UpperBorder.Dispose();
                        hv_LowerBorder.Dispose();
                        hv_AxesColor.Dispose();
                        hv_Style.Dispose();
                        hv_Clip.Dispose();
                        hv_YTicks.Dispose();
                        hv_XGrid.Dispose();
                        hv_YGrid.Dispose();
                        hv_GridColor.Dispose();
                        hv_YPosition.Dispose();
                        hv_FormatX.Dispose();
                        hv_FormatY.Dispose();
                        hv_LineWidth.Dispose();
                        hv_NumGenParamNames.Dispose();
                        hv_NumGenParamValues.Dispose();
                        hv_GenParamIndex.Dispose();
                        hv_XGridTicks.Dispose();
                        hv_YTickDirection.Dispose();
                        hv_XTickDirection.Dispose();
                        hv_XAxisWidthPx.Dispose();
                        hv_XAxisWidth.Dispose();
                        hv_XScaleFactor.Dispose();
                        hv_YAxisHeightPx.Dispose();
                        hv_YAxisHeight.Dispose();
                        hv_YScaleFactor.Dispose();
                        hv_YAxisOffsetPx.Dispose();
                        hv_XAxisOffsetPx.Dispose();
                        hv_DotStyle.Dispose();
                        hv_XGridValues.Dispose();
                        hv_XGridStart.Dispose();
                        hv_XCoord.Dispose();
                        hv_IndexGrid.Dispose();
                        hv_YGridValues.Dispose();
                        hv_YGridStart.Dispose();
                        hv_YCoord.Dispose();
                        hv_Ascent.Dispose();
                        hv_Descent.Dispose();
                        hv_TextWidthXLabel.Dispose();
                        hv_TextHeightXLabel.Dispose();
                        hv_TextWidthYLabel.Dispose();
                        hv_TextHeightYLabel.Dispose();
                        hv_XTickStart.Dispose();
                        hv_Indices.Dispose();
                        hv_TypeTicks.Dispose();
                        hv_IndexTicks.Dispose();
                        hv_Ascent1.Dispose();
                        hv_Descent1.Dispose();
                        hv_TextWidthXTicks.Dispose();
                        hv_TextHeightXTicks.Dispose();
                        hv_YTickValues.Dispose();
                        hv_YTickStart.Dispose();
                        hv_TextWidthYTicks.Dispose();
                        hv_TextHeightYTicks.Dispose();
                        hv_Num.Dispose();
                        hv_I.Dispose();
                        hv_YSelected.Dispose();
                        hv_StyleOriginal.Dispose();
                        hv_OldLineWidth.Dispose();
                        hv_Radii.Dispose();
                        hv_OldContourStyle.Dispose();
                        hv_Y1Selected.Dispose();
                        hv_X1Selected.Dispose();
                        hv_Index.Dispose();
                        hv_Row1.Dispose();
                        hv_Row2.Dispose();
                        hv_Col1.Dispose();
                        hv_Col2.Dispose();

                        return;
                    }

                    hv_XValuesAreStrings.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_XValuesAreStrings = hv_XValues_COPY_INP_TMP.TupleIsStringElem()
                            ;
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_XValuesAreStrings = new HTuple(((hv_XValuesAreStrings.TupleSum()
                                )).TupleEqual(new HTuple(hv_XValuesAreStrings.TupleLength())));
                            hv_XValuesAreStrings.Dispose();
                            hv_XValuesAreStrings = ExpTmpLocalVar_XValuesAreStrings;
                        }
                    }
                    if ((int)(hv_XValuesAreStrings) != 0)
                    {
                        //XValues are given as strings: Show XValues as ticks.
                        hv_XTickValues.Dispose();
                        hv_XTickValues = new HTuple(hv_XValues_COPY_INP_TMP);
                        hv_XTicks.Dispose();
                        hv_XTicks = 1;
                        //Set x-axis dimensions.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_XValues = HTuple.TupleGenSequence(
                                    1, new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()), 1);
                                hv_XValues_COPY_INP_TMP.Dispose();
                                hv_XValues_COPY_INP_TMP = ExpTmpLocalVar_XValues;
                            }
                        }
                    }
                    //Set default x-axis dimensions.
                    if ((int)(new HTuple((new HTuple(hv_XValues_COPY_INP_TMP.TupleLength())).TupleGreater(
                        1))) != 0)
                    {
                        hv_XAxisStartValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XAxisStartValue = hv_XValues_COPY_INP_TMP.TupleMin()
                                ;
                        }
                        hv_XAxisEndValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XAxisEndValue = hv_XValues_COPY_INP_TMP.TupleMax()
                                ;
                        }
                    }
                    else
                    {
                        hv_XAxisEndValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XAxisEndValue = (hv_XValues_COPY_INP_TMP.TupleSelect(
                                0)) + 0.5;
                        }
                        hv_XAxisStartValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XAxisStartValue = (hv_XValues_COPY_INP_TMP.TupleSelect(
                                0)) - 0.5;
                        }
                    }
                }
                //Set default y-axis dimensions.
                if ((int)(new HTuple((new HTuple(hv_YValues_COPY_INP_TMP.TupleLength())).TupleGreater(
                    1))) != 0)
                {
                    hv_YAxisStartValue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_YAxisStartValue = hv_YValues_COPY_INP_TMP.TupleMin()
                            ;
                    }
                    hv_YAxisEndValue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_YAxisEndValue = hv_YValues_COPY_INP_TMP.TupleMax()
                            ;
                    }
                }
                else if ((int)(new HTuple((new HTuple(hv_YValues_COPY_INP_TMP.TupleLength()
                    )).TupleEqual(1))) != 0)
                {
                    hv_YAxisStartValue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_YAxisStartValue = (hv_YValues_COPY_INP_TMP.TupleSelect(
                            0)) - 0.5;
                    }
                    hv_YAxisEndValue.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_YAxisEndValue = (hv_YValues_COPY_INP_TMP.TupleSelect(
                            0)) + 0.5;
                    }
                }
                else
                {
                    hv_YAxisStartValue.Dispose();
                    hv_YAxisStartValue = 0;
                    hv_YAxisEndValue.Dispose();
                    hv_YAxisEndValue = 1;
                }
                //Set default interception point of x- and y- axis.
                hv_YAxisPosition.Dispose();
                hv_YAxisPosition = "default";
                hv_XAxisPosition.Dispose();
                hv_XAxisPosition = "default";
                //
                //Set further default values:
                hv_LeftBorder.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_LeftBorder = hv_Width * 0.1;
                }
                hv_RightBorder.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_RightBorder = hv_Width * 0.1;
                }
                hv_UpperBorder.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_UpperBorder = hv_Height * 0.1;
                }
                hv_LowerBorder.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_LowerBorder = hv_Height * 0.1;
                }
                hv_AxesColor.Dispose();
                hv_AxesColor = "white";
                hv_Style.Dispose();
                hv_Style = "line";
                hv_Clip.Dispose();
                hv_Clip = "no";
                hv_XTicks.Dispose();
                hv_XTicks = "min_max_origin";
                hv_YTicks.Dispose();
                hv_YTicks = "min_max_origin";
                hv_XGrid.Dispose();
                hv_XGrid = "none";
                hv_YGrid.Dispose();
                hv_YGrid = "none";
                hv_GridColor.Dispose();
                hv_GridColor = "dim gray";
                hv_YPosition.Dispose();
                hv_YPosition = "left";
                hv_FormatX.Dispose();
                hv_FormatX = "default";
                hv_FormatY.Dispose();
                hv_FormatY = "default";
                hv_LineWidth.Dispose();
                hv_LineWidth = 1;
                //
                //Parse generic parameters.
                //
                hv_NumGenParamNames.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumGenParamNames = new HTuple(hv_GenParamName.TupleLength()
                        );
                }
                hv_NumGenParamValues.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumGenParamValues = new HTuple(hv_GenParamValue.TupleLength()
                        );
                }
                if ((int)(new HTuple(hv_NumGenParamNames.TupleNotEqual(hv_NumGenParamValues))) != 0)
                {
                    throw new HalconException("Number of generic parameter names does not match generic parameter values.");
                    ho_ContourXGrid.Dispose();
                    ho_ContourYGrid.Dispose();
                    ho_XArrow.Dispose();
                    ho_YArrow.Dispose();
                    ho_ContourXTick.Dispose();
                    ho_ContourYTick.Dispose();
                    ho_Contour.Dispose();
                    ho_Cross.Dispose();
                    ho_Circle.Dispose();
                    ho_Filled.Dispose();
                    ho_Stair.Dispose();
                    ho_StairTmp.Dispose();

                    hv_XValues_COPY_INP_TMP.Dispose();
                    hv_YValues_COPY_INP_TMP.Dispose();
                    hv_ClipRegion.Dispose();
                    hv_Row.Dispose();
                    hv_Column.Dispose();
                    hv_Width.Dispose();
                    hv_Height.Dispose();
                    hv_PartRow1.Dispose();
                    hv_PartColumn1.Dispose();
                    hv_PartRow2.Dispose();
                    hv_PartColumn2.Dispose();
                    hv_Red.Dispose();
                    hv_Green.Dispose();
                    hv_Blue.Dispose();
                    hv_DrawMode.Dispose();
                    hv_OriginStyle.Dispose();
                    hv_PartDiffers.Dispose();
                    hv_PlotYLog.Dispose();
                    hv_YLogIndices.Dispose();
                    hv_PlotYLogUser.Dispose();
                    hv_IsString.Dispose();
                    hv_YInd.Dispose();
                    hv_Indices1.Dispose();
                    hv_XAxisEndValue.Dispose();
                    hv_YAxisEndValue.Dispose();
                    hv_XAxisStartValue.Dispose();
                    hv_YAxisStartValue.Dispose();
                    hv_XValuesAreStrings.Dispose();
                    hv_XTickValues.Dispose();
                    hv_XTicks.Dispose();
                    hv_YAxisPosition.Dispose();
                    hv_XAxisPosition.Dispose();
                    hv_LeftBorder.Dispose();
                    hv_RightBorder.Dispose();
                    hv_UpperBorder.Dispose();
                    hv_LowerBorder.Dispose();
                    hv_AxesColor.Dispose();
                    hv_Style.Dispose();
                    hv_Clip.Dispose();
                    hv_YTicks.Dispose();
                    hv_XGrid.Dispose();
                    hv_YGrid.Dispose();
                    hv_GridColor.Dispose();
                    hv_YPosition.Dispose();
                    hv_FormatX.Dispose();
                    hv_FormatY.Dispose();
                    hv_LineWidth.Dispose();
                    hv_NumGenParamNames.Dispose();
                    hv_NumGenParamValues.Dispose();
                    hv_GenParamIndex.Dispose();
                    hv_XGridTicks.Dispose();
                    hv_YTickDirection.Dispose();
                    hv_XTickDirection.Dispose();
                    hv_XAxisWidthPx.Dispose();
                    hv_XAxisWidth.Dispose();
                    hv_XScaleFactor.Dispose();
                    hv_YAxisHeightPx.Dispose();
                    hv_YAxisHeight.Dispose();
                    hv_YScaleFactor.Dispose();
                    hv_YAxisOffsetPx.Dispose();
                    hv_XAxisOffsetPx.Dispose();
                    hv_DotStyle.Dispose();
                    hv_XGridValues.Dispose();
                    hv_XGridStart.Dispose();
                    hv_XCoord.Dispose();
                    hv_IndexGrid.Dispose();
                    hv_YGridValues.Dispose();
                    hv_YGridStart.Dispose();
                    hv_YCoord.Dispose();
                    hv_Ascent.Dispose();
                    hv_Descent.Dispose();
                    hv_TextWidthXLabel.Dispose();
                    hv_TextHeightXLabel.Dispose();
                    hv_TextWidthYLabel.Dispose();
                    hv_TextHeightYLabel.Dispose();
                    hv_XTickStart.Dispose();
                    hv_Indices.Dispose();
                    hv_TypeTicks.Dispose();
                    hv_IndexTicks.Dispose();
                    hv_Ascent1.Dispose();
                    hv_Descent1.Dispose();
                    hv_TextWidthXTicks.Dispose();
                    hv_TextHeightXTicks.Dispose();
                    hv_YTickValues.Dispose();
                    hv_YTickStart.Dispose();
                    hv_TextWidthYTicks.Dispose();
                    hv_TextHeightYTicks.Dispose();
                    hv_Num.Dispose();
                    hv_I.Dispose();
                    hv_YSelected.Dispose();
                    hv_StyleOriginal.Dispose();
                    hv_OldLineWidth.Dispose();
                    hv_Radii.Dispose();
                    hv_OldContourStyle.Dispose();
                    hv_Y1Selected.Dispose();
                    hv_X1Selected.Dispose();
                    hv_Index.Dispose();
                    hv_Row1.Dispose();
                    hv_Row2.Dispose();
                    hv_Col1.Dispose();
                    hv_Col2.Dispose();

                    return;
                }
                //
                for (hv_GenParamIndex = 0; (int)hv_GenParamIndex <= (int)((new HTuple(hv_GenParamName.TupleLength()
                    )) - 1); hv_GenParamIndex = (int)hv_GenParamIndex + 1)
                {
                    //
                    //Set 'axes_color'.
                    if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "axes_color"))) != 0)
                    {
                        hv_AxesColor.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_AxesColor = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'style'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "style"))) != 0)
                    {
                        hv_Style.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Style = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'clip'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "clip"))) != 0)
                    {
                        hv_Clip.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Clip = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        if ((int)((new HTuple(hv_Clip.TupleNotEqual("yes"))).TupleAnd(new HTuple(hv_Clip.TupleNotEqual(
                            "no")))) != 0)
                        {
                            throw new HalconException(("Unsupported clipping option: '" + hv_Clip) + "'");
                        }
                        //
                        //Set 'ticks'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "ticks"))) != 0)
                    {
                        hv_XTicks.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XTicks = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        hv_YTicks.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YTicks = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'ticks_x'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "ticks_x"))) != 0)
                    {
                        hv_XTicks.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XTicks = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'ticks_y'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "ticks_y"))) != 0)
                    {
                        hv_YTicks.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YTicks = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'grid'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "grid"))) != 0)
                    {
                        hv_XGrid.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XGrid = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        hv_YGrid.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YGrid = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        hv_XGridTicks.Dispose();
                        hv_XGridTicks = new HTuple(hv_XTicks);
                        //
                        //Set 'grid_x'
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "grid_x"))) != 0)
                    {
                        hv_XGrid.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XGrid = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'grid_y'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "grid_y"))) != 0)
                    {
                        hv_YGrid.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YGrid = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'grid_color'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "grid_color"))) != 0)
                    {
                        hv_GridColor.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_GridColor = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'start_x'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "start_x"))) != 0)
                    {
                        hv_XAxisStartValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XAxisStartValue = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'end_x'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "end_x"))) != 0)
                    {
                        hv_XAxisEndValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XAxisEndValue = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'start_y'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "start_y"))) != 0)
                    {
                        hv_YAxisStartValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YAxisStartValue = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        if ((int)(hv_PlotYLog) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_YAxisStartValue = (((new HTuple(0.00000001)).TupleMax2(
                                        hv_YAxisStartValue))).TupleLog10();
                                    hv_YAxisStartValue.Dispose();
                                    hv_YAxisStartValue = ExpTmpLocalVar_YAxisStartValue;
                                }
                            }
                        }
                        //
                        //Set 'end_y'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "end_y"))) != 0)
                    {
                        hv_YAxisEndValue.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YAxisEndValue = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        if ((int)(hv_PlotYLog) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_YAxisEndValue = (((new HTuple(0.00000001)).TupleMax2(
                                        hv_YAxisEndValue))).TupleLog10();
                                    hv_YAxisEndValue.Dispose();
                                    hv_YAxisEndValue = ExpTmpLocalVar_YAxisEndValue;
                                }
                            }
                        }
                        //
                        //Set 'axis_location_y' (old name 'origin_x').
                    }
                    else if ((int)((new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "axis_location_y"))).TupleOr(new HTuple(((hv_GenParamName.TupleSelect(
                        hv_GenParamIndex))).TupleEqual("origin_x")))) != 0)
                    {
                        hv_YAxisPosition.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YAxisPosition = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'axis_location_x' (old name: 'origin_y').
                    }
                    else if ((int)((new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "axis_location_x"))).TupleOr(new HTuple(((hv_GenParamName.TupleSelect(
                        hv_GenParamIndex))).TupleEqual("origin_y")))) != 0)
                    {
                        hv_XAxisPosition.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XAxisPosition = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'margin'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "margin"))) != 0)
                    {
                        hv_LeftBorder.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_LeftBorder = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        hv_RightBorder.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_RightBorder = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        hv_UpperBorder.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_UpperBorder = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        hv_LowerBorder.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_LowerBorder = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'margin_left'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "margin_left"))) != 0)
                    {
                        hv_LeftBorder.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_LeftBorder = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'margin_right'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "margin_right"))) != 0)
                    {
                        hv_RightBorder.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_RightBorder = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'margin_top'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "margin_top"))) != 0)
                    {
                        hv_UpperBorder.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_UpperBorder = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                        //
                        //Set 'margin_bottom'.
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "margin_bottom"))) != 0)
                    {
                        hv_LowerBorder.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_LowerBorder = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "format_x"))) != 0)
                    {
                        hv_FormatX.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FormatX = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "format_y"))) != 0)
                    {
                        hv_FormatY.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FormatY = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "line_width"))) != 0)
                    {
                        hv_LineWidth.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_LineWidth = hv_GenParamValue.TupleSelect(
                                hv_GenParamIndex);
                        }
                    }
                    else if ((int)(new HTuple(((hv_GenParamName.TupleSelect(hv_GenParamIndex))).TupleEqual(
                        "log_y"))) != 0)
                    {
                        //log_y already checked before because some other values depend on it.
                    }
                    else
                    {
                        throw new HalconException(("Unknown generic parameter: '" + (hv_GenParamName.TupleSelect(
                            hv_GenParamIndex))) + "'");
                    }
                }
                //
                //Check consistency of start and end values of the axes.
                if ((int)(new HTuple(hv_XAxisStartValue.TupleGreater(hv_XAxisEndValue))) != 0)
                {
                    throw new HalconException("Value for 'start_x' is greater than value for 'end_x'");
                }
                if ((int)(new HTuple(hv_YAxisStartValue.TupleGreater(hv_YAxisEndValue))) != 0)
                {
                    throw new HalconException("Value for 'start_y' is greater than value for 'end_y'");
                }
                //
                //Set the position of the y-axis.
                if ((int)(new HTuple(hv_YAxisPosition.TupleEqual("default"))) != 0)
                {
                    hv_YAxisPosition.Dispose();
                    hv_YAxisPosition = new HTuple(hv_XAxisStartValue);
                }
                if ((int)(new HTuple(((hv_YAxisPosition.TupleIsString())).TupleEqual(1))) != 0)
                {
                    if ((int)(new HTuple(hv_YAxisPosition.TupleEqual("left"))) != 0)
                    {
                        hv_YAxisPosition.Dispose();
                        hv_YAxisPosition = new HTuple(hv_XAxisStartValue);
                    }
                    else if ((int)(new HTuple(hv_YAxisPosition.TupleEqual("right"))) != 0)
                    {
                        hv_YAxisPosition.Dispose();
                        hv_YAxisPosition = new HTuple(hv_XAxisEndValue);
                    }
                    else if ((int)(new HTuple(hv_YAxisPosition.TupleEqual("origin"))) != 0)
                    {
                        hv_YAxisPosition.Dispose();
                        hv_YAxisPosition = 0;
                    }
                    else
                    {
                        throw new HalconException(("Unsupported axis_location_y: '" + hv_YAxisPosition) + "'");
                    }
                }
                //Set the position of the ticks on the y-axis
                //depending of the location of the y-axis.
                if ((int)(new HTuple((new HTuple(((hv_XAxisStartValue.TupleConcat(hv_XAxisEndValue))).TupleMean()
                    )).TupleGreater(hv_YAxisPosition))) != 0)
                {
                    hv_YTickDirection.Dispose();
                    hv_YTickDirection = "right";
                }
                else
                {
                    hv_YTickDirection.Dispose();
                    hv_YTickDirection = "left";
                }
                //
                //Set the position of the x-axis.
                if ((int)(new HTuple(hv_XAxisPosition.TupleEqual("default"))) != 0)
                {
                    hv_XAxisPosition.Dispose();
                    hv_XAxisPosition = new HTuple(hv_YAxisStartValue);
                }
                if ((int)(new HTuple(((hv_XAxisPosition.TupleIsString())).TupleEqual(1))) != 0)
                {
                    if ((int)(new HTuple(hv_XAxisPosition.TupleEqual("bottom"))) != 0)
                    {
                        hv_XAxisPosition.Dispose();
                        hv_XAxisPosition = new HTuple(hv_YAxisStartValue);
                    }
                    else if ((int)(new HTuple(hv_XAxisPosition.TupleEqual("top"))) != 0)
                    {
                        hv_XAxisPosition.Dispose();
                        hv_XAxisPosition = new HTuple(hv_YAxisEndValue);
                    }
                    else if ((int)(new HTuple(hv_XAxisPosition.TupleEqual("origin"))) != 0)
                    {
                        hv_XAxisPosition.Dispose();
                        hv_XAxisPosition = 0;
                    }
                    else
                    {
                        throw new HalconException(("Unsupported axis_location_x: '" + hv_XAxisPosition) + "'");
                    }
                }
                //Set the position of the ticks on the y-axis
                //depending of the location of the y-axis.
                if ((int)(new HTuple((new HTuple(((hv_YAxisStartValue.TupleConcat(hv_YAxisEndValue))).TupleMean()
                    )).TupleGreater(hv_XAxisPosition))) != 0)
                {
                    hv_XTickDirection.Dispose();
                    hv_XTickDirection = "up";
                }
                else
                {
                    hv_XTickDirection.Dispose();
                    hv_XTickDirection = "down";
                }
                //
                //Calculate basic pixel coordinates and scale factors.
                //
                hv_XAxisWidthPx.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_XAxisWidthPx = (hv_Width - hv_LeftBorder) - hv_RightBorder;
                }
                hv_XAxisWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_XAxisWidth = hv_XAxisEndValue - hv_XAxisStartValue;
                }
                if ((int)(new HTuple(hv_XAxisWidth.TupleEqual(0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_XAxisStartValue = hv_XAxisStartValue - 0.5;
                            hv_XAxisStartValue.Dispose();
                            hv_XAxisStartValue = ExpTmpLocalVar_XAxisStartValue;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_XAxisEndValue = hv_XAxisEndValue + 0.5;
                            hv_XAxisEndValue.Dispose();
                            hv_XAxisEndValue = ExpTmpLocalVar_XAxisEndValue;
                        }
                    }
                    hv_XAxisWidth.Dispose();
                    hv_XAxisWidth = 1;
                }
                hv_XScaleFactor.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_XScaleFactor = hv_XAxisWidthPx / (hv_XAxisWidth.TupleReal()
                        );
                }
                hv_YAxisHeightPx.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_YAxisHeightPx = (hv_Height - hv_LowerBorder) - hv_UpperBorder;
                }
                hv_YAxisHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_YAxisHeight = hv_YAxisEndValue - hv_YAxisStartValue;
                }
                if ((int)(new HTuple(hv_YAxisHeight.TupleEqual(0))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_YAxisStartValue = hv_YAxisStartValue - 0.5;
                            hv_YAxisStartValue.Dispose();
                            hv_YAxisStartValue = ExpTmpLocalVar_YAxisStartValue;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_YAxisEndValue = hv_YAxisEndValue + 0.5;
                            hv_YAxisEndValue.Dispose();
                            hv_YAxisEndValue = ExpTmpLocalVar_YAxisEndValue;
                        }
                    }
                    hv_YAxisHeight.Dispose();
                    hv_YAxisHeight = 1;
                }
                hv_YScaleFactor.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_YScaleFactor = hv_YAxisHeightPx / (hv_YAxisHeight.TupleReal()
                        );
                }
                hv_YAxisOffsetPx.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_YAxisOffsetPx = (hv_YAxisPosition - hv_XAxisStartValue) * hv_XScaleFactor;
                }
                hv_XAxisOffsetPx.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_XAxisOffsetPx = (hv_XAxisPosition - hv_YAxisStartValue) * hv_YScaleFactor;
                }
                //
                //Display grid lines.
                //
                if ((int)(new HTuple(hv_GridColor.TupleNotEqual("none"))) != 0)
                {
                    hv_DotStyle.Dispose();
                    hv_DotStyle = new HTuple();
                    hv_DotStyle[0] = 5;
                    hv_DotStyle[1] = 7;
                    HOperatorSet.SetLineStyle(hv_WindowHandle, hv_DotStyle);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_GridColor);
                    }
                    //
                    //Display x grid lines.
                    if ((int)(new HTuple(hv_XGrid.TupleNotEqual("none"))) != 0)
                    {
                        if ((int)(new HTuple(hv_XGrid.TupleEqual("min_max_origin"))) != 0)
                        {
                            //Calculate 'min_max_origin' grid line coordinates.
                            if ((int)(new HTuple(hv_YAxisPosition.TupleEqual(hv_XAxisStartValue))) != 0)
                            {
                                hv_XGridValues.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_XGridValues = new HTuple();
                                    hv_XGridValues = hv_XGridValues.TupleConcat(hv_XAxisStartValue, hv_XAxisEndValue);
                                }
                            }
                            else
                            {
                                hv_XGridValues.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_XGridValues = new HTuple();
                                    hv_XGridValues = hv_XGridValues.TupleConcat(hv_XAxisStartValue, hv_YAxisPosition, hv_XAxisEndValue);
                                }
                            }
                        }
                        else
                        {
                            //Calculate equidistant grid line coordinates.
                            hv_XGridStart.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_XGridStart = (((hv_XAxisStartValue / hv_XGrid)).TupleCeil()
                                    ) * hv_XGrid;
                            }
                            hv_XGridValues.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_XGridValues = HTuple.TupleGenSequence(
                                    hv_XGridStart, hv_XAxisEndValue, hv_XGrid);
                            }
                        }
                        hv_XCoord.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_XCoord = (hv_XGridValues - hv_XAxisStartValue) * hv_XScaleFactor;
                        }
                        //Generate and display grid lines.
                        for (hv_IndexGrid = 0; (int)hv_IndexGrid <= (int)((new HTuple(hv_XGridValues.TupleLength()
                            )) - 1); hv_IndexGrid = (int)hv_IndexGrid + 1)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_ContourXGrid.Dispose();
                                HOperatorSet.GenContourPolygonXld(out ho_ContourXGrid, ((hv_Height - hv_LowerBorder)).TupleConcat(
                                    hv_UpperBorder), ((hv_LeftBorder + (hv_XCoord.TupleSelect(hv_IndexGrid)))).TupleConcat(
                                    hv_LeftBorder + (hv_XCoord.TupleSelect(hv_IndexGrid))));
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_ContourXGrid, HDevWindowStack.GetActive());
                            }
                        }
                    }
                    //
                    //Display y grid lines.
                    if ((int)(new HTuple(hv_YGrid.TupleNotEqual("none"))) != 0)
                    {
                        if ((int)(new HTuple(hv_YGrid.TupleEqual("min_max_origin"))) != 0)
                        {
                            //Calculate 'min_max_origin' grid line coordinates.
                            if ((int)(new HTuple(hv_XAxisPosition.TupleEqual(hv_YAxisStartValue))) != 0)
                            {
                                hv_YGridValues.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_YGridValues = new HTuple();
                                    hv_YGridValues = hv_YGridValues.TupleConcat(hv_YAxisStartValue, hv_YAxisEndValue);
                                }
                            }
                            else
                            {
                                hv_YGridValues.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_YGridValues = new HTuple();
                                    hv_YGridValues = hv_YGridValues.TupleConcat(hv_YAxisStartValue, hv_XAxisPosition, hv_YAxisEndValue);
                                }
                            }
                        }
                        else
                        {
                            //Calculate equidistant grid line coordinates.
                            hv_YGridStart.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_YGridStart = (((hv_YAxisStartValue / hv_YGrid)).TupleCeil()
                                    ) * hv_YGrid;
                            }
                            hv_YGridValues.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_YGridValues = HTuple.TupleGenSequence(
                                    hv_YGridStart, hv_YAxisEndValue, hv_YGrid);
                            }
                        }
                        hv_YCoord.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YCoord = (hv_YGridValues - hv_YAxisStartValue) * hv_YScaleFactor;
                        }
                        //Generate and display grid lines.
                        for (hv_IndexGrid = 0; (int)hv_IndexGrid <= (int)((new HTuple(hv_YGridValues.TupleLength()
                            )) - 1); hv_IndexGrid = (int)hv_IndexGrid + 1)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_ContourYGrid.Dispose();
                                HOperatorSet.GenContourPolygonXld(out ho_ContourYGrid, (((hv_Height - hv_LowerBorder) - (hv_YCoord.TupleSelect(
                                    hv_IndexGrid)))).TupleConcat((hv_Height - hv_LowerBorder) - (hv_YCoord.TupleSelect(
                                    hv_IndexGrid))), hv_LeftBorder.TupleConcat(hv_Width - hv_RightBorder));
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_ContourYGrid, HDevWindowStack.GetActive());
                            }
                        }
                    }
                }
                HOperatorSet.SetLineStyle(hv_WindowHandle, new HTuple());
                //
                //
                //Display the coordinate system axes.
                if ((int)(new HTuple(hv_AxesColor.TupleNotEqual("none"))) != 0)
                {
                    //Display axes.
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_AxesColor);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_XArrow.Dispose();
                        gen_arrow_contour_xld(out ho_XArrow, (hv_Height - hv_LowerBorder) - hv_XAxisOffsetPx,
                            hv_LeftBorder, (hv_Height - hv_LowerBorder) - hv_XAxisOffsetPx, hv_Width - hv_RightBorder,
                            0, 0);
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_XArrow, HDevWindowStack.GetActive());
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_YArrow.Dispose();
                        gen_arrow_contour_xld(out ho_YArrow, hv_Height - hv_LowerBorder, hv_LeftBorder + hv_YAxisOffsetPx,
                            hv_UpperBorder, hv_LeftBorder + hv_YAxisOffsetPx, 0, 0);
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispObj(ho_YArrow, HDevWindowStack.GetActive());
                    }
                    //Display labels.
                    hv_Ascent.Dispose(); hv_Descent.Dispose(); hv_TextWidthXLabel.Dispose(); hv_TextHeightXLabel.Dispose();
                    HOperatorSet.GetStringExtents(hv_WindowHandle, hv_XLabel, out hv_Ascent,
                        out hv_Descent, out hv_TextWidthXLabel, out hv_TextHeightXLabel);
                    hv_Ascent.Dispose(); hv_Descent.Dispose(); hv_TextWidthYLabel.Dispose(); hv_TextHeightYLabel.Dispose();
                    HOperatorSet.GetStringExtents(hv_WindowHandle, hv_YLabel, out hv_Ascent,
                        out hv_Descent, out hv_TextWidthYLabel, out hv_TextHeightYLabel);
                    if ((int)(new HTuple(hv_YTickDirection.TupleEqual("right"))) != 0)
                    {
                        if ((int)(new HTuple(hv_XTickDirection.TupleEqual("up"))) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XLabel, "image",
                                        ((hv_Height - hv_LowerBorder) - hv_TextHeightXLabel) - 3, ((hv_Width - hv_RightBorder) - hv_TextWidthXLabel) - 3,
                                        hv_AxesColor, "box", "false");
                                }
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), " " + hv_YLabel, "image",
                                        hv_UpperBorder, (hv_LeftBorder + 3) + hv_YAxisOffsetPx, hv_AxesColor,
                                        "box", "false");
                                }
                            }
                        }
                        else
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XLabel, "image",
                                        ((hv_Height - hv_LowerBorder) + 3) - hv_XAxisOffsetPx, ((hv_Width - hv_RightBorder) - hv_TextWidthXLabel) - 3,
                                        hv_AxesColor, "box", "false");
                                }
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), " " + hv_YLabel, "image",
                                        ((hv_Height - hv_LowerBorder) - hv_TextHeightXLabel) - 3, (hv_LeftBorder + 3) + hv_YAxisOffsetPx,
                                        hv_AxesColor, "box", "false");
                                }
                            }
                        }
                    }
                    else
                    {
                        if ((int)(new HTuple(hv_XTickDirection.TupleEqual("up"))) != 0)
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XLabel, "image",
                                        ((hv_Height - hv_LowerBorder) - (2 * hv_TextHeightXLabel)) + 3, hv_LeftBorder - 3,
                                        hv_AxesColor, "box", "false");
                                }
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), " " + hv_YLabel, "image",
                                        hv_UpperBorder, ((hv_Width - hv_RightBorder) - hv_TextWidthYLabel) - 13,
                                        hv_AxesColor, "box", "false");
                                }
                            }
                        }
                        else
                        {
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XLabel, "image",
                                        ((hv_Height - hv_LowerBorder) + 3) - hv_XAxisOffsetPx, hv_LeftBorder - 3,
                                        hv_AxesColor, "box", "false");
                                }
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.DispText(HDevWindowStack.GetActive(), " " + hv_YLabel, "image",
                                        ((hv_Height - hv_LowerBorder) - hv_TextHeightXLabel) - 3, ((hv_Width - hv_RightBorder) - (2 * hv_TextWidthYLabel)) - 3,
                                        hv_AxesColor, "box", "false");
                                }
                            }
                        }
                    }
                }
                //
                //Display ticks.
                //
                if ((int)(new HTuple(hv_AxesColor.TupleNotEqual("none"))) != 0)
                {
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_AxesColor);
                    }
                    if ((int)(new HTuple(hv_XTicks.TupleNotEqual("none"))) != 0)
                    {
                        //
                        //Display x ticks.
                        if ((int)(hv_XValuesAreStrings) != 0)
                        {
                            //Display string XValues as categories.
                            hv_XTicks.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_XTicks = (new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()
                                    )) / (new HTuple(hv_XTickValues.TupleLength()));
                            }
                            hv_XCoord.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_XCoord = (hv_XValues_COPY_INP_TMP - hv_XAxisStartValue) * hv_XScaleFactor;
                            }
                        }
                        else
                        {
                            //Display tick values.
                            if ((int)(new HTuple(hv_XTicks.TupleEqual("min_max_origin"))) != 0)
                            {
                                //Calculate 'min_max_origin' tick coordinates.
                                if ((int)(new HTuple(hv_YAxisPosition.TupleEqual(hv_XAxisStartValue))) != 0)
                                {
                                    hv_XTickValues.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_XTickValues = new HTuple();
                                        hv_XTickValues = hv_XTickValues.TupleConcat(hv_XAxisStartValue, hv_XAxisEndValue);
                                    }
                                }
                                else
                                {
                                    hv_XTickValues.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_XTickValues = new HTuple();
                                        hv_XTickValues = hv_XTickValues.TupleConcat(hv_XAxisStartValue, hv_YAxisPosition, hv_XAxisEndValue);
                                    }
                                }
                            }
                            else
                            {
                                //Calculate equidistant tick coordinates.
                                hv_XTickStart.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_XTickStart = (((hv_XAxisStartValue / hv_XTicks)).TupleCeil()
                                        ) * hv_XTicks;
                                }
                                hv_XTickValues.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_XTickValues = HTuple.TupleGenSequence(
                                        hv_XTickStart, hv_XAxisEndValue, hv_XTicks);
                                }
                            }
                            //Remove ticks that are smaller than the x-axis start.
                            hv_Indices.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Indices = ((hv_XTickValues.TupleLessElem(
                                    hv_XAxisStartValue))).TupleFind(1);
                            }
                            hv_XCoord.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_XCoord = (hv_XTickValues - hv_XAxisStartValue) * hv_XScaleFactor;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_XCoord = hv_XCoord.TupleRemove(
                                        hv_Indices);
                                    hv_XCoord.Dispose();
                                    hv_XCoord = ExpTmpLocalVar_XCoord;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_XTickValues = hv_XTickValues.TupleRemove(
                                        hv_Indices);
                                    hv_XTickValues.Dispose();
                                    hv_XTickValues = ExpTmpLocalVar_XTickValues;
                                }
                            }
                            //
                            if ((int)(new HTuple(hv_FormatX.TupleEqual("default"))) != 0)
                            {
                                hv_TypeTicks.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_TypeTicks = hv_XTicks.TupleType()
                                        ;
                                }
                                if ((int)(new HTuple(hv_TypeTicks.TupleEqual(4))) != 0)
                                {
                                    //String ('min_max_origin').
                                    //Format depends on actual values.
                                    hv_TypeTicks.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_TypeTicks = hv_XTickValues.TupleType()
                                            ;
                                    }
                                }
                                if ((int)(new HTuple(hv_TypeTicks.TupleEqual(1))) != 0)
                                {
                                    //Round to integer.
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_XTickValues = hv_XTickValues.TupleInt()
                                                ;
                                            hv_XTickValues.Dispose();
                                            hv_XTickValues = ExpTmpLocalVar_XTickValues;
                                        }
                                    }
                                }
                                else
                                {
                                    //Use floating point numbers.
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_XTickValues = hv_XTickValues.TupleString(
                                                ".2f");
                                            hv_XTickValues.Dispose();
                                            hv_XTickValues = ExpTmpLocalVar_XTickValues;
                                        }
                                    }
                                }
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_XTickValues = hv_XTickValues.TupleString(
                                            hv_FormatX);
                                        hv_XTickValues.Dispose();
                                        hv_XTickValues = ExpTmpLocalVar_XTickValues;
                                    }
                                }
                            }
                        }
                        //Generate and display ticks.
                        for (hv_IndexTicks = 0; (int)hv_IndexTicks <= (int)((new HTuple(hv_XTickValues.TupleLength()
                            )) - 1); hv_IndexTicks = (int)hv_IndexTicks + 1)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Ascent1.Dispose(); hv_Descent1.Dispose(); hv_TextWidthXTicks.Dispose(); hv_TextHeightXTicks.Dispose();
                                HOperatorSet.GetStringExtents(hv_WindowHandle, hv_XTickValues.TupleSelect(
                                    hv_IndexTicks), out hv_Ascent1, out hv_Descent1, out hv_TextWidthXTicks,
                                    out hv_TextHeightXTicks);
                            }
                            if ((int)(new HTuple(hv_XTickDirection.TupleEqual("up"))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_ContourXTick.Dispose();
                                    HOperatorSet.GenContourPolygonXld(out ho_ContourXTick, (((hv_Height - hv_LowerBorder) - hv_XAxisOffsetPx)).TupleConcat(
                                        ((hv_Height - hv_LowerBorder) - hv_XAxisOffsetPx) - 5), ((hv_LeftBorder + (hv_XCoord.TupleSelect(
                                        hv_IndexTicks)))).TupleConcat(hv_LeftBorder + (hv_XCoord.TupleSelect(
                                        hv_IndexTicks))));
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XTickValues.TupleSelect(
                                            hv_IndexTicks), "image", ((hv_Height - hv_LowerBorder) + 2) - hv_XAxisOffsetPx,
                                            (hv_LeftBorder + (hv_XCoord.TupleSelect(hv_IndexTicks))) - (0.5 * hv_TextWidthXTicks),
                                            hv_AxesColor, "box", "false");
                                    }
                                }
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_ContourXTick.Dispose();
                                    HOperatorSet.GenContourPolygonXld(out ho_ContourXTick, ((((hv_Height - hv_LowerBorder) - hv_XAxisOffsetPx) + 5)).TupleConcat(
                                        (hv_Height - hv_LowerBorder) - hv_XAxisOffsetPx), ((hv_LeftBorder + (hv_XCoord.TupleSelect(
                                        hv_IndexTicks)))).TupleConcat(hv_LeftBorder + (hv_XCoord.TupleSelect(
                                        hv_IndexTicks))));
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_XTickValues.TupleSelect(
                                            hv_IndexTicks), "image", ((hv_Height - hv_LowerBorder) - (2 * hv_TextHeightXTicks)) - hv_XAxisOffsetPx,
                                            (hv_LeftBorder + (hv_XCoord.TupleSelect(hv_IndexTicks))) - (0.5 * hv_TextWidthXTicks),
                                            hv_AxesColor, "box", "false");
                                    }
                                }
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_ContourXTick, HDevWindowStack.GetActive());
                            }
                        }
                    }
                    //
                    if ((int)(new HTuple(hv_YTicks.TupleNotEqual("none"))) != 0)
                    {
                        //
                        //Display y ticks.

                        if ((int)(new HTuple(hv_YTicks.TupleEqual("min_max_origin"))) != 0)
                        {
                            //Calculate 'min_max_origin' tick coordinates.
                            if ((int)(new HTuple(hv_XAxisPosition.TupleEqual(hv_YAxisStartValue))) != 0)
                            {
                                hv_YTickValues.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_YTickValues = new HTuple();
                                    hv_YTickValues = hv_YTickValues.TupleConcat(hv_YAxisStartValue, hv_YAxisEndValue);
                                }
                            }
                            else
                            {
                                hv_YTickValues.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_YTickValues = new HTuple();
                                    hv_YTickValues = hv_YTickValues.TupleConcat(hv_YAxisStartValue, hv_XAxisPosition, hv_YAxisEndValue);
                                }
                            }
                        }
                        else
                        {
                            //Calculate equidistant tick coordinates.
                            hv_YTickStart.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_YTickStart = (((hv_YAxisStartValue / hv_YTicks)).TupleCeil()
                                    ) * hv_YTicks;
                            }
                            hv_YTickValues.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_YTickValues = HTuple.TupleGenSequence(
                                    hv_YTickStart, hv_YAxisEndValue, hv_YTicks);
                            }
                        }

                        //Remove ticks that are smaller than the y-axis start.
                        hv_Indices.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Indices = ((hv_YTickValues.TupleLessElem(
                                hv_YAxisStartValue))).TupleFind(1);
                        }
                        hv_YCoord.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_YCoord = (hv_YTickValues - hv_YAxisStartValue) * hv_YScaleFactor;
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_YCoord = hv_YCoord.TupleRemove(
                                    hv_Indices);
                                hv_YCoord.Dispose();
                                hv_YCoord = ExpTmpLocalVar_YCoord;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_YTickValues = hv_YTickValues.TupleRemove(
                                    hv_Indices);
                                hv_YTickValues.Dispose();
                                hv_YTickValues = ExpTmpLocalVar_YTickValues;
                            }
                        }
                        //
                        if ((int)(hv_PlotYLog) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_YTickValues = (new HTuple(10)).TuplePow(
                                        hv_YTickValues);
                                    hv_YTickValues.Dispose();
                                    hv_YTickValues = ExpTmpLocalVar_YTickValues;
                                }
                            }
                        }
                        if ((int)(new HTuple(hv_FormatY.TupleEqual("default"))) != 0)
                        {
                            hv_TypeTicks.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_TypeTicks = hv_YTicks.TupleType()
                                    ;
                            }
                            if ((int)(new HTuple(hv_TypeTicks.TupleEqual(4))) != 0)
                            {
                                //String ('min_max_origin').
                                //Format depends on actual values.
                                hv_TypeTicks.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_TypeTicks = hv_YTickValues.TupleType()
                                        ;
                                }
                            }
                            if ((int)(new HTuple(hv_TypeTicks.TupleEqual(1))) != 0)
                            {
                                //Round to integer.
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_YTickValues = hv_YTickValues.TupleInt()
                                            ;
                                        hv_YTickValues.Dispose();
                                        hv_YTickValues = ExpTmpLocalVar_YTickValues;
                                    }
                                }
                            }
                            else
                            {
                                //Use floating point numbers.
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_YTickValues = hv_YTickValues.TupleString(
                                            ".2f");
                                        hv_YTickValues.Dispose();
                                        hv_YTickValues = ExpTmpLocalVar_YTickValues;
                                    }
                                }
                            }
                        }
                        else
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_YTickValues = hv_YTickValues.TupleString(
                                        hv_FormatY);
                                    hv_YTickValues.Dispose();
                                    hv_YTickValues = ExpTmpLocalVar_YTickValues;
                                }
                            }
                        }
                        //Generate and display ticks.
                        for (hv_IndexTicks = 0; (int)hv_IndexTicks <= (int)((new HTuple(hv_YTickValues.TupleLength()
                            )) - 1); hv_IndexTicks = (int)hv_IndexTicks + 1)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Ascent1.Dispose(); hv_Descent1.Dispose(); hv_TextWidthYTicks.Dispose(); hv_TextHeightYTicks.Dispose();
                                HOperatorSet.GetStringExtents(hv_WindowHandle, hv_YTickValues.TupleSelect(
                                    hv_IndexTicks), out hv_Ascent1, out hv_Descent1, out hv_TextWidthYTicks,
                                    out hv_TextHeightYTicks);
                            }
                            //Since we only deal with numbers, use the Ascent as text height.
                            hv_TextHeightYTicks.Dispose();
                            hv_TextHeightYTicks = new HTuple(hv_Ascent);
                            if ((int)(new HTuple(hv_YTickDirection.TupleEqual("right"))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_ContourYTick.Dispose();
                                    HOperatorSet.GenContourPolygonXld(out ho_ContourYTick, (((hv_Height - hv_LowerBorder) - (hv_YCoord.TupleSelect(
                                        hv_IndexTicks)))).TupleConcat((hv_Height - hv_LowerBorder) - (hv_YCoord.TupleSelect(
                                        hv_IndexTicks))), ((hv_LeftBorder + hv_YAxisOffsetPx)).TupleConcat(
                                        (hv_LeftBorder + hv_YAxisOffsetPx) + 5));
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_YTickValues.TupleSelect(
                                            hv_IndexTicks), "image", (((hv_Height - hv_LowerBorder) - hv_TextHeightYTicks) + 3) - (hv_YCoord.TupleSelect(
                                            hv_IndexTicks)), ((hv_LeftBorder - hv_TextWidthYTicks) - 4) + hv_YAxisOffsetPx,
                                            hv_Color, "box", "false");
                                    }
                                }
                            }
                            else
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_ContourYTick.Dispose();
                                    HOperatorSet.GenContourPolygonXld(out ho_ContourYTick, (((hv_Height - hv_LowerBorder) - (hv_YCoord.TupleSelect(
                                        hv_IndexTicks)))).TupleConcat((hv_Height - hv_LowerBorder) - (hv_YCoord.TupleSelect(
                                        hv_IndexTicks))), (((hv_LeftBorder + hv_YAxisOffsetPx) - 5)).TupleConcat(
                                        hv_LeftBorder + hv_YAxisOffsetPx));
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_YTickValues.TupleSelect(
                                            hv_IndexTicks), "image", (((hv_Height - hv_LowerBorder) - hv_TextHeightYTicks) + 3) - (hv_YCoord.TupleSelect(
                                            hv_IndexTicks)), (hv_LeftBorder + 4) + hv_YAxisOffsetPx, hv_Color,
                                            "box", "false");
                                    }
                                }
                            }
                            if (HDevWindowStack.IsOpen())
                            {
                                HOperatorSet.DispObj(ho_ContourYTick, HDevWindowStack.GetActive());
                            }
                        }
                    }
                }
                //
                //Display function plot.
                //
                if ((int)(new HTuple(hv_Color.TupleNotEqual("none"))) != 0)
                {
                    if ((int)((new HTuple(hv_XValues_COPY_INP_TMP.TupleNotEqual(new HTuple()))).TupleAnd(
                        new HTuple(hv_YValues_COPY_INP_TMP.TupleNotEqual(new HTuple())))) != 0)
                    {
                        hv_Num.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Num = (new HTuple(hv_YValues_COPY_INP_TMP.TupleLength()
                                )) / (new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()));
                        }
                        //
                        //Iterate over all functions to be displayed.
                        HTuple end_val619 = hv_Num - 1;
                        HTuple step_val619 = 1;
                        for (hv_I = 0; hv_I.Continue(end_val619, step_val619); hv_I = hv_I.TupleAdd(step_val619))
                        {
                            //Select y values for current function.
                            hv_YSelected.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_YSelected = hv_YValues_COPY_INP_TMP.TupleSelectRange(
                                    hv_I * (new HTuple(hv_XValues_COPY_INP_TMP.TupleLength())), ((hv_I + 1) * (new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()
                                    ))) - 1);
                            }
                            //Set color
                            if ((int)(new HTuple(hv_Color.TupleEqual(new HTuple()))) != 0)
                            {
                                HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
                            }
                            else
                            {
                                if (HDevWindowStack.IsOpen())
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetColor(HDevWindowStack.GetActive(), hv_Color.TupleSelect(
                                            hv_I % (new HTuple(hv_Color.TupleLength()))));
                                    }
                                }
                            }
                            //
                            //Display in different styles.
                            //
                            if ((int)((new HTuple((new HTuple((new HTuple(hv_Style.TupleEqual("line"))).TupleOr(
                                new HTuple(hv_Style.TupleEqual(new HTuple()))))).TupleOr(hv_Style.TupleIsReal()
                                ))).TupleOr(hv_Style.TupleIsInt())) != 0)
                            {
                                //Style = Line. For real value, the line is plotted dashed.
                                if ((int)(((hv_Style.TupleIsReal())).TupleOr(hv_Style.TupleIsInt())) != 0)
                                {
                                    hv_StyleOriginal.Dispose();
                                    HOperatorSet.GetLineStyle(hv_WindowHandle, out hv_StyleOriginal);
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetLineStyle(hv_WindowHandle, hv_Style.TupleConcat(hv_Style / 2.0));
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_Contour.Dispose();
                                    HOperatorSet.GenContourPolygonXld(out ho_Contour, ((hv_Height - hv_LowerBorder) - (hv_YSelected * hv_YScaleFactor)) + (hv_YAxisStartValue * hv_YScaleFactor),
                                        ((hv_XValues_COPY_INP_TMP * hv_XScaleFactor) + hv_LeftBorder) - (hv_XAxisStartValue * hv_XScaleFactor));
                                }
                                //Clip, if necessary.
                                if ((int)(new HTuple(hv_Clip.TupleEqual("yes"))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ClipContoursXld(ho_Contour, out ExpTmpOutVar_0, hv_UpperBorder,
                                            hv_LeftBorder, hv_Height - hv_LowerBorder, hv_Width - hv_RightBorder);
                                        ho_Contour.Dispose();
                                        ho_Contour = ExpTmpOutVar_0;
                                    }
                                }
                                hv_OldLineWidth.Dispose();
                                HOperatorSet.GetLineWidth(hv_WindowHandle, out hv_OldLineWidth);
                                if (HDevWindowStack.IsOpen())
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_LineWidth.TupleInt()
                                            );
                                    }
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    HOperatorSet.DispObj(ho_Contour, HDevWindowStack.GetActive());
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HOperatorSet.SetLineWidth(HDevWindowStack.GetActive(), hv_OldLineWidth.TupleInt()
                                            );
                                    }
                                }
                                if ((int)(((hv_Style.TupleIsReal())).TupleOr(hv_Style.TupleIsInt())) != 0)
                                {
                                    HOperatorSet.SetLineStyle(hv_WindowHandle, hv_StyleOriginal);
                                }
                            }
                            else if ((int)(new HTuple(hv_Style.TupleEqual("cross"))) != 0)
                            {
                                //Style = Cross.
                                hv_LineWidth.Dispose();
                                HOperatorSet.GetLineWidth(hv_WindowHandle, out hv_LineWidth);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_Cross.Dispose();
                                    HOperatorSet.GenCrossContourXld(out ho_Cross, ((hv_Height - hv_LowerBorder) - (hv_YSelected * hv_YScaleFactor)) + (hv_YAxisStartValue * hv_YScaleFactor),
                                        ((hv_XValues_COPY_INP_TMP * hv_XScaleFactor) + hv_LeftBorder) - (hv_XAxisStartValue * hv_XScaleFactor),
                                        6, 0.785398);
                                }
                                //Clip, if necessary.
                                if ((int)(new HTuple(hv_Clip.TupleEqual("yes"))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ClipContoursXld(ho_Cross, out ExpTmpOutVar_0, hv_UpperBorder,
                                            hv_LeftBorder, hv_Height - hv_LowerBorder, hv_Width - hv_RightBorder);
                                        ho_Cross.Dispose();
                                        ho_Cross = ExpTmpOutVar_0;
                                    }
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    HOperatorSet.DispObj(ho_Cross, HDevWindowStack.GetActive());
                                }
                            }
                            else if ((int)(new HTuple(hv_Style.TupleEqual("circle"))) != 0)
                            {
                                //Style = Circle.
                                hv_LineWidth.Dispose();
                                HOperatorSet.GetLineWidth(hv_WindowHandle, out hv_LineWidth);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Radii.Dispose();
                                    HOperatorSet.TupleGenConst(new HTuple(hv_YSelected.TupleLength()),
                                        3 * hv_LineWidth, out hv_Radii);
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_Circle.Dispose();
                                    HOperatorSet.GenCircleContourXld(out ho_Circle, ((hv_Height - hv_LowerBorder) - (hv_YSelected * hv_YScaleFactor)) + (hv_YAxisStartValue * hv_YScaleFactor),
                                        ((hv_XValues_COPY_INP_TMP * hv_XScaleFactor) + hv_LeftBorder) - (hv_XAxisStartValue * hv_XScaleFactor),
                                        hv_Radii, 0, 6.28318, "positive", 1);
                                }
                                //Clip, if necessary.
                                if ((int)(new HTuple(hv_Clip.TupleEqual("yes"))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ClipContoursXld(ho_Circle, out ExpTmpOutVar_0, hv_UpperBorder,
                                            hv_LeftBorder, hv_Height - hv_LowerBorder, hv_Width - hv_RightBorder);
                                        ho_Circle.Dispose();
                                        ho_Circle = ExpTmpOutVar_0;
                                    }
                                }
                                hv_OldContourStyle.Dispose();
                                HOperatorSet.GetContourStyle(hv_WindowHandle, out hv_OldContourStyle);
                                HOperatorSet.SetContourStyle(hv_WindowHandle, "stroke_and_fill");
                                if (HDevWindowStack.IsOpen())
                                {
                                    HOperatorSet.DispObj(ho_Circle, HDevWindowStack.GetActive());
                                }
                                HOperatorSet.SetContourStyle(hv_WindowHandle, hv_OldContourStyle);
                            }
                            else if ((int)(new HTuple(hv_Style.TupleEqual("filled"))) != 0)
                            {
                                //Style = Filled.
                                hv_Y1Selected.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Y1Selected = new HTuple();
                                    hv_Y1Selected = hv_Y1Selected.TupleConcat(0 + hv_XAxisPosition);
                                    hv_Y1Selected = hv_Y1Selected.TupleConcat(hv_YSelected);
                                    hv_Y1Selected = hv_Y1Selected.TupleConcat(0 + hv_XAxisPosition);
                                }
                                hv_X1Selected.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_X1Selected = new HTuple();
                                    hv_X1Selected = hv_X1Selected.TupleConcat(hv_XValues_COPY_INP_TMP.TupleMin()
                                        );
                                    hv_X1Selected = hv_X1Selected.TupleConcat(hv_XValues_COPY_INP_TMP);
                                    hv_X1Selected = hv_X1Selected.TupleConcat(hv_XValues_COPY_INP_TMP.TupleMax()
                                        );
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_Filled.Dispose();
                                    HOperatorSet.GenRegionPolygonFilled(out ho_Filled, ((hv_Height - hv_LowerBorder) - (hv_Y1Selected * hv_YScaleFactor)) + (hv_YAxisStartValue * hv_YScaleFactor),
                                        ((hv_X1Selected * hv_XScaleFactor) + hv_LeftBorder) - (hv_XAxisStartValue * hv_XScaleFactor));
                                }
                                //Clip, if necessary.
                                if ((int)(new HTuple(hv_Clip.TupleEqual("yes"))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ClipRegion(ho_Filled, out ExpTmpOutVar_0, hv_UpperBorder,
                                            hv_LeftBorder, hv_Height - hv_LowerBorder, hv_Width - hv_RightBorder);
                                        ho_Filled.Dispose();
                                        ho_Filled = ExpTmpOutVar_0;
                                    }
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    HOperatorSet.DispObj(ho_Filled, HDevWindowStack.GetActive());
                                }
                            }
                            else if ((int)(new HTuple(hv_Style.TupleEqual("step"))) != 0)
                            {
                                ho_Stair.Dispose();
                                HOperatorSet.GenEmptyObj(out ho_Stair);
                                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_XValues_COPY_INP_TMP.TupleLength()
                                    )) - 2); hv_Index = (int)hv_Index + 1)
                                {
                                    hv_Row1.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Row1 = ((hv_Height - hv_LowerBorder) - ((hv_YSelected.TupleSelect(
                                            hv_Index)) * hv_YScaleFactor)) + (hv_YAxisStartValue * hv_YScaleFactor);
                                    }
                                    hv_Row2.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Row2 = ((hv_Height - hv_LowerBorder) - ((hv_YSelected.TupleSelect(
                                            hv_Index + 1)) * hv_YScaleFactor)) + (hv_YAxisStartValue * hv_YScaleFactor);
                                    }
                                    hv_Col1.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Col1 = (((hv_XValues_COPY_INP_TMP.TupleSelect(
                                            hv_Index)) * hv_XScaleFactor) + hv_LeftBorder) - (hv_XAxisStartValue * hv_XScaleFactor);
                                    }
                                    hv_Col2.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_Col2 = (((hv_XValues_COPY_INP_TMP.TupleSelect(
                                            hv_Index + 1)) * hv_XScaleFactor) + hv_LeftBorder) - (hv_XAxisStartValue * hv_XScaleFactor);
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        ho_StairTmp.Dispose();
                                        HOperatorSet.GenContourPolygonXld(out ho_StairTmp, ((hv_Row1.TupleConcat(
                                            hv_Row1))).TupleConcat(hv_Row2), ((hv_Col1.TupleConcat(hv_Col2))).TupleConcat(
                                            hv_Col2));
                                    }
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ConcatObj(ho_Stair, ho_StairTmp, out ExpTmpOutVar_0);
                                        ho_Stair.Dispose();
                                        ho_Stair = ExpTmpOutVar_0;
                                    }
                                }
                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.UnionAdjacentContoursXld(ho_Stair, out ExpTmpOutVar_0,
                                        0.1, 0.1, "attr_keep");
                                    ho_Stair.Dispose();
                                    ho_Stair = ExpTmpOutVar_0;
                                }
                                if ((int)(new HTuple(hv_Clip.TupleEqual("yes"))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ClipRegion(ho_Stair, out ExpTmpOutVar_0, hv_UpperBorder,
                                            hv_LeftBorder, hv_Height - hv_LowerBorder, hv_Width - hv_RightBorder);
                                        ho_Stair.Dispose();
                                        ho_Stair = ExpTmpOutVar_0;
                                    }
                                }
                                if (HDevWindowStack.IsOpen())
                                {
                                    HOperatorSet.DispObj(ho_Stair, HDevWindowStack.GetActive());
                                }
                            }
                            else
                            {
                                throw new HalconException("Unsupported style: " + hv_Style);
                            }
                        }
                    }
                }
                //
                //
                HOperatorSet.SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.SetDraw(HDevWindowStack.GetActive(), hv_DrawMode);
                }
                HOperatorSet.SetLineStyle(hv_WindowHandle, hv_OriginStyle);
                HOperatorSet.SetSystem("clip_region", hv_ClipRegion);
                ho_ContourXGrid.Dispose();
                ho_ContourYGrid.Dispose();
                ho_XArrow.Dispose();
                ho_YArrow.Dispose();
                ho_ContourXTick.Dispose();
                ho_ContourYTick.Dispose();
                ho_Contour.Dispose();
                ho_Cross.Dispose();
                ho_Circle.Dispose();
                ho_Filled.Dispose();
                ho_Stair.Dispose();
                ho_StairTmp.Dispose();

                hv_XValues_COPY_INP_TMP.Dispose();
                hv_YValues_COPY_INP_TMP.Dispose();
                hv_ClipRegion.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_PartRow1.Dispose();
                hv_PartColumn1.Dispose();
                hv_PartRow2.Dispose();
                hv_PartColumn2.Dispose();
                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();
                hv_DrawMode.Dispose();
                hv_OriginStyle.Dispose();
                hv_PartDiffers.Dispose();
                hv_PlotYLog.Dispose();
                hv_YLogIndices.Dispose();
                hv_PlotYLogUser.Dispose();
                hv_IsString.Dispose();
                hv_YInd.Dispose();
                hv_Indices1.Dispose();
                hv_XAxisEndValue.Dispose();
                hv_YAxisEndValue.Dispose();
                hv_XAxisStartValue.Dispose();
                hv_YAxisStartValue.Dispose();
                hv_XValuesAreStrings.Dispose();
                hv_XTickValues.Dispose();
                hv_XTicks.Dispose();
                hv_YAxisPosition.Dispose();
                hv_XAxisPosition.Dispose();
                hv_LeftBorder.Dispose();
                hv_RightBorder.Dispose();
                hv_UpperBorder.Dispose();
                hv_LowerBorder.Dispose();
                hv_AxesColor.Dispose();
                hv_Style.Dispose();
                hv_Clip.Dispose();
                hv_YTicks.Dispose();
                hv_XGrid.Dispose();
                hv_YGrid.Dispose();
                hv_GridColor.Dispose();
                hv_YPosition.Dispose();
                hv_FormatX.Dispose();
                hv_FormatY.Dispose();
                hv_LineWidth.Dispose();
                hv_NumGenParamNames.Dispose();
                hv_NumGenParamValues.Dispose();
                hv_GenParamIndex.Dispose();
                hv_XGridTicks.Dispose();
                hv_YTickDirection.Dispose();
                hv_XTickDirection.Dispose();
                hv_XAxisWidthPx.Dispose();
                hv_XAxisWidth.Dispose();
                hv_XScaleFactor.Dispose();
                hv_YAxisHeightPx.Dispose();
                hv_YAxisHeight.Dispose();
                hv_YScaleFactor.Dispose();
                hv_YAxisOffsetPx.Dispose();
                hv_XAxisOffsetPx.Dispose();
                hv_DotStyle.Dispose();
                hv_XGridValues.Dispose();
                hv_XGridStart.Dispose();
                hv_XCoord.Dispose();
                hv_IndexGrid.Dispose();
                hv_YGridValues.Dispose();
                hv_YGridStart.Dispose();
                hv_YCoord.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_TextWidthXLabel.Dispose();
                hv_TextHeightXLabel.Dispose();
                hv_TextWidthYLabel.Dispose();
                hv_TextHeightYLabel.Dispose();
                hv_XTickStart.Dispose();
                hv_Indices.Dispose();
                hv_TypeTicks.Dispose();
                hv_IndexTicks.Dispose();
                hv_Ascent1.Dispose();
                hv_Descent1.Dispose();
                hv_TextWidthXTicks.Dispose();
                hv_TextHeightXTicks.Dispose();
                hv_YTickValues.Dispose();
                hv_YTickStart.Dispose();
                hv_TextWidthYTicks.Dispose();
                hv_TextHeightYTicks.Dispose();
                hv_Num.Dispose();
                hv_I.Dispose();
                hv_YSelected.Dispose();
                hv_StyleOriginal.Dispose();
                hv_OldLineWidth.Dispose();
                hv_Radii.Dispose();
                hv_OldContourStyle.Dispose();
                hv_Y1Selected.Dispose();
                hv_X1Selected.Dispose();
                hv_Index.Dispose();
                hv_Row1.Dispose();
                hv_Row2.Dispose();
                hv_Col1.Dispose();
                hv_Col2.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_ContourXGrid.Dispose();
                ho_ContourYGrid.Dispose();
                ho_XArrow.Dispose();
                ho_YArrow.Dispose();
                ho_ContourXTick.Dispose();
                ho_ContourYTick.Dispose();
                ho_Contour.Dispose();
                ho_Cross.Dispose();
                ho_Circle.Dispose();
                ho_Filled.Dispose();
                ho_Stair.Dispose();
                ho_StairTmp.Dispose();

                hv_XValues_COPY_INP_TMP.Dispose();
                hv_YValues_COPY_INP_TMP.Dispose();
                hv_ClipRegion.Dispose();
                hv_Row.Dispose();
                hv_Column.Dispose();
                hv_Width.Dispose();
                hv_Height.Dispose();
                hv_PartRow1.Dispose();
                hv_PartColumn1.Dispose();
                hv_PartRow2.Dispose();
                hv_PartColumn2.Dispose();
                hv_Red.Dispose();
                hv_Green.Dispose();
                hv_Blue.Dispose();
                hv_DrawMode.Dispose();
                hv_OriginStyle.Dispose();
                hv_PartDiffers.Dispose();
                hv_PlotYLog.Dispose();
                hv_YLogIndices.Dispose();
                hv_PlotYLogUser.Dispose();
                hv_IsString.Dispose();
                hv_YInd.Dispose();
                hv_Indices1.Dispose();
                hv_XAxisEndValue.Dispose();
                hv_YAxisEndValue.Dispose();
                hv_XAxisStartValue.Dispose();
                hv_YAxisStartValue.Dispose();
                hv_XValuesAreStrings.Dispose();
                hv_XTickValues.Dispose();
                hv_XTicks.Dispose();
                hv_YAxisPosition.Dispose();
                hv_XAxisPosition.Dispose();
                hv_LeftBorder.Dispose();
                hv_RightBorder.Dispose();
                hv_UpperBorder.Dispose();
                hv_LowerBorder.Dispose();
                hv_AxesColor.Dispose();
                hv_Style.Dispose();
                hv_Clip.Dispose();
                hv_YTicks.Dispose();
                hv_XGrid.Dispose();
                hv_YGrid.Dispose();
                hv_GridColor.Dispose();
                hv_YPosition.Dispose();
                hv_FormatX.Dispose();
                hv_FormatY.Dispose();
                hv_LineWidth.Dispose();
                hv_NumGenParamNames.Dispose();
                hv_NumGenParamValues.Dispose();
                hv_GenParamIndex.Dispose();
                hv_XGridTicks.Dispose();
                hv_YTickDirection.Dispose();
                hv_XTickDirection.Dispose();
                hv_XAxisWidthPx.Dispose();
                hv_XAxisWidth.Dispose();
                hv_XScaleFactor.Dispose();
                hv_YAxisHeightPx.Dispose();
                hv_YAxisHeight.Dispose();
                hv_YScaleFactor.Dispose();
                hv_YAxisOffsetPx.Dispose();
                hv_XAxisOffsetPx.Dispose();
                hv_DotStyle.Dispose();
                hv_XGridValues.Dispose();
                hv_XGridStart.Dispose();
                hv_XCoord.Dispose();
                hv_IndexGrid.Dispose();
                hv_YGridValues.Dispose();
                hv_YGridStart.Dispose();
                hv_YCoord.Dispose();
                hv_Ascent.Dispose();
                hv_Descent.Dispose();
                hv_TextWidthXLabel.Dispose();
                hv_TextHeightXLabel.Dispose();
                hv_TextWidthYLabel.Dispose();
                hv_TextHeightYLabel.Dispose();
                hv_XTickStart.Dispose();
                hv_Indices.Dispose();
                hv_TypeTicks.Dispose();
                hv_IndexTicks.Dispose();
                hv_Ascent1.Dispose();
                hv_Descent1.Dispose();
                hv_TextWidthXTicks.Dispose();
                hv_TextHeightXTicks.Dispose();
                hv_YTickValues.Dispose();
                hv_YTickStart.Dispose();
                hv_TextWidthYTicks.Dispose();
                hv_TextHeightYTicks.Dispose();
                hv_Num.Dispose();
                hv_I.Dispose();
                hv_YSelected.Dispose();
                hv_StyleOriginal.Dispose();
                hv_OldLineWidth.Dispose();
                hv_Radii.Dispose();
                hv_OldContourStyle.Dispose();
                hv_Y1Selected.Dispose();
                hv_X1Selected.Dispose();
                hv_Index.Dispose();
                hv_Row1.Dispose();
                hv_Row2.Dispose();
                hv_Col1.Dispose();
                hv_Col2.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Tuple / Conversion
        // Short Description: Prints a tuple of values to a string. 
        private void pretty_print_tuple(HTuple hv_Tuple, out HTuple hv_TupleStr)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_J = new HTuple();
            // Initialize local and output iconic variables 
            hv_TupleStr = new HTuple();
            try
            {
                //
                //This procedure prints a tuple of values to a string.
                //
                if ((int)(new HTuple((new HTuple(hv_Tuple.TupleLength())).TupleGreater(1))) != 0)
                {
                    hv_TupleStr.Dispose();
                    hv_TupleStr = "[";
                    for (hv_J = 0; (int)hv_J <= (int)((new HTuple(hv_Tuple.TupleLength())) - 1); hv_J = (int)hv_J + 1)
                    {
                        if ((int)(new HTuple(hv_J.TupleGreater(0))) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_TupleStr = hv_TupleStr + new HTuple(",");
                                    hv_TupleStr.Dispose();
                                    hv_TupleStr = ExpTmpLocalVar_TupleStr;
                                }
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_TupleStr = hv_TupleStr + (hv_Tuple.TupleSelect(
                                    hv_J));
                                hv_TupleStr.Dispose();
                                hv_TupleStr = ExpTmpLocalVar_TupleStr;
                            }
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_TupleStr = hv_TupleStr + "]";
                            hv_TupleStr.Dispose();
                            hv_TupleStr = ExpTmpLocalVar_TupleStr;
                        }
                    }
                }
                else
                {
                    hv_TupleStr.Dispose();
                    hv_TupleStr = new HTuple(hv_Tuple);
                }

                hv_J.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_J.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Read the dictionaries DLSamples from files. 
        public void read_dl_samples(HTuple hv_DLDataset, HTuple hv_SampleIndices, out HTuple hv_DLSampleBatch)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_DatasetSamples = new HTuple(), hv_MinIndex = new HTuple();
            HTuple hv_MaxIndex = new HTuple(), hv_KeyDirExists = new HTuple();
            HTuple hv_DictDir = new HTuple(), hv_DLSamplesProc = new HTuple();
            HTuple hv_ImageIndex = new HTuple(), hv_KeyFileExists = new HTuple();
            HTuple hv_ImageID = new HTuple(), hv_FileNameRelative = new HTuple();
            HTuple hv_FileNameSample = new HTuple(), hv_FileExists = new HTuple();
            HTuple hv_DictPath = new HTuple(), hv_DLSample = new HTuple();
            HTuple hv_Exception = new HTuple();
            // Initialize local and output iconic variables 
            hv_DLSampleBatch = new HTuple();
            try
            {
                //
                //This procedure reads a batch of DLSample dictionaries from disk.
                //The wanted samples are selected from a DLDataset by their indices.
                //The indices of the wanted samples are handed over in SampleIndices.
                //It returns the tuple of read-in dictionaries in DLSampleBatch.
                //
                //Sanity checks of inputs.
                //
                if ((int)(new HTuple((new HTuple(hv_SampleIndices.TupleLength())).TupleLessEqual(
                    0))) != 0)
                {
                    //Check the length of selected indices.
                    throw new HalconException(new HTuple("Invalid length of SelectedIndices: ") + (new HTuple(hv_SampleIndices.TupleLength()
                        )));
                }
                else
                {
                    //Get the samples from the DLDataset.
                    hv_DatasetSamples.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DatasetSamples);
                    //Get min and max value of given indices.
                    hv_MinIndex.Dispose();
                    HOperatorSet.TupleMin(hv_SampleIndices, out hv_MinIndex);
                    hv_MaxIndex.Dispose();
                    HOperatorSet.TupleMax(hv_SampleIndices, out hv_MaxIndex);
                    if ((int)((new HTuple(hv_MinIndex.TupleLess(0))).TupleOr(new HTuple(hv_MaxIndex.TupleGreater(
                        (new HTuple(hv_DatasetSamples.TupleLength())) - 1)))) != 0)
                    {
                        //Check the value range of the provided indices.
                        throw new HalconException("The given SampleIndices are not within the range of available samples in DLDataset.");
                    }
                }
                //
                //Check if the key dlsample_dir is given.
                hv_KeyDirExists.Dispose();
                HOperatorSet.GetDictParam(hv_DLDataset, "key_exists", "dlsample_dir", out hv_KeyDirExists);
                //
                if ((int)(hv_KeyDirExists) != 0)
                {
                    //
                    //Get the dlsample_dir.
                    hv_DictDir.Dispose();
                    HOperatorSet.GetDictTuple(hv_DLDataset, "dlsample_dir", out hv_DictDir);
                    //Get the samples to be processed.
                    hv_DLSamplesProc.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_DLSamplesProc = hv_DatasetSamples.TupleSelect(
                            hv_SampleIndices);
                    }
                    //
                    //Initialize DLSampleBatch tuple.
                    hv_DLSampleBatch.Dispose();
                    hv_DLSampleBatch = new HTuple();
                    //
                    //Read in all DLSamples into the batch.
                    for (hv_ImageIndex = 0; (int)hv_ImageIndex <= (int)((new HTuple(hv_SampleIndices.TupleLength()
                        )) - 1); hv_ImageIndex = (int)hv_ImageIndex + 1)
                    {
                        //Check if dlsample key exist.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_KeyFileExists.Dispose();
                            HOperatorSet.GetDictParam(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                                "key_exists", "dlsample_file_name", out hv_KeyFileExists);
                        }
                        //
                        if ((int)(hv_KeyFileExists.TupleNot()) != 0)
                        {
                            //
                            //If the key does not exist, check if a corresponding file exists.
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ImageID.Dispose();
                                HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                                    "image_id", out hv_ImageID);
                            }
                            hv_FileNameRelative.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_FileNameRelative = hv_ImageID + "_dlsample.hdict";
                            }
                            hv_FileNameSample.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_FileNameSample = (hv_DictDir + "/") + hv_FileNameRelative;
                            }
                            //
                            hv_FileExists.Dispose();
                            HOperatorSet.FileExists(hv_FileNameSample, out hv_FileExists);
                            if ((int)(hv_FileExists) != 0)
                            {
                                //If it exists, create corresponding key.
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                                        "dlsample_file_name", hv_FileNameRelative);
                                }
                            }
                            else
                            {
                                //If not, throw an error.
                                throw new HalconException("No 'dlsample_file_name' and hdict file available for image ID " + hv_ImageID);
                            }
                            //
                        }
                        //
                        //If dlsample dictionary is available for reading, read it.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_DictPath.Dispose();
                            HOperatorSet.GetDictTuple(hv_DLSamplesProc.TupleSelect(hv_ImageIndex),
                                "dlsample_file_name", out hv_DictPath);
                        }
                        try
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_DLSample.Dispose();
                                HOperatorSet.ReadDict((hv_DictDir + "/") + hv_DictPath, new HTuple(), new HTuple(),
                                    out hv_DLSample);
                            }
                        }
                        // catch (Exception) 
                        catch (HalconException HDevExpDefaultException1)
                        {
                            HDevExpDefaultException1.ToHTuple(out hv_Exception);
                            throw new HalconException((((("An error has occurred while reading " + hv_DictDir) + "/") + hv_DictPath) + new HTuple(" , HALCON error # ")) + (hv_Exception.TupleSelect(
                                0)));
                        }
                        //Add it to the DLSampleBatch.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_DLSampleBatch = hv_DLSampleBatch.TupleConcat(
                                    hv_DLSample);
                                hv_DLSampleBatch.Dispose();
                                hv_DLSampleBatch = ExpTmpLocalVar_DLSampleBatch;
                            }
                        }
                        //
                    }
                }
                else
                {
                    throw new HalconException("The dataset needs to include the key 'dlsample_dir' for reading a DLSample from file.");
                }


                hv_DatasetSamples.Dispose();
                hv_MinIndex.Dispose();
                hv_MaxIndex.Dispose();
                hv_KeyDirExists.Dispose();
                hv_DictDir.Dispose();
                hv_DLSamplesProc.Dispose();
                hv_ImageIndex.Dispose();
                hv_KeyFileExists.Dispose();
                hv_ImageID.Dispose();
                hv_FileNameRelative.Dispose();
                hv_FileNameSample.Dispose();
                hv_FileExists.Dispose();
                hv_DictPath.Dispose();
                hv_DLSample.Dispose();
                hv_Exception.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_DatasetSamples.Dispose();
                hv_MinIndex.Dispose();
                hv_MaxIndex.Dispose();
                hv_KeyDirExists.Dispose();
                hv_DictDir.Dispose();
                hv_DLSamplesProc.Dispose();
                hv_ImageIndex.Dispose();
                hv_KeyFileExists.Dispose();
                hv_ImageID.Dispose();
                hv_FileNameRelative.Dispose();
                hv_FileNameSample.Dispose();
                hv_FileExists.Dispose();
                hv_DictPath.Dispose();
                hv_DLSample.Dispose();
                hv_Exception.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Reduce the evaluation result to a single value. 
        private void reduce_dl_evaluation_result(HTuple hv_EvaluationResult, HTuple hv_EvaluationComparisonKeys,
            out HTuple hv_Value, out HTuple hv_ValidEvaluationKeys)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_KeysEvalResult = new HTuple();
            HTuple hv_NumMatches = new HTuple(), hv_FirstMaxNumDetections = new HTuple();
            HTuple hv_KeysFirstMaxNumDetections = new HTuple(), hv_DetectionResult = new HTuple();
            HTuple hv_Index = new HTuple(), hv_ClassificationResult = new HTuple();
            HTuple hv_KeysExist = new HTuple(), hv_Indices = new HTuple();
            HTuple hv_Values = new HTuple(), hv_K = new HTuple(), hv_Key = new HTuple();
            HTuple hv_Tuple = new HTuple();
            HTuple hv_EvaluationComparisonKeys_COPY_INP_TMP = new HTuple(hv_EvaluationComparisonKeys);
            HTuple hv_EvaluationResult_COPY_INP_TMP = new HTuple(hv_EvaluationResult);

            // Initialize local and output iconic variables 
            hv_Value = new HTuple();
            hv_ValidEvaluationKeys = new HTuple();
            try
            {
                //
                //In order to compare a model we need to reduce the evaluation parameter/result
                //to a single float Value which is comparable via >.
                //
                if ((int)((new HTuple((new HTuple(hv_EvaluationComparisonKeys_COPY_INP_TMP.TupleLength()
                    )).TupleGreater(0))).TupleAnd(new HTuple((new HTuple(hv_EvaluationResult_COPY_INP_TMP.TupleLength()
                    )).TupleGreater(0)))) != 0)
                {
                    //We need to check for a special case: detection results.
                    //They have a complex structure.
                    hv_KeysEvalResult.Dispose();
                    HOperatorSet.GetDictParam(hv_EvaluationResult_COPY_INP_TMP, "keys", new HTuple(),
                        out hv_KeysEvalResult);
                    hv_NumMatches.Dispose();
                    HOperatorSet.TupleRegexpTest(hv_KeysEvalResult, "max_num_detections_.*",
                        out hv_NumMatches);
                    if ((int)(new HTuple(hv_NumMatches.TupleGreater(0))) != 0)
                    {
                        //We use only the first results of every level.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_FirstMaxNumDetections.Dispose();
                            HOperatorSet.GetDictTuple(hv_EvaluationResult_COPY_INP_TMP, hv_KeysEvalResult.TupleSelect(
                                0), out hv_FirstMaxNumDetections);
                        }
                        hv_KeysFirstMaxNumDetections.Dispose();
                        HOperatorSet.GetDictParam(hv_FirstMaxNumDetections, "keys", new HTuple(),
                            out hv_KeysFirstMaxNumDetections);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_DetectionResult.Dispose();
                            HOperatorSet.GetDictTuple(hv_FirstMaxNumDetections, hv_KeysFirstMaxNumDetections.TupleSelect(
                                0), out hv_DetectionResult);
                        }
                        //We use this result here as the top level to retrieve values.
                        hv_EvaluationResult_COPY_INP_TMP.Dispose();
                        hv_EvaluationResult_COPY_INP_TMP = new HTuple(hv_DetectionResult);
                    }
                    //We need to check for a special case: classification results.
                    //They have a complex structure.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Index.Dispose();
                        HOperatorSet.TupleFind(hv_KeysEvalResult.TupleEqualElem("global"), 1, out hv_Index);
                    }
                    if ((int)(new HTuple(hv_Index.TupleNotEqual(-1))) != 0)
                    {
                        //We use the results for key 'global'.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ClassificationResult.Dispose();
                            HOperatorSet.GetDictTuple(hv_EvaluationResult_COPY_INP_TMP, hv_KeysEvalResult.TupleSelect(
                                hv_Index), out hv_ClassificationResult);
                        }
                        hv_EvaluationResult_COPY_INP_TMP.Dispose();
                        hv_EvaluationResult_COPY_INP_TMP = new HTuple(hv_ClassificationResult);
                    }
                    //Reduce comparison to keys that exist.
                    hv_KeysExist.Dispose();
                    HOperatorSet.GetDictParam(hv_EvaluationResult_COPY_INP_TMP, "key_exists",
                        hv_EvaluationComparisonKeys_COPY_INP_TMP, out hv_KeysExist);
                    //
                    hv_Indices.Dispose();
                    HOperatorSet.TupleFind(hv_KeysExist, 1, out hv_Indices);
                    if ((int)(new HTuple(hv_Indices.TupleEqual(-1))) != 0)
                    {
                        hv_EvaluationComparisonKeys_COPY_INP_TMP.Dispose();
                        hv_EvaluationComparisonKeys_COPY_INP_TMP = new HTuple();
                    }
                    else
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_EvaluationComparisonKeys = hv_EvaluationComparisonKeys_COPY_INP_TMP.TupleSelect(
                                    hv_Indices);
                                hv_EvaluationComparisonKeys_COPY_INP_TMP.Dispose();
                                hv_EvaluationComparisonKeys_COPY_INP_TMP = ExpTmpLocalVar_EvaluationComparisonKeys;
                            }
                        }
                    }
                }
                //
                hv_ValidEvaluationKeys.Dispose();
                hv_ValidEvaluationKeys = new HTuple(hv_EvaluationComparisonKeys_COPY_INP_TMP);
                //
                hv_Value.Dispose();
                hv_Value = 0.0;
                hv_Values.Dispose();
                hv_Values = new HTuple();
                if ((int)(new HTuple((new HTuple(hv_EvaluationResult_COPY_INP_TMP.TupleLength()
                    )).TupleGreater(0))) != 0)
                {
                    for (hv_K = 0; (int)hv_K <= (int)((new HTuple(hv_EvaluationComparisonKeys_COPY_INP_TMP.TupleLength()
                        )) - 1); hv_K = (int)hv_K + 1)
                    {
                        hv_Key.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Key = hv_EvaluationComparisonKeys_COPY_INP_TMP.TupleSelect(
                                hv_K);
                        }
                        //
                        hv_Tuple.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvaluationResult_COPY_INP_TMP, hv_Key, out hv_Tuple);
                        //Use the mean in order to reduce tuples with length > 1.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Values = hv_Values.TupleConcat(
                                    hv_Tuple.TupleMean());
                                hv_Values.Dispose();
                                hv_Values = ExpTmpLocalVar_Values;
                            }
                        }
                    }
                }
                else
                {
                    hv_Value.Dispose();
                    hv_Value = -1;
                }
                if ((int)(new HTuple((new HTuple(hv_Values.TupleLength())).TupleGreater(0))) != 0)
                {
                    hv_Value.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Value = hv_Values.TupleMean()
                            ;
                    }
                }
                //

                hv_EvaluationComparisonKeys_COPY_INP_TMP.Dispose();
                hv_EvaluationResult_COPY_INP_TMP.Dispose();
                hv_KeysEvalResult.Dispose();
                hv_NumMatches.Dispose();
                hv_FirstMaxNumDetections.Dispose();
                hv_KeysFirstMaxNumDetections.Dispose();
                hv_DetectionResult.Dispose();
                hv_Index.Dispose();
                hv_ClassificationResult.Dispose();
                hv_KeysExist.Dispose();
                hv_Indices.Dispose();
                hv_Values.Dispose();
                hv_K.Dispose();
                hv_Key.Dispose();
                hv_Tuple.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_EvaluationComparisonKeys_COPY_INP_TMP.Dispose();
                hv_EvaluationResult_COPY_INP_TMP.Dispose();
                hv_KeysEvalResult.Dispose();
                hv_NumMatches.Dispose();
                hv_FirstMaxNumDetections.Dispose();
                hv_KeysFirstMaxNumDetections.Dispose();
                hv_DetectionResult.Dispose();
                hv_Index.Dispose();
                hv_ClassificationResult.Dispose();
                hv_KeysExist.Dispose();
                hv_Indices.Dispose();
                hv_Values.Dispose();
                hv_K.Dispose();
                hv_Key.Dispose();
                hv_Tuple.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Restore serialized DL train infos to resume the training. 
        private void restore_dl_train_info_for_resuming(HTuple hv_StartEpoch, HTuple hv_SerializationData,
            HTuple hv_TrainParam, HTuple hv_DisplayData, out HTuple hv_EvaluationInfos,
            out HTuple hv_TrainInfos, out HTuple hv_DisplayEvaluationEpochs, out HTuple hv_DisplayValidationEvaluationValues,
            out HTuple hv_DisplayTrainEvaluationValues, out HTuple hv_DisplayLossEpochs,
            out HTuple hv_DisplayLoss, out HTuple hv_DisplayLearningRates, out HTuple hv_TrainResultsRestored,
            out HTuple hv_StartEpochNumber)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_TrainResults = new HTuple(), hv_SerializationStrategies = new HTuple();
            HTuple hv_RawData = new HTuple(), hv_FoundEpochs = new HTuple();
            HTuple hv_FoundDicts = new HTuple(), hv_Index = new HTuple();
            HTuple hv_Strategy = new HTuple(), hv_Type = new HTuple();
            HTuple hv_Basename = new HTuple(), hv_Substrings = new HTuple();
            HTuple hv_BaseFolder = new HTuple(), hv_Files = new HTuple();
            HTuple hv_DictFiles = new HTuple(), hv_EpochStrings = new HTuple();
            HTuple hv_EpochStringsNumbers = new HTuple(), hv_DictFileNames = new HTuple();
            HTuple hv_IndexDict = new HTuple(), hv_DictFileName = new HTuple();
            HTuple hv_InfoDicts = new HTuple(), hv_Epochs = new HTuple();
            HTuple hv_ReadSuccess = new HTuple(), hv_InfoDict = new HTuple();
            HTuple hv_Epoch = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_EvaluationComparisonKeys = new HTuple(), hv_DisplayEnabled = new HTuple();
            HTuple hv_IndexEval = new HTuple(), hv_EvaluationResult = new HTuple();
            HTuple hv_Value = new HTuple(), hv_IndexTrain = new HTuple();
            HTuple hv_EpochsStatus = new HTuple(), hv_MeanLoss = new HTuple();
            HTuple hv_ModelParams = new HTuple(), hv_DisplayLearningRate = new HTuple();
            HTuple hv_LossParam = new HTuple(), hv_CountSamples = new HTuple();
            HTuple hv_LossValues = new HTuple(), hv_NumMeanLossSamples = new HTuple();
            HTuple hv_SamplesPerEpoch = new HTuple(), hv_MeanLossCur = new HTuple();
            HTuple hv_NumSamplesInterval = new HTuple(), hv_LossValueIdxsPrev = new HTuple();
            HTuple hv_MeanLossCurInterval = new HTuple(), hv_LossValuesCurInterval = new HTuple();
            HTuple hv_IndexSample = new HTuple(), hv_TrainResult = new HTuple();
            HTuple hv_NumEpochs = new HTuple(), hv_ValidEvaluationKeys = new HTuple();
            HTuple hv_StartEpoch_COPY_INP_TMP = new HTuple(hv_StartEpoch);

            // Initialize local and output iconic variables 
            hv_EvaluationInfos = new HTuple();
            hv_TrainInfos = new HTuple();
            hv_DisplayEvaluationEpochs = new HTuple();
            hv_DisplayValidationEvaluationValues = new HTuple();
            hv_DisplayTrainEvaluationValues = new HTuple();
            hv_DisplayLossEpochs = new HTuple();
            hv_DisplayLoss = new HTuple();
            hv_DisplayLearningRates = new HTuple();
            hv_TrainResultsRestored = new HTuple();
            hv_StartEpochNumber = new HTuple();
            try
            {
                //
                //This procedure initializes training relevant parameters that are stored
                //during training. If StartEpoch is greater than zero or equal to 'resume',
                //the procedure restores this information. This allows to properly resume a
                //training that had been paused or should be continued for another reason.
                //
                //Initialize the variable to collect all training results during training.
                hv_TrainResults.Dispose();
                hv_TrainResults = new HTuple();
                //
                //Initialize the variable to collect the evaluation information during training.
                hv_EvaluationInfos.Dispose();
                hv_EvaluationInfos = new HTuple();
                hv_TrainResultsRestored.Dispose();
                hv_TrainResultsRestored = new HTuple();
                //
                //Initialize the variable to collect the train status information during training.
                hv_TrainInfos.Dispose();
                hv_TrainInfos = new HTuple();
                //
                //Initialize visualization parameters.
                hv_DisplayLossEpochs.Dispose();
                hv_DisplayLossEpochs = new HTuple();
                hv_DisplayLoss.Dispose();
                hv_DisplayLoss = new HTuple();
                hv_DisplayEvaluationEpochs.Dispose();
                hv_DisplayEvaluationEpochs = new HTuple();
                hv_DisplayValidationEvaluationValues.Dispose();
                hv_DisplayValidationEvaluationValues = new HTuple();
                hv_DisplayTrainEvaluationValues.Dispose();
                hv_DisplayTrainEvaluationValues = new HTuple();
                hv_DisplayLearningRates.Dispose();
                hv_DisplayLearningRates = new HTuple();
                //
                //Initialize the start epoch number.
                hv_StartEpochNumber.Dispose();
                hv_StartEpochNumber = 0;
                //
                //Training parameters are initialized for new training,
                //hence return if StartEpoch is zero.
                if ((int)(new HTuple(hv_StartEpoch_COPY_INP_TMP.TupleEqual(0.0))) != 0)
                {

                    hv_StartEpoch_COPY_INP_TMP.Dispose();
                    hv_TrainResults.Dispose();
                    hv_SerializationStrategies.Dispose();
                    hv_RawData.Dispose();
                    hv_FoundEpochs.Dispose();
                    hv_FoundDicts.Dispose();
                    hv_Index.Dispose();
                    hv_Strategy.Dispose();
                    hv_Type.Dispose();
                    hv_Basename.Dispose();
                    hv_Substrings.Dispose();
                    hv_BaseFolder.Dispose();
                    hv_Files.Dispose();
                    hv_DictFiles.Dispose();
                    hv_EpochStrings.Dispose();
                    hv_EpochStringsNumbers.Dispose();
                    hv_DictFileNames.Dispose();
                    hv_IndexDict.Dispose();
                    hv_DictFileName.Dispose();
                    hv_InfoDicts.Dispose();
                    hv_Epochs.Dispose();
                    hv_ReadSuccess.Dispose();
                    hv_InfoDict.Dispose();
                    hv_Epoch.Dispose();
                    hv_Exception.Dispose();
                    hv_EvaluationComparisonKeys.Dispose();
                    hv_DisplayEnabled.Dispose();
                    hv_IndexEval.Dispose();
                    hv_EvaluationResult.Dispose();
                    hv_Value.Dispose();
                    hv_IndexTrain.Dispose();
                    hv_EpochsStatus.Dispose();
                    hv_MeanLoss.Dispose();
                    hv_ModelParams.Dispose();
                    hv_DisplayLearningRate.Dispose();
                    hv_LossParam.Dispose();
                    hv_CountSamples.Dispose();
                    hv_LossValues.Dispose();
                    hv_NumMeanLossSamples.Dispose();
                    hv_SamplesPerEpoch.Dispose();
                    hv_MeanLossCur.Dispose();
                    hv_NumSamplesInterval.Dispose();
                    hv_LossValueIdxsPrev.Dispose();
                    hv_MeanLossCurInterval.Dispose();
                    hv_LossValuesCurInterval.Dispose();
                    hv_IndexSample.Dispose();
                    hv_TrainResult.Dispose();
                    hv_NumEpochs.Dispose();
                    hv_ValidEvaluationKeys.Dispose();

                    return;
                }
                //
                //This procedure reads the latest training and evaluation infos from disk to resume training.
                //
                //Initialize each serialization strategy.
                hv_SerializationStrategies.Dispose();
                HOperatorSet.GetDictTuple(hv_SerializationData, "strategies", out hv_SerializationStrategies);
                hv_RawData.Dispose();
                HOperatorSet.GetDictTuple(hv_SerializationData, "raw_data", out hv_RawData);
                //
                //Loop over all serialization strategies. If more than one is available and StartEpoch='resume',
                //choose the most up-to-date training information that can be found.
                hv_FoundEpochs.Dispose();
                hv_FoundEpochs = new HTuple();
                hv_FoundDicts.Dispose();
                hv_FoundDicts = new HTuple();
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_SerializationStrategies.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    //
                    //Get current strategy and data.
                    hv_Strategy.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Strategy = hv_SerializationStrategies.TupleSelect(
                            hv_Index);
                    }
                    hv_Type.Dispose();
                    HOperatorSet.GetDictTuple(hv_Strategy, "type", out hv_Type);
                    hv_Basename.Dispose();
                    HOperatorSet.GetDictTuple(hv_Strategy, "basename", out hv_Basename);
                    //
                    if ((int)((new HTuple((new HTuple(hv_Type.TupleEqual("best"))).TupleOr(new HTuple(hv_Type.TupleEqual(
                        "current"))))).TupleOr(new HTuple(hv_Type.TupleEqual("epochs")))) != 0)
                    {
                        //
                        if ((int)(new HTuple(hv_Type.TupleEqual("epochs"))) != 0)
                        {
                            //Find the last written training information
                            {
                                HTuple ExpTmpOutVar_0;
                                HOperatorSet.TupleRegexpReplace(hv_Basename, (new HTuple("\\\\+")).TupleConcat(
                                    "replace_all"), "/", out ExpTmpOutVar_0);
                                hv_Basename.Dispose();
                                hv_Basename = ExpTmpOutVar_0;
                            }
                            hv_Substrings.Dispose();
                            HOperatorSet.TupleSplit(hv_Basename, "/", out hv_Substrings);
                            hv_BaseFolder.Dispose();
                            hv_BaseFolder = ".";
                            if ((int)(new HTuple((new HTuple(hv_Substrings.TupleLength())).TupleGreater(
                                1))) != 0)
                            {
                                hv_BaseFolder.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_BaseFolder = (hv_Substrings.TupleSelectRange(
                                        0, (new HTuple(hv_Substrings.TupleLength())) - 2)) + "/";
                                }
                            }
                            hv_Files.Dispose();
                            HOperatorSet.ListFiles(hv_BaseFolder, "files", out hv_Files);
                            hv_DictFiles.Dispose();
                            HOperatorSet.TupleRegexpSelect(hv_Files, "[0-9]\\.[0-9]*_info\\.hdict",
                                out hv_DictFiles);
                            hv_EpochStrings.Dispose();
                            HOperatorSet.TupleRegexpMatch(hv_DictFiles, "[0-9]\\.[0-9]*", out hv_EpochStrings);
                            hv_EpochStringsNumbers.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_EpochStringsNumbers = hv_EpochStrings.TupleNumber()
                                    ;
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_DictFileNames.Dispose();
                                HOperatorSet.TupleGenConst(new HTuple(hv_EpochStrings.TupleLength()),
                                    "", out hv_DictFileNames);
                            }
                            for (hv_IndexDict = 0; (int)hv_IndexDict <= (int)((new HTuple(hv_EpochStrings.TupleLength()
                                )) - 1); hv_IndexDict = (int)hv_IndexDict + 1)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_DictFileName.Dispose();
                                    HOperatorSet.TupleRegexpSelect(hv_DictFiles, (((hv_EpochStringsNumbers.TupleSelect(
                                        hv_IndexDict))).TupleString(".2f")) + "_info.hdict", out hv_DictFileName);
                                }
                                if ((int)(new HTuple((new HTuple(hv_DictFileName.TupleLength())).TupleNotEqual(
                                    0))) != 0)
                                {
                                    if (hv_DictFileNames == null)
                                        hv_DictFileNames = new HTuple();
                                    hv_DictFileNames[hv_IndexDict] = hv_DictFileName;
                                }
                            }
                        }
                        else
                        {
                            hv_DictFileNames.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_DictFileNames = hv_Basename + "_info.hdict";
                            }
                        }
                        //
                        //Try to read in the training information dicts.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_InfoDicts.Dispose();
                            HOperatorSet.TupleGenConst(new HTuple(hv_DictFileNames.TupleLength()),
                                -1, out hv_InfoDicts);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Epochs.Dispose();
                            HOperatorSet.TupleGenConst(new HTuple(hv_DictFileNames.TupleLength()),
                                -1, out hv_Epochs);
                        }
                        hv_ReadSuccess.Dispose();
                        hv_ReadSuccess = 0;
                        for (hv_IndexDict = 0; (int)hv_IndexDict <= (int)((new HTuple(hv_DictFileNames.TupleLength()
                            )) - 1); hv_IndexDict = (int)hv_IndexDict + 1)
                        {
                            try
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_InfoDict.Dispose();
                                    HOperatorSet.ReadDict(hv_DictFileNames.TupleSelect(hv_IndexDict), new HTuple(),
                                        new HTuple(), out hv_InfoDict);
                                }
                                hv_Epoch.Dispose();
                                HOperatorSet.GetDictTuple(hv_InfoDict, "epoch", out hv_Epoch);
                                if (hv_InfoDicts == null)
                                    hv_InfoDicts = new HTuple();
                                hv_InfoDicts[hv_IndexDict] = hv_InfoDict;
                                if (hv_Epochs == null)
                                    hv_Epochs = new HTuple();
                                hv_Epochs[hv_IndexDict] = hv_Epoch;
                                hv_ReadSuccess.Dispose();
                                hv_ReadSuccess = 1;
                            }
                            // catch (Exception) 
                            catch (HalconException HDevExpDefaultException1)
                            {
                                HDevExpDefaultException1.ToHTuple(out hv_Exception);
                            }
                        }
                        if ((int)(hv_ReadSuccess.TupleNot()) != 0)
                        {
                            //Not even a single file has been found.
                            continue;
                        }
                        //
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_FoundEpochs = hv_FoundEpochs.TupleConcat(
                                    hv_Epochs);
                                hv_FoundEpochs.Dispose();
                                hv_FoundEpochs = ExpTmpLocalVar_FoundEpochs;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_FoundDicts = hv_FoundDicts.TupleConcat(
                                    hv_InfoDicts);
                                hv_FoundDicts.Dispose();
                                hv_FoundDicts = ExpTmpLocalVar_FoundDicts;
                            }
                        }
                        //
                    }
                    else if ((int)(new HTuple(hv_Type.TupleEqual("final"))) != 0)
                    {
                        //Nothing to restore.
                        continue;
                    }
                    else
                    {
                        throw new HalconException(("Unknown serialization strategy type: '" + hv_Type) + "'");
                    }
                }
                //
                //Check if training can or needs to be resumed.
                if ((int)(new HTuple(hv_StartEpoch_COPY_INP_TMP.TupleEqual("resume"))) != 0)
                {
                    //Resume at highest epoch available.
                    hv_Epoch.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Epoch = hv_FoundEpochs.TupleMax()
                            ;
                    }
                    if ((int)(new HTuple(hv_Epoch.TupleLess(0.0))) != 0)
                    {
                        throw new HalconException("No training information found. Training cannot be resumed.");
                    }
                    hv_Index.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Index = ((hv_FoundEpochs.TupleEqualElem(
                            hv_Epoch))).TupleFindFirst(1);
                    }
                    hv_InfoDict.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_InfoDict = hv_FoundDicts.TupleSelect(
                            hv_Index);
                    }
                    hv_StartEpoch_COPY_INP_TMP.Dispose();
                    hv_StartEpoch_COPY_INP_TMP = new HTuple(hv_Epoch);
                }
                else
                {
                    //Check if requested StartEpoch was found.
                    hv_Index.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Index = ((hv_FoundEpochs.TupleEqualElem(
                            hv_StartEpoch_COPY_INP_TMP))).TupleFindFirst(1);
                    }
                    if ((int)((new HTuple(hv_Index.TupleNotEqual(new HTuple()))).TupleAnd(new HTuple(hv_Index.TupleNotEqual(
                        -1)))) != 0)
                    {
                        hv_InfoDict.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_InfoDict = hv_FoundDicts.TupleSelect(
                                hv_Index);
                        }
                    }
                    else
                    {
                        //Try to find the rounded value as it is serialized.
                        hv_Index.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Index = ((((hv_FoundEpochs.TupleString(
                                ".2f"))).TupleEqualElem(hv_StartEpoch_COPY_INP_TMP.TupleString(".2f")))).TupleFindFirst(
                                1);
                        }
                        if ((int)((new HTuple(hv_Index.TupleNotEqual(new HTuple()))).TupleAnd(new HTuple(hv_Index.TupleNotEqual(
                            -1)))) != 0)
                        {
                            hv_InfoDict.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_InfoDict = hv_FoundDicts.TupleSelect(
                                    hv_Index);
                            }
                        }
                        else
                        {
                            throw new HalconException("No training information matches requested StartEpoch " + hv_StartEpoch_COPY_INP_TMP);
                        }
                    }
                }
                //
                //Get evaluation and training infos.
                hv_EvaluationInfos.Dispose();
                HOperatorSet.GetDictTuple(hv_InfoDict, "evaluation_infos", out hv_EvaluationInfos);
                hv_TrainInfos.Dispose();
                HOperatorSet.GetDictTuple(hv_InfoDict, "train_infos", out hv_TrainInfos);
                hv_EvaluationComparisonKeys.Dispose();
                HOperatorSet.GetDictTuple(hv_TrainParam, "evaluation_comparison_keys", out hv_EvaluationComparisonKeys);
                //
                //Restore history of display values.
                hv_DisplayEnabled.Dispose();
                HOperatorSet.GetDictTuple(hv_DisplayData, "enabled", out hv_DisplayEnabled);
                if ((int)(hv_DisplayEnabled) != 0)
                {
                    for (hv_IndexEval = 0; (int)hv_IndexEval <= (int)((new HTuple(hv_EvaluationInfos.TupleLength()
                        )) - 1); hv_IndexEval = (int)hv_IndexEval + 1)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_EvaluationResult.Dispose();
                            HOperatorSet.GetDictTuple(hv_EvaluationInfos.TupleSelect(hv_IndexEval),
                                "result", out hv_EvaluationResult);
                        }
                        hv_Value.Dispose(); hv_ValidEvaluationKeys.Dispose();
                        reduce_dl_evaluation_result(hv_EvaluationResult, hv_EvaluationComparisonKeys,
                            out hv_Value, out hv_ValidEvaluationKeys);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_DisplayValidationEvaluationValues = hv_DisplayValidationEvaluationValues.TupleConcat(
                                    hv_Value);
                                hv_DisplayValidationEvaluationValues.Dispose();
                                hv_DisplayValidationEvaluationValues = ExpTmpLocalVar_DisplayValidationEvaluationValues;
                            }
                        }
                        hv_Value.Dispose();
                        hv_Value = -1;
                        try
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_EvaluationResult.Dispose();
                                HOperatorSet.GetDictTuple(hv_EvaluationInfos.TupleSelect(hv_IndexEval),
                                    "train_result", out hv_EvaluationResult);
                            }
                            hv_Value.Dispose(); hv_ValidEvaluationKeys.Dispose();
                            reduce_dl_evaluation_result(hv_EvaluationResult, hv_EvaluationComparisonKeys,
                                out hv_Value, out hv_ValidEvaluationKeys);
                        }
                        // catch (Exception) 
                        catch (HalconException HDevExpDefaultException1)
                        {
                            HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_DisplayTrainEvaluationValues = hv_DisplayTrainEvaluationValues.TupleConcat(
                                    hv_Value);
                                hv_DisplayTrainEvaluationValues.Dispose();
                                hv_DisplayTrainEvaluationValues = ExpTmpLocalVar_DisplayTrainEvaluationValues;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Epoch.Dispose();
                            HOperatorSet.GetDictTuple(hv_EvaluationInfos.TupleSelect(hv_IndexEval),
                                "epoch", out hv_Epoch);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_DisplayEvaluationEpochs = hv_DisplayEvaluationEpochs.TupleConcat(
                                    hv_Epoch);
                                hv_DisplayEvaluationEpochs.Dispose();
                                hv_DisplayEvaluationEpochs = ExpTmpLocalVar_DisplayEvaluationEpochs;
                            }
                        }
                    }
                    for (hv_IndexTrain = 0; (int)hv_IndexTrain <= (int)((new HTuple(hv_TrainInfos.TupleLength()
                        )) - 1); hv_IndexTrain = (int)hv_IndexTrain + 1)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_EpochsStatus.Dispose();
                            HOperatorSet.GetDictTuple(hv_TrainInfos.TupleSelect(hv_IndexTrain), "epoch",
                                out hv_EpochsStatus);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_DisplayLossEpochs = hv_DisplayLossEpochs.TupleConcat(
                                    hv_EpochsStatus);
                                hv_DisplayLossEpochs.Dispose();
                                hv_DisplayLossEpochs = ExpTmpLocalVar_DisplayLossEpochs;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MeanLoss.Dispose();
                            HOperatorSet.GetDictTuple(hv_TrainInfos.TupleSelect(hv_IndexTrain), "mean_loss",
                                out hv_MeanLoss);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_DisplayLoss = hv_DisplayLoss.TupleConcat(
                                    hv_MeanLoss);
                                hv_DisplayLoss.Dispose();
                                hv_DisplayLoss = ExpTmpLocalVar_DisplayLoss;
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ModelParams.Dispose();
                            HOperatorSet.GetDictTuple(hv_TrainInfos.TupleSelect(hv_IndexTrain), "model_params",
                                out hv_ModelParams);
                        }
                        hv_DisplayLearningRate.Dispose();
                        HOperatorSet.GetDictTuple(hv_ModelParams, "learning_rate", out hv_DisplayLearningRate);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_DisplayLearningRates = hv_DisplayLearningRates.TupleConcat(
                                    hv_DisplayLearningRate);
                                hv_DisplayLearningRates.Dispose();
                                hv_DisplayLearningRates = ExpTmpLocalVar_DisplayLearningRates;
                            }
                        }
                    }
                }
                //
                //Restore dictionaries that contain the approximate loss-values for each iteration.
                //We cannot reconstruct the exact loss values, therefore, we use the serialized mean values.
                hv_LossParam.Dispose();
                hv_LossParam = "total_loss";
                hv_CountSamples.Dispose();
                hv_CountSamples = 0;
                hv_LossValues.Dispose();
                hv_LossValues = new HTuple();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Epoch.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainInfos.TupleSelect(0), "epoch", out hv_Epoch);
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumMeanLossSamples.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainInfos.TupleSelect(0), "mean_loss_samples",
                        out hv_NumMeanLossSamples);
                }
                hv_SamplesPerEpoch.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_SamplesPerEpoch = (hv_NumMeanLossSamples.TupleReal()
                        ) / hv_Epoch;
                }
                //
                for (hv_IndexTrain = 0; (int)hv_IndexTrain <= (int)((new HTuple(hv_TrainInfos.TupleLength()
                    )) - 1); hv_IndexTrain = (int)hv_IndexTrain + 1)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_MeanLossCur.Dispose();
                        HOperatorSet.GetDictTuple(hv_TrainInfos.TupleSelect(hv_IndexTrain), "mean_loss",
                            out hv_MeanLossCur);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumMeanLossSamples.Dispose();
                        HOperatorSet.GetDictTuple(hv_TrainInfos.TupleSelect(hv_IndexTrain), "mean_loss_samples",
                            out hv_NumMeanLossSamples);
                    }
                    //The iterations within one interval are not fixed.
                    //Calculate the current iteration and the number of iterations within the interval based on the epoch.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Epoch.Dispose();
                        HOperatorSet.GetDictTuple(hv_TrainInfos.TupleSelect(hv_IndexTrain), "epoch",
                            out hv_Epoch);
                    }
                    hv_NumSamplesInterval.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumSamplesInterval = (((hv_Epoch * hv_SamplesPerEpoch)).TupleRound()
                            ) - hv_CountSamples;
                    }
                    //For multiple resuming it can happen that more than one train-info for the same time-point exists.
                    if ((int)(new HTuple(hv_NumSamplesInterval.TupleEqual(0))) != 0)
                    {
                        continue;
                    }
                    //Calculate the mean loss within the interval between the previous and the current serialization time-point.
                    hv_LossValueIdxsPrev.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_LossValueIdxsPrev = (HTuple.TupleGenSequence(
                            (new HTuple(hv_LossValues.TupleLength())) - (hv_NumMeanLossSamples - hv_NumSamplesInterval),
                            (new HTuple(hv_LossValues.TupleLength())) - 1, 1)).TupleInt();
                    }
                    if ((int)(new HTuple(hv_LossValueIdxsPrev.TupleLength())) != 0)
                    {
                        //The total mean loss (MeanLossCur) consists of the mean loss within this interval (MeanLossCurInterval) and
                        //the fraction of previous samples.
                        hv_MeanLossCurInterval.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MeanLossCurInterval = ((hv_MeanLossCur * hv_NumMeanLossSamples) - (((hv_LossValues.TupleSelect(
                                hv_LossValueIdxsPrev))).TupleSum())) / hv_NumSamplesInterval;
                        }
                    }
                    else
                    {
                        //In this case the total mean loss is just the loss of this interval.
                        hv_MeanLossCurInterval.Dispose();
                        hv_MeanLossCurInterval = new HTuple(hv_MeanLossCur);
                    }
                    //
                    hv_LossValuesCurInterval.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_LossValuesCurInterval = HTuple.TupleGenConst(
                            hv_NumSamplesInterval, hv_MeanLossCurInterval);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_LossValues = hv_LossValues.TupleConcat(
                                hv_LossValuesCurInterval);
                            hv_LossValues.Dispose();
                            hv_LossValues = ExpTmpLocalVar_LossValues;
                        }
                    }
                    //
                    //Pack the loss values into dictionaries.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_TrainResultsRestored = hv_TrainResultsRestored.TupleConcat(
                                HTuple.TupleGenConst(hv_NumSamplesInterval, -1));
                            hv_TrainResultsRestored.Dispose();
                            hv_TrainResultsRestored = ExpTmpLocalVar_TrainResultsRestored;
                        }
                    }
                    HTuple end_val200 = hv_NumSamplesInterval - 1;
                    HTuple step_val200 = 1;
                    for (hv_IndexSample = 0; hv_IndexSample.Continue(end_val200, step_val200); hv_IndexSample = hv_IndexSample.TupleAdd(step_val200))
                    {
                        hv_TrainResult.Dispose();
                        HOperatorSet.CreateDict(out hv_TrainResult);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_TrainResult, hv_LossParam, hv_LossValuesCurInterval.TupleSelect(
                                hv_IndexSample));
                        }
                        if (hv_TrainResultsRestored == null)
                            hv_TrainResultsRestored = new HTuple();
                        hv_TrainResultsRestored[hv_CountSamples] = hv_TrainResult;
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_CountSamples = hv_CountSamples + 1;
                                hv_CountSamples.Dispose();
                                hv_CountSamples = ExpTmpLocalVar_CountSamples;
                            }
                        }
                    }
                }
                //
                //Plot the current training status.
                if ((int)(hv_DisplayEnabled) != 0)
                {
                    hv_NumEpochs.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainParam, "num_epochs", out hv_NumEpochs);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetDictTuple(hv_TrainInfos.TupleSelect((new HTuple(hv_TrainInfos.TupleLength()
                            )) - 1), "num_epochs", hv_NumEpochs);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        dev_display_update_train_dl_model(hv_TrainParam, hv_DisplayData, hv_TrainInfos.TupleSelect(
                            (new HTuple(hv_TrainInfos.TupleLength())) - 1), hv_DisplayLossEpochs, hv_DisplayLoss,
                            hv_DisplayLearningRates, hv_DisplayEvaluationEpochs, hv_DisplayValidationEvaluationValues,
                            hv_DisplayTrainEvaluationValues);
                    }
                }
                //
                //Return StartEpoch as number.
                hv_StartEpochNumber.Dispose();
                hv_StartEpochNumber = new HTuple(hv_StartEpoch_COPY_INP_TMP);
                //

                hv_StartEpoch_COPY_INP_TMP.Dispose();
                hv_TrainResults.Dispose();
                hv_SerializationStrategies.Dispose();
                hv_RawData.Dispose();
                hv_FoundEpochs.Dispose();
                hv_FoundDicts.Dispose();
                hv_Index.Dispose();
                hv_Strategy.Dispose();
                hv_Type.Dispose();
                hv_Basename.Dispose();
                hv_Substrings.Dispose();
                hv_BaseFolder.Dispose();
                hv_Files.Dispose();
                hv_DictFiles.Dispose();
                hv_EpochStrings.Dispose();
                hv_EpochStringsNumbers.Dispose();
                hv_DictFileNames.Dispose();
                hv_IndexDict.Dispose();
                hv_DictFileName.Dispose();
                hv_InfoDicts.Dispose();
                hv_Epochs.Dispose();
                hv_ReadSuccess.Dispose();
                hv_InfoDict.Dispose();
                hv_Epoch.Dispose();
                hv_Exception.Dispose();
                hv_EvaluationComparisonKeys.Dispose();
                hv_DisplayEnabled.Dispose();
                hv_IndexEval.Dispose();
                hv_EvaluationResult.Dispose();
                hv_Value.Dispose();
                hv_IndexTrain.Dispose();
                hv_EpochsStatus.Dispose();
                hv_MeanLoss.Dispose();
                hv_ModelParams.Dispose();
                hv_DisplayLearningRate.Dispose();
                hv_LossParam.Dispose();
                hv_CountSamples.Dispose();
                hv_LossValues.Dispose();
                hv_NumMeanLossSamples.Dispose();
                hv_SamplesPerEpoch.Dispose();
                hv_MeanLossCur.Dispose();
                hv_NumSamplesInterval.Dispose();
                hv_LossValueIdxsPrev.Dispose();
                hv_MeanLossCurInterval.Dispose();
                hv_LossValuesCurInterval.Dispose();
                hv_IndexSample.Dispose();
                hv_TrainResult.Dispose();
                hv_NumEpochs.Dispose();
                hv_ValidEvaluationKeys.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_StartEpoch_COPY_INP_TMP.Dispose();
                hv_TrainResults.Dispose();
                hv_SerializationStrategies.Dispose();
                hv_RawData.Dispose();
                hv_FoundEpochs.Dispose();
                hv_FoundDicts.Dispose();
                hv_Index.Dispose();
                hv_Strategy.Dispose();
                hv_Type.Dispose();
                hv_Basename.Dispose();
                hv_Substrings.Dispose();
                hv_BaseFolder.Dispose();
                hv_Files.Dispose();
                hv_DictFiles.Dispose();
                hv_EpochStrings.Dispose();
                hv_EpochStringsNumbers.Dispose();
                hv_DictFileNames.Dispose();
                hv_IndexDict.Dispose();
                hv_DictFileName.Dispose();
                hv_InfoDicts.Dispose();
                hv_Epochs.Dispose();
                hv_ReadSuccess.Dispose();
                hv_InfoDict.Dispose();
                hv_Epoch.Dispose();
                hv_Exception.Dispose();
                hv_EvaluationComparisonKeys.Dispose();
                hv_DisplayEnabled.Dispose();
                hv_IndexEval.Dispose();
                hv_EvaluationResult.Dispose();
                hv_Value.Dispose();
                hv_IndexTrain.Dispose();
                hv_EpochsStatus.Dispose();
                hv_MeanLoss.Dispose();
                hv_ModelParams.Dispose();
                hv_DisplayLearningRate.Dispose();
                hv_LossParam.Dispose();
                hv_CountSamples.Dispose();
                hv_LossValues.Dispose();
                hv_NumMeanLossSamples.Dispose();
                hv_SamplesPerEpoch.Dispose();
                hv_MeanLossCur.Dispose();
                hv_NumSamplesInterval.Dispose();
                hv_LossValueIdxsPrev.Dispose();
                hv_MeanLossCurInterval.Dispose();
                hv_LossValuesCurInterval.Dispose();
                hv_IndexSample.Dispose();
                hv_TrainResult.Dispose();
                hv_NumEpochs.Dispose();
                hv_ValidEvaluationKeys.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Filters / Arithmetic
        // Short Description: Scale the gray values of an image from the interval [Min,Max] to [0,255] 
        public void scale_image_range(HObject ho_Image, out HObject ho_ImageScaled, HTuple hv_Min,
            HTuple hv_Max)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_ImageSelected = null, ho_SelectedChannel = null;
            HObject ho_LowerRegion = null, ho_UpperRegion = null, ho_ImageSelectedScaled = null;

            // Local copy input parameter variables 
            HObject ho_Image_COPY_INP_TMP;
            ho_Image_COPY_INP_TMP = new HObject(ho_Image);



            // Local control variables 

            HTuple hv_LowerLimit = new HTuple(), hv_UpperLimit = new HTuple();
            HTuple hv_Mult = new HTuple(), hv_Add = new HTuple(), hv_NumImages = new HTuple();
            HTuple hv_ImageIndex = new HTuple(), hv_Channels = new HTuple();
            HTuple hv_ChannelIndex = new HTuple(), hv_MinGray = new HTuple();
            HTuple hv_MaxGray = new HTuple(), hv_Range = new HTuple();
            HTuple hv_Max_COPY_INP_TMP = new HTuple(hv_Max);
            HTuple hv_Min_COPY_INP_TMP = new HTuple(hv_Min);

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ImageScaled);
            HOperatorSet.GenEmptyObj(out ho_ImageSelected);
            HOperatorSet.GenEmptyObj(out ho_SelectedChannel);
            HOperatorSet.GenEmptyObj(out ho_LowerRegion);
            HOperatorSet.GenEmptyObj(out ho_UpperRegion);
            HOperatorSet.GenEmptyObj(out ho_ImageSelectedScaled);
            try
            {
                //Convenience procedure to scale the gray values of the
                //input image Image from the interval [Min,Max]
                //to the interval [0,255] (default).
                //Gray values < 0 or > 255 (after scaling) are clipped.
                //
                //If the image shall be scaled to an interval different from [0,255],
                //this can be achieved by passing tuples with 2 values [From, To]
                //as Min and Max.
                //Example:
                //scale_image_range(Image:ImageScaled:[100,50],[200,250])
                //maps the gray values of Image from the interval [100,200] to [50,250].
                //All other gray values will be clipped.
                //
                //input parameters:
                //Image: the input image
                //Min: the minimum gray value which will be mapped to 0
                //     If a tuple with two values is given, the first value will
                //     be mapped to the second value.
                //Max: The maximum gray value which will be mapped to 255
                //     If a tuple with two values is given, the first value will
                //     be mapped to the second value.
                //
                //Output parameter:
                //ImageScale: the resulting scaled image.
                //
                if ((int)(new HTuple((new HTuple(hv_Min_COPY_INP_TMP.TupleLength())).TupleEqual(
                    2))) != 0)
                {
                    hv_LowerLimit.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_LowerLimit = hv_Min_COPY_INP_TMP.TupleSelect(
                            1);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Min = hv_Min_COPY_INP_TMP.TupleSelect(
                                0);
                            hv_Min_COPY_INP_TMP.Dispose();
                            hv_Min_COPY_INP_TMP = ExpTmpLocalVar_Min;
                        }
                    }
                }
                else
                {
                    hv_LowerLimit.Dispose();
                    hv_LowerLimit = 0.0;
                }
                if ((int)(new HTuple((new HTuple(hv_Max_COPY_INP_TMP.TupleLength())).TupleEqual(
                    2))) != 0)
                {
                    hv_UpperLimit.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_UpperLimit = hv_Max_COPY_INP_TMP.TupleSelect(
                            1);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Max = hv_Max_COPY_INP_TMP.TupleSelect(
                                0);
                            hv_Max_COPY_INP_TMP.Dispose();
                            hv_Max_COPY_INP_TMP = ExpTmpLocalVar_Max;
                        }
                    }
                }
                else
                {
                    hv_UpperLimit.Dispose();
                    hv_UpperLimit = 255.0;
                }
                //
                //Calculate scaling parameters.
                //Only scale if the scaling range is not zero.
                if ((int)((new HTuple(((((hv_Max_COPY_INP_TMP - hv_Min_COPY_INP_TMP)).TupleAbs()
                    )).TupleLess(1.0E-6))).TupleNot()) != 0)
                {
                    hv_Mult.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Mult = (((hv_UpperLimit - hv_LowerLimit)).TupleReal()
                            ) / (hv_Max_COPY_INP_TMP - hv_Min_COPY_INP_TMP);
                    }
                    hv_Add.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Add = ((-hv_Mult) * hv_Min_COPY_INP_TMP) + hv_LowerLimit;
                    }
                    //Scale image.
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ScaleImage(ho_Image_COPY_INP_TMP, out ExpTmpOutVar_0, hv_Mult,
                            hv_Add);
                        ho_Image_COPY_INP_TMP.Dispose();
                        ho_Image_COPY_INP_TMP = ExpTmpOutVar_0;
                    }
                }
                //
                //Clip gray values if necessary.
                //This must be done for each image and channel separately.
                ho_ImageScaled.Dispose();
                HOperatorSet.GenEmptyObj(out ho_ImageScaled);
                hv_NumImages.Dispose();
                HOperatorSet.CountObj(ho_Image_COPY_INP_TMP, out hv_NumImages);
                HTuple end_val51 = hv_NumImages;
                HTuple step_val51 = 1;
                for (hv_ImageIndex = 1; hv_ImageIndex.Continue(end_val51, step_val51); hv_ImageIndex = hv_ImageIndex.TupleAdd(step_val51))
                {
                    ho_ImageSelected.Dispose();
                    HOperatorSet.SelectObj(ho_Image_COPY_INP_TMP, out ho_ImageSelected, hv_ImageIndex);
                    hv_Channels.Dispose();
                    HOperatorSet.CountChannels(ho_ImageSelected, out hv_Channels);
                    HTuple end_val54 = hv_Channels;
                    HTuple step_val54 = 1;
                    for (hv_ChannelIndex = 1; hv_ChannelIndex.Continue(end_val54, step_val54); hv_ChannelIndex = hv_ChannelIndex.TupleAdd(step_val54))
                    {
                        ho_SelectedChannel.Dispose();
                        HOperatorSet.AccessChannel(ho_ImageSelected, out ho_SelectedChannel, hv_ChannelIndex);
                        hv_MinGray.Dispose(); hv_MaxGray.Dispose(); hv_Range.Dispose();
                        HOperatorSet.MinMaxGray(ho_SelectedChannel, ho_SelectedChannel, 0, out hv_MinGray,
                            out hv_MaxGray, out hv_Range);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_LowerRegion.Dispose();
                            HOperatorSet.Threshold(ho_SelectedChannel, out ho_LowerRegion, ((hv_MinGray.TupleConcat(
                                hv_LowerLimit))).TupleMin(), hv_LowerLimit);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho_UpperRegion.Dispose();
                            HOperatorSet.Threshold(ho_SelectedChannel, out ho_UpperRegion, hv_UpperLimit,
                                ((hv_UpperLimit.TupleConcat(hv_MaxGray))).TupleMax());
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.PaintRegion(ho_LowerRegion, ho_SelectedChannel, out ExpTmpOutVar_0,
                                hv_LowerLimit, "fill");
                            ho_SelectedChannel.Dispose();
                            ho_SelectedChannel = ExpTmpOutVar_0;
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.PaintRegion(ho_UpperRegion, ho_SelectedChannel, out ExpTmpOutVar_0,
                                hv_UpperLimit, "fill");
                            ho_SelectedChannel.Dispose();
                            ho_SelectedChannel = ExpTmpOutVar_0;
                        }
                        if ((int)(new HTuple(hv_ChannelIndex.TupleEqual(1))) != 0)
                        {
                            ho_ImageSelectedScaled.Dispose();
                            HOperatorSet.CopyObj(ho_SelectedChannel, out ho_ImageSelectedScaled,
                                1, 1);
                        }
                        else
                        {
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.AppendChannel(ho_ImageSelectedScaled, ho_SelectedChannel,
                                    out ExpTmpOutVar_0);
                                ho_ImageSelectedScaled.Dispose();
                                ho_ImageSelectedScaled = ExpTmpOutVar_0;
                            }
                        }
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_ImageScaled, ho_ImageSelectedScaled, out ExpTmpOutVar_0
                            );
                        ho_ImageScaled.Dispose();
                        ho_ImageScaled = ExpTmpOutVar_0;
                    }
                }
                ho_Image_COPY_INP_TMP.Dispose();
                ho_ImageSelected.Dispose();
                ho_SelectedChannel.Dispose();
                ho_LowerRegion.Dispose();
                ho_UpperRegion.Dispose();
                ho_ImageSelectedScaled.Dispose();

                hv_Max_COPY_INP_TMP.Dispose();
                hv_Min_COPY_INP_TMP.Dispose();
                hv_LowerLimit.Dispose();
                hv_UpperLimit.Dispose();
                hv_Mult.Dispose();
                hv_Add.Dispose();
                hv_NumImages.Dispose();
                hv_ImageIndex.Dispose();
                hv_Channels.Dispose();
                hv_ChannelIndex.Dispose();
                hv_MinGray.Dispose();
                hv_MaxGray.Dispose();
                hv_Range.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Image_COPY_INP_TMP.Dispose();
                ho_ImageSelected.Dispose();
                ho_SelectedChannel.Dispose();
                ho_LowerRegion.Dispose();
                ho_UpperRegion.Dispose();
                ho_ImageSelectedScaled.Dispose();

                hv_Max_COPY_INP_TMP.Dispose();
                hv_Min_COPY_INP_TMP.Dispose();
                hv_LowerLimit.Dispose();
                hv_UpperLimit.Dispose();
                hv_Mult.Dispose();
                hv_Add.Dispose();
                hv_NumImages.Dispose();
                hv_ImageIndex.Dispose();
                hv_Channels.Dispose();
                hv_ChannelIndex.Dispose();
                hv_MinGray.Dispose();
                hv_MaxGray.Dispose();
                hv_Range.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Serialize a DLModelHandle with current meta information. 
        private void serialize_train_dl_model_intermediate(HTuple hv_DLModelHandle, HTuple hv_Epoch,
            HTuple hv_Strategy, HTuple hv_TrainInfos, HTuple hv_EvaluationInfos, out HTuple hv_FilenameModel,
            out HTuple hv_FilenameMetaData)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Type = new HTuple(), hv_Basename = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_Epochs = new HTuple();
            HTuple hv_Index = new HTuple(), hv_MetaData = new HTuple();
            // Initialize local and output iconic variables 
            hv_FilenameModel = new HTuple();
            hv_FilenameMetaData = new HTuple();
            try
            {
                //
                //Serialize the model DLModelHandle with current meta information.
                //
                //We need the type of strategy used.
                hv_Type.Dispose();
                HOperatorSet.GetDictTuple(hv_Strategy, "type", out hv_Type);

                //Get basename/default.
                try
                {
                    hv_Basename.Dispose();
                    HOperatorSet.GetDictTuple(hv_Strategy, "basename", out hv_Basename);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    if ((int)(new HTuple(hv_Type.TupleEqual("epochs"))) != 0)
                    {
                        hv_Basename.Dispose();
                        hv_Basename = "model_at_epoch";
                    }
                    else
                    {
                        hv_Basename.Dispose();
                        hv_Basename = new HTuple(hv_Type);
                    }
                }
                //
                //If we serialize epochs and only one basename is given,
                //we need to add the current epoch to it.
                //If a basename has been specified for each epoch,
                //appending the current epoch is not necessary.
                if ((int)(new HTuple(hv_Type.TupleEqual("epochs"))) != 0)
                {
                    hv_Epochs.Dispose();
                    HOperatorSet.GetDictTuple(hv_Strategy, "epochs", out hv_Epochs);
                    if ((int)(new HTuple((new HTuple(hv_Basename.TupleLength())).TupleEqual(new HTuple(hv_Epochs.TupleLength()
                        )))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Index.Dispose();
                            HOperatorSet.TupleFindLast(hv_Epoch.TupleLessElem(hv_Epochs), 0, out hv_Index);
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Basename = hv_Basename.TupleSelect(
                                    hv_Index);
                                hv_Basename.Dispose();
                                hv_Basename = ExpTmpLocalVar_Basename;
                            }
                        }
                    }
                    else
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Basename = (hv_Basename + "_") + (hv_Epoch.TupleString(
                                    ".2f"));
                                hv_Basename.Dispose();
                                hv_Basename = ExpTmpLocalVar_Basename;
                            }
                        }
                    }
                }
                //
                //Filenames.
                hv_FilenameModel.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_FilenameModel = hv_Basename + ".hdl";
                }
                hv_FilenameMetaData.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_FilenameMetaData = hv_Basename + "_info.hdict";
                }
                //
                //Metadata.
                hv_MetaData.Dispose();
                HOperatorSet.CreateDict(out hv_MetaData);
                HOperatorSet.SetDictTuple(hv_MetaData, "train_infos", hv_TrainInfos);
                HOperatorSet.SetDictTuple(hv_MetaData, "evaluation_infos", hv_EvaluationInfos);
                HOperatorSet.SetDictTuple(hv_MetaData, "epoch", hv_Epoch);
                //
                //Write files.
                HOperatorSet.WriteDlModel(hv_DLModelHandle, hv_FilenameModel);
                HOperatorSet.WriteDict(hv_MetaData, hv_FilenameMetaData, new HTuple(), new HTuple());

                hv_Type.Dispose();
                hv_Basename.Dispose();
                hv_Exception.Dispose();
                hv_Epochs.Dispose();
                hv_Index.Dispose();
                hv_MetaData.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Type.Dispose();
                hv_Basename.Dispose();
                hv_Exception.Dispose();
                hv_Epochs.Dispose();
                hv_Index.Dispose();
                hv_MetaData.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Text
        // Short Description: Set font independent of OS 
        public void set_display_font(HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font,
            HTuple hv_Bold, HTuple hv_Slant)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_OS = new HTuple(), hv_Fonts = new HTuple();
            HTuple hv_Style = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_AvailableFonts = new HTuple(), hv_Fdx = new HTuple();
            HTuple hv_Indices = new HTuple();
            HTuple hv_Font_COPY_INP_TMP = new HTuple(hv_Font);
            HTuple hv_Size_COPY_INP_TMP = new HTuple(hv_Size);

            // Initialize local and output iconic variables 
            try
            {
                //This procedure sets the text font of the current window with
                //the specified attributes.
                //
                //Input parameters:
                //WindowHandle: The graphics window for which the font will be set
                //Size: The font size. If Size=-1, the default of 16 is used.
                //Bold: If set to 'true', a bold font is used
                //Slant: If set to 'true', a slanted font is used
                //
                hv_OS.Dispose();
                HOperatorSet.GetSystem("operating_system", out hv_OS);
                if ((int)((new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
                    new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(-1)))) != 0)
                {
                    hv_Size_COPY_INP_TMP.Dispose();
                    hv_Size_COPY_INP_TMP = 16;
                }
                if ((int)(new HTuple(((hv_OS.TupleSubstr(0, 2))).TupleEqual("Win"))) != 0)
                {
                    //Restore previous behaviour
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Size = ((1.13677 * hv_Size_COPY_INP_TMP)).TupleInt()
                                ;
                            hv_Size_COPY_INP_TMP.Dispose();
                            hv_Size_COPY_INP_TMP = ExpTmpLocalVar_Size;
                        }
                    }
                }
                else
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Size = hv_Size_COPY_INP_TMP.TupleInt()
                                ;
                            hv_Size_COPY_INP_TMP.Dispose();
                            hv_Size_COPY_INP_TMP = ExpTmpLocalVar_Size;
                        }
                    }
                }
                if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("Courier"))) != 0)
                {
                    hv_Fonts.Dispose();
                    hv_Fonts = new HTuple();
                    hv_Fonts[0] = "Courier";
                    hv_Fonts[1] = "Courier 10 Pitch";
                    hv_Fonts[2] = "Courier New";
                    hv_Fonts[3] = "CourierNew";
                    hv_Fonts[4] = "Liberation Mono";
                }
                else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("mono"))) != 0)
                {
                    hv_Fonts.Dispose();
                    hv_Fonts = new HTuple();
                    hv_Fonts[0] = "Consolas";
                    hv_Fonts[1] = "Menlo";
                    hv_Fonts[2] = "Courier";
                    hv_Fonts[3] = "Courier 10 Pitch";
                    hv_Fonts[4] = "FreeMono";
                    hv_Fonts[5] = "Liberation Mono";
                }
                else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("sans"))) != 0)
                {
                    hv_Fonts.Dispose();
                    hv_Fonts = new HTuple();
                    hv_Fonts[0] = "Luxi Sans";
                    hv_Fonts[1] = "DejaVu Sans";
                    hv_Fonts[2] = "FreeSans";
                    hv_Fonts[3] = "Arial";
                    hv_Fonts[4] = "Liberation Sans";
                }
                else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("serif"))) != 0)
                {
                    hv_Fonts.Dispose();
                    hv_Fonts = new HTuple();
                    hv_Fonts[0] = "Times New Roman";
                    hv_Fonts[1] = "Luxi Serif";
                    hv_Fonts[2] = "DejaVu Serif";
                    hv_Fonts[3] = "FreeSerif";
                    hv_Fonts[4] = "Utopia";
                    hv_Fonts[5] = "Liberation Serif";
                }
                else
                {
                    hv_Fonts.Dispose();
                    hv_Fonts = new HTuple(hv_Font_COPY_INP_TMP);
                }
                hv_Style.Dispose();
                hv_Style = "";
                if ((int)(new HTuple(hv_Bold.TupleEqual("true"))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Style = hv_Style + "Bold";
                            hv_Style.Dispose();
                            hv_Style = ExpTmpLocalVar_Style;
                        }
                    }
                }
                else if ((int)(new HTuple(hv_Bold.TupleNotEqual("false"))) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "Wrong value of control parameter Bold";
                    throw new HalconException(hv_Exception);
                }
                if ((int)(new HTuple(hv_Slant.TupleEqual("true"))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Style = hv_Style + "Italic";
                            hv_Style.Dispose();
                            hv_Style = ExpTmpLocalVar_Style;
                        }
                    }
                }
                else if ((int)(new HTuple(hv_Slant.TupleNotEqual("false"))) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "Wrong value of control parameter Slant";
                    throw new HalconException(hv_Exception);
                }
                if ((int)(new HTuple(hv_Style.TupleEqual(""))) != 0)
                {
                    hv_Style.Dispose();
                    hv_Style = "Normal";
                }
                hv_AvailableFonts.Dispose();
                HOperatorSet.QueryFont(hv_WindowHandle, out hv_AvailableFonts);
                hv_Font_COPY_INP_TMP.Dispose();
                hv_Font_COPY_INP_TMP = "";
                for (hv_Fdx = 0; (int)hv_Fdx <= (int)((new HTuple(hv_Fonts.TupleLength())) - 1); hv_Fdx = (int)hv_Fdx + 1)
                {
                    hv_Indices.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Indices = hv_AvailableFonts.TupleFind(
                            hv_Fonts.TupleSelect(hv_Fdx));
                    }
                    if ((int)(new HTuple((new HTuple(hv_Indices.TupleLength())).TupleGreater(
                        0))) != 0)
                    {
                        if ((int)(new HTuple(((hv_Indices.TupleSelect(0))).TupleGreaterEqual(0))) != 0)
                        {
                            hv_Font_COPY_INP_TMP.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Font_COPY_INP_TMP = hv_Fonts.TupleSelect(
                                    hv_Fdx);
                            }
                            break;
                        }
                    }
                }
                if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual(""))) != 0)
                {
                    throw new HalconException("Wrong value of control parameter Font");
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_Font = (((hv_Font_COPY_INP_TMP + "-") + hv_Style) + "-") + hv_Size_COPY_INP_TMP;
                        hv_Font_COPY_INP_TMP.Dispose();
                        hv_Font_COPY_INP_TMP = ExpTmpLocalVar_Font;
                    }
                }
                HOperatorSet.SetFont(hv_WindowHandle, hv_Font_COPY_INP_TMP);

                hv_Font_COPY_INP_TMP.Dispose();
                hv_Size_COPY_INP_TMP.Dispose();
                hv_OS.Dispose();
                hv_Fonts.Dispose();
                hv_Style.Dispose();
                hv_Exception.Dispose();
                hv_AvailableFonts.Dispose();
                hv_Fdx.Dispose();
                hv_Indices.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Font_COPY_INP_TMP.Dispose();
                hv_Size_COPY_INP_TMP.Dispose();
                hv_OS.Dispose();
                hv_Fonts.Dispose();
                hv_Style.Dispose();
                hv_Exception.Dispose();
                hv_AvailableFonts.Dispose();
                hv_Fdx.Dispose();
                hv_Indices.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Set the maximum batch size for a given DLModelHandle and GPU. 
        public void set_dl_model_param_max_gpu_batch_size(HTuple hv_DLModelHandle, HTuple hv_BatchSizeUpperBound)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ModelType = new HTuple(), hv_GpuID = new HTuple();
            HTuple hv_DLDeviceOrig = new HTuple(), hv_DLDeviceGPU = new HTuple();
            HTuple hv_DLDeviceCPU = new HTuple(), hv_SerializedItemHandle = new HTuple();
            HTuple hv_OriginalModel = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_BatchSizeTestL = new HTuple(), hv_BatchSizeTestR = new HTuple();
            HTuple hv_BatchSizeTest = new HTuple(), hv_ErrorHint = new HTuple();
            HTuple hv_ExceptionThrown = new HTuple(), hv_TrainSamples = new HTuple();
            HTuple hv_TrainResult = new HTuple(), hv_BatchSize = new HTuple();
            HTuple hv_DLModelHandle_COPY_INP_TMP = new HTuple(hv_DLModelHandle);

            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure sets the batch size of the deep-learning-based model DLModelHandle
                //to the maximum possible value given the current GPU memory.
                //
                hv_ModelType.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle_COPY_INP_TMP, "type", out hv_ModelType);
                if ((int)((new HTuple((new HTuple(hv_ModelType.TupleNotEqual("classification"))).TupleAnd(
                    new HTuple(hv_ModelType.TupleNotEqual("detection"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual(
                    "segmentation")))) != 0)
                {
                    throw new HalconException(new HTuple("Not implemented. Currently, this procedure only works for ") + new HTuple("classification, detection, and segmentation models."));
                }
                //Get the current GPU ID of the model and get the according GPU device.
                hv_GpuID.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle_COPY_INP_TMP, "gpu", out hv_GpuID);
                hv_DLDeviceOrig.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle_COPY_INP_TMP, "device", out hv_DLDeviceOrig);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_DLDeviceGPU.Dispose();
                    HOperatorSet.QueryAvailableDlDevices((new HTuple("runtime")).TupleConcat("id"),
                        (new HTuple("gpu")).TupleConcat(hv_GpuID), out hv_DLDeviceGPU);
                }
                try
                {
                    //First we free the GPU memory completely to get a clean model.
                    //Note, this only works for hardware where 'cpu' is available.
                    hv_DLDeviceCPU.Dispose();
                    HOperatorSet.QueryAvailableDlDevices("runtime", "cpu", out hv_DLDeviceCPU);
                    HOperatorSet.SetDlModelParam(hv_DLModelHandle_COPY_INP_TMP, "device", hv_DLDeviceCPU);
                    HOperatorSet.SetDlModelParam(hv_DLModelHandle_COPY_INP_TMP, "batch_size",
                        1);
                    //
                    //Create a copy which we want to use so that we do not modify the original model.
                    hv_SerializedItemHandle.Dispose();
                    HOperatorSet.SerializeDlModel(hv_DLModelHandle_COPY_INP_TMP, out hv_SerializedItemHandle);
                    hv_OriginalModel.Dispose();
                    hv_OriginalModel = new HTuple(hv_DLModelHandle_COPY_INP_TMP);
                    hv_DLModelHandle_COPY_INP_TMP.Dispose();
                    HOperatorSet.DeserializeDlModel(hv_SerializedItemHandle, out hv_DLModelHandle_COPY_INP_TMP);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    //In case no CPU hardware is available we try to find maximum batch size
                    //directly.
                    hv_OriginalModel.Dispose();
                    hv_OriginalModel = new HTuple();
                }
                //
                //Initialize the bounds.
                hv_BatchSizeTestL.Dispose();
                hv_BatchSizeTestL = 1;
                hv_BatchSizeTestR.Dispose();
                hv_BatchSizeTestR = new HTuple(hv_BatchSizeUpperBound);
                hv_BatchSizeTest.Dispose();
                hv_BatchSizeTest = new HTuple(hv_BatchSizeUpperBound);
                try
                {
                    //Set initial batch size to 1. This has to work. Otherwise an exception is thrown.
                    HOperatorSet.SetDlModelParam(hv_DLModelHandle_COPY_INP_TMP, "batch_size",
                        hv_BatchSizeTestL);
                    HOperatorSet.SetDlModelParam(hv_DLModelHandle_COPY_INP_TMP, "device", hv_DLDeviceGPU);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    if ((int)((new HTuple(((hv_Exception.TupleSelect(0))).TupleNotEqual(4104))).TupleAnd(
                        new HTuple(((hv_Exception.TupleSelect(0))).TupleNotEqual(4201)))) != 0)
                    {
                        //Not an out of CUDA memory or cuDNN error. Hence, throw.
                        throw new HalconException(hv_Exception);
                    }
                    if ((int)((new HTuple((new HTuple(hv_ModelType.TupleEqual("classification"))).TupleOr(
                        new HTuple(hv_ModelType.TupleEqual("detection"))))).TupleOr(new HTuple(hv_ModelType.TupleEqual(
                        "segmentation")))) != 0)
                    {
                        hv_ErrorHint.Dispose();
                        hv_ErrorHint = "Try to reduce image_dimension or use a GPU with more RAM.";
                    }
                    else
                    {
                        hv_ErrorHint.Dispose();
                        hv_ErrorHint = "Try to use a GPU with more RAM.";
                    }
                    throw new HalconException("Error while trying to find the maximum batch size. Even the minimum (1) does not fit into memory. " + hv_ErrorHint);

                    hv_DLModelHandle_COPY_INP_TMP.Dispose();
                    hv_ModelType.Dispose();
                    hv_GpuID.Dispose();
                    hv_DLDeviceOrig.Dispose();
                    hv_DLDeviceGPU.Dispose();
                    hv_DLDeviceCPU.Dispose();
                    hv_SerializedItemHandle.Dispose();
                    hv_OriginalModel.Dispose();
                    hv_Exception.Dispose();
                    hv_BatchSizeTestL.Dispose();
                    hv_BatchSizeTestR.Dispose();
                    hv_BatchSizeTest.Dispose();
                    hv_ErrorHint.Dispose();
                    hv_ExceptionThrown.Dispose();
                    hv_TrainSamples.Dispose();
                    hv_TrainResult.Dispose();
                    hv_BatchSize.Dispose();

                    return;
                }
                //
                //Loop as long as we have not found the maximum batch size for the available GPU memory.
                while ((int)(new HTuple(((hv_BatchSizeTestR - hv_BatchSizeTestL)).TupleGreater(
                    1))) != 0)
                {
                    //
                    //Check if an exception is thrown due to out of memory errors.
                    hv_ExceptionThrown.Dispose();
                    hv_ExceptionThrown = 0;
                    try
                    {
                        //Try to set the batch size.
                        HOperatorSet.SetDlModelParam(hv_DLModelHandle_COPY_INP_TMP, "batch_size",
                            hv_BatchSizeTest);
                        //
                        //Even if the batch size setting works it might be that a train step fails
                        //because during training more data is needed.
                        //
                        //Hence, generate blank train samples here.
                        hv_TrainSamples.Dispose();
                        gen_blank_dl_train_samples(hv_DLModelHandle_COPY_INP_TMP, out hv_TrainSamples);
                        //
                        //Do a few train steps to get the training data initialized.
                        hv_TrainResult.Dispose();
                        HOperatorSet.TrainDlModelBatch(hv_DLModelHandle_COPY_INP_TMP, hv_TrainSamples,
                            out hv_TrainResult);
                        hv_TrainResult.Dispose();
                        HOperatorSet.TrainDlModelBatch(hv_DLModelHandle_COPY_INP_TMP, hv_TrainSamples,
                            out hv_TrainResult);
                        hv_TrainResult.Dispose();
                        HOperatorSet.TrainDlModelBatch(hv_DLModelHandle_COPY_INP_TMP, hv_TrainSamples,
                            out hv_TrainResult);
                    }
                    // catch (Exception) 
                    catch (HalconException HDevExpDefaultException1)
                    {
                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        if ((int)((new HTuple(((hv_Exception.TupleSelect(0))).TupleNotEqual(4104))).TupleAnd(
                            new HTuple(((hv_Exception.TupleSelect(0))).TupleNotEqual(4201)))) != 0)
                        {
                            //Not an out of CUDA memory or cuDNN error. Hence, throw.
                            throw new HalconException(hv_Exception);
                        }
                        //Update the upper bound.
                        hv_BatchSizeTestR.Dispose();
                        hv_BatchSizeTestR = new HTuple(hv_BatchSizeTest);
                        hv_ExceptionThrown.Dispose();
                        hv_ExceptionThrown = 1;
                    }
                    if ((int)(hv_ExceptionThrown.TupleNot()) != 0)
                    {
                        //Update the lower bound.
                        hv_BatchSizeTestL.Dispose();
                        hv_BatchSizeTestL = new HTuple(hv_BatchSizeTest);
                    }
                    //Continue with next test.
                    hv_BatchSizeTest.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_BatchSizeTest = hv_BatchSizeTestL + ((hv_BatchSizeTestR - hv_BatchSizeTestL) / 2);
                    }
                }
                hv_BatchSize.Dispose();
                hv_BatchSize = new HTuple(hv_BatchSizeTest);
                //In case we used a copy we clear it.
                if ((int)(new HTuple((new HTuple(hv_OriginalModel.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    HOperatorSet.ClearDlModel(hv_DLModelHandle_COPY_INP_TMP);
                    //Use the original model again.
                    hv_DLModelHandle_COPY_INP_TMP.Dispose();
                    hv_DLModelHandle_COPY_INP_TMP = new HTuple(hv_OriginalModel);
                }
                HOperatorSet.SetDlModelParam(hv_DLModelHandle_COPY_INP_TMP, "device", hv_DLDeviceOrig);
                HOperatorSet.SetDlModelParam(hv_DLModelHandle_COPY_INP_TMP, "batch_size", hv_BatchSize);
                //

                hv_DLModelHandle_COPY_INP_TMP.Dispose();
                hv_ModelType.Dispose();
                hv_GpuID.Dispose();
                hv_DLDeviceOrig.Dispose();
                hv_DLDeviceGPU.Dispose();
                hv_DLDeviceCPU.Dispose();
                hv_SerializedItemHandle.Dispose();
                hv_OriginalModel.Dispose();
                hv_Exception.Dispose();
                hv_BatchSizeTestL.Dispose();
                hv_BatchSizeTestR.Dispose();
                hv_BatchSizeTest.Dispose();
                hv_ErrorHint.Dispose();
                hv_ExceptionThrown.Dispose();
                hv_TrainSamples.Dispose();
                hv_TrainResult.Dispose();
                hv_BatchSize.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_DLModelHandle_COPY_INP_TMP.Dispose();
                hv_ModelType.Dispose();
                hv_GpuID.Dispose();
                hv_DLDeviceOrig.Dispose();
                hv_DLDeviceGPU.Dispose();
                hv_DLDeviceCPU.Dispose();
                hv_SerializedItemHandle.Dispose();
                hv_OriginalModel.Dispose();
                hv_Exception.Dispose();
                hv_BatchSizeTestL.Dispose();
                hv_BatchSizeTestR.Dispose();
                hv_BatchSizeTest.Dispose();
                hv_ErrorHint.Dispose();
                hv_ExceptionThrown.Dispose();
                hv_TrainSamples.Dispose();
                hv_TrainResult.Dispose();
                hv_BatchSize.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Time
        // Short Description: Create a formatted string of a time span. 
        public void timespan_string(HTuple hv_TotalSeconds, HTuple hv_Format, out HTuple hv_TimeString)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Seconds = new HTuple(), hv_TotalMinutes = new HTuple();
            HTuple hv_Minutes = new HTuple(), hv_TotalHours = new HTuple();
            HTuple hv_Hours = new HTuple(), hv_Days = new HTuple();
            HTuple hv_TotalSeconds_COPY_INP_TMP = new HTuple(hv_TotalSeconds);

            // Initialize local and output iconic variables 
            hv_TimeString = new HTuple();
            try
            {
                //
                //This procedure creates a readable representation of a time span
                //given the elapsed time in seconds.
                //
                //Ensure that the input is an integer.
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_TotalSeconds = hv_TotalSeconds_COPY_INP_TMP.TupleInt()
                            ;
                        hv_TotalSeconds_COPY_INP_TMP.Dispose();
                        hv_TotalSeconds_COPY_INP_TMP = ExpTmpLocalVar_TotalSeconds;
                    }
                }
                //
                hv_Seconds.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Seconds = hv_TotalSeconds_COPY_INP_TMP % 60;
                }
                //
                hv_TotalMinutes.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TotalMinutes = hv_TotalSeconds_COPY_INP_TMP / 60;
                }
                hv_Minutes.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Minutes = hv_TotalMinutes % 60;
                }
                //
                hv_TotalHours.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_TotalHours = hv_TotalSeconds_COPY_INP_TMP / 3600;
                }
                hv_Hours.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Hours = hv_TotalHours % 24;
                }
                //
                hv_Days.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_Days = hv_TotalSeconds_COPY_INP_TMP / 86400;
                }
                //
                if ((int)(new HTuple(hv_Format.TupleEqual("auto"))) != 0)
                {
                    //Print the highest non-zero unit and all remaining sub-units.
                    if ((int)(new HTuple(hv_Days.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (((((((hv_Days.TupleString(
                                "d")) + "d ") + (hv_Hours.TupleString("d"))) + "h ") + (hv_Minutes.TupleString(
                                "d"))) + "m ") + (hv_Seconds.TupleString("d"))) + "s";
                        }
                    }
                    else if ((int)(new HTuple(hv_Hours.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (((((hv_Hours.TupleString(
                                "d")) + "h ") + (hv_Minutes.TupleString("d"))) + "m ") + (hv_Seconds.TupleString(
                                "d"))) + "s";
                        }
                    }
                    else if ((int)(new HTuple(hv_Minutes.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (((hv_Minutes.TupleString(
                                "d")) + "m ") + (hv_Seconds.TupleString("d"))) + "s";
                        }
                    }
                    else
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (hv_Seconds.TupleString(
                                "d")) + "s";
                        }
                    }
                }
                else if ((int)(new HTuple(hv_Format.TupleEqual("top1"))) != 0)
                {
                    //Print the highest non-zero unit.
                    if ((int)(new HTuple(hv_Days.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (hv_Days.TupleString(
                                "d")) + "d";
                        }
                    }
                    else if ((int)(new HTuple(hv_Hours.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (hv_Hours.TupleString(
                                "d")) + "h";
                        }
                    }
                    else if ((int)(new HTuple(hv_Minutes.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (hv_Minutes.TupleString(
                                "d")) + "m";
                        }
                    }
                    else
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (hv_Seconds.TupleString(
                                "d")) + "s";
                        }
                    }
                }
                else if ((int)(new HTuple(hv_Format.TupleEqual("top2"))) != 0)
                {
                    //Print the highest non-zero unit and the following sub-unit.
                    if ((int)(new HTuple(hv_Days.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (((hv_Days.TupleString(
                                "d")) + "d ") + (hv_Hours.TupleString("d"))) + "h";
                        }
                    }
                    else if ((int)(new HTuple(hv_Hours.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (((hv_Hours.TupleString(
                                "d")) + "h ") + (hv_Minutes.TupleString("d"))) + "m";
                        }
                    }
                    else if ((int)(new HTuple(hv_Minutes.TupleGreater(0))) != 0)
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (((hv_Minutes.TupleString(
                                "d")) + "m ") + (hv_Seconds.TupleString("d"))) + "s";
                        }
                    }
                    else
                    {
                        hv_TimeString.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_TimeString = (hv_Seconds.TupleString(
                                "d")) + "s";
                        }
                    }
                }
                else if ((int)(new HTuple(hv_Format.TupleEqual("dhms"))) != 0)
                {
                    //Print a Days-Hours-Minutes-Seconds string.
                    hv_TimeString.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TimeString = (((((((hv_Days.TupleString(
                            "d")) + "d ") + (hv_Hours.TupleString("d"))) + "h ") + (hv_Minutes.TupleString(
                            "d"))) + "m ") + (hv_Seconds.TupleString("d"))) + "s";
                    }
                }
                else if ((int)(new HTuple(hv_Format.TupleEqual("hms"))) != 0)
                {
                    //Print a Hours-Minutes-Seconds string, where hours can be >= 24.
                    hv_TimeString.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TimeString = (((((hv_TotalHours.TupleString(
                            "d")) + "h ") + (hv_Minutes.TupleString("d"))) + "m ") + (hv_Seconds.TupleString(
                            "d"))) + "s";
                    }
                }
                else
                {
                    throw new HalconException("Unknown format string.");
                }
                //

                hv_TotalSeconds_COPY_INP_TMP.Dispose();
                hv_Seconds.Dispose();
                hv_TotalMinutes.Dispose();
                hv_Minutes.Dispose();
                hv_TotalHours.Dispose();
                hv_Hours.Dispose();
                hv_Days.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_TotalSeconds_COPY_INP_TMP.Dispose();
                hv_Seconds.Dispose();
                hv_TotalMinutes.Dispose();
                hv_Minutes.Dispose();
                hv_TotalHours.Dispose();
                hv_Hours.Dispose();
                hv_Days.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Train a deep-learning-based model on a dataset. 
        public void train_dl_model(HTuple hv_DLDataset, HTuple hv_DLModelHandle, HTuple hv_TrainParam,
            HTuple hv_StartEpoch, out HTuple hv_TrainResults, out HTuple hv_TrainInfos,
            out HTuple hv_EvaluationInfos)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ModelType = new HTuple(), hv_DLSamples = new HTuple();
            HTuple hv_TrainSampleIndices = new HTuple(), hv_NumTrainSamples = new HTuple();
            HTuple hv_NumEpochs = new HTuple(), hv_SeedRand = new HTuple();
            HTuple hv_SampleIndicesTrainRaw = new HTuple(), hv_Index = new HTuple();
            HTuple hv_Shuffled = new HTuple(), hv_SampleSeedsTrainRaw = new HTuple();
            HTuple hv_BatchSize = new HTuple(), hv_ChangeStrategyData = new HTuple();
            HTuple hv_SerializationData = new HTuple(), hv_DisplayData = new HTuple();
            HTuple hv_DisplayEnabled = new HTuple(), hv_DisplayPreviewInitialized = new HTuple();
            HTuple hv_DisplayEvaluationEpochs = new HTuple(), hv_DisplayValidationEvaluationValues = new HTuple();
            HTuple hv_DisplayTrainEvaluationValues = new HTuple();
            HTuple hv_DisplayLossEpochs = new HTuple(), hv_DisplayLoss = new HTuple();
            HTuple hv_DisplayLearningRates = new HTuple(), hv_TrainResultsRestored = new HTuple();
            HTuple hv_StartTime = new HTuple(), hv_FirstIteration = new HTuple();
            HTuple hv_Epoch = new HTuple(), hv_Iteration = new HTuple();
            HTuple hv_NumIterationsPerEpoch = new HTuple(), hv_BatchSizeDevice = new HTuple();
            HTuple hv_BatchSizeMultiplier = new HTuple(), hv_BatchSizeModel = new HTuple();
            HTuple hv_NumIterations = new HTuple(), hv_SampleIndicesTrain = new HTuple();
            HTuple hv_BatchStart = new HTuple(), hv_BatchEnd = new HTuple();
            HTuple hv_BatchIndices = new HTuple(), hv_DLSampleBatch = new HTuple();
            HTuple hv_AugmentationParam = new HTuple(), hv_TrainResult = new HTuple();
            HTuple hv_EvaluationIntervalEpochs = new HTuple(), hv_EvaluationInterval = new HTuple();
            HTuple hv_ValidationEvaluationResult = new HTuple(), hv_TrainEvaluationResult = new HTuple();
            HTuple hv_DisplayParam = new HTuple(), hv_SelectPercentageTrainSamples = new HTuple();
            HTuple hv_EvaluationParam = new HTuple(), hv__ = new HTuple();
            HTuple hv_TrainEvaluationSampleIndices = new HTuple();
            HTuple hv_TrainEvaluationRatio = new HTuple(), hv_NumTrainEvaluationSampleIndices = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_EvaluationInfo = new HTuple();
            HTuple hv_EvaluationComparisonKeys = new HTuple(), hv_Valuevalidation = new HTuple();
            HTuple hv_ValueTrain = new HTuple(), hv_TrainInfoUpdateIntervalSeconds = new HTuple();
            HTuple hv_LastUpdate = new HTuple(), hv_Seconds = new HTuple();
            HTuple hv_NumSamplesMeanLoss = new HTuple(), hv_TrainInfo = new HTuple();
            HTuple hv_UpdateTime = new HTuple(), hv_EpochsStatus = new HTuple();
            HTuple hv_MeanLoss = new HTuple(), hv_DisplayLearningRate = new HTuple();
            HTuple hv_UpdateImagesIntervalEpochs = new HTuple(), hv_UpdateImagesInterval = new HTuple();
            HTuple hv_WindowImages = new HTuple(), hv_FirstCall = new HTuple();
            HTuple hv_NumImages = new HTuple(), hv_GenParamTiled = new HTuple();
            HTuple hv_TrainParamAnomaly = new HTuple(), hv_EnableDisplay = new HTuple();
            HTuple hv_WindowHandleInfo = new HTuple();
            HTuple hv_StartEpoch_COPY_INP_TMP = new HTuple(hv_StartEpoch);

            // Initialize local and output iconic variables 
            hv_TrainResults = new HTuple();
            hv_TrainInfos = new HTuple();
            hv_EvaluationInfos = new HTuple();
            try
            {
                //
                //This procedure contains all steps for training a model given through DLModelHandle
                //on a dataset DLDataset.
                //The required training parameters are provided through the dictionary TrainParam,
                //which can be created by create_dl_train_param.
                //The training is started at StartEpoch, which allows resuming the training of a model.
                //In case of models of type 'anomaly_detection', training cannot be resumed and hence,
                //StartEpoch is always 0.
                //
                //The procedure returns three dictionaries:
                //- TrainResults: Collected results returned by train_dl_model_batch of every iteration.
                //                For models of type 'anomaly_detection': The final error and the final epoch.
                //- TrainInfo: Collected information of the training progress. This dictionary is empty
                //             for models of type 'anomaly_detection'.
                //- EvaluationInfos: Evaluation results collected during training. This dictionary is empty
                //                   for models of type 'anomaly_detection'.
                //
                //Get the model type.
                hv_ModelType.Dispose();
                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "type", out hv_ModelType);
                if ((int)((new HTuple((new HTuple((new HTuple(hv_ModelType.TupleNotEqual("classification"))).TupleAnd(
                    new HTuple(hv_ModelType.TupleNotEqual("detection"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual(
                    "segmentation"))))).TupleAnd(new HTuple(hv_ModelType.TupleNotEqual("anomaly_detection")))) != 0)
                {
                    throw new HalconException("Invalid model type");
                }
                //
                //Get the samples for training.
                hv_DLSamples.Dispose();
                HOperatorSet.GetDictTuple(hv_DLDataset, "samples", out hv_DLSamples);
                hv_TrainSampleIndices.Dispose();
                find_dl_samples(hv_DLSamples, "split", "train", "match", out hv_TrainSampleIndices);
                hv_NumTrainSamples.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumTrainSamples = new HTuple(hv_TrainSampleIndices.TupleLength()
                        );
                }
                //
                //Check inconsistent training parameters.
                check_train_dl_model_params(hv_DLDataset, hv_DLModelHandle, hv_NumTrainSamples,
                    hv_StartEpoch_COPY_INP_TMP, hv_TrainParam);
                //
                if ((int)((new HTuple((new HTuple(hv_ModelType.TupleEqual("classification"))).TupleOr(
                    new HTuple(hv_ModelType.TupleEqual("detection"))))).TupleOr(new HTuple(hv_ModelType.TupleEqual(
                    "segmentation")))) != 0)
                {
                    //
                    //Check if training is required.
                    hv_NumEpochs.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainParam, "num_epochs", out hv_NumEpochs);
                    if ((int)(hv_StartEpoch_COPY_INP_TMP.TupleIsNumber()) != 0)
                    {
                        if ((int)(new HTuple(hv_StartEpoch_COPY_INP_TMP.TupleGreaterEqual(hv_NumEpochs))) != 0)
                        {
                            //Nothing to do.

                            hv_StartEpoch_COPY_INP_TMP.Dispose();
                            hv_ModelType.Dispose();
                            hv_DLSamples.Dispose();
                            hv_TrainSampleIndices.Dispose();
                            hv_NumTrainSamples.Dispose();
                            hv_NumEpochs.Dispose();
                            hv_SeedRand.Dispose();
                            hv_SampleIndicesTrainRaw.Dispose();
                            hv_Index.Dispose();
                            hv_Shuffled.Dispose();
                            hv_SampleSeedsTrainRaw.Dispose();
                            hv_BatchSize.Dispose();
                            hv_ChangeStrategyData.Dispose();
                            hv_SerializationData.Dispose();
                            hv_DisplayData.Dispose();
                            hv_DisplayEnabled.Dispose();
                            hv_DisplayPreviewInitialized.Dispose();
                            hv_DisplayEvaluationEpochs.Dispose();
                            hv_DisplayValidationEvaluationValues.Dispose();
                            hv_DisplayTrainEvaluationValues.Dispose();
                            hv_DisplayLossEpochs.Dispose();
                            hv_DisplayLoss.Dispose();
                            hv_DisplayLearningRates.Dispose();
                            hv_TrainResultsRestored.Dispose();
                            hv_StartTime.Dispose();
                            hv_FirstIteration.Dispose();
                            hv_Epoch.Dispose();
                            hv_Iteration.Dispose();
                            hv_NumIterationsPerEpoch.Dispose();
                            hv_BatchSizeDevice.Dispose();
                            hv_BatchSizeMultiplier.Dispose();
                            hv_BatchSizeModel.Dispose();
                            hv_NumIterations.Dispose();
                            hv_SampleIndicesTrain.Dispose();
                            hv_BatchStart.Dispose();
                            hv_BatchEnd.Dispose();
                            hv_BatchIndices.Dispose();
                            hv_DLSampleBatch.Dispose();
                            hv_AugmentationParam.Dispose();
                            hv_TrainResult.Dispose();
                            hv_EvaluationIntervalEpochs.Dispose();
                            hv_EvaluationInterval.Dispose();
                            hv_ValidationEvaluationResult.Dispose();
                            hv_TrainEvaluationResult.Dispose();
                            hv_DisplayParam.Dispose();
                            hv_SelectPercentageTrainSamples.Dispose();
                            hv_EvaluationParam.Dispose();
                            hv__.Dispose();
                            hv_TrainEvaluationSampleIndices.Dispose();
                            hv_TrainEvaluationRatio.Dispose();
                            hv_NumTrainEvaluationSampleIndices.Dispose();
                            hv_Exception.Dispose();
                            hv_EvaluationInfo.Dispose();
                            hv_EvaluationComparisonKeys.Dispose();
                            hv_Valuevalidation.Dispose();
                            hv_ValueTrain.Dispose();
                            hv_TrainInfoUpdateIntervalSeconds.Dispose();
                            hv_LastUpdate.Dispose();
                            hv_Seconds.Dispose();
                            hv_NumSamplesMeanLoss.Dispose();
                            hv_TrainInfo.Dispose();
                            hv_UpdateTime.Dispose();
                            hv_EpochsStatus.Dispose();
                            hv_MeanLoss.Dispose();
                            hv_DisplayLearningRate.Dispose();
                            hv_UpdateImagesIntervalEpochs.Dispose();
                            hv_UpdateImagesInterval.Dispose();
                            hv_WindowImages.Dispose();
                            hv_FirstCall.Dispose();
                            hv_NumImages.Dispose();
                            hv_GenParamTiled.Dispose();
                            hv_TrainParamAnomaly.Dispose();
                            hv_EnableDisplay.Dispose();
                            hv_WindowHandleInfo.Dispose();

                            return;
                        }
                    }
                    //
                    //Set random seed according to parameter value.
                    hv_SeedRand.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainParam, "seed_rand", out hv_SeedRand);
                    if ((int)(new HTuple((new HTuple(hv_SeedRand.TupleLength())).TupleGreater(
                        0))) != 0)
                    {
                        //Note, that setting this random seed will not enforce every training to
                        //result in the exact same model because the cuDNN library uses approximate
                        //algorithms on some architectures.
                        //If you want to enforce bit-wise reproducibility, you should also set:
                        //   'set_system('cudnn_deterministic', 'true')'
                        //However, this can slow down computations on some architectures.
                        HOperatorSet.SetSystem("seed_rand", hv_SeedRand);
                    }
                    //
                    //Generate a random sample index for the whole training independent of batch size.
                    hv_SampleIndicesTrainRaw.Dispose();
                    hv_SampleIndicesTrainRaw = new HTuple();
                    HTuple end_val56 = (hv_NumEpochs.TupleCeil()
                        ) - 1;
                    HTuple step_val56 = 1;
                    for (hv_Index = 0; hv_Index.Continue(end_val56, step_val56); hv_Index = hv_Index.TupleAdd(step_val56))
                    {
                        hv_Shuffled.Dispose();
                        tuple_shuffle(hv_TrainSampleIndices, out hv_Shuffled);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_SampleIndicesTrainRaw = hv_SampleIndicesTrainRaw.TupleConcat(
                                    hv_Shuffled);
                                hv_SampleIndicesTrainRaw.Dispose();
                                hv_SampleIndicesTrainRaw = ExpTmpLocalVar_SampleIndicesTrainRaw;
                            }
                        }
                    }
                    //
                    //Generate a random seed pool for the whole training independent of batch size.
                    hv_SampleSeedsTrainRaw.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SampleSeedsTrainRaw = (new HTuple((((new HTuple(2)).TuplePow(
                            31)) - 1) * HTuple.TupleRand(new HTuple(hv_SampleIndicesTrainRaw.TupleLength()
                            )))).TupleInt();
                    }
                    //
                    //Initialize the variables for the training.
                    //
                    //Initialize the batch size with an invalid value so that
                    //the while loop will initialize all values directly.
                    hv_BatchSize.Dispose();
                    hv_BatchSize = -1;
                    //
                    //Initialize change strategies.
                    hv_ChangeStrategyData.Dispose();
                    init_train_dl_model_change_strategies(hv_TrainParam, out hv_ChangeStrategyData);
                    //
                    //Initialize serialization strategies.
                    hv_SerializationData.Dispose();
                    init_train_dl_model_serialization_strategies(hv_TrainParam, out hv_SerializationData);
                    //
                    //Initialize visualizations if enabled.
                    hv_DisplayData.Dispose();
                    dev_display_init_train_dl_model(hv_DLModelHandle, hv_TrainParam, out hv_DisplayData);
                    hv_DisplayEnabled.Dispose();
                    HOperatorSet.GetDictTuple(hv_DisplayData, "enabled", out hv_DisplayEnabled);
                    hv_DisplayPreviewInitialized.Dispose();
                    hv_DisplayPreviewInitialized = 0;
                    //
                    //Initialize parameters to start new or resume previous training.
                    hv_EvaluationInfos.Dispose(); hv_TrainInfos.Dispose(); hv_DisplayEvaluationEpochs.Dispose(); hv_DisplayValidationEvaluationValues.Dispose(); hv_DisplayTrainEvaluationValues.Dispose(); hv_DisplayLossEpochs.Dispose(); hv_DisplayLoss.Dispose(); hv_DisplayLearningRates.Dispose(); hv_TrainResultsRestored.Dispose();
                    {
                        HTuple ExpTmpOutVar_0;
                        restore_dl_train_info_for_resuming(hv_StartEpoch_COPY_INP_TMP, hv_SerializationData,
                            hv_TrainParam, hv_DisplayData, out hv_EvaluationInfos, out hv_TrainInfos,
                            out hv_DisplayEvaluationEpochs, out hv_DisplayValidationEvaluationValues,
                            out hv_DisplayTrainEvaluationValues, out hv_DisplayLossEpochs, out hv_DisplayLoss,
                            out hv_DisplayLearningRates, out hv_TrainResultsRestored, out ExpTmpOutVar_0);
                        hv_StartEpoch_COPY_INP_TMP.Dispose();
                        hv_StartEpoch_COPY_INP_TMP = ExpTmpOutVar_0;
                    }
                    //
                    //Start time for measurement of elapsed training time.
                    hv_StartTime.Dispose();
                    HOperatorSet.CountSeconds(out hv_StartTime);
                    //
                    //The while loop needs to know if it is the very first iteration.
                    hv_FirstIteration.Dispose();
                    hv_FirstIteration = 1;
                    while ((int)(1) != 0)
                    {
                        //Do some initializations only for the very first iteration.
                        if ((int)(hv_FirstIteration) != 0)
                        {
                            //Jump to StartEpoch (Default: 0 but it could be used to resume training at given StartIteration).
                            hv_Epoch.Dispose();
                            hv_Epoch = new HTuple(hv_StartEpoch_COPY_INP_TMP);
                        }
                        else
                        {
                            hv_Epoch.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Epoch = (hv_Iteration + 1) / (hv_NumIterationsPerEpoch.TupleReal()
                                    );
                            }
                        }
                        //
                        //Update any parameters based on strategies.
                        update_train_dl_model_change_strategies(hv_DLModelHandle, hv_ChangeStrategyData,
                            hv_Epoch);
                        //
                        //Check if the current batch size and total model batch size differ.
                        hv_BatchSizeDevice.Dispose();
                        HOperatorSet.GetDlModelParam(hv_DLModelHandle, "batch_size", out hv_BatchSizeDevice);
                        hv_BatchSizeMultiplier.Dispose();
                        HOperatorSet.GetDlModelParam(hv_DLModelHandle, "batch_size_multiplier",
                            out hv_BatchSizeMultiplier);
                        hv_BatchSizeModel.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BatchSizeModel = hv_BatchSizeDevice * hv_BatchSizeMultiplier;
                        }
                        //
                        if ((int)((new HTuple(hv_BatchSize.TupleNotEqual(hv_BatchSizeModel))).TupleOr(
                            hv_FirstIteration)) != 0)
                        {
                            //Set the current value.
                            hv_BatchSize.Dispose();
                            hv_BatchSize = new HTuple(hv_BatchSizeModel);
                            //Now, we compute all values which are related to the batch size of the model.
                            //That way, the batch_size can be changed during the training without issues.
                            //All inputs/outputs/visualizations are based on epochs.
                            //
                            //Calculate total number of iterations.
                            hv_NumIterationsPerEpoch.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_NumIterationsPerEpoch = ((((hv_NumTrainSamples / (hv_BatchSize.TupleReal()
                                    ))).TupleFloor())).TupleInt();
                            }
                            hv_NumIterations.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_NumIterations = ((hv_NumIterationsPerEpoch * hv_NumEpochs)).TupleInt()
                                    ;
                            }
                            //Select those indices that fit into the batch size.
                            hv_SampleIndicesTrain.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_SampleIndicesTrain = hv_SampleIndicesTrainRaw.TupleSelectRange(
                                    0, (hv_NumIterations * hv_BatchSize) - 1);
                            }
                            //The TrainResults tuple will be updated every iteration.
                            //Hence, we initialize it as a constant tuple for speedup.
                            //It is based on the iterations and hence cannot be reused if the batch size changes.
                            hv_TrainResults.Dispose();
                            HOperatorSet.TupleGenConst(hv_NumIterations, -1, out hv_TrainResults);
                            if ((int)(hv_FirstIteration.TupleNot()) != 0)
                            {
                                hv_Iteration.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Iteration = (((((hv_Epoch.TupleReal()
                                        ) * hv_NumIterationsPerEpoch)).TupleFloor())).TupleInt();
                                }
                                hv_Epoch.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Epoch = (hv_Iteration + 1) / (hv_NumIterationsPerEpoch.TupleReal()
                                        );
                                }
                            }
                        }
                        //
                        //In the first iteration do some initializations.
                        if ((int)(hv_FirstIteration) != 0)
                        {
                            //Jump to StartEpoch (Default: 0 but it could be used to resume training at given StartIteration).
                            hv_Iteration.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Iteration = (((((hv_StartEpoch_COPY_INP_TMP.TupleReal()
                                    ) * hv_NumIterationsPerEpoch)).TupleFloor())).TupleInt();
                            }
                            hv_FirstIteration.Dispose();
                            hv_FirstIteration = 0;
                            if ((int)(new HTuple((((hv_Iteration * hv_BatchSize) + hv_BatchSize)).TupleGreater(
                                new HTuple(hv_SampleIndicesTrain.TupleLength())))) != 0)
                            {
                                hv_Iteration.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_Iteration = hv_NumIterations - 1;
                                }
                                break;
                            }
                            if ((int)((new HTuple(hv_StartEpoch_COPY_INP_TMP.TupleGreater(0.0))).TupleAnd(
                                new HTuple((new HTuple(hv_TrainResultsRestored.TupleLength())).TupleGreater(
                                0)))) != 0)
                            {
                                //Overwrite the first train results.
                                if ((int)(new HTuple((new HTuple(hv_TrainResultsRestored.TupleLength()
                                    )).TupleGreater(hv_Iteration))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_TrainResultsRestored = hv_TrainResultsRestored.TupleSelectRange(
                                                (new HTuple(hv_TrainResultsRestored.TupleLength())) - hv_Iteration,
                                                (new HTuple(hv_TrainResultsRestored.TupleLength())) - 1);
                                            hv_TrainResultsRestored.Dispose();
                                            hv_TrainResultsRestored = ExpTmpLocalVar_TrainResultsRestored;
                                        }
                                    }
                                }
                                if (hv_TrainResults == null)
                                    hv_TrainResults = new HTuple();
                                hv_TrainResults[HTuple.TupleGenSequence(hv_Iteration - (new HTuple(hv_TrainResultsRestored.TupleLength()
                                    )), hv_Iteration - 1, 1)] = hv_TrainResultsRestored;
                            }
                        }
                        //
                        //Generate the sample batch indices.
                        hv_BatchStart.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BatchStart = hv_Iteration * hv_BatchSize;
                        }
                        hv_BatchEnd.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BatchEnd = (hv_BatchStart + hv_BatchSize) - 1;
                        }
                        hv_BatchIndices.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_BatchIndices = hv_SampleIndicesTrain.TupleSelectRange(
                                hv_BatchStart, hv_BatchEnd);
                        }
                        //
                        //Set a random seed for the sample batch.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetSystem("seed_rand", hv_SampleSeedsTrainRaw.TupleSelect(
                                hv_BatchEnd));
                        }
                        //
                        //Read preprocessed samples.
                        hv_DLSampleBatch.Dispose();
                        read_dl_samples(hv_DLDataset, hv_BatchIndices, out hv_DLSampleBatch);
                        //
                        //Augment samples based on train parameter.
                        hv_AugmentationParam.Dispose();
                        HOperatorSet.GetDictTuple(hv_TrainParam, "augmentation_param", out hv_AugmentationParam);
                        augment_dl_samples(hv_DLSampleBatch, hv_AugmentationParam);
                        //
                        //Train the model on current batch.
                        hv_TrainResult.Dispose();
                        HOperatorSet.TrainDlModelBatch(hv_DLModelHandle, hv_DLSampleBatch, out hv_TrainResult);
                        //
                        //We store each train result.
                        if (hv_TrainResults == null)
                            hv_TrainResults = new HTuple();
                        hv_TrainResults[hv_Iteration] = hv_TrainResult;

                        //
                        //Evaluation handling.
                        hv_EvaluationIntervalEpochs.Dispose();
                        HOperatorSet.GetDictTuple(hv_TrainParam, "evaluation_interval_epochs",
                            out hv_EvaluationIntervalEpochs);
                        hv_EvaluationInterval.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_EvaluationInterval = ((((hv_EvaluationIntervalEpochs * hv_NumIterationsPerEpoch)).TupleFloor()
                                )).TupleInt();
                        }
                        hv_ValidationEvaluationResult.Dispose();
                        hv_ValidationEvaluationResult = new HTuple();
                        hv_TrainEvaluationResult.Dispose();
                        hv_TrainEvaluationResult = new HTuple();
                        hv_DisplayParam.Dispose();
                        HOperatorSet.GetDictTuple(hv_DisplayData, "display_param", out hv_DisplayParam);
                        //Get percentage of evaluated training samples from display parameters.
                        hv_SelectPercentageTrainSamples.Dispose();
                        HOperatorSet.GetDictTuple(hv_DisplayParam, "selected_percentage_train_samples",
                            out hv_SelectPercentageTrainSamples);
                        if ((int)(new HTuple(hv_EvaluationInterval.TupleGreater(0))) != 0)
                        {
                            //Evaluate the model at given intervals.
                            if ((int)((new HTuple((new HTuple((((hv_Iteration + 1) % hv_EvaluationInterval)).TupleEqual(
                                0))).TupleAnd(new HTuple(hv_Iteration.TupleNotEqual(0))))).TupleOr(
                                new HTuple(hv_Iteration.TupleEqual(hv_NumIterations - 1)))) != 0)
                            {
                                hv_EvaluationParam.Dispose();
                                HOperatorSet.GetDictTuple(hv_TrainParam, "evaluation_param", out hv_EvaluationParam);
                                //Evaluate on validation split.
                                hv_ValidationEvaluationResult.Dispose(); hv__.Dispose();
                                evaluate_dl_model(hv_DLDataset, hv_DLModelHandle, "split", "validation",
                                    hv_EvaluationParam, out hv_ValidationEvaluationResult, out hv__);
                                //Evaluate a subset of the train split.
                                hv_TrainEvaluationSampleIndices.Dispose();
                                tuple_shuffle(hv_TrainSampleIndices, out hv_TrainEvaluationSampleIndices);
                                hv_TrainEvaluationRatio.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_TrainEvaluationRatio = hv_SelectPercentageTrainSamples / 100.0;
                                }
                                hv_NumTrainEvaluationSampleIndices.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_NumTrainEvaluationSampleIndices = ((hv_TrainEvaluationRatio * (new HTuple(hv_TrainEvaluationSampleIndices.TupleLength()
                                        )))).TupleInt();
                                }
                                if ((int)(new HTuple(hv_NumTrainEvaluationSampleIndices.TupleGreater(
                                    0))) != 0)
                                {
                                    //It might happen that the subset is too small for evaluation.
                                    try
                                    {
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_TrainEvaluationResult.Dispose(); hv__.Dispose();
                                            evaluate_dl_model(hv_DLDataset, hv_DLModelHandle, "sample_indices",
                                                hv_TrainEvaluationSampleIndices.TupleSelectRange(0, hv_NumTrainEvaluationSampleIndices - 1),
                                                hv_EvaluationParam, out hv_TrainEvaluationResult, out hv__);
                                        }
                                    }
                                    // catch (Exception) 
                                    catch (HalconException HDevExpDefaultException1)
                                    {
                                        HDevExpDefaultException1.ToHTuple(out hv_Exception);
                                    }
                                }
                                hv_EvaluationInfo.Dispose();
                                HOperatorSet.CreateDict(out hv_EvaluationInfo);
                                HOperatorSet.SetDictTuple(hv_EvaluationInfo, "epoch", hv_Epoch);
                                HOperatorSet.SetDictTuple(hv_EvaluationInfo, "iteration", hv_Iteration);
                                HOperatorSet.SetDictTuple(hv_EvaluationInfo, "result", hv_ValidationEvaluationResult);
                                HOperatorSet.SetDictTuple(hv_EvaluationInfo, "result_train", hv_TrainEvaluationResult);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_EvaluationInfos = hv_EvaluationInfos.TupleConcat(
                                            hv_EvaluationInfo);
                                        hv_EvaluationInfos.Dispose();
                                        hv_EvaluationInfos = ExpTmpLocalVar_EvaluationInfos;
                                    }
                                }
                                if ((int)(hv_DisplayEnabled) != 0)
                                {
                                    hv_EvaluationComparisonKeys.Dispose();
                                    HOperatorSet.GetDictTuple(hv_TrainParam, "evaluation_comparison_keys",
                                        out hv_EvaluationComparisonKeys);
                                    hv_Valuevalidation.Dispose(); hv__.Dispose();
                                    reduce_dl_evaluation_result(hv_ValidationEvaluationResult, hv_EvaluationComparisonKeys,
                                        out hv_Valuevalidation, out hv__);
                                    hv_ValueTrain.Dispose(); hv__.Dispose();
                                    reduce_dl_evaluation_result(hv_TrainEvaluationResult, hv_EvaluationComparisonKeys,
                                        out hv_ValueTrain, out hv__);
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_DisplayValidationEvaluationValues = hv_DisplayValidationEvaluationValues.TupleConcat(
                                                hv_Valuevalidation);
                                            hv_DisplayValidationEvaluationValues.Dispose();
                                            hv_DisplayValidationEvaluationValues = ExpTmpLocalVar_DisplayValidationEvaluationValues;
                                        }
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_DisplayTrainEvaluationValues = hv_DisplayTrainEvaluationValues.TupleConcat(
                                                hv_ValueTrain);
                                            hv_DisplayTrainEvaluationValues.Dispose();
                                            hv_DisplayTrainEvaluationValues = ExpTmpLocalVar_DisplayTrainEvaluationValues;
                                        }
                                    }
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_DisplayEvaluationEpochs = hv_DisplayEvaluationEpochs.TupleConcat(
                                                hv_Epoch);
                                            hv_DisplayEvaluationEpochs.Dispose();
                                            hv_DisplayEvaluationEpochs = ExpTmpLocalVar_DisplayEvaluationEpochs;
                                        }
                                    }
                                }
                            }
                        }
                        //
                        //Check if an update is needed.
                        hv_TrainInfoUpdateIntervalSeconds.Dispose();
                        HOperatorSet.GetDictTuple(hv_TrainParam, "update_interval_seconds", out hv_TrainInfoUpdateIntervalSeconds);
                        hv_LastUpdate.Dispose();
                        HOperatorSet.GetDictTuple(hv_DisplayData, "last_update", out hv_LastUpdate);
                        hv_Seconds.Dispose();
                        HOperatorSet.CountSeconds(out hv_Seconds);
                        //Check for next update (enough time has elapsed or last iteration).
                        if ((int)((new HTuple((new HTuple(((((hv_LastUpdate - hv_Seconds)).TupleAbs()
                            )).TupleGreater(hv_TrainInfoUpdateIntervalSeconds))).TupleOr(new HTuple(hv_Iteration.TupleEqual(
                            hv_NumIterations - 1))))).TupleOr(new HTuple((new HTuple(hv_ValidationEvaluationResult.TupleLength()
                            )).TupleGreater(0)))) != 0)
                        {
                            HOperatorSet.SetDictTuple(hv_DisplayData, "last_update", hv_Seconds);
                            hv_EvaluationComparisonKeys.Dispose();
                            HOperatorSet.GetDictTuple(hv_TrainParam, "evaluation_comparison_keys",
                                out hv_EvaluationComparisonKeys);
                            hv_NumSamplesMeanLoss.Dispose();
                            HOperatorSet.GetDictTuple(hv_TrainParam, "num_samples_mean_loss", out hv_NumSamplesMeanLoss);
                            hv_TrainInfo.Dispose();
                            collect_train_dl_model_info(hv_DLModelHandle, hv_TrainResults, hv_EvaluationInfos,
                                hv_EvaluationComparisonKeys, hv_Iteration, hv_NumIterations, hv_NumIterationsPerEpoch,
                                hv_NumSamplesMeanLoss, out hv_TrainInfo);
                            HOperatorSet.SetDictTuple(hv_TrainInfo, "start_epoch", hv_StartEpoch_COPY_INP_TMP);
                            HOperatorSet.SetDictTuple(hv_TrainInfo, "start_time", hv_StartTime);
                            hv_UpdateTime.Dispose();
                            HOperatorSet.CountSeconds(out hv_UpdateTime);
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HOperatorSet.SetDictTuple(hv_TrainInfo, "time_elapsed", hv_UpdateTime - hv_StartTime);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_TrainInfos = hv_TrainInfos.TupleConcat(
                                        hv_TrainInfo);
                                    hv_TrainInfos.Dispose();
                                    hv_TrainInfos = ExpTmpLocalVar_TrainInfos;
                                }
                            }
                            //
                            //Display handling.
                            if ((int)(hv_DisplayEnabled) != 0)
                            {
                                hv_EpochsStatus.Dispose();
                                HOperatorSet.GetDictTuple(hv_TrainInfo, "epoch", out hv_EpochsStatus);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_DisplayLossEpochs = hv_DisplayLossEpochs.TupleConcat(
                                            hv_EpochsStatus);
                                        hv_DisplayLossEpochs.Dispose();
                                        hv_DisplayLossEpochs = ExpTmpLocalVar_DisplayLossEpochs;
                                    }
                                }
                                hv_MeanLoss.Dispose();
                                HOperatorSet.GetDictTuple(hv_TrainInfo, "mean_loss", out hv_MeanLoss);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_DisplayLoss = hv_DisplayLoss.TupleConcat(
                                            hv_MeanLoss);
                                        hv_DisplayLoss.Dispose();
                                        hv_DisplayLoss = ExpTmpLocalVar_DisplayLoss;
                                    }
                                }
                                hv_DisplayLearningRate.Dispose();
                                HOperatorSet.GetDlModelParam(hv_DLModelHandle, "learning_rate", out hv_DisplayLearningRate);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_DisplayLearningRates = hv_DisplayLearningRates.TupleConcat(
                                            hv_DisplayLearningRate);
                                        hv_DisplayLearningRates.Dispose();
                                        hv_DisplayLearningRates = ExpTmpLocalVar_DisplayLearningRates;
                                    }
                                }
                                dev_display_update_train_dl_model(hv_TrainParam, hv_DisplayData, hv_TrainInfo,
                                    hv_DisplayLossEpochs, hv_DisplayLoss, hv_DisplayLearningRates,
                                    hv_DisplayEvaluationEpochs, hv_DisplayValidationEvaluationValues,
                                    hv_DisplayTrainEvaluationValues);
                            }
                        }
                        //Image result preview handling.
                        if ((int)(hv_DisplayEnabled) != 0)
                        {
                            //Check if the image preview has to be updated.
                            hv_UpdateImagesIntervalEpochs.Dispose();
                            HOperatorSet.GetDictTuple(hv_DisplayParam, "update_images_interval_epochs",
                                out hv_UpdateImagesIntervalEpochs);
                            hv_UpdateImagesInterval.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_UpdateImagesInterval = (((((hv_UpdateImagesIntervalEpochs.TupleReal()
                                    ) * hv_NumIterationsPerEpoch)).TupleFloor())).TupleInt();
                            }
                            if ((int)(new HTuple(hv_UpdateImagesInterval.TupleEqual(0))) != 0)
                            {
                                hv_UpdateImagesInterval.Dispose();
                                hv_UpdateImagesInterval = 1;
                            }
                            if ((int)((new HTuple(((hv_Iteration % hv_UpdateImagesInterval)).TupleEqual(
                                0))).TupleOr(hv_DisplayPreviewInitialized.TupleNot())) != 0)
                            {
                                hv_WindowImages.Dispose();
                                HOperatorSet.GetDictTuple(hv_DisplayData, "window_images", out hv_WindowImages);
                                hv_FirstCall.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_FirstCall = new HTuple((new HTuple(hv_WindowImages.TupleLength()
                                        )).TupleEqual(0));
                                }
                                hv_NumImages.Dispose();
                                HOperatorSet.GetDictTuple(hv_DisplayParam, "num_images", out hv_NumImages);
                                hv_GenParamTiled.Dispose();
                                HOperatorSet.GetDictTuple(hv_DisplayParam, "tiled_param", out hv_GenParamTiled);
                                //
                                {
                                    HTuple ExpTmpOutVar_0;
                                    dev_display_dl_data_tiled(hv_DLDataset, hv_DLModelHandle, hv_NumImages,
                                        "validation", hv_GenParamTiled, hv_WindowImages, out ExpTmpOutVar_0);
                                    hv_WindowImages.Dispose();
                                    hv_WindowImages = ExpTmpOutVar_0;
                                }
                                //
                                if ((int)(hv_FirstCall) != 0)
                                {
                                    HOperatorSet.SetDictTuple(hv_DisplayData, "window_images", hv_WindowImages);
                                    set_display_font(hv_WindowImages, 12, "mono", "true", "false");
                                }
                                dev_display_tiled_legend(hv_WindowImages, hv_GenParamTiled);
                                hv_DisplayPreviewInitialized.Dispose();
                                hv_DisplayPreviewInitialized = 1;
                            }
                        }
                        //
                        //Serialization handling.
                        update_train_dl_model_serialization(hv_TrainParam, hv_SerializationData,
                            hv_Iteration, hv_NumIterations, hv_Epoch, hv_ValidationEvaluationResult,
                            hv_DLModelHandle, hv_TrainInfos, hv_EvaluationInfos);
                        //
                        //Check for end of training.
                        if ((int)(new HTuple(hv_Iteration.TupleGreaterEqual(hv_NumIterations - 1))) != 0)
                        {
                            break;
                        }
                        //
                        //Continue with next iteration.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_Iteration = hv_Iteration + 1;
                                hv_Iteration.Dispose();
                                hv_Iteration = ExpTmpLocalVar_Iteration;
                            }
                        }
                    }
                    //

                }
                else if ((int)(new HTuple(hv_ModelType.TupleEqual("anomaly_detection"))) != 0)
                {
                    //Read the training samples.
                    hv_DLSamples.Dispose();
                    read_dl_samples(hv_DLDataset, hv_TrainSampleIndices, out hv_DLSamples);
                    //
                    //Get training parameters for anomaly detection.
                    hv_TrainParamAnomaly.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainParam, "anomaly_param", out hv_TrainParamAnomaly);
                    //
                    //Display information about training.
                    hv_DisplayParam.Dispose();
                    HOperatorSet.GetDictTuple(hv_TrainParam, "display_param", out hv_DisplayParam);
                    hv_EnableDisplay.Dispose();
                    HOperatorSet.GetDictTuple(hv_DisplayParam, "enabled", out hv_EnableDisplay);
                    if ((int)(hv_EnableDisplay) != 0)
                    {
                        hv_WindowHandleInfo.Dispose();
                        dev_display_train_info_anomaly_detection(hv_TrainParam, out hv_WindowHandleInfo);
                    }
                    //
                    //Train the model.
                    hv_TrainResults.Dispose();
                    HOperatorSet.TrainDlModelAnomalyDataset(hv_DLModelHandle, hv_DLSamples, hv_TrainParamAnomaly,
                        out hv_TrainResults);
                    //
                    //Initialize TrainInfos and EvaluationInfos
                    hv_TrainInfos.Dispose();
                    hv_TrainInfos = new HTuple();
                    hv_EvaluationInfos.Dispose();
                    hv_EvaluationInfos = new HTuple();
                    //
                    //Close window with information about the training.
                    if ((int)(hv_EnableDisplay) != 0)
                    {
                        HDevWindowStack.SetActive(hv_WindowHandleInfo);
                    }
                }
                //

                hv_StartEpoch_COPY_INP_TMP.Dispose();
                hv_ModelType.Dispose();
                hv_DLSamples.Dispose();
                hv_TrainSampleIndices.Dispose();
                hv_NumTrainSamples.Dispose();
                hv_NumEpochs.Dispose();
                hv_SeedRand.Dispose();
                hv_SampleIndicesTrainRaw.Dispose();
                hv_Index.Dispose();
                hv_Shuffled.Dispose();
                hv_SampleSeedsTrainRaw.Dispose();
                hv_BatchSize.Dispose();
                hv_ChangeStrategyData.Dispose();
                hv_SerializationData.Dispose();
                hv_DisplayData.Dispose();
                hv_DisplayEnabled.Dispose();
                hv_DisplayPreviewInitialized.Dispose();
                hv_DisplayEvaluationEpochs.Dispose();
                hv_DisplayValidationEvaluationValues.Dispose();
                hv_DisplayTrainEvaluationValues.Dispose();
                hv_DisplayLossEpochs.Dispose();
                hv_DisplayLoss.Dispose();
                hv_DisplayLearningRates.Dispose();
                hv_TrainResultsRestored.Dispose();
                hv_StartTime.Dispose();
                hv_FirstIteration.Dispose();
                hv_Epoch.Dispose();
                hv_Iteration.Dispose();
                hv_NumIterationsPerEpoch.Dispose();
                hv_BatchSizeDevice.Dispose();
                hv_BatchSizeMultiplier.Dispose();
                hv_BatchSizeModel.Dispose();
                hv_NumIterations.Dispose();
                hv_SampleIndicesTrain.Dispose();
                hv_BatchStart.Dispose();
                hv_BatchEnd.Dispose();
                hv_BatchIndices.Dispose();
                hv_DLSampleBatch.Dispose();
                hv_AugmentationParam.Dispose();
                hv_TrainResult.Dispose();
                hv_EvaluationIntervalEpochs.Dispose();
                hv_EvaluationInterval.Dispose();
                hv_ValidationEvaluationResult.Dispose();
                hv_TrainEvaluationResult.Dispose();
                hv_DisplayParam.Dispose();
                hv_SelectPercentageTrainSamples.Dispose();
                hv_EvaluationParam.Dispose();
                hv__.Dispose();
                hv_TrainEvaluationSampleIndices.Dispose();
                hv_TrainEvaluationRatio.Dispose();
                hv_NumTrainEvaluationSampleIndices.Dispose();
                hv_Exception.Dispose();
                hv_EvaluationInfo.Dispose();
                hv_EvaluationComparisonKeys.Dispose();
                hv_Valuevalidation.Dispose();
                hv_ValueTrain.Dispose();
                hv_TrainInfoUpdateIntervalSeconds.Dispose();
                hv_LastUpdate.Dispose();
                hv_Seconds.Dispose();
                hv_NumSamplesMeanLoss.Dispose();
                hv_TrainInfo.Dispose();
                hv_UpdateTime.Dispose();
                hv_EpochsStatus.Dispose();
                hv_MeanLoss.Dispose();
                hv_DisplayLearningRate.Dispose();
                hv_UpdateImagesIntervalEpochs.Dispose();
                hv_UpdateImagesInterval.Dispose();
                hv_WindowImages.Dispose();
                hv_FirstCall.Dispose();
                hv_NumImages.Dispose();
                hv_GenParamTiled.Dispose();
                hv_TrainParamAnomaly.Dispose();
                hv_EnableDisplay.Dispose();
                hv_WindowHandleInfo.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_StartEpoch_COPY_INP_TMP.Dispose();
                hv_ModelType.Dispose();
                hv_DLSamples.Dispose();
                hv_TrainSampleIndices.Dispose();
                hv_NumTrainSamples.Dispose();
                hv_NumEpochs.Dispose();
                hv_SeedRand.Dispose();
                hv_SampleIndicesTrainRaw.Dispose();
                hv_Index.Dispose();
                hv_Shuffled.Dispose();
                hv_SampleSeedsTrainRaw.Dispose();
                hv_BatchSize.Dispose();
                hv_ChangeStrategyData.Dispose();
                hv_SerializationData.Dispose();
                hv_DisplayData.Dispose();
                hv_DisplayEnabled.Dispose();
                hv_DisplayPreviewInitialized.Dispose();
                hv_DisplayEvaluationEpochs.Dispose();
                hv_DisplayValidationEvaluationValues.Dispose();
                hv_DisplayTrainEvaluationValues.Dispose();
                hv_DisplayLossEpochs.Dispose();
                hv_DisplayLoss.Dispose();
                hv_DisplayLearningRates.Dispose();
                hv_TrainResultsRestored.Dispose();
                hv_StartTime.Dispose();
                hv_FirstIteration.Dispose();
                hv_Epoch.Dispose();
                hv_Iteration.Dispose();
                hv_NumIterationsPerEpoch.Dispose();
                hv_BatchSizeDevice.Dispose();
                hv_BatchSizeMultiplier.Dispose();
                hv_BatchSizeModel.Dispose();
                hv_NumIterations.Dispose();
                hv_SampleIndicesTrain.Dispose();
                hv_BatchStart.Dispose();
                hv_BatchEnd.Dispose();
                hv_BatchIndices.Dispose();
                hv_DLSampleBatch.Dispose();
                hv_AugmentationParam.Dispose();
                hv_TrainResult.Dispose();
                hv_EvaluationIntervalEpochs.Dispose();
                hv_EvaluationInterval.Dispose();
                hv_ValidationEvaluationResult.Dispose();
                hv_TrainEvaluationResult.Dispose();
                hv_DisplayParam.Dispose();
                hv_SelectPercentageTrainSamples.Dispose();
                hv_EvaluationParam.Dispose();
                hv__.Dispose();
                hv_TrainEvaluationSampleIndices.Dispose();
                hv_TrainEvaluationRatio.Dispose();
                hv_NumTrainEvaluationSampleIndices.Dispose();
                hv_Exception.Dispose();
                hv_EvaluationInfo.Dispose();
                hv_EvaluationComparisonKeys.Dispose();
                hv_Valuevalidation.Dispose();
                hv_ValueTrain.Dispose();
                hv_TrainInfoUpdateIntervalSeconds.Dispose();
                hv_LastUpdate.Dispose();
                hv_Seconds.Dispose();
                hv_NumSamplesMeanLoss.Dispose();
                hv_TrainInfo.Dispose();
                hv_UpdateTime.Dispose();
                hv_EpochsStatus.Dispose();
                hv_MeanLoss.Dispose();
                hv_DisplayLearningRate.Dispose();
                hv_UpdateImagesIntervalEpochs.Dispose();
                hv_UpdateImagesInterval.Dispose();
                hv_WindowImages.Dispose();
                hv_FirstCall.Dispose();
                hv_NumImages.Dispose();
                hv_GenParamTiled.Dispose();
                hv_TrainParamAnomaly.Dispose();
                hv_EnableDisplay.Dispose();
                hv_WindowHandleInfo.Dispose();

                //throw HDevExpDefaultException;
                MessageBox.Show(HDevExpDefaultException.ToString());
            }
        }

        // Chapter: Tuple / Element Order
        // Short Description: Sort the elements of a tuple randomly. 
        public void tuple_shuffle(HTuple hv_Tuple, out HTuple hv_Shuffled)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShuffleIndices = new HTuple();
            // Initialize local and output iconic variables 
            hv_Shuffled = new HTuple();
            try
            {
                //This procedure sorts the input tuple randomly.
                //
                if ((int)(new HTuple((new HTuple(hv_Tuple.TupleLength())).TupleGreater(0))) != 0)
                {
                    //Create a tuple of random numbers,
                    //sort this tuple, and return the indices
                    //of this sorted tuple.
                    hv_ShuffleIndices.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ShuffleIndices = (HTuple.TupleRand(
                            new HTuple(hv_Tuple.TupleLength()))).TupleSortIndex();
                    }
                    //Assign the elements of Tuple
                    //to these random positions.
                    hv_Shuffled.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Shuffled = hv_Tuple.TupleSelect(
                            hv_ShuffleIndices);
                    }
                }
                else
                {
                    //If the input tuple is empty,
                    //an empty tuple should be returned.
                    hv_Shuffled.Dispose();
                    hv_Shuffled = new HTuple();
                }

                hv_ShuffleIndices.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShuffleIndices.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Update RunningMeasures by evaluating Samples and corresponding Results. 
        public void update_running_evaluation_measures(HTuple hv_Samples, HTuple hv_Results,
            HTuple hv_EvalParams, HTuple hv_RunningMeasures)
        {



            // Local control variables 

            HTuple hv_EvaluationType = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure updates the running measures depending on the evaluation type.
                hv_EvaluationType.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "evaluation_type", out hv_EvaluationType);
                if ((int)(new HTuple(hv_EvaluationType.TupleEqual("anomaly_detection"))) != 0)
                {
                    update_running_image_anomaly_measures(hv_Samples, hv_Results, hv_EvalParams,
                        hv_RunningMeasures);
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("classification"))) != 0)
                {
                    update_running_image_classification_measures(hv_Samples, hv_Results, hv_EvalParams,
                        hv_RunningMeasures);
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("detection"))) != 0)
                {
                    update_running_instance_measures(hv_Samples, hv_Results, hv_EvalParams, hv_RunningMeasures);
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("segmentation"))) != 0)
                {
                    update_running_pixel_measures(hv_Samples, hv_Results, hv_EvalParams, hv_RunningMeasures);
                }
                //

                hv_EvaluationType.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_EvaluationType.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Anomaly Detection
        // Short Description: Update running measures for an image anomaly detection evaluation. 
        private void update_running_image_anomaly_measures(HTuple hv_Samples, HTuple hv_Results,
            HTuple hv_EvalParams, HTuple hv_RunningMeasures)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ImageIDs = new HTuple(), hv_AnomalyLabelIDs = new HTuple();
            HTuple hv_AnomalyScores = new HTuple(), hv_SampleIndex = new HTuple();
            HTuple hv_Sample = new HTuple(), hv_ImageID = new HTuple();
            HTuple hv_AnomalyLabelID = new HTuple(), hv_Result = new HTuple();
            HTuple hv_AnomalyScore = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure updates the RunningMeasures for an evaluation for anomaly detection.
                //
                //These measures are stored in the dictionary RunningMeasures and
                //updated by incorporating the Results the model obtained for the Samples.
                //
                //
                //Get image ids.
                hv_ImageIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "image_ids", out hv_ImageIDs);
                //Get anomaly label ids.
                hv_AnomalyLabelIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "anomaly_label_ids", out hv_AnomalyLabelIDs);
                //Get anomaly scores.
                hv_AnomalyScores.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "anomaly_scores", out hv_AnomalyScores);
                //Loop over all samples and update running measures accordingly.
                for (hv_SampleIndex = 0; (int)hv_SampleIndex <= (int)((new HTuple(hv_Samples.TupleLength()
                    )) - 1); hv_SampleIndex = (int)hv_SampleIndex + 1)
                {
                    hv_Sample.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Sample = hv_Samples.TupleSelect(
                            hv_SampleIndex);
                    }
                    hv_ImageID.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "image_id", out hv_ImageID);
                    hv_AnomalyLabelID.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "anomaly_label_id", out hv_AnomalyLabelID);
                    hv_Result.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Result = hv_Results.TupleSelect(
                            hv_SampleIndex);
                    }
                    hv_AnomalyScore.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "anomaly_score", out hv_AnomalyScore);
                    //
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ImageIDs = hv_ImageIDs.TupleConcat(
                                hv_ImageID);
                            hv_ImageIDs.Dispose();
                            hv_ImageIDs = ExpTmpLocalVar_ImageIDs;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_AnomalyLabelIDs = hv_AnomalyLabelIDs.TupleConcat(
                                hv_AnomalyLabelID);
                            hv_AnomalyLabelIDs.Dispose();
                            hv_AnomalyLabelIDs = ExpTmpLocalVar_AnomalyLabelIDs;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_AnomalyScores = hv_AnomalyScores.TupleConcat(
                                hv_AnomalyScore);
                            hv_AnomalyScores.Dispose();
                            hv_AnomalyScores = ExpTmpLocalVar_AnomalyScores;
                        }
                    }
                }
                //
                //Set image ids in running measures.
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_ids", hv_ImageIDs);
                //Set anomaly label ids in running measures.
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "anomaly_label_ids", hv_AnomalyLabelIDs);
                //Set anomaly scores in running measures.
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "anomaly_scores", hv_AnomalyScores);
                //

                hv_ImageIDs.Dispose();
                hv_AnomalyLabelIDs.Dispose();
                hv_AnomalyScores.Dispose();
                hv_SampleIndex.Dispose();
                hv_Sample.Dispose();
                hv_ImageID.Dispose();
                hv_AnomalyLabelID.Dispose();
                hv_Result.Dispose();
                hv_AnomalyScore.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ImageIDs.Dispose();
                hv_AnomalyLabelIDs.Dispose();
                hv_AnomalyScores.Dispose();
                hv_SampleIndex.Dispose();
                hv_Sample.Dispose();
                hv_ImageID.Dispose();
                hv_AnomalyLabelID.Dispose();
                hv_Result.Dispose();
                hv_AnomalyScore.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Update running measures for an image classification evaluation. 
        private void update_running_image_classification_measures(HTuple hv_Samples, HTuple hv_Results,
            HTuple hv_EvalParams, HTuple hv_RunningMeasures)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_RegExpTopKError = new HTuple(), hv_Measures = new HTuple();
            HTuple hv_K = new HTuple(), hv_M = new HTuple(), hv_ComputeTopKError = new HTuple();
            HTuple hv_ImageIDs = new HTuple(), hv_ImageLabelIDs = new HTuple();
            HTuple hv_Top1Prediction = new HTuple(), hv_TopKPredictionDicts = new HTuple();
            HTuple hv_Index = new HTuple(), hv_Sample = new HTuple();
            HTuple hv_ImageID = new HTuple(), hv_ImageLabelID = new HTuple();
            HTuple hv_Result = new HTuple(), hv_PredictedClassIDs = new HTuple();
            HTuple hv_TopKPrediction = new HTuple(), hv_TopKPredictionDict = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure updates the RunningMeasures for an evaluation for classification.
                //
                //To avoid memory, only save first K predictions per sample.
                hv_RegExpTopKError.Dispose();
                hv_RegExpTopKError = "top([0-9]+)_error";
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                hv_K.Dispose();
                hv_K = 1;
                for (hv_M = 0; (int)hv_M <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_M = (int)hv_M + 1)
                {
                    hv_ComputeTopKError.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ComputeTopKError = ((hv_Measures.TupleSelect(
                            hv_M))).TupleRegexpTest(hv_RegExpTopKError);
                    }
                    if ((int)(hv_ComputeTopKError) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_K = hv_K.TupleMax2(
                                    ((((hv_Measures.TupleSelect(hv_M))).TupleRegexpMatch(hv_RegExpTopKError))).TupleNumber()
                                    );
                                hv_K.Dispose();
                                hv_K = ExpTmpLocalVar_K;
                            }
                        }
                    }
                }
                //
                //Extend tuples in RunningMeasures with new results.
                hv_ImageIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "image_ids", out hv_ImageIDs);
                hv_ImageLabelIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "image_label_ids", out hv_ImageLabelIDs);
                hv_Top1Prediction.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "top1_predictions", out hv_Top1Prediction);
                hv_TopKPredictionDicts.Dispose();
                HOperatorSet.GetDictTuple(hv_RunningMeasures, "topk_predictions", out hv_TopKPredictionDicts);
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Samples.TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
                {
                    hv_Sample.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Sample = hv_Samples.TupleSelect(
                            hv_Index);
                    }
                    hv_ImageID.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "image_id", out hv_ImageID);
                    hv_ImageLabelID.Dispose();
                    HOperatorSet.GetDictTuple(hv_Sample, "image_label_id", out hv_ImageLabelID);
                    hv_Result.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Result = hv_Results.TupleSelect(
                            hv_Index);
                    }
                    hv_PredictedClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_Result, "classification_class_ids", out hv_PredictedClassIDs);
                    hv_TopKPrediction.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_TopKPrediction = hv_PredictedClassIDs.TupleSelectRange(
                            0, hv_K - 1);
                    }
                    hv_TopKPredictionDict.Dispose();
                    HOperatorSet.CreateDict(out hv_TopKPredictionDict);
                    HOperatorSet.SetDictTuple(hv_TopKPredictionDict, "predictions", hv_TopKPrediction);
                    //
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ImageIDs = hv_ImageIDs.TupleConcat(
                                hv_ImageID);
                            hv_ImageIDs.Dispose();
                            hv_ImageIDs = ExpTmpLocalVar_ImageIDs;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ImageLabelIDs = hv_ImageLabelIDs.TupleConcat(
                                hv_ImageLabelID);
                            hv_ImageLabelIDs.Dispose();
                            hv_ImageLabelIDs = ExpTmpLocalVar_ImageLabelIDs;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Top1Prediction = hv_Top1Prediction.TupleConcat(
                                hv_TopKPrediction.TupleSelect(0));
                            hv_Top1Prediction.Dispose();
                            hv_Top1Prediction = ExpTmpLocalVar_Top1Prediction;
                        }
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_TopKPredictionDicts = hv_TopKPredictionDicts.TupleConcat(
                                hv_TopKPredictionDict);
                            hv_TopKPredictionDicts.Dispose();
                            hv_TopKPredictionDicts = ExpTmpLocalVar_TopKPredictionDicts;
                        }
                    }
                }
                //
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_ids", hv_ImageIDs);
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "image_label_ids", hv_ImageLabelIDs);
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "top1_predictions", hv_Top1Prediction);
                HOperatorSet.SetDictTuple(hv_RunningMeasures, "topk_predictions", hv_TopKPredictionDicts);
                //

                hv_RegExpTopKError.Dispose();
                hv_Measures.Dispose();
                hv_K.Dispose();
                hv_M.Dispose();
                hv_ComputeTopKError.Dispose();
                hv_ImageIDs.Dispose();
                hv_ImageLabelIDs.Dispose();
                hv_Top1Prediction.Dispose();
                hv_TopKPredictionDicts.Dispose();
                hv_Index.Dispose();
                hv_Sample.Dispose();
                hv_ImageID.Dispose();
                hv_ImageLabelID.Dispose();
                hv_Result.Dispose();
                hv_PredictedClassIDs.Dispose();
                hv_TopKPrediction.Dispose();
                hv_TopKPredictionDict.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_RegExpTopKError.Dispose();
                hv_Measures.Dispose();
                hv_K.Dispose();
                hv_M.Dispose();
                hv_ComputeTopKError.Dispose();
                hv_ImageIDs.Dispose();
                hv_ImageLabelIDs.Dispose();
                hv_Top1Prediction.Dispose();
                hv_TopKPredictionDicts.Dispose();
                hv_Index.Dispose();
                hv_Sample.Dispose();
                hv_ImageID.Dispose();
                hv_ImageLabelID.Dispose();
                hv_Result.Dispose();
                hv_PredictedClassIDs.Dispose();
                hv_TopKPrediction.Dispose();
                hv_TopKPredictionDict.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Update running measures for an instance-based evaluation. 
        private void update_running_instance_measures(HTuple hv_Samples, HTuple hv_Results,
            HTuple hv_EvalParams, HTuple hv_RunningMeasures)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_MaxNumDetections = new HTuple();
            HTuple hv_AreaRanges = new HTuple(), hv_IoUThresholds = new HTuple();
            HTuple hv_InstanceType = new HTuple(), hv_ClassIDs = new HTuple();
            HTuple hv_NumClasses = new HTuple(), hv_Measures = new HTuple();
            HTuple hv_AreaNames = new HTuple(), hv_MinAreas = new HTuple();
            HTuple hv_MaxAreas = new HTuple(), hv_NumAreaRanges = new HTuple();
            HTuple hv_AllocationBlockLength = new HTuple(), hv_DetailedEvaluation = new HTuple();
            HTuple hv_KeyExists = new HTuple(), hv_ClassIDToClassIdx = new HTuple();
            HTuple hv_EvaluateOrientation = new HTuple(), hv_SIdx = new HTuple();
            HTuple hv_CurrentSample = new HTuple(), hv_CurrentResult = new HTuple();
            HTuple hv_GtClassIDs = new HTuple(), hv_ResClassIDs = new HTuple();
            HTuple hv_NumGT = new HTuple(), hv_NumRes = new HTuple();
            HTuple hv_Confidences = new HTuple(), hv_ResSortIndices = new HTuple();
            HTuple hv_GtAreas = new HTuple(), hv_ResAreas = new HTuple();
            HTuple hv_IoUs = new HTuple(), hv_GtPhis = new HTuple();
            HTuple hv_ResPhis = new HTuple(), hv_MDIdx = new HTuple();
            HTuple hv_MaxNum = new HTuple(), hv_MaxNumStr = new HTuple();
            HTuple hv_CurrentRunningMeasures = new HTuple(), hv_AreaIdx = new HTuple();
            HTuple hv_MinArea = new HTuple(), hv_MaxArea = new HTuple();
            HTuple hv_AreaName = new HTuple(), hv_AreaRunningMeasures = new HTuple();
            HTuple hv_GtIgnore = new HTuple(), hv_GtIgnoreInds = new HTuple();
            HTuple hv_PerClassNumGt = new HTuple(), hv_PerClassNumPred = new HTuple();
            HTuple hv_PerClassConfidences = new HTuple(), hv_PerClassNumGtIgnore = new HTuple();
            HTuple hv_SampleHasFP = new HTuple(), hv_SampleHasFN = new HTuple();
            HTuple hv_ClsIdx = new HTuple(), hv_CurrentClassID = new HTuple();
            HTuple hv_CurrentGtIdxs = new HTuple(), hv_CurrentNumGt = new HTuple();
            HTuple hv_CurrentGtIgnore = new HTuple(), hv_CurrentNumGtIgnore = new HTuple();
            HTuple hv_CurrentNumGtNoIgnore = new HTuple(), hv_CurrentResIdxs = new HTuple();
            HTuple hv_CurrentNumRes = new HTuple(), hv_CurrentResAreas = new HTuple();
            HTuple hv_OldNumPred = new HTuple(), hv_CurrentClassConfidences = new HTuple();
            HTuple hv_GtSortIdx = new HTuple(), hv_CurrentResPhis = new HTuple();
            HTuple hv_CurrentGtPhis = new HTuple(), hv_ITIdx = new HTuple();
            HTuple hv_GtMatched = new HTuple(), hv_ResMatched = new HTuple();
            HTuple hv_ResAbsOrientationDiff = new HTuple(), hv_ResIgnore = new HTuple();
            HTuple hv_ResIdx = new HTuple(), hv_CurrentIoU = new HTuple();
            HTuple hv_MatchIdx = new HTuple(), hv_GtIdx = new HTuple();
            HTuple hv_AreaIgnore = new HTuple(), hv_PerIoUMeasure = new HTuple();
            HTuple hv_PerClassMeasures = new HTuple(), hv_CurrentIsTP = new HTuple();
            HTuple hv_CurrentIgnore = new HTuple(), hv_CurrentAbsOrientationDiff = new HTuple();
            HTuple hv_GtMatchedNoIgnore = new HTuple(), hv_ResIsFPClass = new HTuple();
            HTuple hv_ResIsFPBackground = new HTuple(), hv_ResIsFPLocalization = new HTuple();
            HTuple hv_ResIsFPDuplicate = new HTuple(), hv_ResIsFPMultiple = new HTuple();
            HTuple hv_ResAbsOrientationDiffClass = new HTuple(), hv_ResAbsOrientationDiffLocalization = new HTuple();
            HTuple hv_ResAbsOrientationDiffDuplicate = new HTuple();
            HTuple hv_ResAbsOrientationDiffMultiple = new HTuple();
            HTuple hv_FPResIdxsThisClass = new HTuple(), hv_FPResIdxsAllResults = new HTuple();
            HTuple hv_GTIdxsNotToIgnore = new HTuple(), hv_MaxIoU = new HTuple();
            HTuple hv_IoUsWithGT = new HTuple(), hv_MaxIdx = new HTuple();
            HTuple hv_GTClassIDMaxIoU = new HTuple(), hv_AbsOrientationDiff = new HTuple();
            HTuple hv_IsFPClass = new HTuple(), hv_IsFPBackground = new HTuple();
            HTuple hv_IsFPLocalization = new HTuple(), hv_IsFPDuplicate = new HTuple();
            HTuple hv_IsFPMultiple = new HTuple(), hv_AbsOrientationDiffMultiple = new HTuple();
            HTuple hv_AbsOrientationDiffDuplicate = new HTuple(), hv_AbsOrientationDiffLocalization = new HTuple();
            HTuple hv_AbsOrientationDiffClass = new HTuple(), hv_CurrentImageID = new HTuple();
            HTuple hv_ImageIDsWithFN = new HTuple(), hv_NumImageIDsWithFN = new HTuple();
            HTuple hv_ImageIDsWithFP = new HTuple(), hv_NumImageIDsWithFP = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure updates the RunningMeasures
                //for an instance-based evaluation for detection.
                //These measures are stored in the dictionary RunningMeasures and
                //updated by incorporating the Results the model obtained for the Samples.
                //
                dev_update_off();
                //Get the necessary evaluation parameters.
                hv_MaxNumDetections.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "max_num_detections", out hv_MaxNumDetections);
                hv_AreaRanges.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "area_ranges", out hv_AreaRanges);
                hv_IoUThresholds.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "iou_threshold", out hv_IoUThresholds);
                hv_InstanceType.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "instance_type", out hv_InstanceType);
                hv_ClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                hv_NumClasses.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                //
                //Get the area parameters: name, min, and max.
                hv_AreaNames.Dispose();
                HOperatorSet.GetDictTuple(hv_AreaRanges, "name", out hv_AreaNames);
                hv_MinAreas.Dispose();
                HOperatorSet.GetDictTuple(hv_AreaRanges, "min", out hv_MinAreas);
                hv_MaxAreas.Dispose();
                HOperatorSet.GetDictTuple(hv_AreaRanges, "max", out hv_MaxAreas);
                hv_NumAreaRanges.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_NumAreaRanges = (new HTuple(hv_AreaNames.TupleLength()
                        )) - 1;
                }
                //
                //Get the allocation length for extending tuples.
                hv_AllocationBlockLength.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "allocation_block_length", out hv_AllocationBlockLength);
                //
                //Check if a detailed evaluation should be done.
                hv_DetailedEvaluation.Dispose();
                hv_DetailedEvaluation = 0;
                hv_KeyExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "detailed_evaluation",
                    out hv_KeyExists);
                if ((int)(hv_KeyExists.TupleSelect(0)) != 0)
                {
                    hv_DetailedEvaluation.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "detailed_evaluation", out hv_DetailedEvaluation);
                }
                if ((int)(hv_DetailedEvaluation) != 0)
                {
                    //We need a mapping from class IDs to class indices
                    hv_ClassIDToClassIdx.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ClassIDToClassIdx = HTuple.TupleGenConst(
                            (hv_ClassIDs.TupleMax()) + 1, -1);
                    }
                    if (hv_ClassIDToClassIdx == null)
                        hv_ClassIDToClassIdx = new HTuple();
                    hv_ClassIDToClassIdx[hv_ClassIDs] = HTuple.TupleGenSequence(0, hv_NumClasses - 1, 1);
                }
                //
                //Check if the orientation is to be evaluated.
                hv_EvaluateOrientation.Dispose();
                hv_EvaluateOrientation = 0;
                if ((int)((new HTuple(hv_InstanceType.TupleEqual("rectangle2"))).TupleAnd((new HTuple(((hv_Measures.TupleFind(
                    "soap"))).TupleNotEqual(-1))).TupleOr(new HTuple(((hv_Measures.TupleFind(
                    "all"))).TupleNotEqual(-1))))) != 0)
                {
                    hv_EvaluateOrientation.Dispose();
                    hv_EvaluateOrientation = 1;
                }
                //
                //Go through samples.
                for (hv_SIdx = 0; (int)hv_SIdx <= (int)((new HTuple(hv_Samples.TupleLength())) - 1); hv_SIdx = (int)hv_SIdx + 1)
                {
                    //
                    hv_CurrentSample.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentSample = hv_Samples.TupleSelect(
                            hv_SIdx);
                    }
                    hv_CurrentResult.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_CurrentResult = hv_Results.TupleSelect(
                            hv_SIdx);
                    }
                    //
                    //Get classes.
                    hv_GtClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_CurrentSample, "bbox_label_id", out hv_GtClassIDs);
                    hv_ResClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_CurrentResult, "bbox_class_id", out hv_ResClassIDs);
                    hv_NumGT.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumGT = new HTuple(hv_GtClassIDs.TupleLength()
                            );
                    }
                    hv_NumRes.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_NumRes = new HTuple(hv_ResClassIDs.TupleLength()
                            );
                    }
                    //
                    //Get result confidences and sort them in descending order.
                    hv_Confidences.Dispose();
                    HOperatorSet.GetDictTuple(hv_CurrentResult, "bbox_confidence", out hv_Confidences);
                    hv_ResSortIndices.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ResSortIndices = ((-hv_Confidences)).TupleSortIndex()
                            ;
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_Confidences = hv_Confidences.TupleSelect(
                                hv_ResSortIndices);
                            hv_Confidences.Dispose();
                            hv_Confidences = ExpTmpLocalVar_Confidences;
                        }
                    }
                    //Sort the result class IDs.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ResClassIDs = hv_ResClassIDs.TupleSelect(
                                hv_ResSortIndices);
                            hv_ResClassIDs.Dispose();
                            hv_ResClassIDs = ExpTmpLocalVar_ResClassIDs;
                        }
                    }
                    //
                    //Compute the IoUs of the instances.
                    hv_GtAreas.Dispose(); hv_ResAreas.Dispose(); hv_IoUs.Dispose();
                    area_iou(hv_CurrentSample, hv_CurrentResult, hv_InstanceType, hv_ResSortIndices,
                        out hv_GtAreas, out hv_ResAreas, out hv_IoUs);
                    //
                    if ((int)(hv_EvaluateOrientation) != 0)
                    {
                        hv_GtPhis.Dispose();
                        HOperatorSet.GetDictTuple(hv_CurrentSample, "bbox_phi", out hv_GtPhis);
                        hv_ResPhis.Dispose();
                        HOperatorSet.GetDictTuple(hv_CurrentResult, "bbox_phi", out hv_ResPhis);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_ResPhis = hv_ResPhis.TupleSelect(
                                    hv_ResSortIndices);
                                hv_ResPhis.Dispose();
                                hv_ResPhis = ExpTmpLocalVar_ResPhis;
                            }
                        }
                    }
                    //Loop over the maximal number of detections.
                    for (hv_MDIdx = 0; (int)hv_MDIdx <= (int)((new HTuple(hv_MaxNumDetections.TupleLength()
                        )) - 1); hv_MDIdx = (int)hv_MDIdx + 1)
                    {
                        hv_MaxNum.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MaxNum = hv_MaxNumDetections.TupleSelect(
                                hv_MDIdx);
                        }
                        hv_MaxNumStr.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_MaxNumStr = "" + hv_MaxNum;
                        }
                        if ((int)(new HTuple(hv_MaxNum.TupleEqual(-1))) != 0)
                        {
                            hv_MaxNumStr.Dispose();
                            hv_MaxNumStr = "all";
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_CurrentRunningMeasures.Dispose();
                            HOperatorSet.GetDictTuple(hv_RunningMeasures, "max_num_detections_" + hv_MaxNumStr,
                                out hv_CurrentRunningMeasures);
                        }
                        //
                        //Loop over the area ranges.
                        for (hv_AreaIdx = 0; (int)hv_AreaIdx <= (int)((new HTuple(hv_AreaNames.TupleLength()
                            )) - 1); hv_AreaIdx = (int)hv_AreaIdx + 1)
                        {
                            //
                            //Get information about the current area range.
                            hv_MinArea.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_MinArea = hv_MinAreas.TupleSelect(
                                    hv_AreaIdx);
                            }
                            hv_MaxArea.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_MaxArea = hv_MaxAreas.TupleSelect(
                                    hv_AreaIdx);
                            }
                            hv_AreaName.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_AreaName = hv_AreaNames.TupleSelect(
                                    hv_AreaIdx);
                            }
                            //
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_AreaRunningMeasures.Dispose();
                                HOperatorSet.GetDictTuple(hv_CurrentRunningMeasures, "area_" + hv_AreaName,
                                    out hv_AreaRunningMeasures);
                            }
                            //
                            //Set ignore-flag for ground truth instances.
                            hv_GtIgnore.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_GtIgnore = HTuple.TupleGenConst(
                                    hv_NumGT, 0);
                            }
                            //
                            //Ignore ground truth instances with area outside the area range.
                            if ((int)(new HTuple(hv_NumGT.TupleGreater(0))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_GtIgnoreInds.Dispose();
                                    HOperatorSet.TupleFind(((hv_GtAreas.TupleLessElem(hv_MinArea))).TupleOr(
                                        hv_GtAreas.TupleGreaterElem(hv_MaxArea)), 1, out hv_GtIgnoreInds);
                                }
                                if ((int)(new HTuple(hv_GtIgnoreInds.TupleGreater(-1))) != 0)
                                {
                                    if (hv_GtIgnore == null)
                                        hv_GtIgnore = new HTuple();
                                    hv_GtIgnore[hv_GtIgnoreInds] = 1;
                                }
                            }
                            //
                            hv_PerClassNumGt.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_gt", out hv_PerClassNumGt);
                            hv_PerClassNumPred.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_pred", out hv_PerClassNumPred);
                            hv_PerClassConfidences.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "confidence", out hv_PerClassConfidences);
                            hv_PerClassNumGtIgnore.Dispose();
                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "num_gt_ignore", out hv_PerClassNumGtIgnore);
                            //
                            if ((int)(hv_DetailedEvaluation) != 0)
                            {
                                //Store if a sample has at least one false positive or false negative (for each IoU threshold).
                                hv_SampleHasFP.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_SampleHasFP = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                                hv_SampleHasFN.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_SampleHasFN = HTuple.TupleGenConst(
                                        new HTuple(hv_IoUThresholds.TupleLength()), 0);
                                }
                            }
                            //
                            //Loop over the classes.
                            HTuple end_val112 = hv_NumClasses - 1;
                            HTuple step_val112 = 1;
                            for (hv_ClsIdx = 0; hv_ClsIdx.Continue(end_val112, step_val112); hv_ClsIdx = hv_ClsIdx.TupleAdd(step_val112))
                            {
                                hv_CurrentClassID.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentClassID = hv_ClassIDs.TupleSelect(
                                        hv_ClsIdx);
                                }
                                //
                                //Get the ground truth for this class.
                                hv_CurrentGtIdxs.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentGtIdxs = hv_GtClassIDs.TupleFind(
                                        hv_CurrentClassID);
                                }
                                if ((int)(new HTuple(hv_CurrentGtIdxs.TupleEqual(-1))) != 0)
                                {
                                    hv_CurrentGtIdxs.Dispose();
                                    hv_CurrentGtIdxs = new HTuple();
                                }
                                hv_CurrentNumGt.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentNumGt = new HTuple(hv_CurrentGtIdxs.TupleLength()
                                        );
                                }
                                //
                                //Get ground truth ignore for this class.
                                hv_CurrentGtIgnore.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentGtIgnore = hv_GtIgnore.TupleSelect(
                                        hv_CurrentGtIdxs);
                                }
                                if ((int)(new HTuple((new HTuple(hv_CurrentGtIgnore.TupleLength())).TupleEqual(
                                    0))) != 0)
                                {
                                    hv_CurrentNumGtIgnore.Dispose();
                                    hv_CurrentNumGtIgnore = 0;
                                }
                                else
                                {
                                    hv_CurrentNumGtIgnore.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_CurrentNumGtIgnore = hv_CurrentGtIgnore.TupleSum()
                                            ;
                                    }
                                }
                                //
                                //Number of gt for this class and without ignore.
                                hv_CurrentNumGtNoIgnore.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentNumGtNoIgnore = hv_CurrentNumGt - hv_CurrentNumGtIgnore;
                                }
                                //
                                //Get results for this class.
                                hv_CurrentResIdxs.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentResIdxs = hv_ResClassIDs.TupleFind(
                                        hv_CurrentClassID);
                                }
                                if ((int)(new HTuple(hv_CurrentResIdxs.TupleEqual(-1))) != 0)
                                {
                                    hv_CurrentResIdxs.Dispose();
                                    hv_CurrentResIdxs = new HTuple();
                                }
                                hv_CurrentNumRes.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentNumRes = hv_MaxNum.TupleMin2(
                                        new HTuple(hv_CurrentResIdxs.TupleLength()));
                                }
                                //MaxNum -1 corresponds to taking all results.
                                if ((int)(new HTuple(hv_MaxNum.TupleEqual(-1))) != 0)
                                {
                                    hv_CurrentNumRes.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_CurrentNumRes = new HTuple(hv_CurrentResIdxs.TupleLength()
                                            );
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_CurrentResIdxs = hv_CurrentResIdxs.TupleSelectRange(
                                            0, hv_CurrentNumRes - 1);
                                        hv_CurrentResIdxs.Dispose();
                                        hv_CurrentResIdxs = ExpTmpLocalVar_CurrentResIdxs;
                                    }
                                }
                                //
                                //Get areas of the current results.
                                hv_CurrentResAreas.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentResAreas = hv_ResAreas.TupleSelect(
                                        hv_CurrentResIdxs);
                                }
                                //
                                //Update the confidences, num_gt and num_pred for this class.
                                hv_OldNumPred.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_OldNumPred = hv_PerClassNumPred.TupleSelect(
                                        hv_ClsIdx);
                                }
                                if (hv_PerClassNumGt == null)
                                    hv_PerClassNumGt = new HTuple();
                                hv_PerClassNumGt[hv_ClsIdx] = (hv_PerClassNumGt.TupleSelect(hv_ClsIdx)) + hv_CurrentNumGt;
                                if (hv_PerClassNumGtIgnore == null)
                                    hv_PerClassNumGtIgnore = new HTuple();
                                hv_PerClassNumGtIgnore[hv_ClsIdx] = (hv_PerClassNumGtIgnore.TupleSelect(
                                    hv_ClsIdx)) + hv_CurrentNumGtIgnore;
                                if (hv_PerClassNumPred == null)
                                    hv_PerClassNumPred = new HTuple();
                                hv_PerClassNumPred[hv_ClsIdx] = (hv_PerClassNumPred.TupleSelect(hv_ClsIdx)) + hv_CurrentNumRes;
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_CurrentClassConfidences.Dispose();
                                    HOperatorSet.GetDictTuple(hv_PerClassConfidences, "class_" + (hv_ClassIDs.TupleSelect(
                                        hv_ClsIdx)), out hv_CurrentClassConfidences);
                                }
                                //Confidences are allocated in blocks of AllocationBlockLength. Therefore, we have to check
                                //if the allocated block is long enough, otherwise allocate a new block.
                                if ((int)(new HTuple(((hv_PerClassNumPred.TupleSelect(hv_ClsIdx))).TupleGreater(
                                    new HTuple(hv_CurrentClassConfidences.TupleLength())))) != 0)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        {
                                            HTuple
                                              ExpTmpLocalVar_CurrentClassConfidences = hv_CurrentClassConfidences.TupleConcat(
                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                            hv_CurrentClassConfidences.Dispose();
                                            hv_CurrentClassConfidences = ExpTmpLocalVar_CurrentClassConfidences;
                                        }
                                    }
                                }
                                if (hv_CurrentClassConfidences == null)
                                    hv_CurrentClassConfidences = new HTuple();
                                hv_CurrentClassConfidences[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                    hv_ClsIdx)) - 1, 1)] = hv_Confidences.TupleSelect(hv_CurrentResIdxs);
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_PerClassConfidences, "class_" + (hv_ClassIDs.TupleSelect(
                                        hv_ClsIdx)), hv_CurrentClassConfidences);
                                }
                                //
                                //Sort the ground truth: Non-ignored instances first.
                                hv_GtSortIdx.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_GtSortIdx = hv_CurrentGtIgnore.TupleSortIndex()
                                        ;
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_CurrentGtIgnore = hv_CurrentGtIgnore.TupleSelect(
                                            hv_GtSortIdx);
                                        hv_CurrentGtIgnore.Dispose();
                                        hv_CurrentGtIgnore = ExpTmpLocalVar_CurrentGtIgnore;
                                    }
                                }
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    {
                                        HTuple
                                          ExpTmpLocalVar_CurrentGtIdxs = hv_CurrentGtIdxs.TupleSelect(
                                            hv_GtSortIdx);
                                        hv_CurrentGtIdxs.Dispose();
                                        hv_CurrentGtIdxs = ExpTmpLocalVar_CurrentGtIdxs;
                                    }
                                }
                                //
                                //Get orientations of result and ground truth instances.
                                if ((int)(hv_EvaluateOrientation) != 0)
                                {
                                    hv_CurrentResPhis.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_CurrentResPhis = hv_ResPhis.TupleSelect(
                                            hv_CurrentResIdxs);
                                    }
                                    hv_CurrentGtPhis.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_CurrentGtPhis = hv_GtPhis.TupleSelect(
                                            hv_CurrentGtIdxs);
                                    }
                                }
                                //
                                if ((int)(new HTuple(hv_CurrentNumRes.TupleGreater(0))) != 0)
                                {
                                    //Loop over IoU thresholds.
                                    for (hv_ITIdx = 0; (int)hv_ITIdx <= (int)((new HTuple(hv_IoUThresholds.TupleLength()
                                        )) - 1); hv_ITIdx = (int)hv_ITIdx + 1)
                                    {
                                        //We check which ground truth and
                                        //result instance can be matched.
                                        hv_GtMatched.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_GtMatched = HTuple.TupleGenConst(
                                                hv_CurrentNumGt, 0);
                                        }
                                        hv_ResMatched.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_ResMatched = HTuple.TupleGenConst(
                                                hv_CurrentNumRes, 0);
                                        }
                                        //
                                        if ((int)(hv_EvaluateOrientation) != 0)
                                        {
                                            //Initialize the absolute orientation difference to -1.
                                            hv_ResAbsOrientationDiff.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ResAbsOrientationDiff = HTuple.TupleGenConst(
                                                    hv_CurrentNumRes, -1);
                                            }
                                        }
                                        //Store which detections should be ignored.
                                        hv_ResIgnore.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_ResIgnore = HTuple.TupleGenConst(
                                                hv_CurrentNumRes, 0);
                                        }
                                        HTuple end_val187 = hv_CurrentNumRes - 1;
                                        HTuple step_val187 = 1;
                                        for (hv_ResIdx = 0; hv_ResIdx.Continue(end_val187, step_val187); hv_ResIdx = hv_ResIdx.TupleAdd(step_val187))
                                        {
                                            //Set the currently best achieved IoU to the IoU threshold and
                                            //initialize the matching index.
                                            hv_CurrentIoU.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_CurrentIoU = ((hv_IoUThresholds.TupleSelect(
                                                    hv_ITIdx))).TupleMin2(1 - 1.0e-10);
                                            }
                                            hv_MatchIdx.Dispose();
                                            hv_MatchIdx = -1;
                                            //Loop over ground truth.
                                            HTuple end_val193 = hv_CurrentNumGt - 1;
                                            HTuple step_val193 = 1;
                                            for (hv_GtIdx = 0; hv_GtIdx.Continue(end_val193, step_val193); hv_GtIdx = hv_GtIdx.TupleAdd(step_val193))
                                            {
                                                //Continue if this ground truth has already been matched.
                                                if ((int)(hv_GtMatched.TupleSelect(hv_GtIdx)) != 0)
                                                {
                                                    continue;
                                                }
                                                //Stop if matched with non-ignored ground truth and current ground truth is on ignore.
                                                if ((int)(new HTuple(hv_MatchIdx.TupleGreater(-1))) != 0)
                                                {
                                                    if ((int)((new HTuple(((hv_CurrentGtIgnore.TupleSelect(hv_MatchIdx))).TupleEqual(
                                                        0))).TupleAnd(new HTuple(((hv_CurrentGtIgnore.TupleSelect(
                                                        hv_GtIdx))).TupleEqual(1)))) != 0)
                                                    {
                                                        break;
                                                    }
                                                }
                                                //Continue if IoU is not better than a previous match.
                                                if ((int)(new HTuple(((hv_IoUs.TupleSelect(((hv_CurrentGtIdxs.TupleSelect(
                                                    hv_GtIdx)) * hv_NumRes) + (hv_CurrentResIdxs.TupleSelect(hv_ResIdx))))).TupleLess(
                                                    hv_CurrentIoU))) != 0)
                                                {
                                                    continue;
                                                }
                                                //We got a new best match, store it.
                                                hv_CurrentIoU.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_CurrentIoU = hv_IoUs.TupleSelect(
                                                        ((hv_CurrentGtIdxs.TupleSelect(hv_GtIdx)) * hv_NumRes) + (hv_CurrentResIdxs.TupleSelect(
                                                        hv_ResIdx)));
                                                }
                                                hv_MatchIdx.Dispose();
                                                hv_MatchIdx = new HTuple(hv_GtIdx);
                                            }
                                            //If a match has been made we store it for both ground truth and result.
                                            if ((int)(new HTuple(hv_MatchIdx.TupleNotEqual(-1))) != 0)
                                            {
                                                //In COCO they use the IDs of GT and Res, we just use 1
                                                //to indicate the matching, but don't store which one has been matched.
                                                if (hv_ResMatched == null)
                                                    hv_ResMatched = new HTuple();
                                                hv_ResMatched[hv_ResIdx] = 1;
                                                if (hv_GtMatched == null)
                                                    hv_GtMatched = new HTuple();
                                                hv_GtMatched[hv_MatchIdx] = 1;
                                                if (hv_ResIgnore == null)
                                                    hv_ResIgnore = new HTuple();
                                                hv_ResIgnore[hv_ResIdx] = hv_CurrentGtIgnore.TupleSelect(hv_MatchIdx);
                                                //
                                                if ((int)(hv_EvaluateOrientation) != 0)
                                                {
                                                    //Set the absolute orientation difference.
                                                    if (hv_ResAbsOrientationDiff == null)
                                                        hv_ResAbsOrientationDiff = new HTuple();
                                                    hv_ResAbsOrientationDiff[hv_ResIdx] = (((hv_CurrentResPhis.TupleSelect(
                                                        hv_ResIdx)) - (hv_CurrentGtPhis.TupleSelect(hv_MatchIdx)))).TupleAbs()
                                                        ;
                                                    if ((int)(new HTuple(((hv_ResAbsOrientationDiff.TupleSelect(
                                                        hv_ResIdx))).TupleGreater((new HTuple(180)).TupleRad()
                                                        ))) != 0)
                                                    {
                                                        if (hv_ResAbsOrientationDiff == null)
                                                            hv_ResAbsOrientationDiff = new HTuple();
                                                        hv_ResAbsOrientationDiff[hv_ResIdx] = ((new HTuple(360)).TupleRad()
                                                            ) - (hv_ResAbsOrientationDiff.TupleSelect(hv_ResIdx));
                                                    }
                                                }
                                            }
                                        }
                                        //Ignore the unmatched results that are outside of the current area range.
                                        hv_AreaIgnore.Dispose();
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_AreaIgnore = ((hv_CurrentResAreas.TupleLessElem(
                                                hv_MinArea))).TupleOr(hv_CurrentResAreas.TupleGreaterElem(hv_MaxArea));
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            {
                                                HTuple
                                                  ExpTmpLocalVar_ResIgnore = (new HTuple(((hv_ResMatched.TupleEqualElem(
                                                    -1))).TupleAnd(hv_AreaIgnore.TupleEqualElem(1)))).TupleOr(hv_ResIgnore);
                                                hv_ResIgnore.Dispose();
                                                hv_ResIgnore = ExpTmpLocalVar_ResIgnore;
                                            }
                                        }
                                        //True positives are the matched results.
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_PerIoUMeasure.Dispose();
                                            HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                                hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUMeasure);
                                        }
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            hv_PerClassMeasures.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "class_" + (hv_ClassIDs.TupleSelect(
                                                hv_ClsIdx)), out hv_PerClassMeasures);
                                        }
                                        hv_CurrentIsTP.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_tp", out hv_CurrentIsTP);
                                        //As for confidences, check if we have to allocate a new block.
                                        if ((int)(new HTuple(((hv_PerClassNumPred.TupleSelect(hv_ClsIdx))).TupleGreater(
                                            new HTuple(hv_CurrentIsTP.TupleLength())))) != 0)
                                        {
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                {
                                                    HTuple
                                                      ExpTmpLocalVar_CurrentIsTP = hv_CurrentIsTP.TupleConcat(
                                                        HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                    hv_CurrentIsTP.Dispose();
                                                    hv_CurrentIsTP = ExpTmpLocalVar_CurrentIsTP;
                                                }
                                            }
                                        }
                                        if (hv_CurrentIsTP == null)
                                            hv_CurrentIsTP = new HTuple();
                                        hv_CurrentIsTP[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                            hv_ClsIdx)) - 1, 1)] = hv_ResMatched;
                                        HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_tp", hv_CurrentIsTP);
                                        //Set the ignored results.
                                        hv_CurrentIgnore.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerClassMeasures, "ignore", out hv_CurrentIgnore);
                                        if ((int)(new HTuple(((hv_PerClassNumPred.TupleSelect(hv_ClsIdx))).TupleGreater(
                                            new HTuple(hv_CurrentIgnore.TupleLength())))) != 0)
                                        {
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                {
                                                    HTuple
                                                      ExpTmpLocalVar_CurrentIgnore = hv_CurrentIgnore.TupleConcat(
                                                        HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                    hv_CurrentIgnore.Dispose();
                                                    hv_CurrentIgnore = ExpTmpLocalVar_CurrentIgnore;
                                                }
                                            }
                                        }
                                        if (hv_CurrentIgnore == null)
                                            hv_CurrentIgnore = new HTuple();
                                        hv_CurrentIgnore[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                            hv_ClsIdx)) - 1, 1)] = hv_ResIgnore;
                                        HOperatorSet.SetDictTuple(hv_PerClassMeasures, "ignore", hv_CurrentIgnore);
                                        //Set the absolute orientation difference.
                                        if ((int)(hv_EvaluateOrientation) != 0)
                                        {
                                            hv_CurrentAbsOrientationDiff.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerClassMeasures, "abs_orientation_diff",
                                                out hv_CurrentAbsOrientationDiff);
                                            if ((int)(new HTuple(((hv_PerClassNumPred.TupleSelect(hv_ClsIdx))).TupleGreater(
                                                new HTuple(hv_CurrentAbsOrientationDiff.TupleLength())))) != 0)
                                            {
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_CurrentAbsOrientationDiff = hv_CurrentAbsOrientationDiff.TupleConcat(
                                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                        hv_CurrentAbsOrientationDiff.Dispose();
                                                        hv_CurrentAbsOrientationDiff = ExpTmpLocalVar_CurrentAbsOrientationDiff;
                                                    }
                                                }
                                            }
                                            if (hv_CurrentAbsOrientationDiff == null)
                                                hv_CurrentAbsOrientationDiff = new HTuple();
                                            hv_CurrentAbsOrientationDiff[HTuple.TupleGenSequence(hv_OldNumPred,
                                                (hv_PerClassNumPred.TupleSelect(hv_ClsIdx)) - 1, 1)] = hv_ResAbsOrientationDiff;
                                            HOperatorSet.SetDictTuple(hv_PerClassMeasures, "abs_orientation_diff",
                                                hv_CurrentAbsOrientationDiff);
                                        }
                                        //
                                        //Beginning of detailed evaluation processing (optional).
                                        //
                                        if ((int)(hv_DetailedEvaluation) != 0)
                                        {
                                            //Check if there have been false negatives.
                                            if ((int)(new HTuple(hv_CurrentNumGtNoIgnore.TupleGreater(0))) != 0)
                                            {
                                                hv_GtMatchedNoIgnore.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_GtMatchedNoIgnore = hv_GtMatched.TupleAnd(
                                                        hv_CurrentGtIgnore.TupleNot());
                                                }
                                                if ((int)(new HTuple(((hv_GtMatchedNoIgnore.TupleSum())).TupleLess(
                                                    hv_CurrentNumGtNoIgnore))) != 0)
                                                {
                                                    if (hv_SampleHasFN == null)
                                                        hv_SampleHasFN = new HTuple();
                                                    hv_SampleHasFN[hv_ITIdx] = 1;
                                                }
                                            }
                                            //
                                            //Initialize the detailed running measures.
                                            hv_ResIsFPClass.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ResIsFPClass = HTuple.TupleGenConst(
                                                    hv_CurrentNumRes, -1);
                                            }
                                            hv_ResIsFPBackground.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ResIsFPBackground = HTuple.TupleGenConst(
                                                    hv_CurrentNumRes, 0);
                                            }
                                            hv_ResIsFPLocalization.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ResIsFPLocalization = HTuple.TupleGenConst(
                                                    hv_CurrentNumRes, 0);
                                            }
                                            hv_ResIsFPDuplicate.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ResIsFPDuplicate = HTuple.TupleGenConst(
                                                    hv_CurrentNumRes, 0);
                                            }
                                            hv_ResIsFPMultiple.Dispose();
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                hv_ResIsFPMultiple = HTuple.TupleGenConst(
                                                    hv_CurrentNumRes, 0);
                                            }
                                            //
                                            //Initialize detailed running measures for orientation difference.
                                            if ((int)(hv_EvaluateOrientation) != 0)
                                            {
                                                hv_ResAbsOrientationDiffClass.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_ResAbsOrientationDiffClass = HTuple.TupleGenConst(
                                                        hv_CurrentNumRes, -1);
                                                }
                                                hv_ResAbsOrientationDiffLocalization.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_ResAbsOrientationDiffLocalization = HTuple.TupleGenConst(
                                                        hv_CurrentNumRes, -1);
                                                }
                                                hv_ResAbsOrientationDiffDuplicate.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_ResAbsOrientationDiffDuplicate = HTuple.TupleGenConst(
                                                        hv_CurrentNumRes, -1);
                                                }
                                                hv_ResAbsOrientationDiffMultiple.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_ResAbsOrientationDiffMultiple = HTuple.TupleGenConst(
                                                        hv_CurrentNumRes, -1);
                                                }
                                            }
                                            //Check if there have been false positives.
                                            if ((int)(new HTuple(((hv_ResMatched.TupleSum())).TupleLess(hv_CurrentNumRes))) != 0)
                                            {
                                                if (hv_SampleHasFP == null)
                                                    hv_SampleHasFP = new HTuple();
                                                hv_SampleHasFP[hv_ITIdx] = 1;
                                                //
                                                //For each false positive, find out what was the reason for being false positive:
                                                hv_FPResIdxsThisClass.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_FPResIdxsThisClass = hv_ResMatched.TupleFind(
                                                        0);
                                                }
                                                hv_FPResIdxsAllResults.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_FPResIdxsAllResults = hv_CurrentResIdxs.TupleSelect(
                                                        hv_FPResIdxsThisClass);
                                                }
                                                hv_GTIdxsNotToIgnore.Dispose();
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    hv_GTIdxsNotToIgnore = hv_GtIgnore.TupleFind(
                                                        0);
                                                }
                                                for (hv_ResIdx = 0; (int)hv_ResIdx <= (int)((new HTuple(hv_FPResIdxsThisClass.TupleLength()
                                                    )) - 1); hv_ResIdx = (int)hv_ResIdx + 1)
                                                {
                                                    if ((int)(((hv_ResIgnore.TupleSelect(hv_FPResIdxsThisClass.TupleSelect(
                                                        hv_ResIdx)))).TupleNot()) != 0)
                                                    {
                                                        if ((int)((new HTuple((new HTuple(hv_GTIdxsNotToIgnore.TupleLength()
                                                            )).TupleEqual(0))).TupleOr(new HTuple(hv_GTIdxsNotToIgnore.TupleEqual(
                                                            -1)))) != 0)
                                                        {
                                                            //No GT instances or all GT instances are ignored.
                                                            //Thus, any detection is a background detection
                                                            hv_MaxIoU.Dispose();
                                                            hv_MaxIoU = 0.0;
                                                        }
                                                        else
                                                        {
                                                            //We have GT instances to consider.
                                                            hv_IoUsWithGT.Dispose();
                                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                            {
                                                                hv_IoUsWithGT = hv_IoUs.TupleSelect(
                                                                    (hv_GTIdxsNotToIgnore * hv_NumRes) + (hv_FPResIdxsAllResults.TupleSelect(
                                                                    hv_ResIdx)));
                                                            }
                                                            hv_MaxIoU.Dispose();
                                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                            {
                                                                hv_MaxIoU = hv_IoUsWithGT.TupleMax()
                                                                    ;
                                                            }
                                                            //It is enough to look for the first occurrence because the IoUs to ground truth should be different.
                                                            hv_MaxIdx.Dispose();
                                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                            {
                                                                hv_MaxIdx = hv_IoUsWithGT.TupleFindFirst(
                                                                    hv_MaxIoU);
                                                            }
                                                            hv_GTClassIDMaxIoU.Dispose();
                                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                            {
                                                                hv_GTClassIDMaxIoU = hv_GtClassIDs.TupleSelect(
                                                                    hv_GTIdxsNotToIgnore.TupleSelect(hv_MaxIdx));
                                                            }
                                                        }
                                                        if ((int)(hv_EvaluateOrientation.TupleAnd(new HTuple(hv_MaxIoU.TupleGreater(
                                                            0.0)))) != 0)
                                                        {
                                                            //Calculate the absolute orientation difference to the GT instance with maximal IoU.
                                                            hv_AbsOrientationDiff.Dispose();
                                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                            {
                                                                hv_AbsOrientationDiff = (((hv_ResPhis.TupleSelect(
                                                                    hv_FPResIdxsAllResults.TupleSelect(hv_ResIdx))) - (hv_GtPhis.TupleSelect(
                                                                    hv_GTIdxsNotToIgnore.TupleSelect(hv_MaxIdx))))).TupleAbs()
                                                                    ;
                                                            }
                                                            if ((int)(new HTuple(hv_AbsOrientationDiff.TupleGreater(
                                                                (new HTuple(180)).TupleRad()))) != 0)
                                                            {
                                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                                {
                                                                    {
                                                                        HTuple
                                                                          ExpTmpLocalVar_AbsOrientationDiff = ((new HTuple(360)).TupleRad()
                                                                            ) - hv_AbsOrientationDiff;
                                                                        hv_AbsOrientationDiff.Dispose();
                                                                        hv_AbsOrientationDiff = ExpTmpLocalVar_AbsOrientationDiff;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        //Determine false positive type.
                                                        if ((int)(new HTuple(hv_MaxIoU.TupleEqual(0.0))) != 0)
                                                        {
                                                            //Background detection. This detection does not overlap to any ground truth (that is not ignored).
                                                            if (hv_ResIsFPBackground == null)
                                                                hv_ResIsFPBackground = new HTuple();
                                                            hv_ResIsFPBackground[hv_FPResIdxsThisClass.TupleSelect(
                                                                hv_ResIdx)] = 1;
                                                        }
                                                        else if ((int)((new HTuple(hv_MaxIoU.TupleGreaterEqual(
                                                            hv_IoUThresholds.TupleSelect(hv_ITIdx)))).TupleAnd(
                                                            new HTuple(hv_CurrentClassID.TupleNotEqual(hv_GTClassIDMaxIoU)))) != 0)
                                                        {
                                                            //False class.
                                                            //Note that this does not necessarily mean that this detection
                                                            //would be a true positive if the class was changed. It could still be a duplicate.
                                                            if (hv_ResIsFPClass == null)
                                                                hv_ResIsFPClass = new HTuple();
                                                            hv_ResIsFPClass[hv_FPResIdxsThisClass.TupleSelect(hv_ResIdx)] = hv_ClassIDToClassIdx.TupleSelect(
                                                                hv_GTClassIDMaxIoU);
                                                            //Store the absolute orientation difference.
                                                            if ((int)(hv_EvaluateOrientation) != 0)
                                                            {
                                                                if (hv_ResAbsOrientationDiffClass == null)
                                                                    hv_ResAbsOrientationDiffClass = new HTuple();
                                                                hv_ResAbsOrientationDiffClass[hv_FPResIdxsThisClass.TupleSelect(
                                                                    hv_ResIdx)] = hv_AbsOrientationDiff;
                                                            }
                                                        }
                                                        else if ((int)((new HTuple(hv_MaxIoU.TupleGreaterEqual(
                                                            hv_IoUThresholds.TupleSelect(hv_ITIdx)))).TupleAnd(
                                                            new HTuple(hv_CurrentClassID.TupleEqual(hv_GTClassIDMaxIoU)))) != 0)
                                                        {
                                                            //Duplicate detection. There must exist another detection with a higher confidence with the same ground truth.
                                                            if (hv_ResIsFPDuplicate == null)
                                                                hv_ResIsFPDuplicate = new HTuple();
                                                            hv_ResIsFPDuplicate[hv_FPResIdxsThisClass.TupleSelect(
                                                                hv_ResIdx)] = 1;
                                                            //Store the absolute orientation difference.
                                                            if ((int)(hv_EvaluateOrientation) != 0)
                                                            {
                                                                if (hv_ResAbsOrientationDiffDuplicate == null)
                                                                    hv_ResAbsOrientationDiffDuplicate = new HTuple();
                                                                hv_ResAbsOrientationDiffDuplicate[hv_FPResIdxsThisClass.TupleSelect(
                                                                    hv_ResIdx)] = hv_AbsOrientationDiff;
                                                            }
                                                        }
                                                        else if ((int)((new HTuple(hv_MaxIoU.TupleLess(
                                                            hv_IoUThresholds.TupleSelect(hv_ITIdx)))).TupleAnd(
                                                            new HTuple(hv_CurrentClassID.TupleEqual(hv_GTClassIDMaxIoU)))) != 0)
                                                        {
                                                            //Bad localization. Class is correct, but the IoU is too low.
                                                            if (hv_ResIsFPLocalization == null)
                                                                hv_ResIsFPLocalization = new HTuple();
                                                            hv_ResIsFPLocalization[hv_FPResIdxsThisClass.TupleSelect(
                                                                hv_ResIdx)] = 1;
                                                            //Store the absolute orientation difference.
                                                            if ((int)(hv_EvaluateOrientation) != 0)
                                                            {
                                                                if (hv_ResAbsOrientationDiffLocalization == null)
                                                                    hv_ResAbsOrientationDiffLocalization = new HTuple();
                                                                hv_ResAbsOrientationDiffLocalization[hv_FPResIdxsThisClass.TupleSelect(
                                                                    hv_ResIdx)] = hv_AbsOrientationDiff;
                                                            }
                                                        }
                                                        else if ((int)((new HTuple(hv_MaxIoU.TupleLess(
                                                            hv_IoUThresholds.TupleSelect(hv_ITIdx)))).TupleAnd(
                                                            new HTuple(hv_CurrentClassID.TupleNotEqual(hv_GTClassIDMaxIoU)))) != 0)
                                                        {
                                                            //Wrong class and bad localization.
                                                            if (hv_ResIsFPMultiple == null)
                                                                hv_ResIsFPMultiple = new HTuple();
                                                            hv_ResIsFPMultiple[hv_FPResIdxsThisClass.TupleSelect(
                                                                hv_ResIdx)] = 1;
                                                            //Store the absolute orientation difference.
                                                            if ((int)(hv_EvaluateOrientation) != 0)
                                                            {
                                                                if (hv_ResAbsOrientationDiffMultiple == null)
                                                                    hv_ResAbsOrientationDiffMultiple = new HTuple();
                                                                hv_ResAbsOrientationDiffMultiple[hv_FPResIdxsThisClass.TupleSelect(
                                                                    hv_ResIdx)] = hv_AbsOrientationDiff;
                                                            }
                                                        }
                                                        else
                                                        {
                                                            //This case should never occur.
                                                            throw new HalconException("Fatal error during detailed evaluation.");
                                                        }
                                                    }
                                                }
                                            }
                                            //
                                            //Overwrite the detailed running measures.
                                            hv_IsFPClass.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_fp_class",
                                                out hv_IsFPClass);
                                            hv_IsFPBackground.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_fp_background",
                                                out hv_IsFPBackground);
                                            hv_IsFPLocalization.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_fp_localization",
                                                out hv_IsFPLocalization);
                                            hv_IsFPDuplicate.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_fp_duplicate",
                                                out hv_IsFPDuplicate);
                                            hv_IsFPMultiple.Dispose();
                                            HOperatorSet.GetDictTuple(hv_PerClassMeasures, "is_fp_multiple",
                                                out hv_IsFPMultiple);
                                            if ((int)(hv_EvaluateOrientation) != 0)
                                            {
                                                hv_AbsOrientationDiffMultiple.Dispose();
                                                HOperatorSet.GetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_multiple",
                                                    out hv_AbsOrientationDiffMultiple);
                                                hv_AbsOrientationDiffDuplicate.Dispose();
                                                HOperatorSet.GetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_duplicate",
                                                    out hv_AbsOrientationDiffDuplicate);
                                                hv_AbsOrientationDiffLocalization.Dispose();
                                                HOperatorSet.GetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_localization",
                                                    out hv_AbsOrientationDiffLocalization);
                                                hv_AbsOrientationDiffClass.Dispose();
                                                HOperatorSet.GetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_class",
                                                    out hv_AbsOrientationDiffClass);
                                            }
                                            //Allocate new blocks if necessary (all have the same length).
                                            if ((int)(new HTuple(((hv_PerClassNumPred.TupleSelect(hv_ClsIdx))).TupleGreater(
                                                new HTuple(hv_IsFPClass.TupleLength())))) != 0)
                                            {
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_IsFPClass = hv_IsFPClass.TupleConcat(
                                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                        hv_IsFPClass.Dispose();
                                                        hv_IsFPClass = ExpTmpLocalVar_IsFPClass;
                                                    }
                                                }
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_IsFPBackground = hv_IsFPBackground.TupleConcat(
                                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                        hv_IsFPBackground.Dispose();
                                                        hv_IsFPBackground = ExpTmpLocalVar_IsFPBackground;
                                                    }
                                                }
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_IsFPLocalization = hv_IsFPLocalization.TupleConcat(
                                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                        hv_IsFPLocalization.Dispose();
                                                        hv_IsFPLocalization = ExpTmpLocalVar_IsFPLocalization;
                                                    }
                                                }
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_IsFPDuplicate = hv_IsFPDuplicate.TupleConcat(
                                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                        hv_IsFPDuplicate.Dispose();
                                                        hv_IsFPDuplicate = ExpTmpLocalVar_IsFPDuplicate;
                                                    }
                                                }
                                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                {
                                                    {
                                                        HTuple
                                                          ExpTmpLocalVar_IsFPMultiple = hv_IsFPMultiple.TupleConcat(
                                                            HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                        hv_IsFPMultiple.Dispose();
                                                        hv_IsFPMultiple = ExpTmpLocalVar_IsFPMultiple;
                                                    }
                                                }
                                                if ((int)(hv_EvaluateOrientation) != 0)
                                                {
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        {
                                                            HTuple
                                                              ExpTmpLocalVar_AbsOrientationDiffMultiple = hv_AbsOrientationDiffMultiple.TupleConcat(
                                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                            hv_AbsOrientationDiffMultiple.Dispose();
                                                            hv_AbsOrientationDiffMultiple = ExpTmpLocalVar_AbsOrientationDiffMultiple;
                                                        }
                                                    }
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        {
                                                            HTuple
                                                              ExpTmpLocalVar_AbsOrientationDiffDuplicate = hv_AbsOrientationDiffDuplicate.TupleConcat(
                                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                            hv_AbsOrientationDiffDuplicate.Dispose();
                                                            hv_AbsOrientationDiffDuplicate = ExpTmpLocalVar_AbsOrientationDiffDuplicate;
                                                        }
                                                    }
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        {
                                                            HTuple
                                                              ExpTmpLocalVar_AbsOrientationDiffLocalization = hv_AbsOrientationDiffLocalization.TupleConcat(
                                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                            hv_AbsOrientationDiffLocalization.Dispose();
                                                            hv_AbsOrientationDiffLocalization = ExpTmpLocalVar_AbsOrientationDiffLocalization;
                                                        }
                                                    }
                                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                                    {
                                                        {
                                                            HTuple
                                                              ExpTmpLocalVar_AbsOrientationDiffClass = hv_AbsOrientationDiffClass.TupleConcat(
                                                                HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                            hv_AbsOrientationDiffClass.Dispose();
                                                            hv_AbsOrientationDiffClass = ExpTmpLocalVar_AbsOrientationDiffClass;
                                                        }
                                                    }
                                                }
                                            }
                                            if (hv_IsFPClass == null)
                                                hv_IsFPClass = new HTuple();
                                            hv_IsFPClass[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                                hv_ClsIdx)) - 1, 1)] = hv_ResIsFPClass;
                                            if (hv_IsFPBackground == null)
                                                hv_IsFPBackground = new HTuple();
                                            hv_IsFPBackground[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                                hv_ClsIdx)) - 1, 1)] = hv_ResIsFPBackground;
                                            if (hv_IsFPLocalization == null)
                                                hv_IsFPLocalization = new HTuple();
                                            hv_IsFPLocalization[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                                hv_ClsIdx)) - 1, 1)] = hv_ResIsFPLocalization;
                                            if (hv_IsFPDuplicate == null)
                                                hv_IsFPDuplicate = new HTuple();
                                            hv_IsFPDuplicate[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                                hv_ClsIdx)) - 1, 1)] = hv_ResIsFPDuplicate;
                                            if (hv_IsFPMultiple == null)
                                                hv_IsFPMultiple = new HTuple();
                                            hv_IsFPMultiple[HTuple.TupleGenSequence(hv_OldNumPred, (hv_PerClassNumPred.TupleSelect(
                                                hv_ClsIdx)) - 1, 1)] = hv_ResIsFPMultiple;
                                            if ((int)(hv_EvaluateOrientation) != 0)
                                            {
                                                if (hv_AbsOrientationDiffMultiple == null)
                                                    hv_AbsOrientationDiffMultiple = new HTuple();
                                                hv_AbsOrientationDiffMultiple[HTuple.TupleGenSequence(hv_OldNumPred,
                                                    (hv_PerClassNumPred.TupleSelect(hv_ClsIdx)) - 1, 1)] = hv_ResAbsOrientationDiffMultiple;
                                                if (hv_AbsOrientationDiffDuplicate == null)
                                                    hv_AbsOrientationDiffDuplicate = new HTuple();
                                                hv_AbsOrientationDiffDuplicate[HTuple.TupleGenSequence(hv_OldNumPred,
                                                    (hv_PerClassNumPred.TupleSelect(hv_ClsIdx)) - 1, 1)] = hv_ResAbsOrientationDiffDuplicate;
                                                if (hv_AbsOrientationDiffLocalization == null)
                                                    hv_AbsOrientationDiffLocalization = new HTuple();
                                                hv_AbsOrientationDiffLocalization[HTuple.TupleGenSequence(hv_OldNumPred,
                                                    (hv_PerClassNumPred.TupleSelect(hv_ClsIdx)) - 1, 1)] = hv_ResAbsOrientationDiffLocalization;
                                                if (hv_AbsOrientationDiffClass == null)
                                                    hv_AbsOrientationDiffClass = new HTuple();
                                                hv_AbsOrientationDiffClass[HTuple.TupleGenSequence(hv_OldNumPred,
                                                    (hv_PerClassNumPred.TupleSelect(hv_ClsIdx)) - 1, 1)] = hv_ResAbsOrientationDiffClass;
                                            }
                                            HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_fp_class",
                                                hv_IsFPClass);
                                            HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_fp_background",
                                                hv_IsFPBackground);
                                            HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_fp_localization",
                                                hv_IsFPLocalization);
                                            HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_fp_duplicate",
                                                hv_IsFPDuplicate);
                                            HOperatorSet.SetDictTuple(hv_PerClassMeasures, "is_fp_multiple",
                                                hv_IsFPMultiple);
                                            if ((int)(hv_EvaluateOrientation) != 0)
                                            {
                                                HOperatorSet.SetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_multiple",
                                                    hv_AbsOrientationDiffMultiple);
                                                HOperatorSet.SetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_duplicate",
                                                    hv_AbsOrientationDiffDuplicate);
                                                HOperatorSet.SetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_localization",
                                                    hv_AbsOrientationDiffLocalization);
                                                HOperatorSet.SetDictTuple(hv_PerClassMeasures, "abs_orientation_diff_class",
                                                    hv_AbsOrientationDiffClass);
                                            }
                                        }
                                        //
                                        //End of detailed evaluation processing.
                                        //
                                    }
                                }
                                else
                                {
                                    if ((int)(hv_DetailedEvaluation.TupleAnd(new HTuple(hv_CurrentNumGtNoIgnore.TupleGreater(
                                        0)))) != 0)
                                    {
                                        //There are false negatives for this class.
                                        //Loop over IoU thresholds.
                                        for (hv_ITIdx = 0; (int)hv_ITIdx <= (int)((new HTuple(hv_IoUThresholds.TupleLength()
                                            )) - 1); hv_ITIdx = (int)hv_ITIdx + 1)
                                        {
                                            if (hv_SampleHasFN == null)
                                                hv_SampleHasFN = new HTuple();
                                            hv_SampleHasFN[hv_ITIdx] = 1;
                                        }
                                    }
                                }
                            }
                            //Update the confidences, num_gt and num_pred.
                            HOperatorSet.SetDictTuple(hv_AreaRunningMeasures, "num_gt", hv_PerClassNumGt);
                            HOperatorSet.SetDictTuple(hv_AreaRunningMeasures, "num_pred", hv_PerClassNumPred);
                            HOperatorSet.SetDictTuple(hv_AreaRunningMeasures, "confidence", hv_PerClassConfidences);
                            HOperatorSet.SetDictTuple(hv_AreaRunningMeasures, "num_gt_ignore", hv_PerClassNumGtIgnore);
                            //
                            if ((int)(hv_DetailedEvaluation) != 0)
                            {
                                //Set values that are calculated over all classes (for each IoU threshold).
                                for (hv_ITIdx = 0; (int)hv_ITIdx <= (int)((new HTuple(hv_IoUThresholds.TupleLength()
                                    )) - 1); hv_ITIdx = (int)hv_ITIdx + 1)
                                {
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_PerIoUMeasure.Dispose();
                                        HOperatorSet.GetDictTuple(hv_AreaRunningMeasures, "iou_" + ((("" + (hv_IoUThresholds.TupleSelect(
                                            hv_ITIdx)))).TupleRegexpReplace("\\.", "")), out hv_PerIoUMeasure);
                                    }
                                    //Set image IDs with false negatives
                                    if ((int)(hv_SampleHasFN.TupleSelect(hv_ITIdx)) != 0)
                                    {
                                        hv_CurrentImageID.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentSample, "image_id", out hv_CurrentImageID);
                                        hv_ImageIDsWithFN.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_negatives",
                                            out hv_ImageIDsWithFN);
                                        hv_NumImageIDsWithFN.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_negatives",
                                            out hv_NumImageIDsWithFN);
                                        //Allocate a new block if necessary.
                                        if ((int)(new HTuple(((hv_NumImageIDsWithFN + 1)).TupleGreater(new HTuple(hv_ImageIDsWithFN.TupleLength()
                                            )))) != 0)
                                        {
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                {
                                                    HTuple
                                                      ExpTmpLocalVar_ImageIDsWithFN = hv_ImageIDsWithFN.TupleConcat(
                                                        HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                    hv_ImageIDsWithFN.Dispose();
                                                    hv_ImageIDsWithFN = ExpTmpLocalVar_ImageIDsWithFN;
                                                }
                                            }
                                        }
                                        if (hv_ImageIDsWithFN == null)
                                            hv_ImageIDsWithFN = new HTuple();
                                        hv_ImageIDsWithFN[hv_NumImageIDsWithFN] = hv_CurrentImageID;
                                        HOperatorSet.SetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_negatives",
                                            hv_ImageIDsWithFN);
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_negatives",
                                                hv_NumImageIDsWithFN + 1);
                                        }
                                    }
                                    if ((int)(hv_SampleHasFP.TupleSelect(hv_ITIdx)) != 0)
                                    {
                                        hv_CurrentImageID.Dispose();
                                        HOperatorSet.GetDictTuple(hv_CurrentSample, "image_id", out hv_CurrentImageID);
                                        hv_ImageIDsWithFP.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_positives",
                                            out hv_ImageIDsWithFP);
                                        hv_NumImageIDsWithFP.Dispose();
                                        HOperatorSet.GetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_positives",
                                            out hv_NumImageIDsWithFP);
                                        //Allocate a new block if necessary.
                                        if ((int)(new HTuple(((hv_NumImageIDsWithFP + 1)).TupleGreater(new HTuple(hv_ImageIDsWithFP.TupleLength()
                                            )))) != 0)
                                        {
                                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                            {
                                                {
                                                    HTuple
                                                      ExpTmpLocalVar_ImageIDsWithFP = hv_ImageIDsWithFP.TupleConcat(
                                                        HTuple.TupleGenConst(hv_AllocationBlockLength, -1));
                                                    hv_ImageIDsWithFP.Dispose();
                                                    hv_ImageIDsWithFP = ExpTmpLocalVar_ImageIDsWithFP;
                                                }
                                            }
                                        }
                                        if (hv_ImageIDsWithFP == null)
                                            hv_ImageIDsWithFP = new HTuple();
                                        hv_ImageIDsWithFP[hv_NumImageIDsWithFP] = hv_CurrentImageID;
                                        HOperatorSet.SetDictTuple(hv_PerIoUMeasure, "image_ids_with_false_positives",
                                            hv_ImageIDsWithFP);
                                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                        {
                                            HOperatorSet.SetDictTuple(hv_PerIoUMeasure, "num_image_ids_with_false_positives",
                                                hv_NumImageIDsWithFP + 1);
                                        }
                                    }
                                }
                            }
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetDictTuple(hv_CurrentRunningMeasures, "area_" + hv_AreaName,
                                hv_AreaRunningMeasures);
                        }
                    }
                }
                //

                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_IoUThresholds.Dispose();
                hv_InstanceType.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClasses.Dispose();
                hv_Measures.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_NumAreaRanges.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_KeyExists.Dispose();
                hv_ClassIDToClassIdx.Dispose();
                hv_EvaluateOrientation.Dispose();
                hv_SIdx.Dispose();
                hv_CurrentSample.Dispose();
                hv_CurrentResult.Dispose();
                hv_GtClassIDs.Dispose();
                hv_ResClassIDs.Dispose();
                hv_NumGT.Dispose();
                hv_NumRes.Dispose();
                hv_Confidences.Dispose();
                hv_ResSortIndices.Dispose();
                hv_GtAreas.Dispose();
                hv_ResAreas.Dispose();
                hv_IoUs.Dispose();
                hv_GtPhis.Dispose();
                hv_ResPhis.Dispose();
                hv_MDIdx.Dispose();
                hv_MaxNum.Dispose();
                hv_MaxNumStr.Dispose();
                hv_CurrentRunningMeasures.Dispose();
                hv_AreaIdx.Dispose();
                hv_MinArea.Dispose();
                hv_MaxArea.Dispose();
                hv_AreaName.Dispose();
                hv_AreaRunningMeasures.Dispose();
                hv_GtIgnore.Dispose();
                hv_GtIgnoreInds.Dispose();
                hv_PerClassNumGt.Dispose();
                hv_PerClassNumPred.Dispose();
                hv_PerClassConfidences.Dispose();
                hv_PerClassNumGtIgnore.Dispose();
                hv_SampleHasFP.Dispose();
                hv_SampleHasFN.Dispose();
                hv_ClsIdx.Dispose();
                hv_CurrentClassID.Dispose();
                hv_CurrentGtIdxs.Dispose();
                hv_CurrentNumGt.Dispose();
                hv_CurrentGtIgnore.Dispose();
                hv_CurrentNumGtIgnore.Dispose();
                hv_CurrentNumGtNoIgnore.Dispose();
                hv_CurrentResIdxs.Dispose();
                hv_CurrentNumRes.Dispose();
                hv_CurrentResAreas.Dispose();
                hv_OldNumPred.Dispose();
                hv_CurrentClassConfidences.Dispose();
                hv_GtSortIdx.Dispose();
                hv_CurrentResPhis.Dispose();
                hv_CurrentGtPhis.Dispose();
                hv_ITIdx.Dispose();
                hv_GtMatched.Dispose();
                hv_ResMatched.Dispose();
                hv_ResAbsOrientationDiff.Dispose();
                hv_ResIgnore.Dispose();
                hv_ResIdx.Dispose();
                hv_CurrentIoU.Dispose();
                hv_MatchIdx.Dispose();
                hv_GtIdx.Dispose();
                hv_AreaIgnore.Dispose();
                hv_PerIoUMeasure.Dispose();
                hv_PerClassMeasures.Dispose();
                hv_CurrentIsTP.Dispose();
                hv_CurrentIgnore.Dispose();
                hv_CurrentAbsOrientationDiff.Dispose();
                hv_GtMatchedNoIgnore.Dispose();
                hv_ResIsFPClass.Dispose();
                hv_ResIsFPBackground.Dispose();
                hv_ResIsFPLocalization.Dispose();
                hv_ResIsFPDuplicate.Dispose();
                hv_ResIsFPMultiple.Dispose();
                hv_ResAbsOrientationDiffClass.Dispose();
                hv_ResAbsOrientationDiffLocalization.Dispose();
                hv_ResAbsOrientationDiffDuplicate.Dispose();
                hv_ResAbsOrientationDiffMultiple.Dispose();
                hv_FPResIdxsThisClass.Dispose();
                hv_FPResIdxsAllResults.Dispose();
                hv_GTIdxsNotToIgnore.Dispose();
                hv_MaxIoU.Dispose();
                hv_IoUsWithGT.Dispose();
                hv_MaxIdx.Dispose();
                hv_GTClassIDMaxIoU.Dispose();
                hv_AbsOrientationDiff.Dispose();
                hv_IsFPClass.Dispose();
                hv_IsFPBackground.Dispose();
                hv_IsFPLocalization.Dispose();
                hv_IsFPDuplicate.Dispose();
                hv_IsFPMultiple.Dispose();
                hv_AbsOrientationDiffMultiple.Dispose();
                hv_AbsOrientationDiffDuplicate.Dispose();
                hv_AbsOrientationDiffLocalization.Dispose();
                hv_AbsOrientationDiffClass.Dispose();
                hv_CurrentImageID.Dispose();
                hv_ImageIDsWithFN.Dispose();
                hv_NumImageIDsWithFN.Dispose();
                hv_ImageIDsWithFP.Dispose();
                hv_NumImageIDsWithFP.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_MaxNumDetections.Dispose();
                hv_AreaRanges.Dispose();
                hv_IoUThresholds.Dispose();
                hv_InstanceType.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClasses.Dispose();
                hv_Measures.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_NumAreaRanges.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_KeyExists.Dispose();
                hv_ClassIDToClassIdx.Dispose();
                hv_EvaluateOrientation.Dispose();
                hv_SIdx.Dispose();
                hv_CurrentSample.Dispose();
                hv_CurrentResult.Dispose();
                hv_GtClassIDs.Dispose();
                hv_ResClassIDs.Dispose();
                hv_NumGT.Dispose();
                hv_NumRes.Dispose();
                hv_Confidences.Dispose();
                hv_ResSortIndices.Dispose();
                hv_GtAreas.Dispose();
                hv_ResAreas.Dispose();
                hv_IoUs.Dispose();
                hv_GtPhis.Dispose();
                hv_ResPhis.Dispose();
                hv_MDIdx.Dispose();
                hv_MaxNum.Dispose();
                hv_MaxNumStr.Dispose();
                hv_CurrentRunningMeasures.Dispose();
                hv_AreaIdx.Dispose();
                hv_MinArea.Dispose();
                hv_MaxArea.Dispose();
                hv_AreaName.Dispose();
                hv_AreaRunningMeasures.Dispose();
                hv_GtIgnore.Dispose();
                hv_GtIgnoreInds.Dispose();
                hv_PerClassNumGt.Dispose();
                hv_PerClassNumPred.Dispose();
                hv_PerClassConfidences.Dispose();
                hv_PerClassNumGtIgnore.Dispose();
                hv_SampleHasFP.Dispose();
                hv_SampleHasFN.Dispose();
                hv_ClsIdx.Dispose();
                hv_CurrentClassID.Dispose();
                hv_CurrentGtIdxs.Dispose();
                hv_CurrentNumGt.Dispose();
                hv_CurrentGtIgnore.Dispose();
                hv_CurrentNumGtIgnore.Dispose();
                hv_CurrentNumGtNoIgnore.Dispose();
                hv_CurrentResIdxs.Dispose();
                hv_CurrentNumRes.Dispose();
                hv_CurrentResAreas.Dispose();
                hv_OldNumPred.Dispose();
                hv_CurrentClassConfidences.Dispose();
                hv_GtSortIdx.Dispose();
                hv_CurrentResPhis.Dispose();
                hv_CurrentGtPhis.Dispose();
                hv_ITIdx.Dispose();
                hv_GtMatched.Dispose();
                hv_ResMatched.Dispose();
                hv_ResAbsOrientationDiff.Dispose();
                hv_ResIgnore.Dispose();
                hv_ResIdx.Dispose();
                hv_CurrentIoU.Dispose();
                hv_MatchIdx.Dispose();
                hv_GtIdx.Dispose();
                hv_AreaIgnore.Dispose();
                hv_PerIoUMeasure.Dispose();
                hv_PerClassMeasures.Dispose();
                hv_CurrentIsTP.Dispose();
                hv_CurrentIgnore.Dispose();
                hv_CurrentAbsOrientationDiff.Dispose();
                hv_GtMatchedNoIgnore.Dispose();
                hv_ResIsFPClass.Dispose();
                hv_ResIsFPBackground.Dispose();
                hv_ResIsFPLocalization.Dispose();
                hv_ResIsFPDuplicate.Dispose();
                hv_ResIsFPMultiple.Dispose();
                hv_ResAbsOrientationDiffClass.Dispose();
                hv_ResAbsOrientationDiffLocalization.Dispose();
                hv_ResAbsOrientationDiffDuplicate.Dispose();
                hv_ResAbsOrientationDiffMultiple.Dispose();
                hv_FPResIdxsThisClass.Dispose();
                hv_FPResIdxsAllResults.Dispose();
                hv_GTIdxsNotToIgnore.Dispose();
                hv_MaxIoU.Dispose();
                hv_IoUsWithGT.Dispose();
                hv_MaxIdx.Dispose();
                hv_GTClassIDMaxIoU.Dispose();
                hv_AbsOrientationDiff.Dispose();
                hv_IsFPClass.Dispose();
                hv_IsFPBackground.Dispose();
                hv_IsFPLocalization.Dispose();
                hv_IsFPDuplicate.Dispose();
                hv_IsFPMultiple.Dispose();
                hv_AbsOrientationDiffMultiple.Dispose();
                hv_AbsOrientationDiffDuplicate.Dispose();
                hv_AbsOrientationDiffLocalization.Dispose();
                hv_AbsOrientationDiffClass.Dispose();
                hv_CurrentImageID.Dispose();
                hv_ImageIDsWithFN.Dispose();
                hv_NumImageIDsWithFN.Dispose();
                hv_ImageIDsWithFP.Dispose();
                hv_NumImageIDsWithFP.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Update running measures for a pixel-based evaluation. 
        private void update_running_pixel_measures(HTuple hv_Samples, HTuple hv_Results,
            HTuple hv_EvalParams, HTuple hv_RunningMeasures)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Annot = null, ho_Result = null, ho_ClsIgnore = null;
            HObject ho_ClsIgnoreTmp = null, ho_ClsAnnot = null, ho_ClsResult = null;
            HObject ho_TPReg = null, ho_FPReg = null, ho_FNReg = null;

            // Local control variables 

            HTuple hv_ClassIDs = new HTuple(), hv_IgnoreClassIDs = new HTuple();
            HTuple hv_Measures = new HTuple(), hv_CalcConfMatrix = new HTuple();
            HTuple hv_NumClasses = new HTuple(), hv_MaxId = new HTuple();
            HTuple hv_ConfMatrix = new HTuple(), hv_MapClassIDs = new HTuple();
            HTuple hv_ClsIdToClsIdx = new HTuple(), hv_TP = new HTuple();
            HTuple hv_FP = new HTuple(), hv_FN = new HTuple(), hv_SampleIndex = new HTuple();
            HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
            HTuple hv_AnnotVals = new HTuple(), hv_ResultVals = new HTuple();
            HTuple hv_ConfTuple = new HTuple(), hv_ConfHist = new HTuple();
            HTuple hv_BinSize = new HTuple(), hv_ConfMatrixTmp = new HTuple();
            HTuple hv_IgnoreIndex = new HTuple(), hv_ClsIndex = new HTuple();
            HTuple hv_ClsId = new HTuple(), hv_ClsTP = new HTuple();
            HTuple hv_ClsFP = new HTuple(), hv_ClsFN = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Annot);
            HOperatorSet.GenEmptyObj(out ho_Result);
            HOperatorSet.GenEmptyObj(out ho_ClsIgnore);
            HOperatorSet.GenEmptyObj(out ho_ClsIgnoreTmp);
            HOperatorSet.GenEmptyObj(out ho_ClsAnnot);
            HOperatorSet.GenEmptyObj(out ho_ClsResult);
            HOperatorSet.GenEmptyObj(out ho_TPReg);
            HOperatorSet.GenEmptyObj(out ho_FPReg);
            HOperatorSet.GenEmptyObj(out ho_FNReg);
            try
            {
                //
                //This procedure updates the RunningMeasures
                //for a pixel-based evaluation for segmentation.
                //These measures are stored in the dictionary RunningMeasures and
                //updated by incorporating the Results the model obtained for the Samples.
                //
                //Get the class IDs.
                hv_ClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                //Get the ignore class IDs.
                hv_IgnoreClassIDs.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "ignore_class_ids", out hv_IgnoreClassIDs);
                //Check if we need to compute/update the confusion matrix.
                hv_Measures.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                hv_CalcConfMatrix.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_CalcConfMatrix = (new HTuple(((hv_Measures.TupleFind(
                        "pixel_confusion_matrix"))).TupleGreater(-1))).TupleOr(new HTuple(((hv_Measures.TupleFind(
                        "all"))).TupleGreater(-1)));
                }
                //Get the number of classes.
                hv_NumClasses.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
                //Get the maximum class ID plus a possible ignore-class.
                hv_MaxId.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_MaxId = (hv_ClassIDs.TupleMax()
                        ) + (new HTuple((new HTuple(hv_IgnoreClassIDs.TupleLength())).TupleGreater(
                        0)));
                }
                //
                if ((int)(hv_CalcConfMatrix) != 0)
                {
                    //Get the current confusion matrix.
                    hv_ConfMatrix.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "pixel_confusion_matrix", out hv_ConfMatrix);
                    //Check if we need to map the class IDs.
                    hv_MapClassIDs.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "class_id_mapping",
                        out hv_MapClassIDs);
                    if ((int)(hv_MapClassIDs) != 0)
                    {
                        hv_ClsIdToClsIdx.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "class_id_mapping", out hv_ClsIdToClsIdx);
                        hv_NumClasses.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_NumClasses = (hv_ClsIdToClsIdx.TupleMax()
                                ) + 1;
                        }
                    }
                }
                else
                {
                    //Get the tuples for TP/FP/FN
                    hv_TP.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "tp", out hv_TP);
                    hv_FP.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "fp", out hv_FP);
                    hv_FN.Dispose();
                    HOperatorSet.GetDictTuple(hv_RunningMeasures, "fn", out hv_FN);
                }
                //
                //Loop over images, i.e. sample dicts.
                for (hv_SampleIndex = 0; (int)hv_SampleIndex <= (int)((new HTuple(hv_Samples.TupleLength()
                    )) - 1); hv_SampleIndex = (int)hv_SampleIndex + 1)
                {
                    //Get annotation.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_Annot.Dispose();
                        HOperatorSet.GetDictObject(out ho_Annot, hv_Samples.TupleSelect(hv_SampleIndex),
                            "segmentation_image");
                    }
                    //Get result.
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_Result.Dispose();
                        HOperatorSet.GetDictObject(out ho_Result, hv_Results.TupleSelect(hv_SampleIndex),
                            "segmentation_image");
                    }
                    //
                    //Update the measures.
                    if ((int)(hv_CalcConfMatrix) != 0)
                    {
                        //Get the ground truth and predicted class IDs of all pixels.
                        hv_Rows.Dispose(); hv_Columns.Dispose();
                        HOperatorSet.GetRegionPoints(ho_Annot, out hv_Rows, out hv_Columns);
                        hv_AnnotVals.Dispose();
                        HOperatorSet.GetGrayval(ho_Annot, hv_Rows, hv_Columns, out hv_AnnotVals);
                        hv_ResultVals.Dispose();
                        HOperatorSet.GetGrayval(ho_Result, hv_Rows, hv_Columns, out hv_ResultVals);
                        //Map the class IDs to class indices.
                        if ((int)(hv_MapClassIDs) != 0)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_AnnotVals = hv_ClsIdToClsIdx.TupleSelect(
                                        hv_AnnotVals);
                                    hv_AnnotVals.Dispose();
                                    hv_AnnotVals = ExpTmpLocalVar_AnnotVals;
                                }
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                {
                                    HTuple
                                      ExpTmpLocalVar_ResultVals = hv_ClsIdToClsIdx.TupleSelect(
                                        hv_ResultVals);
                                    hv_ResultVals.Dispose();
                                    hv_ResultVals = ExpTmpLocalVar_ResultVals;
                                }
                            }
                        }
                        //The ground truth and predicted IDs are accumulated
                        //such that each confusion pair (class_i <-> class_j) gets a unique value.
                        hv_ConfTuple.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ConfTuple = (hv_NumClasses * hv_AnnotVals) + hv_ResultVals;
                        }
                        //Compute the histogram of this confusion tuple.
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_ConfHist.Dispose(); hv_BinSize.Dispose();
                            HOperatorSet.TupleHistoRange(hv_ConfTuple, 0, (hv_NumClasses * hv_NumClasses) - 1,
                                hv_NumClasses * hv_NumClasses, out hv_ConfHist, out hv_BinSize);
                        }
                        hv_ConfMatrixTmp.Dispose();
                        HOperatorSet.CreateMatrix(hv_NumClasses, hv_NumClasses, hv_ConfHist, out hv_ConfMatrixTmp);
                        {
                            HTuple ExpTmpOutVar_0;
                            HOperatorSet.TransposeMatrix(hv_ConfMatrixTmp, out ExpTmpOutVar_0);
                            hv_ConfMatrixTmp.Dispose();
                            hv_ConfMatrixTmp = ExpTmpOutVar_0;
                        }
                        {
                            HTuple ExpTmpOutVar_0;
                            HOperatorSet.AddMatrix(hv_ConfMatrix, hv_ConfMatrixTmp, out ExpTmpOutVar_0);
                            hv_ConfMatrix.Dispose();
                            hv_ConfMatrix = ExpTmpOutVar_0;
                        }
                    }
                    else
                    {
                        //Get the ignore region.
                        ho_ClsIgnore.Dispose();
                        HOperatorSet.GenEmptyRegion(out ho_ClsIgnore);
                        for (hv_IgnoreIndex = 0; (int)hv_IgnoreIndex <= (int)((new HTuple(hv_IgnoreClassIDs.TupleLength()
                            )) - 1); hv_IgnoreIndex = (int)hv_IgnoreIndex + 1)
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_ClsIgnoreTmp.Dispose();
                                HOperatorSet.Threshold(ho_Annot, out ho_ClsIgnoreTmp, hv_IgnoreClassIDs.TupleSelect(
                                    hv_IgnoreIndex), hv_IgnoreClassIDs.TupleSelect(hv_IgnoreIndex));
                            }
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.Union2(ho_ClsIgnore, ho_ClsIgnoreTmp, out ExpTmpOutVar_0
                                    );
                                ho_ClsIgnore.Dispose();
                                ho_ClsIgnore = ExpTmpOutVar_0;
                            }
                        }
                        //
                        //Go through model classes.
                        for (hv_ClsIndex = 0; (int)hv_ClsIndex <= (int)((new HTuple(hv_ClassIDs.TupleLength()
                            )) - 1); hv_ClsIndex = (int)hv_ClsIndex + 1)
                        {
                            hv_ClsId.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_ClsId = hv_ClassIDs.TupleSelect(
                                    hv_ClsIndex);
                            }
                            //Get the annotated region for this class.
                            ho_ClsAnnot.Dispose();
                            HOperatorSet.Threshold(ho_Annot, out ho_ClsAnnot, hv_ClsId, hv_ClsId);
                            //Get the result region for this class.
                            ho_ClsResult.Dispose();
                            HOperatorSet.Threshold(ho_Result, out ho_ClsResult, hv_ClsId, hv_ClsId);
                            //The pixels in the ignore region should not be considered.
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.Difference(ho_ClsResult, ho_ClsIgnore, out ExpTmpOutVar_0
                                    );
                                ho_ClsResult.Dispose();
                                ho_ClsResult = ExpTmpOutVar_0;
                            }
                            //Get TP/FP/FN.
                            ho_TPReg.Dispose();
                            HOperatorSet.Intersection(ho_ClsAnnot, ho_ClsResult, out ho_TPReg);
                            ho_FPReg.Dispose();
                            HOperatorSet.Difference(ho_ClsResult, ho_ClsAnnot, out ho_FPReg);
                            //We define false negatives as pixels that have been labeled as this class,
                            //but not been correctly predicted.
                            ho_FNReg.Dispose();
                            HOperatorSet.Difference(ho_ClsAnnot, ho_ClsResult, out ho_FNReg);
                            //Get corresponding pixel numbers and update.
                            hv_ClsTP.Dispose();
                            HOperatorSet.RegionFeatures(ho_TPReg, "area", out hv_ClsTP);
                            hv_ClsFP.Dispose();
                            HOperatorSet.RegionFeatures(ho_FPReg, "area", out hv_ClsFP);
                            hv_ClsFN.Dispose();
                            HOperatorSet.RegionFeatures(ho_FNReg, "area", out hv_ClsFN);
                            if (hv_TP == null)
                                hv_TP = new HTuple();
                            hv_TP[hv_ClsIndex] = (hv_TP.TupleSelect(hv_ClsIndex)) + hv_ClsTP;
                            if (hv_FP == null)
                                hv_FP = new HTuple();
                            hv_FP[hv_ClsIndex] = (hv_FP.TupleSelect(hv_ClsIndex)) + hv_ClsFP;
                            if (hv_FN == null)
                                hv_FN = new HTuple();
                            hv_FN[hv_ClsIndex] = (hv_FN.TupleSelect(hv_ClsIndex)) + hv_ClsFN;
                        }
                    }
                }
                //
                //Update running measures.
                if ((int)(hv_CalcConfMatrix) != 0)
                {
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "pixel_confusion_matrix", hv_ConfMatrix);
                }
                else
                {
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "tp", hv_TP);
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "fp", hv_FP);
                    HOperatorSet.SetDictTuple(hv_RunningMeasures, "fn", hv_FN);
                }
                //
                ho_Annot.Dispose();
                ho_Result.Dispose();
                ho_ClsIgnore.Dispose();
                ho_ClsIgnoreTmp.Dispose();
                ho_ClsAnnot.Dispose();
                ho_ClsResult.Dispose();
                ho_TPReg.Dispose();
                ho_FPReg.Dispose();
                ho_FNReg.Dispose();

                hv_ClassIDs.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_Measures.Dispose();
                hv_CalcConfMatrix.Dispose();
                hv_NumClasses.Dispose();
                hv_MaxId.Dispose();
                hv_ConfMatrix.Dispose();
                hv_MapClassIDs.Dispose();
                hv_ClsIdToClsIdx.Dispose();
                hv_TP.Dispose();
                hv_FP.Dispose();
                hv_FN.Dispose();
                hv_SampleIndex.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_AnnotVals.Dispose();
                hv_ResultVals.Dispose();
                hv_ConfTuple.Dispose();
                hv_ConfHist.Dispose();
                hv_BinSize.Dispose();
                hv_ConfMatrixTmp.Dispose();
                hv_IgnoreIndex.Dispose();
                hv_ClsIndex.Dispose();
                hv_ClsId.Dispose();
                hv_ClsTP.Dispose();
                hv_ClsFP.Dispose();
                hv_ClsFN.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Annot.Dispose();
                ho_Result.Dispose();
                ho_ClsIgnore.Dispose();
                ho_ClsIgnoreTmp.Dispose();
                ho_ClsAnnot.Dispose();
                ho_ClsResult.Dispose();
                ho_TPReg.Dispose();
                ho_FPReg.Dispose();
                ho_FNReg.Dispose();

                hv_ClassIDs.Dispose();
                hv_IgnoreClassIDs.Dispose();
                hv_Measures.Dispose();
                hv_CalcConfMatrix.Dispose();
                hv_NumClasses.Dispose();
                hv_MaxId.Dispose();
                hv_ConfMatrix.Dispose();
                hv_MapClassIDs.Dispose();
                hv_ClsIdToClsIdx.Dispose();
                hv_TP.Dispose();
                hv_FP.Dispose();
                hv_FN.Dispose();
                hv_SampleIndex.Dispose();
                hv_Rows.Dispose();
                hv_Columns.Dispose();
                hv_AnnotVals.Dispose();
                hv_ResultVals.Dispose();
                hv_ConfTuple.Dispose();
                hv_ConfHist.Dispose();
                hv_BinSize.Dispose();
                hv_ConfMatrixTmp.Dispose();
                hv_IgnoreIndex.Dispose();
                hv_ClsIndex.Dispose();
                hv_ClsId.Dispose();
                hv_ClsTP.Dispose();
                hv_ClsFP.Dispose();
                hv_ClsFN.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Update model parameters according to the change strategies. 
        private void update_train_dl_model_change_strategies(HTuple hv_DLModelHandle,
            HTuple hv_ChangeStrategyData, HTuple hv_Epoch)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Enabled = new HTuple(), hv_ChangeStrategies = new HTuple();
            HTuple hv_Index = new HTuple(), hv_ChangeStrategy = new HTuple();
            HTuple hv_ModelParam = new HTuple(), hv_Epochs = new HTuple();
            HTuple hv_Values = new HTuple(), hv_Initial = new HTuple();
            HTuple hv_Greater = new HTuple(), hv_ValueIndex = new HTuple();
            HTuple hv_Value = new HTuple(), hv_InternalCurrentExists = new HTuple();
            HTuple hv_InternalCurrent = new HTuple(), hv_ScaleThreshold = new HTuple();
            HTuple hv_CurrentLR = new HTuple(), hv_LRChangeRatio = new HTuple();
            HTuple hv_PreviousMomentumExists = new HTuple(), hv_CurrentMomentum = new HTuple();
            HTuple hv_AdaptedMomentum = new HTuple(), hv_AdaptedMomentumExists = new HTuple();
            HTuple hv_PreviousMomentum = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //This procedure updates all parameters according to the change strategies
                //with respect to the current iteration.
                //
                hv_Enabled.Dispose();
                HOperatorSet.GetDictTuple(hv_ChangeStrategyData, "enabled", out hv_Enabled);
                if ((int)(hv_Enabled.TupleNot()) != 0)
                {

                    hv_Enabled.Dispose();
                    hv_ChangeStrategies.Dispose();
                    hv_Index.Dispose();
                    hv_ChangeStrategy.Dispose();
                    hv_ModelParam.Dispose();
                    hv_Epochs.Dispose();
                    hv_Values.Dispose();
                    hv_Initial.Dispose();
                    hv_Greater.Dispose();
                    hv_ValueIndex.Dispose();
                    hv_Value.Dispose();
                    hv_InternalCurrentExists.Dispose();
                    hv_InternalCurrent.Dispose();
                    hv_ScaleThreshold.Dispose();
                    hv_CurrentLR.Dispose();
                    hv_LRChangeRatio.Dispose();
                    hv_PreviousMomentumExists.Dispose();
                    hv_CurrentMomentum.Dispose();
                    hv_AdaptedMomentum.Dispose();
                    hv_AdaptedMomentumExists.Dispose();
                    hv_PreviousMomentum.Dispose();

                    return;
                }
                //
                hv_ChangeStrategies.Dispose();
                HOperatorSet.GetDictTuple(hv_ChangeStrategyData, "strategies", out hv_ChangeStrategies);
                //
                //Update the parameter of each strategy.
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_ChangeStrategies.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    hv_ChangeStrategy.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ChangeStrategy = hv_ChangeStrategies.TupleSelect(
                            hv_Index);
                    }
                    hv_ModelParam.Dispose();
                    HOperatorSet.GetDictTuple(hv_ChangeStrategy, "model_param", out hv_ModelParam);
                    hv_Epochs.Dispose();
                    HOperatorSet.GetDictTuple(hv_ChangeStrategy, "epochs", out hv_Epochs);
                    hv_Values.Dispose();
                    HOperatorSet.GetDictTuple(hv_ChangeStrategy, "values", out hv_Values);
                    hv_Initial.Dispose();
                    HOperatorSet.GetDictTuple(hv_ChangeStrategy, "initial_value", out hv_Initial);
                    //Epochs defines at which epoch the change happens. Its sorting is enforced during initialization.
                    hv_Greater.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Greater = hv_Epoch.TupleGreaterEqualElem(
                            hv_Epochs);
                    }
                    hv_ValueIndex.Dispose();
                    HOperatorSet.TupleFindLast(hv_Greater, 1, out hv_ValueIndex);
                    if ((int)(new HTuple(hv_ValueIndex.TupleEqual(-1))) != 0)
                    {
                        hv_Value.Dispose();
                        hv_Value = new HTuple(hv_Initial);
                    }
                    else
                    {
                        hv_Value.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Value = hv_Values.TupleSelect(
                                hv_ValueIndex);
                        }
                    }
                    //Check current value and only make changes if the value changed.
                    hv_InternalCurrentExists.Dispose();
                    HOperatorSet.GetDictParam(hv_ChangeStrategy, "key_exists", "internal_current_value",
                        out hv_InternalCurrentExists);
                    if ((int)(hv_InternalCurrentExists) != 0)
                    {
                        hv_InternalCurrent.Dispose();
                        HOperatorSet.GetDictTuple(hv_ChangeStrategy, "internal_current_value",
                            out hv_InternalCurrent);
                    }
                    else
                    {
                        hv_InternalCurrent.Dispose();
                        HOperatorSet.GetDlModelParam(hv_DLModelHandle, hv_ModelParam, out hv_InternalCurrent);
                    }
                    //If the current value differs from the new value we change it.
                    if ((int)(new HTuple(((((hv_InternalCurrent.TupleNotEqualElem(hv_Value))).TupleSum()
                        )).TupleGreater(0))) != 0)
                    {
                        //If the changed model parameter is the learning rate, we also change the momentum
                        //to adapt the scale of the previous update.
                        if ((int)(new HTuple(hv_ModelParam.TupleEqual("learning_rate"))) != 0)
                        {
                            //Get the threshold.
                            hv_ScaleThreshold.Dispose();
                            HOperatorSet.GetDictTuple(hv_ChangeStrategy, "scale_momentum_threshold",
                                out hv_ScaleThreshold);
                            if ((int)(new HTuple((new HTuple(hv_ScaleThreshold.TupleLength())).TupleGreater(
                                0))) != 0)
                            {
                                hv_CurrentLR.Dispose();
                                HOperatorSet.GetDlModelParam(hv_DLModelHandle, hv_ModelParam, out hv_CurrentLR);
                                //Check if the change is larger than the specified threshold.
                                hv_LRChangeRatio.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    hv_LRChangeRatio = (((hv_Value.TupleReal()
                                        ) / (hv_CurrentLR.TupleMax2(1e-10)))).TupleMax2((hv_CurrentLR.TupleReal()
                                        ) / (hv_Value.TupleMax2(1e-10)));
                                }
                                if ((int)((new HTuple(hv_LRChangeRatio.TupleGreater(hv_ScaleThreshold))).TupleAnd(
                                    new HTuple(hv_CurrentLR.TupleGreater(1e-7)))) != 0)
                                {
                                    hv_PreviousMomentumExists.Dispose();
                                    HOperatorSet.GetDictParam(hv_ChangeStrategy, "key_exists", "previous_momentum",
                                        out hv_PreviousMomentumExists);
                                    if ((int)(hv_PreviousMomentumExists) != 0)
                                    {
                                        hv_CurrentMomentum.Dispose();
                                        HOperatorSet.GetDictTuple(hv_ChangeStrategy, "previous_momentum",
                                            out hv_CurrentMomentum);
                                    }
                                    else
                                    {
                                        hv_CurrentMomentum.Dispose();
                                        HOperatorSet.GetDlModelParam(hv_DLModelHandle, "momentum", out hv_CurrentMomentum);
                                    }
                                    hv_AdaptedMomentum.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        hv_AdaptedMomentum = (hv_Value / (hv_CurrentLR.TupleReal()
                                            )) * hv_CurrentMomentum;
                                    }
                                    HOperatorSet.SetDlModelParam(hv_DLModelHandle, "momentum", hv_AdaptedMomentum);
                                    //In the next iteration the momentum has to be set back.
                                    HOperatorSet.SetDictTuple(hv_ChangeStrategy, "adapted_momentum",
                                        1);
                                    HOperatorSet.SetDictTuple(hv_ChangeStrategy, "previous_momentum",
                                        hv_CurrentMomentum);
                                }
                            }
                        }
                        HOperatorSet.SetDlModelParam(hv_DLModelHandle, hv_ModelParam, hv_Value);
                    }
                    else if ((int)(new HTuple(hv_ModelParam.TupleEqual("learning_rate"))) != 0)
                    {
                        //Get the threshold.
                        hv_ScaleThreshold.Dispose();
                        HOperatorSet.GetDictTuple(hv_ChangeStrategy, "scale_momentum_threshold",
                            out hv_ScaleThreshold);
                        if ((int)(new HTuple((new HTuple(hv_ScaleThreshold.TupleLength())).TupleGreater(
                            0))) != 0)
                        {
                            //Set the momentum back if it was adapted in the previous iteration.
                            hv_AdaptedMomentumExists.Dispose();
                            HOperatorSet.GetDictParam(hv_ChangeStrategy, "key_exists", "adapted_momentum",
                                out hv_AdaptedMomentumExists);
                            if ((int)(hv_AdaptedMomentumExists) != 0)
                            {
                                hv_AdaptedMomentum.Dispose();
                                HOperatorSet.GetDictTuple(hv_ChangeStrategy, "adapted_momentum", out hv_AdaptedMomentum);
                                if ((int)(hv_AdaptedMomentum) != 0)
                                {
                                    hv_PreviousMomentum.Dispose();
                                    HOperatorSet.GetDictTuple(hv_ChangeStrategy, "previous_momentum",
                                        out hv_PreviousMomentum);
                                    HOperatorSet.SetDlModelParam(hv_DLModelHandle, "momentum", hv_PreviousMomentum);
                                    HOperatorSet.SetDictTuple(hv_ChangeStrategy, "adapted_momentum",
                                        0);
                                    HOperatorSet.RemoveDictKey(hv_ChangeStrategy, "previous_momentum");
                                }
                            }
                        }
                    }
                    //Store the new internal current value.
                    HOperatorSet.SetDictTuple(hv_ChangeStrategy, "internal_current_value", hv_Value);
                }

                hv_Enabled.Dispose();
                hv_ChangeStrategies.Dispose();
                hv_Index.Dispose();
                hv_ChangeStrategy.Dispose();
                hv_ModelParam.Dispose();
                hv_Epochs.Dispose();
                hv_Values.Dispose();
                hv_Initial.Dispose();
                hv_Greater.Dispose();
                hv_ValueIndex.Dispose();
                hv_Value.Dispose();
                hv_InternalCurrentExists.Dispose();
                hv_InternalCurrent.Dispose();
                hv_ScaleThreshold.Dispose();
                hv_CurrentLR.Dispose();
                hv_LRChangeRatio.Dispose();
                hv_PreviousMomentumExists.Dispose();
                hv_CurrentMomentum.Dispose();
                hv_AdaptedMomentum.Dispose();
                hv_AdaptedMomentumExists.Dispose();
                hv_PreviousMomentum.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_Enabled.Dispose();
                hv_ChangeStrategies.Dispose();
                hv_Index.Dispose();
                hv_ChangeStrategy.Dispose();
                hv_ModelParam.Dispose();
                hv_Epochs.Dispose();
                hv_Values.Dispose();
                hv_Initial.Dispose();
                hv_Greater.Dispose();
                hv_ValueIndex.Dispose();
                hv_Value.Dispose();
                hv_InternalCurrentExists.Dispose();
                hv_InternalCurrent.Dispose();
                hv_ScaleThreshold.Dispose();
                hv_CurrentLR.Dispose();
                hv_LRChangeRatio.Dispose();
                hv_PreviousMomentumExists.Dispose();
                hv_CurrentMomentum.Dispose();
                hv_AdaptedMomentum.Dispose();
                hv_AdaptedMomentumExists.Dispose();
                hv_PreviousMomentum.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Model
        // Short Description: Serialize the model if a strategy applies to the current training status. 
        private void update_train_dl_model_serialization(HTuple hv_TrainParam, HTuple hv_SerializationData,
            HTuple hv_Iteration, HTuple hv_NumIterations, HTuple hv_Epoch, HTuple hv_EvaluationResult,
            HTuple hv_DLModelHandle, HTuple hv_TrainInfos, HTuple hv_EvaluationInfos)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_RawData = new HTuple(), hv_Types = new HTuple();
            HTuple hv_Strategies = new HTuple(), hv_Index = new HTuple();
            HTuple hv_Type = new HTuple(), hv_Data = new HTuple();
            HTuple hv_Strategy = new HTuple(), hv_EvaluationComparisonKeys = new HTuple();
            HTuple hv_BestScoreHighest = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_CurrentBest = new HTuple(), hv_ModelType = new HTuple();
            HTuple hv_Value = new HTuple(), hv_Epochs = new HTuple();
            HTuple hv_Indices = new HTuple(), hv_LastIndex = new HTuple();
            HTuple hv_ValidEvaluationKeys = new HTuple(), hv_FilenameModel = new HTuple();
            HTuple hv_FilenameMetaData = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //
                //Serialize the model if a strategy applies to the current training status.
                //
                hv_RawData.Dispose();
                HOperatorSet.GetDictTuple(hv_SerializationData, "raw_data", out hv_RawData);
                hv_Types.Dispose();
                HOperatorSet.GetDictTuple(hv_SerializationData, "types", out hv_Types);
                hv_Strategies.Dispose();
                HOperatorSet.GetDictTuple(hv_SerializationData, "strategies", out hv_Strategies);
                //
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Types.TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
                {
                    //
                    hv_Type.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Type = hv_Types.TupleSelect(
                            hv_Index);
                    }
                    hv_Data.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Data = hv_RawData.TupleSelect(
                            hv_Index);
                    }
                    hv_Strategy.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Strategy = hv_Strategies.TupleSelect(
                            hv_Index);
                    }
                    //
                    if ((int)(new HTuple(hv_Type.TupleEqual("best"))) != 0)
                    {
                        //If there is no new evaluation result, we will not serialize.
                        if ((int)(new HTuple((new HTuple(hv_EvaluationResult.TupleLength())).TupleEqual(
                            0))) != 0)
                        {
                            continue;
                        }
                        //Get result and check if the new result is better than the serialized old result.
                        hv_EvaluationComparisonKeys.Dispose();
                        HOperatorSet.GetDictTuple(hv_TrainParam, "evaluation_comparison_keys",
                            out hv_EvaluationComparisonKeys);
                        hv_BestScoreHighest.Dispose();
                        hv_BestScoreHighest = new HTuple();
                        try
                        {
                            hv_BestScoreHighest.Dispose();
                            HOperatorSet.GetDictTuple(hv_TrainParam, "evaluation_comparison_keys_best_highest",
                                out hv_BestScoreHighest);
                        }
                        // catch (Exception) 
                        catch (HalconException HDevExpDefaultException1)
                        {
                            HDevExpDefaultException1.ToHTuple(out hv_Exception);
                        }
                        //
                        hv_Value.Dispose(); hv_ValidEvaluationKeys.Dispose();
                        reduce_dl_evaluation_result(hv_EvaluationResult, hv_EvaluationComparisonKeys,
                            out hv_Value, out hv_ValidEvaluationKeys);
                        hv_CurrentBest.Dispose();
                        HOperatorSet.GetDictTuple(hv_Data, "best_value", out hv_CurrentBest);
                        hv_ModelType.Dispose();
                        HOperatorSet.GetDlModelParam(hv_DLModelHandle, "type", out hv_ModelType);
                        if ((int)(new HTuple(hv_BestScoreHighest.TupleEqual(new HTuple()))) != 0)
                        {
                            if ((int)((new HTuple(hv_ModelType.TupleEqual("classification"))).TupleAnd(
                                new HTuple(hv_EvaluationComparisonKeys.TupleEqual("top1_error")))) != 0)
                            {
                                hv_BestScoreHighest.Dispose();
                                hv_BestScoreHighest = 0;
                            }
                            else
                            {
                                hv_BestScoreHighest.Dispose();
                                hv_BestScoreHighest = 1;
                            }
                        }
                        //
                        if ((int)((new HTuple((new HTuple(hv_CurrentBest.TupleEqual(-1))).TupleOr(
                            (new HTuple(hv_Value.TupleLess(hv_CurrentBest))).TupleAnd(hv_BestScoreHighest.TupleNot()
                            )))).TupleOr((new HTuple(hv_Value.TupleGreater(hv_CurrentBest))).TupleAnd(
                            hv_BestScoreHighest))) != 0)
                        {
                            HOperatorSet.SetDictTuple(hv_Data, "best_value", hv_Value);
                            hv_FilenameModel.Dispose(); hv_FilenameMetaData.Dispose();
                            serialize_train_dl_model_intermediate(hv_DLModelHandle, hv_Epoch, hv_Strategy,
                                hv_TrainInfos, hv_EvaluationInfos, out hv_FilenameModel, out hv_FilenameMetaData);
                        }
                    }
                    else if ((int)(new HTuple(hv_Type.TupleEqual("final"))) != 0)
                    {
                        if ((int)(new HTuple(hv_Iteration.TupleEqual(hv_NumIterations - 1))) != 0)
                        {
                            //Serialize final model.
                            hv_FilenameModel.Dispose(); hv_FilenameMetaData.Dispose();
                            serialize_train_dl_model_intermediate(hv_DLModelHandle, hv_Epoch, hv_Strategy,
                                hv_TrainInfos, hv_EvaluationInfos, out hv_FilenameModel, out hv_FilenameMetaData);
                        }
                    }
                    else if ((int)((new HTuple(hv_Type.TupleEqual("epochs"))).TupleOr(
                        new HTuple(hv_Type.TupleEqual("current")))) != 0)
                    {
                        //Check if the specified epoch is reached.
                        hv_Epochs.Dispose();
                        HOperatorSet.GetDictTuple(hv_Data, "epochs", out hv_Epochs);
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Indices.Dispose();
                            HOperatorSet.TupleFindLast(hv_Epoch.TupleLessElem(hv_Epochs), 0, out hv_Indices);
                        }
                        //Also check that the last saved epoch is not the same.
                        hv_LastIndex.Dispose();
                        HOperatorSet.GetDictTuple(hv_Data, "last_epoch_index", out hv_LastIndex);
                        if ((int)((new HTuple(hv_Type.TupleEqual("current"))).TupleAnd(new HTuple((new HTuple(hv_EvaluationResult.TupleLength()
                            )).TupleGreater(0)))) != 0)
                        {
                            //For type current we also write every EvaluationIntervalEpochs epochs.
                            hv_FilenameModel.Dispose(); hv_FilenameMetaData.Dispose();
                            serialize_train_dl_model_intermediate(hv_DLModelHandle, hv_Epoch, hv_Strategy,
                                hv_TrainInfos, hv_EvaluationInfos, out hv_FilenameModel, out hv_FilenameMetaData);
                        }
                        else if ((int)(new HTuple((new HTuple(hv_Indices.TupleLength()
                            )).TupleGreater(0))) != 0)
                        {
                            //
                            if ((int)((new HTuple(((hv_Indices.TupleSelect(0))).TupleGreater(-1))).TupleAnd(
                                new HTuple(((hv_Indices.TupleSelect(0))).TupleNotEqual(hv_LastIndex)))) != 0)
                            {
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    HOperatorSet.SetDictTuple(hv_Data, "last_epoch_index", hv_Indices.TupleSelect(
                                        0));
                                }
                                //Serialize final model.
                                hv_FilenameModel.Dispose(); hv_FilenameMetaData.Dispose();
                                serialize_train_dl_model_intermediate(hv_DLModelHandle, hv_Epoch, hv_Strategy,
                                    hv_TrainInfos, hv_EvaluationInfos, out hv_FilenameModel, out hv_FilenameMetaData);
                            }
                        }
                    }
                }
                //

                hv_RawData.Dispose();
                hv_Types.Dispose();
                hv_Strategies.Dispose();
                hv_Index.Dispose();
                hv_Type.Dispose();
                hv_Data.Dispose();
                hv_Strategy.Dispose();
                hv_EvaluationComparisonKeys.Dispose();
                hv_BestScoreHighest.Dispose();
                hv_Exception.Dispose();
                hv_CurrentBest.Dispose();
                hv_ModelType.Dispose();
                hv_Value.Dispose();
                hv_Epochs.Dispose();
                hv_Indices.Dispose();
                hv_LastIndex.Dispose();
                hv_ValidEvaluationKeys.Dispose();
                hv_FilenameModel.Dispose();
                hv_FilenameMetaData.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_RawData.Dispose();
                hv_Types.Dispose();
                hv_Strategies.Dispose();
                hv_Index.Dispose();
                hv_Type.Dispose();
                hv_Data.Dispose();
                hv_Strategy.Dispose();
                hv_EvaluationComparisonKeys.Dispose();
                hv_BestScoreHighest.Dispose();
                hv_Exception.Dispose();
                hv_CurrentBest.Dispose();
                hv_ModelType.Dispose();
                hv_Value.Dispose();
                hv_Epochs.Dispose();
                hv_Indices.Dispose();
                hv_LastIndex.Dispose();
                hv_ValidEvaluationKeys.Dispose();
                hv_FilenameModel.Dispose();
                hv_FilenameMetaData.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Graphics / Window
        // Short Description: This procedure sets and returns meta information to display images correctly. 
        private void update_window_meta_information(HTuple hv_WindowHandle, HTuple hv_WidthImage,
            HTuple hv_HeightImage, HTuple hv_WindowRow1, HTuple hv_WindowColumn1, HTuple hv_MapColorBarWidth,
            HTuple hv_MarginBottom, out HTuple hv_WindowImageRatioHeight, out HTuple hv_WindowImageRatioWidth,
            out HTuple hv_SetPartRow2, out HTuple hv_SetPartColumn2, out HTuple hv_PrevWindowCoordinatesOut)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv__ = new HTuple(), hv_WindowWidth = new HTuple();
            HTuple hv_WindowHeight = new HTuple(), hv_WindowRow2 = new HTuple();
            HTuple hv_WindowColumn2 = new HTuple(), hv_WindowRatio = new HTuple();
            HTuple hv_ImageRow2 = new HTuple(), hv_ImageColumn2 = new HTuple();
            HTuple hv_ImageRatio = new HTuple(), hv_ImageWindowRatioHeight = new HTuple();
            HTuple hv_ImageRow2InWindow = new HTuple(), hv_ImageCol2InWindow = new HTuple();
            // Initialize local and output iconic variables 
            hv_WindowImageRatioHeight = new HTuple();
            hv_WindowImageRatioWidth = new HTuple();
            hv_SetPartRow2 = new HTuple();
            hv_SetPartColumn2 = new HTuple();
            hv_PrevWindowCoordinatesOut = new HTuple();
            try
            {
                //
                //This procedure sets and returns meta information to display images correctly.
                //
                //Set part for the image to be displayed later and adapt window size (+ MarginBottom + MapColorBarWidth).
                hv__.Dispose(); hv__.Dispose(); hv_WindowWidth.Dispose(); hv_WindowHeight.Dispose();
                HOperatorSet.GetWindowExtents(hv_WindowHandle, out hv__, out hv__, out hv_WindowWidth,
                    out hv_WindowHeight);
                hv_WindowImageRatioHeight.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowImageRatioHeight = hv_WindowHeight / (hv_HeightImage * 1.0);
                }
                hv_WindowImageRatioWidth.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowImageRatioWidth = hv_WindowWidth / (hv_WidthImage * 1.0);
                }
                //
                //Set window part such that image is displayed undistorted.
                hv_WindowRow2.Dispose();
                hv_WindowRow2 = new HTuple(hv_WindowHeight);
                hv_WindowColumn2.Dispose();
                hv_WindowColumn2 = new HTuple(hv_WindowWidth);
                hv_WindowRatio.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowRatio = hv_WindowColumn2 / (hv_WindowRow2 * 1.0);
                }
                //
                hv_ImageRow2.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ImageRow2 = hv_HeightImage + (hv_MarginBottom / hv_WindowImageRatioHeight);
                }
                hv_ImageColumn2.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ImageColumn2 = hv_WidthImage + (hv_MapColorBarWidth / hv_WindowImageRatioWidth);
                }
                hv_ImageRatio.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ImageRatio = hv_ImageColumn2 / (hv_ImageRow2 * 1.0);
                }
                if ((int)(new HTuple(hv_ImageRatio.TupleGreater(hv_WindowRatio))) != 0)
                {
                    //
                    //Extend image until right window border.
                    hv_SetPartColumn2.Dispose();
                    hv_SetPartColumn2 = new HTuple(hv_ImageColumn2);
                    hv_ImageWindowRatioHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageWindowRatioHeight = hv_ImageColumn2 / (hv_WindowColumn2 * 1.0);
                    }
                    hv_ImageRow2InWindow.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageRow2InWindow = hv_ImageRow2 / hv_ImageWindowRatioHeight;
                    }
                    hv_SetPartRow2.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SetPartRow2 = hv_ImageRow2 + ((hv_WindowRow2 - hv_ImageRow2InWindow) / hv_WindowImageRatioWidth);
                    }
                }
                else
                {
                    //
                    //Extend image until bottom of window.
                    hv_SetPartRow2.Dispose();
                    hv_SetPartRow2 = new HTuple(hv_ImageRow2);
                    hv_ImageWindowRatioHeight.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageWindowRatioHeight = hv_ImageRow2 / (hv_WindowRow2 * 1.0);
                    }
                    hv_ImageCol2InWindow.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ImageCol2InWindow = hv_ImageColumn2 / hv_ImageWindowRatioHeight;
                    }
                    hv_SetPartColumn2.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_SetPartColumn2 = hv_ImageColumn2 + ((hv_WindowColumn2 - hv_ImageCol2InWindow) / hv_WindowImageRatioHeight);
                    }
                }
                if (HDevWindowStack.IsOpen())
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_SetPartRow2 - 1,
                            hv_SetPartColumn2 - 1);
                    }
                }
                //
                //Return the coordinates of the new window.
                hv_PrevWindowCoordinatesOut.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_PrevWindowCoordinatesOut = new HTuple();
                    hv_PrevWindowCoordinatesOut = hv_PrevWindowCoordinatesOut.TupleConcat(hv_WindowRow1, hv_WindowColumn1, hv_WindowWidth, hv_WindowHeight);
                }
                //

                hv__.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_WindowRow2.Dispose();
                hv_WindowColumn2.Dispose();
                hv_WindowRatio.Dispose();
                hv_ImageRow2.Dispose();
                hv_ImageColumn2.Dispose();
                hv_ImageRatio.Dispose();
                hv_ImageWindowRatioHeight.Dispose();
                hv_ImageRow2InWindow.Dispose();
                hv_ImageCol2InWindow.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv__.Dispose();
                hv_WindowWidth.Dispose();
                hv_WindowHeight.Dispose();
                hv_WindowRow2.Dispose();
                hv_WindowColumn2.Dispose();
                hv_WindowRatio.Dispose();
                hv_ImageRow2.Dispose();
                hv_ImageColumn2.Dispose();
                hv_ImageRatio.Dispose();
                hv_ImageWindowRatioHeight.Dispose();
                hv_ImageRow2InWindow.Dispose();
                hv_ImageCol2InWindow.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Chapter: Deep Learning / Evaluation
        // Short Description: Check that all given entries in EvalParams are valid. 
        private void validate_evaluation_param(HTuple hv_EvalParams, out HTuple hv_Valid,
            out HTuple hv_Exception)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ClassIDsExist = new HTuple(), hv_ClassIDs = new HTuple();
            HTuple hv_NumClassesExist = new HTuple(), hv_NumClasses = new HTuple();
            HTuple hv_EvalInstancesExists = new HTuple(), hv_EvaluationTypeExists = new HTuple();
            HTuple hv_EvaluationType = new HTuple(), hv_Indices = new HTuple();
            HTuple hv_MeasuresExists = new HTuple(), hv_Measures = new HTuple();
            HTuple hv_ValidMeasures = new HTuple(), hv_Ks = new HTuple();
            HTuple hv_KeysExist = new HTuple(), hv_ClassNames = new HTuple();
            HTuple hv_ClassesToEvaluate = new HTuple(), hv_ClassIDsToEvaluate = new HTuple();
            HTuple hv_IouThreshExists = new HTuple(), hv_IouThresholds = new HTuple();
            HTuple hv_MaxNumDetectionsExists = new HTuple(), hv_MaxNumDetections = new HTuple();
            HTuple hv_AreaRangesExist = new HTuple(), hv_AreaRanges = new HTuple();
            HTuple hv_AreaKeysExist = new HTuple(), hv_AreaNames = new HTuple();
            HTuple hv_MinAreas = new HTuple(), hv_MaxAreas = new HTuple();
            HTuple hv_InstanceTypeExists = new HTuple(), hv_InstanceType = new HTuple();
            HTuple hv_ValidInstanceTypes = new HTuple(), hv_AllocationBlockLengthExists = new HTuple();
            HTuple hv_AllocationBlockLength = new HTuple(), hv_DetailedEvaluationExists = new HTuple();
            HTuple hv_DetailedEvaluation = new HTuple(), hv_KeyExists = new HTuple();
            HTuple hv_InterpolatePRCurves = new HTuple(), hv_IgnoreClassIDsExist = new HTuple();
            HTuple hv_ValidMeasuresString = new HTuple(), hv_Idx = new HTuple();
            HTuple hv_ValidMeasure = new HTuple();
            // Initialize local and output iconic variables 
            hv_Valid = new HTuple();
            hv_Exception = new HTuple();
            try
            {
                //
                //This procedure checks if the dictionary EvalParams
                //contains all necessary parameters and if they are valid (type, range, ...).
                //
                hv_Valid.Dispose();
                hv_Valid = 0;
                hv_Exception.Dispose();
                hv_Exception = "";
                //Check class IDs.
                hv_ClassIDsExist.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "class_ids", out hv_ClassIDsExist);
                if ((int)(hv_ClassIDsExist.TupleNot()) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "The evaluation parameters need a key-value pair for 'class_ids'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();

                    return;
                }
                else
                {
                    hv_ClassIDs.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                    if ((int)(new HTuple((new HTuple(hv_ClassIDs.TupleLength())).TupleLess(1))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'class_ids' should have at least length 1";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    if ((int)(new HTuple(((hv_ClassIDs.TupleIsIntElem())).TupleNotEqual(HTuple.TupleGenConst(
                        new HTuple(hv_ClassIDs.TupleLength()), 1)))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'class_ids' should be of type int";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    if ((int)(new HTuple(((((hv_ClassIDs.TupleLessElem(0))).TupleFind(1))).TupleGreater(
                        -1))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'class_ids' should be positive or zero";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                }
                //Check the entry num_classes.
                hv_NumClassesExist.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "num_classes", out hv_NumClassesExist);
                if ((int)(hv_NumClassesExist.TupleNot()) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "The evaluation parameters need a key-value pair for 'num_classes'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();

                    return;
                }
                else
                {
                    hv_NumClasses.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "num_classes", out hv_NumClasses);
                    if ((int)(new HTuple((new HTuple(hv_NumClasses.TupleLength())).TupleNotEqual(
                        1))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'num_classes' should have length 1";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    if ((int)(new HTuple(((hv_NumClasses.TupleType())).TupleNotEqual((new HTuple((new HTuple(1)).TupleInt()
                        )).TupleType()))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'num_classes' should be of type int";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    if ((int)(new HTuple(hv_NumClasses.TupleLess(1))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'num_classes' should be at least 1";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                }
                //Check that num_classes is equal to |class_ids|.
                if ((int)(new HTuple(hv_NumClasses.TupleNotEqual(new HTuple(hv_ClassIDs.TupleLength()
                    )))) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "'num_classes' has to be set to the number of 'class_ids'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();

                    return;
                }
                //Check the entry 'evaluate_instances'.
                hv_EvalInstancesExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "evaluate_instances",
                    out hv_EvalInstancesExists);
                if ((int)(hv_EvalInstancesExists.TupleNot()) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "The evaluation parameters need a key-value pair for 'evaluate_instances'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();

                    return;
                }
                //Check the entry 'evaluation_type'.
                hv_EvaluationTypeExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "evaluation_type", out hv_EvaluationTypeExists);
                if ((int)(hv_EvaluationTypeExists.TupleNot()) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "The evaluation parameters need a key-value pair for 'evaluation_type'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();

                    return;
                }
                else
                {
                    hv_EvaluationType.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "evaluation_type", out hv_EvaluationType);
                    hv_Indices.Dispose();
                    HOperatorSet.TupleFind((((new HTuple("anomaly_detection")).TupleConcat("classification")).TupleConcat(
                        "segmentation")).TupleConcat("detection"), hv_EvaluationType, out hv_Indices);
                    if ((int)((new HTuple(hv_Indices.TupleEqual(-1))).TupleOr(new HTuple(hv_Indices.TupleEqual(
                        new HTuple())))) != 0)
                    {
                        hv_Exception.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Exception = "Invalid entry for 'evaluation_type': " + hv_EvaluationType;
                        }

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                }
                //Check the entry 'measures'.
                hv_MeasuresExists.Dispose();
                HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "measures", out hv_MeasuresExists);
                if ((int)(hv_MeasuresExists.TupleNot()) != 0)
                {
                    hv_Exception.Dispose();
                    hv_Exception = "The evaluation parameters need a key-value pair for 'measures'";

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();

                    return;
                }
                else
                {
                    hv_Measures.Dispose();
                    HOperatorSet.GetDictTuple(hv_EvalParams, "measures", out hv_Measures);
                    if ((int)(new HTuple((new HTuple(hv_Measures.TupleLength())).TupleEqual(0))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "'measures' should contain at least one entry";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                }
                //Check evaluation type specific entries of EvalParams.
                hv_EvaluationType.Dispose();
                HOperatorSet.GetDictTuple(hv_EvalParams, "evaluation_type", out hv_EvaluationType);
                if ((int)(new HTuple(hv_EvaluationType.TupleEqual("anomaly_detection"))) != 0)
                {
                    //
                    //Check for correct number of classes.
                    if ((int)(new HTuple((new HTuple(hv_ClassIDs.TupleLength())).TupleNotEqual(
                        2))) != 0)
                    {
                        throw new HalconException("The number of classes must be 2 for model type anomaly detection.");
                    }
                    //
                    hv_ValidMeasures.Dispose();
                    hv_ValidMeasures = new HTuple();
                    hv_ValidMeasures[0] = "anomaly_score_histogram";
                    hv_ValidMeasures[1] = "precision";
                    hv_ValidMeasures[2] = "recall";
                    hv_ValidMeasures[3] = "absolute_confusion_matrix";
                    hv_ValidMeasures[4] = "relative_confusion_matrix";
                    hv_ValidMeasures[5] = "all";
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("classification"))) != 0)
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Ks.Dispose();
                        HOperatorSet.TupleGenSequence(1, new HTuple(hv_ClassIDs.TupleLength()), 1,
                            out hv_Ks);
                    }
                    hv_ValidMeasures.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ValidMeasures = ("top" + hv_Ks) + "_error";
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        {
                            HTuple
                              ExpTmpLocalVar_ValidMeasures = hv_ValidMeasures.TupleConcat(
                                ((((new HTuple("precision")).TupleConcat("recall")).TupleConcat("f_score")).TupleConcat(
                                "absolute_confusion_matrix")).TupleConcat("relative_confusion_matrix"));
                            hv_ValidMeasures.Dispose();
                            hv_ValidMeasures = ExpTmpLocalVar_ValidMeasures;
                        }
                    }
                    //
                    //Check if not both of the two options to specify the evaluated classes are chosen.
                    hv_KeysExist.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", (new HTuple("class_names_to_evaluate")).TupleConcat(
                        "class_ids_to_evaluate"), out hv_KeysExist);
                    if ((int)(new HTuple(((hv_KeysExist.TupleSum())).TupleEqual(2))) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "No more than one option of 'class_names_to_evaluate' and 'class_ids_to_evaluate' is allowed";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    if ((int)(hv_KeysExist.TupleSelect(0)) != 0)
                    {
                        hv_ClassNames.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "class_names", out hv_ClassNames);
                        hv_ClassesToEvaluate.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "class_names_to_evaluate", out hv_ClassesToEvaluate);
                        if ((int)(new HTuple(((hv_ClassesToEvaluate.TupleDifference(hv_ClassNames.TupleConcat(
                            "global")))).TupleNotEqual(new HTuple()))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "Invalid entry in 'class_names_to_evaluate'";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                    if ((int)(hv_KeysExist.TupleSelect(1)) != 0)
                    {
                        hv_ClassIDs.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids", out hv_ClassIDs);
                        hv_ClassIDsToEvaluate.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "class_ids_to_evaluate", out hv_ClassIDsToEvaluate);
                        if ((int)(new HTuple(((hv_ClassIDsToEvaluate.TupleDifference(hv_ClassIDs.TupleConcat(
                            "global")))).TupleNotEqual(new HTuple()))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "Invalid entry in 'class_ids_to_evaluate'";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("detection"))) != 0)
                {
                    //Instance-based evaluation.
                    //Add instance measures.
                    hv_ValidMeasures.Dispose();
                    hv_ValidMeasures = new HTuple();
                    hv_ValidMeasures[0] = "all";
                    hv_ValidMeasures[1] = "mean_ap";
                    //
                    //Check if the entry 'iou_threshold' is present.
                    hv_IouThreshExists.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "iou_threshold", out hv_IouThreshExists);
                    if ((int)(hv_IouThreshExists.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "The evaluation parameters need a key-value pair for 'iou_threshold'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    else
                    {
                        hv_IouThresholds.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "iou_threshold", out hv_IouThresholds);
                        //Check the length of 'iou_threshold'.
                        if ((int)(new HTuple((new HTuple(hv_IouThresholds.TupleLength())).TupleLess(
                            1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'iou_threshold' is empty";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        if ((int)(new HTuple(((hv_IouThresholds.TupleIsRealElem())).TupleNotEqual(
                            HTuple.TupleGenConst(new HTuple(hv_IouThresholds.TupleLength()), 1)))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'iou_threshold' should be of type real";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check if the IoU thresholds are within (0.0, 1.0).
                        if ((int)((new HTuple(((hv_IouThresholds.TupleMin())).TupleLessEqual(0.0))).TupleOr(
                            new HTuple(((hv_IouThresholds.TupleMax())).TupleGreaterEqual(1.0)))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = new HTuple("Invalid 'iou_threshold', not in range (0.0, 1.0)");

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                    //
                    //Check if the entry 'max_num_detections' is present.
                    hv_MaxNumDetectionsExists.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "max_num_detections",
                        out hv_MaxNumDetectionsExists);
                    if ((int)(hv_MaxNumDetectionsExists.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "The evaluation parameters need a key-value pair for 'max_num_detections'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    else
                    {
                        hv_MaxNumDetections.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "max_num_detections", out hv_MaxNumDetections);
                        //Check the length of 'max_num_detections'.
                        if ((int)(new HTuple((new HTuple(hv_MaxNumDetections.TupleLength())).TupleLess(
                            1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'max_num_detections' is empty";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        if ((int)(new HTuple(((hv_MaxNumDetections.TupleIsIntElem())).TupleNotEqual(
                            HTuple.TupleGenConst(new HTuple(hv_MaxNumDetections.TupleLength()),
                            1)))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'max_num_detections' should be of type int";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check if 'max_num_detections' is -1 (to use all detections) or positive.
                        if ((int)((new HTuple(((hv_MaxNumDetections.TupleMin())).TupleLess(-1))).TupleOr(
                            new HTuple(((hv_MaxNumDetections.TupleFind(0))).TupleGreater(-1)))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'max_num_detections' should be -1 or positive";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                    //
                    //Check if the entry 'area_ranges' is present.
                    hv_AreaRangesExist.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "area_ranges", out hv_AreaRangesExist);
                    if ((int)(hv_AreaRangesExist.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "The evaluation parameters need a key-value pair for 'area_ranges'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    else
                    {
                        //Check if the entry 'area_ranges' is a dict.
                        hv_AreaRanges.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "area_ranges", out hv_AreaRanges);
                        if ((int)(new HTuple(((hv_AreaRanges.TupleSemType())).TupleNotEqual("dict"))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges' must be a dict";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check that the necessary keys exist.
                        hv_AreaKeysExist.Dispose();
                        HOperatorSet.GetDictParam(hv_AreaRanges, "key_exists", ((new HTuple("name")).TupleConcat(
                            "min")).TupleConcat("max"), out hv_AreaKeysExist);
                        if ((int)(((hv_AreaKeysExist.TupleSelect(0))).TupleNot()) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges' need a key-value pair for 'name'";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        if ((int)(((hv_AreaKeysExist.TupleSelect(1))).TupleNot()) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges' need a key-value pair for 'min'";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        if ((int)(((hv_AreaKeysExist.TupleSelect(2))).TupleNot()) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges' need a key-value pair for 'max'";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check the lengths of the area keys.
                        hv_AreaNames.Dispose();
                        HOperatorSet.GetDictTuple(hv_AreaRanges, "name", out hv_AreaNames);
                        if ((int)(new HTuple((new HTuple(hv_AreaNames.TupleLength())).TupleLess(
                            1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges': 'name' is empty";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        hv_MinAreas.Dispose();
                        HOperatorSet.GetDictTuple(hv_AreaRanges, "min", out hv_MinAreas);
                        if ((int)(new HTuple((new HTuple(hv_MinAreas.TupleLength())).TupleLess(
                            1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges': 'min' is empty";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        hv_MaxAreas.Dispose();
                        HOperatorSet.GetDictTuple(hv_AreaRanges, "max", out hv_MaxAreas);
                        if ((int)(new HTuple((new HTuple(hv_MaxAreas.TupleLength())).TupleLess(
                            1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges': 'max' is empty";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        if ((int)((new HTuple((new HTuple(hv_AreaNames.TupleLength())).TupleNotEqual(
                            new HTuple(hv_MinAreas.TupleLength())))).TupleOr(new HTuple((new HTuple(hv_AreaNames.TupleLength()
                            )).TupleNotEqual(new HTuple(hv_MaxAreas.TupleLength()))))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = new HTuple("'area_ranges': 'name', 'min' and 'max' must have the same length");

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check values of min, max.
                        if ((int)(new HTuple(((((hv_MinAreas.TupleGreaterEqualElem(hv_MaxAreas))).TupleFind(
                            1))).TupleGreater(-1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'area_ranges': 'min' must be elementwise smaller than 'max'";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                    //
                    //Check if instance-type is valid.
                    hv_InstanceTypeExists.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "instance_type", out hv_InstanceTypeExists);
                    if ((int)(hv_InstanceTypeExists.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "The evaluation parameters need a key-value pair for 'instance_type'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    else
                    {
                        hv_InstanceType.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "instance_type", out hv_InstanceType);
                        hv_ValidInstanceTypes.Dispose();
                        hv_ValidInstanceTypes = new HTuple();
                        hv_ValidInstanceTypes[0] = "rectangle1";
                        hv_ValidInstanceTypes[1] = "rectangle2";
                        if ((int)(new HTuple(((hv_ValidInstanceTypes.TupleFind(hv_InstanceType))).TupleEqual(
                            -1))) != 0)
                        {
                            hv_Exception.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                hv_Exception = ("Invalid instance type '" + hv_InstanceType) + "'";
                            }

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                    //
                    //Check if the entry 'allocation_block_length' is present and valid.
                    hv_AllocationBlockLengthExists.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "allocation_block_length",
                        out hv_AllocationBlockLengthExists);
                    if ((int)(hv_AllocationBlockLengthExists.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "The evaluation parameters need a key-value pair for 'allocation_block_length'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    else
                    {
                        hv_AllocationBlockLength.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "allocation_block_length", out hv_AllocationBlockLength);
                        //Check the length of 'allocation_block_length'.
                        if ((int)(new HTuple((new HTuple(hv_AllocationBlockLength.TupleLength()
                            )).TupleNotEqual(1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'allocation_block_length' should have length 1";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check the type of 'allocation_block_length'.
                        if ((int)(new HTuple(((hv_AllocationBlockLength.TupleType())).TupleNotEqual(
                            (new HTuple((new HTuple(0)).TupleInt())).TupleType()))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'allocation_block_length' should be of type int";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check if 'allocation_block_length' is larger than zero.
                        if ((int)(new HTuple(hv_AllocationBlockLength.TupleLess(1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'allocation_block_length' should be positive";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                    //
                    //Check if the entry 'detailed_evaluation' is valid if present.
                    hv_DetailedEvaluationExists.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "detailed_evaluation",
                        out hv_DetailedEvaluationExists);
                    if ((int)(hv_DetailedEvaluationExists.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "The evaluation parameters need a key-value pair for 'detailed_evaluation'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    else
                    {
                        hv_DetailedEvaluation.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "detailed_evaluation", out hv_DetailedEvaluation);
                        //Check the length of 'detailed_evaluation'.
                        if ((int)(new HTuple((new HTuple(hv_DetailedEvaluation.TupleLength())).TupleNotEqual(
                            1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'detailed_evaluation' should have length 1";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check the type of 'detailed_evaluation'.
                        if ((int)(new HTuple(((hv_DetailedEvaluation.TupleType())).TupleNotEqual(
                            (new HTuple(1)).TupleType()))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'detailed_evaluation' should be of type int";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check if 'detailed_evaluation' is true or false.
                        if ((int)((new HTuple(hv_DetailedEvaluation.TupleNotEqual(0))).TupleAnd(
                            new HTuple(hv_DetailedEvaluation.TupleNotEqual(1)))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'detailed_evaluation' should be zero or one";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                    //
                    //Check if the entry 'interpolate_pr_curves' is valid if present.
                    hv_KeyExists.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "interpolate_pr_curves",
                        out hv_KeyExists);
                    if ((int)(hv_KeyExists.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "The evaluation parameters need a key-value pair for 'interpolate_pr_curves'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                    else
                    {
                        hv_InterpolatePRCurves.Dispose();
                        HOperatorSet.GetDictTuple(hv_EvalParams, "interpolate_pr_curves", out hv_InterpolatePRCurves);
                        //Check the length of 'interpolate_pr_curves'.
                        if ((int)(new HTuple((new HTuple(hv_InterpolatePRCurves.TupleLength())).TupleNotEqual(
                            1))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'interpolate_pr_curves' should have length 1";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check the type of 'interpolate_pr_curves'.
                        if ((int)(new HTuple(((hv_InterpolatePRCurves.TupleType())).TupleNotEqual(
                            (new HTuple(1)).TupleType()))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'interpolate_pr_curves' should be of type int";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                        //Check if 'interpolate_pr_curves' is true or false.
                        if ((int)((new HTuple(hv_InterpolatePRCurves.TupleNotEqual(0))).TupleAnd(
                            new HTuple(hv_InterpolatePRCurves.TupleNotEqual(1)))) != 0)
                        {
                            hv_Exception.Dispose();
                            hv_Exception = "'interpolate_pr_curves' should be zero or one";

                            hv_ClassIDsExist.Dispose();
                            hv_ClassIDs.Dispose();
                            hv_NumClassesExist.Dispose();
                            hv_NumClasses.Dispose();
                            hv_EvalInstancesExists.Dispose();
                            hv_EvaluationTypeExists.Dispose();
                            hv_EvaluationType.Dispose();
                            hv_Indices.Dispose();
                            hv_MeasuresExists.Dispose();
                            hv_Measures.Dispose();
                            hv_ValidMeasures.Dispose();
                            hv_Ks.Dispose();
                            hv_KeysExist.Dispose();
                            hv_ClassNames.Dispose();
                            hv_ClassesToEvaluate.Dispose();
                            hv_ClassIDsToEvaluate.Dispose();
                            hv_IouThreshExists.Dispose();
                            hv_IouThresholds.Dispose();
                            hv_MaxNumDetectionsExists.Dispose();
                            hv_MaxNumDetections.Dispose();
                            hv_AreaRangesExist.Dispose();
                            hv_AreaRanges.Dispose();
                            hv_AreaKeysExist.Dispose();
                            hv_AreaNames.Dispose();
                            hv_MinAreas.Dispose();
                            hv_MaxAreas.Dispose();
                            hv_InstanceTypeExists.Dispose();
                            hv_InstanceType.Dispose();
                            hv_ValidInstanceTypes.Dispose();
                            hv_AllocationBlockLengthExists.Dispose();
                            hv_AllocationBlockLength.Dispose();
                            hv_DetailedEvaluationExists.Dispose();
                            hv_DetailedEvaluation.Dispose();
                            hv_KeyExists.Dispose();
                            hv_InterpolatePRCurves.Dispose();
                            hv_IgnoreClassIDsExist.Dispose();
                            hv_ValidMeasuresString.Dispose();
                            hv_Idx.Dispose();
                            hv_ValidMeasure.Dispose();

                            return;
                        }
                    }
                    //
                    //Add valid measure 'soap' if instance_type is 'rectangle2'.
                    if ((int)(new HTuple(hv_InstanceType.TupleEqual("rectangle2"))) != 0)
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            {
                                HTuple
                                  ExpTmpLocalVar_ValidMeasures = hv_ValidMeasures.TupleConcat(
                                    "soap");
                                hv_ValidMeasures.Dispose();
                                hv_ValidMeasures = ExpTmpLocalVar_ValidMeasures;
                            }
                        }
                    }
                }
                else if ((int)(new HTuple(hv_EvaluationType.TupleEqual("segmentation"))) != 0)
                {
                    //Pixel-based evaluation.
                    hv_ValidMeasures.Dispose();
                    hv_ValidMeasures = new HTuple();
                    hv_ValidMeasures[0] = "all";
                    hv_ValidMeasures[1] = "pixel_accuracy";
                    hv_ValidMeasures[2] = "mean_accuracy";
                    hv_ValidMeasures[3] = "mean_iou";
                    hv_ValidMeasures[4] = "class_iou";
                    hv_ValidMeasures[5] = "class_pixel_accuracy";
                    hv_ValidMeasures[6] = "pixel_confusion_matrix";
                    hv_ValidMeasures[7] = "frequency_weighted_iou";
                    //
                    //Check if the entry 'ignore_class_ids' exists.
                    hv_IgnoreClassIDsExist.Dispose();
                    HOperatorSet.GetDictParam(hv_EvalParams, "key_exists", "ignore_class_ids",
                        out hv_IgnoreClassIDsExist);
                    if ((int)(hv_IgnoreClassIDsExist.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        hv_Exception = "The evaluation parameters need a key-value pair for 'ignore_class_ids'";

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                }
                else
                {
                    hv_Exception.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_Exception = "Unknown evaluation_type: " + hv_EvaluationType;
                    }

                    hv_ClassIDsExist.Dispose();
                    hv_ClassIDs.Dispose();
                    hv_NumClassesExist.Dispose();
                    hv_NumClasses.Dispose();
                    hv_EvalInstancesExists.Dispose();
                    hv_EvaluationTypeExists.Dispose();
                    hv_EvaluationType.Dispose();
                    hv_Indices.Dispose();
                    hv_MeasuresExists.Dispose();
                    hv_Measures.Dispose();
                    hv_ValidMeasures.Dispose();
                    hv_Ks.Dispose();
                    hv_KeysExist.Dispose();
                    hv_ClassNames.Dispose();
                    hv_ClassesToEvaluate.Dispose();
                    hv_ClassIDsToEvaluate.Dispose();
                    hv_IouThreshExists.Dispose();
                    hv_IouThresholds.Dispose();
                    hv_MaxNumDetectionsExists.Dispose();
                    hv_MaxNumDetections.Dispose();
                    hv_AreaRangesExist.Dispose();
                    hv_AreaRanges.Dispose();
                    hv_AreaKeysExist.Dispose();
                    hv_AreaNames.Dispose();
                    hv_MinAreas.Dispose();
                    hv_MaxAreas.Dispose();
                    hv_InstanceTypeExists.Dispose();
                    hv_InstanceType.Dispose();
                    hv_ValidInstanceTypes.Dispose();
                    hv_AllocationBlockLengthExists.Dispose();
                    hv_AllocationBlockLength.Dispose();
                    hv_DetailedEvaluationExists.Dispose();
                    hv_DetailedEvaluation.Dispose();
                    hv_KeyExists.Dispose();
                    hv_InterpolatePRCurves.Dispose();
                    hv_IgnoreClassIDsExist.Dispose();
                    hv_ValidMeasuresString.Dispose();
                    hv_Idx.Dispose();
                    hv_ValidMeasure.Dispose();

                    return;
                }
                //Check measures.
                hv_ValidMeasuresString.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_ValidMeasuresString = HTuple.TupleGenConst(
                        ((new HTuple(hv_ValidMeasures.TupleLength())) * 2) - 1, new HTuple("','"));
                }
                if (hv_ValidMeasuresString == null)
                    hv_ValidMeasuresString = new HTuple();
                hv_ValidMeasuresString[HTuple.TupleGenSequence(0, (new HTuple(hv_ValidMeasuresString.TupleLength()
                    )) - 1, 2)] = hv_ValidMeasures;
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    {
                        HTuple
                          ExpTmpLocalVar_ValidMeasuresString = hv_ValidMeasuresString.TupleSum()
                            ;
                        hv_ValidMeasuresString.Dispose();
                        hv_ValidMeasuresString = ExpTmpLocalVar_ValidMeasuresString;
                    }
                }
                for (hv_Idx = 0; (int)hv_Idx <= (int)((new HTuple(hv_Measures.TupleLength())) - 1); hv_Idx = (int)hv_Idx + 1)
                {
                    hv_ValidMeasure.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hv_ValidMeasure = ((hv_ValidMeasures.TupleFind(
                            hv_Measures.TupleSelect(hv_Idx)))).TupleGreaterElem(-1);
                    }
                    if ((int)(hv_ValidMeasure.TupleNot()) != 0)
                    {
                        hv_Exception.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hv_Exception = ((("Invalid measure '" + (hv_Measures.TupleSelect(
                                hv_Idx))) + new HTuple("', choose one of ['")) + hv_ValidMeasuresString) + "']";
                        }

                        hv_ClassIDsExist.Dispose();
                        hv_ClassIDs.Dispose();
                        hv_NumClassesExist.Dispose();
                        hv_NumClasses.Dispose();
                        hv_EvalInstancesExists.Dispose();
                        hv_EvaluationTypeExists.Dispose();
                        hv_EvaluationType.Dispose();
                        hv_Indices.Dispose();
                        hv_MeasuresExists.Dispose();
                        hv_Measures.Dispose();
                        hv_ValidMeasures.Dispose();
                        hv_Ks.Dispose();
                        hv_KeysExist.Dispose();
                        hv_ClassNames.Dispose();
                        hv_ClassesToEvaluate.Dispose();
                        hv_ClassIDsToEvaluate.Dispose();
                        hv_IouThreshExists.Dispose();
                        hv_IouThresholds.Dispose();
                        hv_MaxNumDetectionsExists.Dispose();
                        hv_MaxNumDetections.Dispose();
                        hv_AreaRangesExist.Dispose();
                        hv_AreaRanges.Dispose();
                        hv_AreaKeysExist.Dispose();
                        hv_AreaNames.Dispose();
                        hv_MinAreas.Dispose();
                        hv_MaxAreas.Dispose();
                        hv_InstanceTypeExists.Dispose();
                        hv_InstanceType.Dispose();
                        hv_ValidInstanceTypes.Dispose();
                        hv_AllocationBlockLengthExists.Dispose();
                        hv_AllocationBlockLength.Dispose();
                        hv_DetailedEvaluationExists.Dispose();
                        hv_DetailedEvaluation.Dispose();
                        hv_KeyExists.Dispose();
                        hv_InterpolatePRCurves.Dispose();
                        hv_IgnoreClassIDsExist.Dispose();
                        hv_ValidMeasuresString.Dispose();
                        hv_Idx.Dispose();
                        hv_ValidMeasure.Dispose();

                        return;
                    }
                }
                //
                //Done with checks.
                hv_Valid.Dispose();
                hv_Valid = 1;

                hv_ClassIDsExist.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClassesExist.Dispose();
                hv_NumClasses.Dispose();
                hv_EvalInstancesExists.Dispose();
                hv_EvaluationTypeExists.Dispose();
                hv_EvaluationType.Dispose();
                hv_Indices.Dispose();
                hv_MeasuresExists.Dispose();
                hv_Measures.Dispose();
                hv_ValidMeasures.Dispose();
                hv_Ks.Dispose();
                hv_KeysExist.Dispose();
                hv_ClassNames.Dispose();
                hv_ClassesToEvaluate.Dispose();
                hv_ClassIDsToEvaluate.Dispose();
                hv_IouThreshExists.Dispose();
                hv_IouThresholds.Dispose();
                hv_MaxNumDetectionsExists.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRangesExist.Dispose();
                hv_AreaRanges.Dispose();
                hv_AreaKeysExist.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_InstanceTypeExists.Dispose();
                hv_InstanceType.Dispose();
                hv_ValidInstanceTypes.Dispose();
                hv_AllocationBlockLengthExists.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_DetailedEvaluationExists.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_KeyExists.Dispose();
                hv_InterpolatePRCurves.Dispose();
                hv_IgnoreClassIDsExist.Dispose();
                hv_ValidMeasuresString.Dispose();
                hv_Idx.Dispose();
                hv_ValidMeasure.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ClassIDsExist.Dispose();
                hv_ClassIDs.Dispose();
                hv_NumClassesExist.Dispose();
                hv_NumClasses.Dispose();
                hv_EvalInstancesExists.Dispose();
                hv_EvaluationTypeExists.Dispose();
                hv_EvaluationType.Dispose();
                hv_Indices.Dispose();
                hv_MeasuresExists.Dispose();
                hv_Measures.Dispose();
                hv_ValidMeasures.Dispose();
                hv_Ks.Dispose();
                hv_KeysExist.Dispose();
                hv_ClassNames.Dispose();
                hv_ClassesToEvaluate.Dispose();
                hv_ClassIDsToEvaluate.Dispose();
                hv_IouThreshExists.Dispose();
                hv_IouThresholds.Dispose();
                hv_MaxNumDetectionsExists.Dispose();
                hv_MaxNumDetections.Dispose();
                hv_AreaRangesExist.Dispose();
                hv_AreaRanges.Dispose();
                hv_AreaKeysExist.Dispose();
                hv_AreaNames.Dispose();
                hv_MinAreas.Dispose();
                hv_MaxAreas.Dispose();
                hv_InstanceTypeExists.Dispose();
                hv_InstanceType.Dispose();
                hv_ValidInstanceTypes.Dispose();
                hv_AllocationBlockLengthExists.Dispose();
                hv_AllocationBlockLength.Dispose();
                hv_DetailedEvaluationExists.Dispose();
                hv_DetailedEvaluation.Dispose();
                hv_KeyExists.Dispose();
                hv_InterpolatePRCurves.Dispose();
                hv_IgnoreClassIDsExist.Dispose();
                hv_ValidMeasuresString.Dispose();
                hv_Idx.Dispose();
                hv_ValidMeasure.Dispose();

                throw HDevExpDefaultException;
            }
        }

        // Local procedures 
        public void check_data_availability(HTuple hv_ExampleDataDir, HTuple hv_InitialModelFileName,
            HTuple hv_DLDatasetFileName)
        {



            // Local control variables 

            HTuple hv_FileExists = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure checks whether the required files are available.
                //
                hv_FileExists.Dispose();
                HOperatorSet.FileExists(hv_ExampleDataDir, out hv_FileExists);
                if ((int)(hv_FileExists.TupleNot()) != 0)
                {
                    throw new HalconException(hv_ExampleDataDir + " does not exist. Please run part 1 of the example series.");
                }
                //
                hv_FileExists.Dispose();
                HOperatorSet.FileExists(hv_InitialModelFileName, out hv_FileExists);
                if ((int)(hv_FileExists.TupleNot()) != 0)
                {
                    throw new HalconException(hv_InitialModelFileName + " does not exist. Please run part 1 of the example series.");
                }
                //
                hv_FileExists.Dispose();
                HOperatorSet.FileExists(hv_DLDatasetFileName, out hv_FileExists);
                if ((int)(hv_FileExists.TupleNot()) != 0)
                {
                    throw new HalconException(hv_DLDatasetFileName + " does not exist. Please run part 1 of the example series.");
                }
                //

                hv_FileExists.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_FileExists.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_close_example_image_window(HTuple hv_ExampleInternals)
        {



            // Local control variables 

            HTuple hv_WindowHandleImages = new HTuple();
            HTuple hv_Exception = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure closes the image window.
                //
                try
                {
                    hv_WindowHandleImages.Dispose();
                    HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images", out hv_WindowHandleImages);
                    HDevWindowStack.SetActive(hv_WindowHandleImages);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                    }
                    //Delete key.
                    HOperatorSet.RemoveDictKey(hv_ExampleInternals, "window_images");
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                }
                //

                hv_WindowHandleImages.Dispose();
                hv_Exception.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_WindowHandleImages.Dispose();
                hv_Exception.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_close_example_legend_window(HTuple hv_ExampleInternals)
        {



            // Local control variables 

            HTuple hv_WindowHandleLegend = new HTuple();
            HTuple hv_Exception = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure closes the legend window.
                //
                try
                {
                    hv_WindowHandleLegend.Dispose();
                    HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_legend", out hv_WindowHandleLegend);
                    HDevWindowStack.SetActive(hv_WindowHandleLegend);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                    }
                    //Delete key.
                    HOperatorSet.RemoveDictKey(hv_ExampleInternals, "window_legend");
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                }
                //

                hv_WindowHandleLegend.Dispose();
                hv_Exception.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_WindowHandleLegend.Dispose();
                hv_Exception.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_close_example_text_window(HTuple hv_ExampleInternals)
        {



            // Local control variables 

            HTuple hv_WindowHandleImages = new HTuple();
            HTuple hv_Exception = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure closes the text window.
                //
                try
                {
                    hv_WindowHandleImages.Dispose();
                    HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleImages);
                    HDevWindowStack.SetActive(hv_WindowHandleImages);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                    }
                    //Delete key.
                    HOperatorSet.RemoveDictKey(hv_ExampleInternals, "window_text");
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                }

                hv_WindowHandleImages.Dispose();
                hv_Exception.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_WindowHandleImages.Dispose();
                hv_Exception.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_close_example_windows(HTuple hv_ExampleInternals)
        {



            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure closes all example windows opened for explanations.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();

                    return;
                }
                //
                dev_close_example_text_window(hv_ExampleInternals);
                dev_close_example_image_window(hv_ExampleInternals);
                dev_close_example_legend_window(hv_ExampleInternals);
                //

                hv_ShowExampleScreens.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_example_reset_windows(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_WindowHandlesToClose = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_I = new HTuple();
            HTuple hv_WindowHandleKeys = new HTuple(), hv_Index = new HTuple();
            HTuple hv_WindowImagesNeeded = new HTuple(), hv_WindowLegendNeeded = new HTuple();
            HTuple hv_WindowHandleImages = new HTuple(), hv_WindowHandleLegend = new HTuple();
            HTuple hv_WindowHandleText = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure resets the graphics windows.
                //
                //Close any windows that are listed in key 'window_handles_to_close'.
                try
                {
                    hv_WindowHandlesToClose.Dispose();
                    HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_handles_to_close",
                        out hv_WindowHandlesToClose);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    hv_WindowHandlesToClose.Dispose();
                    hv_WindowHandlesToClose = new HTuple();
                }
                for (hv_I = 0; (int)hv_I <= (int)((new HTuple(hv_WindowHandlesToClose.TupleLength()
                    )) - 1); hv_I = (int)hv_I + 1)
                {
                    HDevWindowStack.SetActive(hv_WindowHandlesToClose.TupleSelect(
                        hv_I));
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                    }
                }
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_handles_to_close", new HTuple());
                //
                //Open image window if needed.
                hv_WindowHandleKeys.Dispose();
                HOperatorSet.GetDictParam(hv_ExampleInternals, "keys", new HTuple(), out hv_WindowHandleKeys);
                hv_Index.Dispose();
                HOperatorSet.TupleFind(hv_WindowHandleKeys, "window_images", out hv_Index);
                hv_WindowImagesNeeded.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_needed", out hv_WindowImagesNeeded);
                if ((int)(hv_WindowImagesNeeded.TupleAnd(new HTuple(hv_Index.TupleEqual(-1)))) != 0)
                {
                    //Open new window for images.
                    dev_open_example_image_window(hv_ExampleInternals);
                }
                else if ((int)((new HTuple(hv_WindowImagesNeeded.TupleNot())).TupleAnd(
                    new HTuple(hv_Index.TupleNotEqual(-1)))) != 0)
                {
                    //Window for images exists but is not needed -> close it.
                    dev_close_example_image_window(hv_ExampleInternals);
                }
                //
                //Open legend window if needed.
                hv_WindowHandleKeys.Dispose();
                HOperatorSet.GetDictParam(hv_ExampleInternals, "keys", new HTuple(), out hv_WindowHandleKeys);
                hv_Index.Dispose();
                HOperatorSet.TupleFind(hv_WindowHandleKeys, "window_legend", out hv_Index);
                hv_WindowLegendNeeded.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_legend_needed", out hv_WindowLegendNeeded);
                if ((int)(hv_WindowLegendNeeded.TupleAnd(new HTuple(hv_Index.TupleEqual(-1)))) != 0)
                {
                    //Open new window for legend.
                    dev_open_example_legend_window(hv_ExampleInternals, 290);
                }
                else if ((int)((new HTuple(hv_WindowLegendNeeded.TupleNot())).TupleAnd(
                    new HTuple(hv_Index.TupleNotEqual(-1)))) != 0)
                {
                    //Window for legend exists but is not needed -> close it.
                    dev_close_example_legend_window(hv_ExampleInternals);
                }
                //
                //Set the correct area (part) of the image window.
                try
                {
                    hv_WindowHandleImages.Dispose();
                    HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images", out hv_WindowHandleImages);
                    HDevWindowStack.SetActive(hv_WindowHandleImages);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                    }
                    //Set default window extends
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), 360, 0, 800,
                            400);
                    }
                    HOperatorSet.SetPartStyle(hv_WindowHandleImages, 1);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                }
                //
                //Set the correct area (part) of the legend window.
                try
                {
                    hv_WindowHandleLegend.Dispose();
                    HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_legend", out hv_WindowHandleLegend);
                    HDevWindowStack.SetActive(hv_WindowHandleLegend);
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                    }
                    //Set default window extends
                    if (HDevWindowStack.IsOpen())
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HOperatorSet.SetWindowExtents(HDevWindowStack.GetActive(), 360, 800 + 5,
                                290, 500);
                        }
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.SetPart(HDevWindowStack.GetActive(), 1, 1, -1, -1);
                    }
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                }
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.ClearWindow(HDevWindowStack.GetActive());
                }

                hv_WindowHandlesToClose.Dispose();
                hv_Exception.Dispose();
                hv_I.Dispose();
                hv_WindowHandleKeys.Dispose();
                hv_Index.Dispose();
                hv_WindowImagesNeeded.Dispose();
                hv_WindowLegendNeeded.Dispose();
                hv_WindowHandleImages.Dispose();
                hv_WindowHandleLegend.Dispose();
                hv_WindowHandleText.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_WindowHandlesToClose.Dispose();
                hv_Exception.Dispose();
                hv_I.Dispose();
                hv_WindowHandleKeys.Dispose();
                hv_Index.Dispose();
                hv_WindowImagesNeeded.Dispose();
                hv_WindowLegendNeeded.Dispose();
                hv_WindowHandleImages.Dispose();
                hv_WindowHandleLegend.Dispose();
                hv_WindowHandleText.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_batch_size(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure explains the parameter 'batch_size'.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_Text.Dispose();

                    return;
                }
                //
                //Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                dev_display_example_reset_windows(hv_ExampleInternals);
                //
                //Display the explanatory text.
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                //
                hv_Text.Dispose();
                hv_Text = "Model parameter: 'batch_size'";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "The dataset is divided into smaller subsets of data";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "which are called batches.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "The 'batch_size' determines the number of images taken";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "into a batch and thus are processed simultaneously.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = " ";
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", new HTuple(), new HTuple());
                }
                //

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_error(HTuple hv_ExampleInternals, out HTuple hv_Error)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_ExampleDataDir = new HTuple();
            HTuple hv_InitialModelFileName = new HTuple(), hv_DataDirectory = new HTuple();
            HTuple hv_DLDatasetFileName = new HTuple(), hv_GPUAvailable = new HTuple();
            HTuple hv_CudaLoaded = new HTuple(), hv_CuDNNLoaded = new HTuple();
            HTuple hv_CuBlasLoaded = new HTuple(), hv_ModelExists = new HTuple();
            HTuple hv_DataExists = new HTuple(), hv_ErrorText = new HTuple();
            // Initialize local and output iconic variables 
            hv_Error = new HTuple();
            try
            {
                //This procedure checks whether all required files and GPU libraries are present
                //and shows an error message if anything is missing.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_ExampleDataDir.Dispose();
                    hv_InitialModelFileName.Dispose();
                    hv_DataDirectory.Dispose();
                    hv_DLDatasetFileName.Dispose();
                    hv_GPUAvailable.Dispose();
                    hv_CudaLoaded.Dispose();
                    hv_CuDNNLoaded.Dispose();
                    hv_CuBlasLoaded.Dispose();
                    hv_ModelExists.Dispose();
                    hv_DataExists.Dispose();
                    hv_ErrorText.Dispose();

                    return;
                }
                //
                //Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                dev_display_example_reset_windows(hv_ExampleInternals);
                //
                //Display error text.
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                //
                //Check if 'detect_pills_deep_learning_1_prepare.hdev' has been run
                //which means that both the initial model and preprocessed dataset are available.
                hv_ExampleDataDir.Dispose();
                hv_ExampleDataDir = "detect_pills_data";
                hv_InitialModelFileName.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_InitialModelFileName = hv_ExampleDataDir + "/pretrained_dl_model_detection.hdl";
                }
                hv_DataDirectory.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_DataDirectory = hv_ExampleDataDir + "/dldataset_pill_bag_512x320";
                }
                hv_DLDatasetFileName.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_DLDatasetFileName = hv_DataDirectory + "/dl_dataset.hdict";
                }
                //
                //Check if the necessary libraries for gpu mode are available.
                hv_GPUAvailable.Dispose();
                hv_GPUAvailable = 0;
                hv_CudaLoaded.Dispose();
                HOperatorSet.GetSystem("cuda_loaded", out hv_CudaLoaded);
                hv_CuDNNLoaded.Dispose();
                HOperatorSet.GetSystem("cudnn_loaded", out hv_CuDNNLoaded);
                hv_CuBlasLoaded.Dispose();
                HOperatorSet.GetSystem("cublas_loaded", out hv_CuBlasLoaded);
                if ((int)((new HTuple((new HTuple(hv_CudaLoaded.TupleEqual("true"))).TupleAnd(
                    new HTuple(hv_CuDNNLoaded.TupleEqual("true"))))).TupleAnd(new HTuple(hv_CuBlasLoaded.TupleEqual(
                    "true")))) != 0)
                {
                    hv_GPUAvailable.Dispose();
                    hv_GPUAvailable = 1;
                }
                //
                hv_Error.Dispose();
                hv_Error = 0;
                //
                hv_ModelExists.Dispose();
                HOperatorSet.FileExists(hv_InitialModelFileName, out hv_ModelExists);
                hv_DataExists.Dispose();
                HOperatorSet.FileExists(hv_DLDatasetFileName, out hv_DataExists);
                //
                if ((int)((new HTuple((new HTuple(hv_DataExists.TupleNot())).TupleOr(hv_ModelExists.TupleNot()
                    ))).TupleOr(hv_GPUAvailable.TupleNot())) != 0)
                {
                    hv_Error.Dispose();
                    hv_Error = 1;
                    hv_ErrorText.Dispose();
                    hv_ErrorText = new HTuple();
                    if ((int)((new HTuple(hv_DataExists.TupleNot())).TupleOr(hv_ModelExists.TupleNot()
                        )) != 0)
                    {
                        //Part 1 should be run before continuing this example.
                        if (hv_ErrorText == null)
                            hv_ErrorText = new HTuple();
                        hv_ErrorText[new HTuple(hv_ErrorText.TupleLength())] = "To run this example you need the output of:";
                        if (hv_ErrorText == null)
                            hv_ErrorText = new HTuple();
                        hv_ErrorText[new HTuple(hv_ErrorText.TupleLength())] = " - 'detect_pills_deep_learning_1_prepare.hdev'";
                        if (hv_ErrorText == null)
                            hv_ErrorText = new HTuple();
                        hv_ErrorText[new HTuple(hv_ErrorText.TupleLength())] = "Please run this example first.";
                    }
                    if ((int)(hv_GPUAvailable.TupleNot()) != 0)
                    {
                        //Some of the libraries are missing.
                        if ((int)(hv_DataExists.TupleNot()) != 0)
                        {
                            if (hv_ErrorText == null)
                                hv_ErrorText = new HTuple();
                            hv_ErrorText[new HTuple(hv_ErrorText.TupleLength())] = "";
                        }
                        if (hv_ErrorText == null)
                            hv_ErrorText = new HTuple();
                        hv_ErrorText[new HTuple(hv_ErrorText.TupleLength())] = new HTuple("This example needs to run on a GPU, but some of the necessary");
                        if (hv_ErrorText == null)
                            hv_ErrorText = new HTuple();
                        hv_ErrorText[new HTuple(hv_ErrorText.TupleLength())] = "libraries could not be found:";
                        if ((int)(new HTuple(hv_CudaLoaded.TupleEqual("false"))) != 0)
                        {
                            if (hv_ErrorText == null)
                                hv_ErrorText = new HTuple();
                            hv_ErrorText[new HTuple(hv_ErrorText.TupleLength())] = "- CUDA";
                        }
                        if ((int)(new HTuple(hv_CuDNNLoaded.TupleEqual("false"))) != 0)
                        {
                            if (hv_ErrorText == null)
                                hv_ErrorText = new HTuple();
                            hv_ErrorText[new HTuple(hv_ErrorText.TupleLength())] = "- CuDNN";
                        }
                        if ((int)(new HTuple(hv_CuBlasLoaded.TupleEqual("false"))) != 0)
                        {
                            if (hv_ErrorText == null)
                                hv_ErrorText = new HTuple();
                            hv_ErrorText[new HTuple(hv_ErrorText.TupleLength())] = "- CuBlas";
                        }
                        if (hv_ErrorText == null)
                            hv_ErrorText = new HTuple();
                        hv_ErrorText[new HTuple(hv_ErrorText.TupleLength())] = "Please install the missing libraries before continuing.";
                        //Store the error.
                        HOperatorSet.SetDictTuple(hv_ExampleInternals, "gpu_available", 0);
                    }
                    set_display_font(hv_WindowHandleText, 20, "mono", "true", "false");
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_ErrorText, "window",
                            "top", "left", "red", "box", "true");
                    }
                    set_display_font(hv_WindowHandleText, 16, "mono", "true", "false");
                }
                //

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_ExampleDataDir.Dispose();
                hv_InitialModelFileName.Dispose();
                hv_DataDirectory.Dispose();
                hv_DLDatasetFileName.Dispose();
                hv_GPUAvailable.Dispose();
                hv_CudaLoaded.Dispose();
                hv_CuDNNLoaded.Dispose();
                hv_CuBlasLoaded.Dispose();
                hv_ModelExists.Dispose();
                hv_DataExists.Dispose();
                hv_ErrorText.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_ExampleDataDir.Dispose();
                hv_InitialModelFileName.Dispose();
                hv_DataDirectory.Dispose();
                hv_DLDatasetFileName.Dispose();
                hv_GPUAvailable.Dispose();
                hv_CudaLoaded.Dispose();
                hv_CuDNNLoaded.Dispose();
                hv_CuBlasLoaded.Dispose();
                hv_ModelExists.Dispose();
                hv_DataExists.Dispose();
                hv_ErrorText.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_final(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure shows the final message of the example series.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_Text.Dispose();

                    return;
                }
                //
                dev_open_example_text_window(hv_ExampleInternals);
                //
                //Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                dev_display_example_reset_windows(hv_ExampleInternals);
                //
                //Display the explanatory text.
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                //
                hv_Text.Dispose();
                hv_Text = new HTuple("Now, the second part 'Training of the model' of the workflow");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "for DL object detection is finished.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "The trained model can now be evaluated and used for the inference";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "of new images.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "For evaluation please open";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "'detect_pills_deep_learning_3_evaluate.hdev'.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "For inference please open";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "'detect_pills_deep_learning_4_infer.hdev'.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = " ";
                //
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Please open the next example.",
                        "window", "bottom", "right", "black", new HTuple(), new HTuple());
                }
                //

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_introduction_train(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure displays an overview on the different example parts.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_Text.Dispose();

                    return;
                }
                //
                //Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                dev_display_example_reset_windows(hv_ExampleInternals);
                //
                //Display the overview on the different example parts.
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                //
                hv_Text.Dispose();
                hv_Text = new HTuple("This example is part of a series of examples, which summarize ");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "the workflow for DL object detection. It uses the MVTec pill bag dataset.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "The four parts are: ";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "1. Creation of the model and dataset preprocessing.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "2. Training of the model.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "3. Evaluation of the trained model.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "4. Inference on new images.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "This example covers part 2: 'Training of the model'.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = " ";
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", new HTuple(), new HTuple());
                }
                //

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_learning_rate(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            HObject ho_ImageLoss;

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
            HTuple hv_WindowHandleImages = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ImageLoss);
            try
            {
                //This procedure explains the learning rate.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {
                    ho_ImageLoss.Dispose();

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_Text.Dispose();
                    hv_WindowHandleImages.Dispose();

                    return;
                }
                //
                //Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 1);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                dev_display_example_reset_windows(hv_ExampleInternals);
                //
                //Display the explanatory text.
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                //
                hv_Text.Dispose();
                hv_Text = "Model parameter: 'learning_rate'";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "The 'learning_rate' determines the size of the steps for optimizing";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "the loss function:";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "     - A too high learning rate might result in divergence of";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "       the optimization algorithm.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "     - A very low learning rate will take unnecessarily many steps.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "The behavior of the loss curve for different learning rates is illustrated";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "below.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = " ";
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", new HTuple(), new HTuple());
                }
                //
                //Display learning rate curve.
                hv_WindowHandleImages.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images", out hv_WindowHandleImages);
                HDevWindowStack.SetActive(hv_WindowHandleImages);
                ho_ImageLoss.Dispose();
                HOperatorSet.ReadImage(out ho_ImageLoss, "dl_explanation/training_learning_rate_curves");
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispObj(ho_ImageLoss, HDevWindowStack.GetActive());
                }
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Loss", "image", 35, 110,
                        "black", "box", "false");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Epochs", "image", 685,
                        1230, "black", "box", "false");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "good learning rate",
                        "image", 670, 400, "blue", "box", "false");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "high learning rate",
                        "image", 530, 500, "cyan", "box", "false");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "very high learning rate",
                        "image", 220, 920, "red", "box", "false");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "low learning rate", "image",
                        375, 800, "orange", "box", "false");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Loss curves for different learning rates",
                        "window", "top", "center", "black", "box", "true");
                }
                //
                ho_ImageLoss.Dispose();

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();
                hv_WindowHandleImages.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_ImageLoss.Dispose();

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();
                hv_WindowHandleImages.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_num_epochs(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure explains the parameter 'num_epochs'.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_Text.Dispose();

                    return;
                }
                //
                //Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                dev_display_example_reset_windows(hv_ExampleInternals);
                //
                //Display the explanatory text.
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                //
                hv_Text.Dispose();
                hv_Text = "Training parameter: 'num_epochs'";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "During an epoch the entire training data is used once.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "The number of epochs depends on the individual problem.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("For datasets with a large number of classes, objects per image and");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "variety of object sizes a larger number of epochs might be necessary.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "A good indicator is the rate by which the loss value decreases.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "The number of epochs is set in the procedure ";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "'create_dl_train_param'.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = " ";
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", new HTuple(), new HTuple());
                }
                //

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_other_params(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure explains further training parameters.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_Text.Dispose();

                    return;
                }
                //
                //Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                dev_display_example_reset_windows(hv_ExampleInternals);
                //
                //Display the explanatory text.
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                //
                hv_Text.Dispose();
                hv_Text = new HTuple("Additionally, there are more advanced parameters that can be specified");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("to enhance the training process, for example parameters for:");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("   - Data augmentation (e.g. 'augmentation_percentage', 'rotation')");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "   - Change strategy (e.g. to adapt the 'learning_rate' during training)";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "   - Evaluation measure (e.g. 'mean_ap')";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = " ";
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", new HTuple(), new HTuple());
                }
                //

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_parameters(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure explains model and training parameters in general.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_Text.Dispose();

                    return;
                }
                //
                //Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                dev_display_example_reset_windows(hv_ExampleInternals);
                //
                //Display the explanatory text.
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                //
                hv_Text.Dispose();
                hv_Text = "There are multiple model and training parameters.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("To set the model parameters 'set_dl_model_param' is used,");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "while the training parameters are set in 'create_dl_train_param'.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "The parameters are employed to specify the training process.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "Some of them have a significant impact on the training result.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "The most prominent ones are explained in the following.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = " ";
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", new HTuple(), new HTuple());
                }
                //

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_training_goals_1(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            HObject ho_ImageLoss;

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
            HTuple hv_WindowHandleImages = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ImageLoss);
            try
            {
                //This procedure explains the goals during the training of a model.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {
                    ho_ImageLoss.Dispose();

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_Text.Dispose();
                    hv_WindowHandleImages.Dispose();

                    return;
                }
                //
                //Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 1);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                dev_display_example_reset_windows(hv_ExampleInternals);
                //
                //Display the explanatory text.
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                //
                hv_Text.Dispose();
                hv_Text = "While training there are two main goals to be achieved:";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "--> 1.) The 'loss' is commonly used to optimize the model on the";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("        training data. Hence, the objective is to minimize the loss");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "        on the training data by updating the model parameters iteratively.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "    2.) For the evaluation measure on the validation data the 'mean_ap'";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "        (mean average precision) is usually used for object detection.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "        This value should have an increasing trend during the training";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "        process.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = " ";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "An example of the loss during a successful training is displayed below.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = " ";
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", new HTuple(), new HTuple());
                }
                //
                //Display the training plot.
                hv_WindowHandleImages.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images", out hv_WindowHandleImages);
                HDevWindowStack.SetActive(hv_WindowHandleImages);
                //
                ho_ImageLoss.Dispose();
                HOperatorSet.ReadImage(out ho_ImageLoss, "dl_explanation/training_det_goals_loss");
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispObj(ho_ImageLoss, HDevWindowStack.GetActive());
                }
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Loss", "image", 15, 140,
                        "black", "box", "false");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Epochs", "image", 470,
                        1220, "black", "box", "false");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "1.68", "image", 95, 30,
                        "gray", "box", "false");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "1.12", "image", 210,
                        30, "gray", "box", "false");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "0.56", "image", 330,
                        30, "gray", "box", "false");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "0.00", "image", 455,
                        30, "gray", "box", "false");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "10", "image", 510, 460,
                        "gray", "box", "false");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "20", "image", 510, 815,
                        "gray", "box", "false");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "30", "image", 510, 1180,
                        "gray", "box", "false");
                }
                //
                ho_ImageLoss.Dispose();

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();
                hv_WindowHandleImages.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_ImageLoss.Dispose();

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();
                hv_WindowHandleImages.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_training_goals_2(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            HObject ho_ImageLoss;

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
            HTuple hv_WindowHandleImages = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ImageLoss);
            try
            {
                //This procedure explains the fundamental training goals.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {
                    ho_ImageLoss.Dispose();

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_Text.Dispose();
                    hv_WindowHandleImages.Dispose();

                    return;
                }
                //
                //Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 1);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                dev_display_example_reset_windows(hv_ExampleInternals);
                //
                //Display the explanatory text.
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                //
                hv_Text.Dispose();
                hv_Text = "While training there are two main goals to be achieved:";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "    1.) The 'loss' is commonly used to optimize the model on the";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("        training data. Hence, the objective is to minimize the loss");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "        on the training data by updating the model parameters iteratively.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "--> 2.) For the evaluation measure on the validation data the 'mean_ap'";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "        (mean average precision) is usually used for object detection.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "        This value should have an increasing trend during the training";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "        process.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = " ";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "An example of the 'mean_ap' during a successful training is displayed";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "below.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = " ";
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", new HTuple(), new HTuple());
                }
                //
                //Display the training plot.
                hv_WindowHandleImages.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images", out hv_WindowHandleImages);
                HDevWindowStack.SetActive(hv_WindowHandleImages);
                //
                ho_ImageLoss.Dispose();
                HOperatorSet.ReadImage(out ho_ImageLoss, "dl_explanation/training_det_goals_map");
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispObj(ho_ImageLoss, HDevWindowStack.GetActive());
                }
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "mean_ap", "image", 15,
                        140, "black", "box", "false");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Epochs", "image", 470,
                        1220, "black", "box", "false");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "1.00", "image", 25, 30,
                        "gray", "box", "false");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "0.80", "image", 145,
                        30, "gray", "box", "false");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "0.60", "image", 265,
                        30, "gray", "box", "false");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "0.40", "image", 385,
                        30, "gray", "box", "false");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "10", "image", 510, 415,
                        "gray", "box", "false");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "20", "image", 510, 780,
                        "gray", "box", "false");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "30", "image", 510, 1140,
                        "gray", "box", "false");
                }
                //
                ho_ImageLoss.Dispose();

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();
                hv_WindowHandleImages.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_ImageLoss.Dispose();

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();
                hv_WindowHandleImages.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_training_process(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_Text = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure explains train_dl_model.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_Text.Dispose();

                    return;
                }
                //
                //Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                dev_display_example_reset_windows(hv_ExampleInternals);
                //
                //Display the explanatory text.
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                //
                hv_Text.Dispose();
                hv_Text = new HTuple("After the parameters are set, the model can be trained");
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "on the dataset with the procedure 'train_dl_model'.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "During the training the best training model is stored and";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = "written to the disk after the corresponding training step.";
                if (hv_Text == null)
                    hv_Text = new HTuple();
                hv_Text[new HTuple(hv_Text.TupleLength())] = " ";
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                        "left", "black", "box", "true");
                }
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                        "window", "bottom", "right", "black", new HTuple(), new HTuple());
                }
                //

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_Text.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_display_screen_training_starts(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ShowExampleScreens = new HTuple();
            HTuple hv_WindowHandleText = new HTuple(), hv_GPUAvailable = new HTuple();
            HTuple hv_Text = new HTuple(), hv_CudaLoaded = new HTuple();
            HTuple hv_CuDNNLoaded = new HTuple(), hv_CuBlasLoaded = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure gives a hint that the training starts.
                //
                hv_ShowExampleScreens.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "show_example_screens", out hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_ShowExampleScreens.Dispose();
                    hv_WindowHandleText.Dispose();
                    hv_GPUAvailable.Dispose();
                    hv_Text.Dispose();
                    hv_CudaLoaded.Dispose();
                    hv_CuDNNLoaded.Dispose();
                    hv_CuBlasLoaded.Dispose();

                    return;
                }
                //
                //Reset the open windows for a clean display.
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                dev_display_example_reset_windows(hv_ExampleInternals);
                //
                //Display the explanatory text or error message in case no GPU is available.
                hv_WindowHandleText.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_text", out hv_WindowHandleText);
                HDevWindowStack.SetActive(hv_WindowHandleText);
                //
                hv_GPUAvailable.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "gpu_available", out hv_GPUAvailable);
                //
                if ((int)(hv_GPUAvailable) != 0)
                {
                    hv_Text.Dispose();
                    hv_Text = new HTuple();
                    if (hv_Text == null)
                        hv_Text = new HTuple();
                    hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("Now, the training of the model will start.");
                    if (hv_Text == null)
                        hv_Text = new HTuple();
                    hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                    if (hv_Text == null)
                        hv_Text = new HTuple();
                    hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("During training, the progress is indicated visually.");
                    if (hv_Text == null)
                        hv_Text = new HTuple();
                    hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                    if (hv_Text == null)
                        hv_Text = new HTuple();
                    hv_Text[new HTuple(hv_Text.TupleLength())] = "The training will take a while and depends highly on the parameter";
                    if (hv_Text == null)
                        hv_Text = new HTuple();
                    hv_Text[new HTuple(hv_Text.TupleLength())] = "settings and the used GPU type.";
                    if (hv_Text == null)
                        hv_Text = new HTuple();
                    hv_Text[new HTuple(hv_Text.TupleLength())] = " ";
                    //
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                            "left", "black", "box", "true");
                    }
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), "Press Run (F5) to continue",
                            "window", "bottom", "right", "black", new HTuple(), new HTuple());
                    }
                }
                else
                {
                    hv_CudaLoaded.Dispose();
                    HOperatorSet.GetSystem("cuda_loaded", out hv_CudaLoaded);
                    hv_CuDNNLoaded.Dispose();
                    HOperatorSet.GetSystem("cudnn_loaded", out hv_CuDNNLoaded);
                    hv_CuBlasLoaded.Dispose();
                    HOperatorSet.GetSystem("cublas_loaded", out hv_CuBlasLoaded);
                    hv_Text.Dispose();
                    hv_Text = new HTuple();
                    if (hv_Text == null)
                        hv_Text = new HTuple();
                    hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("This example needs to run on a GPU, but some of the necessary");
                    if (hv_Text == null)
                        hv_Text = new HTuple();
                    hv_Text[new HTuple(hv_Text.TupleLength())] = "libraries could not be found:";
                    if ((int)(new HTuple(hv_CudaLoaded.TupleEqual("false"))) != 0)
                    {
                        if (hv_Text == null)
                            hv_Text = new HTuple();
                        hv_Text[new HTuple(hv_Text.TupleLength())] = "- CUDA";
                    }
                    if ((int)(new HTuple(hv_CuDNNLoaded.TupleEqual("false"))) != 0)
                    {
                        if (hv_Text == null)
                            hv_Text = new HTuple();
                        hv_Text[new HTuple(hv_Text.TupleLength())] = "- CuDNN";
                    }
                    if ((int)(new HTuple(hv_CuBlasLoaded.TupleEqual("false"))) != 0)
                    {
                        if (hv_Text == null)
                            hv_Text = new HTuple();
                        hv_Text[new HTuple(hv_Text.TupleLength())] = "- CuBlas";
                    }
                    if (hv_Text == null)
                        hv_Text = new HTuple();
                    hv_Text[new HTuple(hv_Text.TupleLength())] = "Please install the missing libraries before continuing.";
                    if (hv_Text == null)
                        hv_Text = new HTuple();
                    hv_Text[new HTuple(hv_Text.TupleLength())] = "";
                    if (hv_Text == null)
                        hv_Text = new HTuple();
                    hv_Text[new HTuple(hv_Text.TupleLength())] = new HTuple("Alternatively, you can continue with the examples");
                    if (hv_Text == null)
                        hv_Text = new HTuple();
                    hv_Text[new HTuple(hv_Text.TupleLength())] = "'detect_pills_deep_learning_3_evaluate.hdev' and";
                    if (hv_Text == null)
                        hv_Text = new HTuple();
                    hv_Text[new HTuple(hv_Text.TupleLength())] = "'detect_pills_deep_learning_4_infer.hdev' without a GPU.";
                    //
                    set_display_font(hv_WindowHandleText, 20, "mono", "true", "false");
                    if (HDevWindowStack.IsOpen())
                    {
                        HOperatorSet.DispText(HDevWindowStack.GetActive(), hv_Text, "window", "top",
                            "left", "red", "box", "true");
                    }
                }
                //

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_GPUAvailable.Dispose();
                hv_Text.Dispose();
                hv_CudaLoaded.Dispose();
                hv_CuDNNLoaded.Dispose();
                hv_CuBlasLoaded.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_ShowExampleScreens.Dispose();
                hv_WindowHandleText.Dispose();
                hv_GPUAvailable.Dispose();
                hv_Text.Dispose();
                hv_CudaLoaded.Dispose();
                hv_CuDNNLoaded.Dispose();
                hv_CuBlasLoaded.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_example_init(HTuple hv_ShowExampleScreens, out HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_WindowWidthText = new HTuple(), hv_WindowHeightText = new HTuple();
            HTuple hv_WindowBGColor = new HTuple(), hv_WindowHandleText = new HTuple();
            // Initialize local and output iconic variables 
            hv_ExampleInternals = new HTuple();
            try
            {
                //This procedure initializes the graphic windows that are used for explanations during the example.
                //
                //A dict that will be used/adapted by other example procedures.
                hv_ExampleInternals.Dispose();
                HOperatorSet.CreateDict(out hv_ExampleInternals);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "show_example_screens", hv_ShowExampleScreens);
                if ((int)(hv_ShowExampleScreens.TupleNot()) != 0)
                {

                    hv_WindowWidthText.Dispose();
                    hv_WindowHeightText.Dispose();
                    hv_WindowBGColor.Dispose();
                    hv_WindowHandleText.Dispose();

                    return;
                }
                //
                if (HDevWindowStack.IsOpen())
                {
                    HOperatorSet.CloseWindow(HDevWindowStack.Pop());
                }
                hv_WindowWidthText.Dispose();
                hv_WindowWidthText = 800;
                hv_WindowHeightText.Dispose();
                hv_WindowHeightText = 300;
                hv_WindowBGColor.Dispose();
                hv_WindowBGColor = "gray";
                HOperatorSet.SetWindowAttr("background_color", hv_WindowBGColor);
                HOperatorSet.OpenWindow(0, 0, hv_WindowWidthText, hv_WindowHeightText, 0, "visible", "", out hv_WindowHandleText);
                HDevWindowStack.Push(hv_WindowHandleText);
                set_display_font(hv_WindowHandleText, 16, "mono", "true", "false");
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_text", hv_WindowHandleText);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_text_width", hv_WindowWidthText);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_text_height", hv_WindowHeightText);
                //
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_needed", 0);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend_needed", 0);
                //
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "gpu_available", 1);
                //

                hv_WindowWidthText.Dispose();
                hv_WindowHeightText.Dispose();
                hv_WindowBGColor.Dispose();
                hv_WindowHandleText.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_WindowWidthText.Dispose();
                hv_WindowHeightText.Dispose();
                hv_WindowBGColor.Dispose();
                hv_WindowHandleText.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_open_example_image_window(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_WindowHeightText = new HTuple();
            HTuple hv_WindowWidthImage = new HTuple(), hv_WindowHeightImages = new HTuple();
            HTuple hv_WindowBGColor = new HTuple(), hv_WindowYImages = new HTuple();
            HTuple hv_WindowXImages = new HTuple(), hv_WindowHandleImages = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure initializes the graphic windows that are used to display example images.
                //
                hv_WindowHeightText.Dispose();
                hv_WindowHeightText = 300;
                hv_WindowWidthImage.Dispose();
                hv_WindowWidthImage = 800;
                hv_WindowHeightImages.Dispose();
                hv_WindowHeightImages = 400;
                hv_WindowBGColor.Dispose();
                hv_WindowBGColor = "gray";
                //
                hv_WindowYImages.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_WindowYImages = hv_WindowHeightText + 60;
                }
                hv_WindowXImages.Dispose();
                hv_WindowXImages = 0;
                HOperatorSet.SetWindowAttr("background_color", hv_WindowBGColor);
                HOperatorSet.OpenWindow(hv_WindowYImages, hv_WindowXImages, hv_WindowWidthImage, hv_WindowHeightImages, 0, "visible", "", out hv_WindowHandleImages);
                HDevWindowStack.Push(hv_WindowHandleImages);
                set_display_font(hv_WindowHandleImages, 16, "mono", "true", "false");
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images", hv_WindowHandleImages);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_width", hv_WindowWidthImage);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_height", hv_WindowHeightImages);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_x", hv_WindowXImages);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_images_y", hv_WindowYImages);

                hv_WindowHeightText.Dispose();
                hv_WindowWidthImage.Dispose();
                hv_WindowHeightImages.Dispose();
                hv_WindowBGColor.Dispose();
                hv_WindowYImages.Dispose();
                hv_WindowXImages.Dispose();
                hv_WindowHandleImages.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_WindowHeightText.Dispose();
                hv_WindowWidthImage.Dispose();
                hv_WindowHeightImages.Dispose();
                hv_WindowBGColor.Dispose();
                hv_WindowYImages.Dispose();
                hv_WindowXImages.Dispose();
                hv_WindowHandleImages.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_open_example_legend_window(HTuple hv_ExampleInternals, HTuple hv_WindowWidth)
        {



            // Local control variables 

            HTuple hv_WindowImagesHeight = new HTuple();
            HTuple hv_WindowImagesWidth = new HTuple(), hv_WindowImagesX = new HTuple();
            HTuple hv_WindowImagesY = new HTuple(), hv_WindowHandleLegend = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure initializes the graphic windows that are used to display a legend.
                //
                hv_WindowImagesHeight.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_height", out hv_WindowImagesHeight);
                hv_WindowImagesWidth.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_width", out hv_WindowImagesWidth);
                hv_WindowImagesX.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_x", out hv_WindowImagesX);
                hv_WindowImagesY.Dispose();
                HOperatorSet.GetDictTuple(hv_ExampleInternals, "window_images_y", out hv_WindowImagesY);
                HOperatorSet.SetWindowAttr("background_color", "black");
                HOperatorSet.OpenWindow(hv_WindowImagesY, (hv_WindowImagesX + hv_WindowImagesWidth) + 5, hv_WindowWidth, hv_WindowImagesHeight, 0, "visible", "", out hv_WindowHandleLegend);
                HDevWindowStack.Push(hv_WindowHandleLegend);
                set_display_font(hv_WindowHandleLegend, 14, "mono", "true", "false");
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_legend", hv_WindowHandleLegend);

                hv_WindowImagesHeight.Dispose();
                hv_WindowImagesWidth.Dispose();
                hv_WindowImagesX.Dispose();
                hv_WindowImagesY.Dispose();
                hv_WindowHandleLegend.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_WindowImagesHeight.Dispose();
                hv_WindowImagesWidth.Dispose();
                hv_WindowImagesX.Dispose();
                hv_WindowImagesY.Dispose();
                hv_WindowHandleLegend.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public void dev_open_example_text_window(HTuple hv_ExampleInternals)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_WindowWidthText = new HTuple(), hv_WindowHeightText = new HTuple();
            HTuple hv_WindowBGColor = new HTuple(), hv_WindowHandleText = new HTuple();
            // Initialize local and output iconic variables 
            try
            {
                //This procedure initializes the graphic window which is used to display the text.
                //
                hv_WindowWidthText.Dispose();
                hv_WindowWidthText = 800;
                hv_WindowHeightText.Dispose();
                hv_WindowHeightText = 300;
                hv_WindowBGColor.Dispose();
                hv_WindowBGColor = "gray";
                HOperatorSet.SetWindowAttr("background_color", hv_WindowBGColor);
                HOperatorSet.OpenWindow(0, 0, hv_WindowWidthText, hv_WindowHeightText, 0, "visible", "", out hv_WindowHandleText);
                HDevWindowStack.Push(hv_WindowHandleText);
                set_display_font(hv_WindowHandleText, 16, "mono", "true", "false");
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_text", hv_WindowHandleText);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_text_width", hv_WindowWidthText);
                HOperatorSet.SetDictTuple(hv_ExampleInternals, "window_text_height", hv_WindowHeightText);

                hv_WindowWidthText.Dispose();
                hv_WindowHeightText.Dispose();
                hv_WindowBGColor.Dispose();
                hv_WindowHandleText.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {

                hv_WindowWidthText.Dispose();
                hv_WindowHeightText.Dispose();
                hv_WindowBGColor.Dispose();
                hv_WindowHandleText.Dispose();

                throw HDevExpDefaultException;
            }
        }

    }
}
